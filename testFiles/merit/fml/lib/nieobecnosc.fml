:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: nieobecnosc.fml
:: Utworzony: 05.10.2015
:: Autor: jaws
::======================================================================================================================
:: Zawartość: Plik zawiera formuły obsługi tabeli N (wspólne dla wszystkich form współpracy)
::======================================================================================================================


\n_addb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz przed dołączeniem.
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.N='T'
|| return(1)
?};
exec('n_modb','nieobecnosc')


\n_adda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz po dołączeniu.
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY: ~~
::  OLD: \n_tr_add_po/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~_a | do_state()<>1
|| return()
?};

{? TRIG_OFF.N='T'
|| return()
?};

exec('__KAL','object');

_rok:=N.OD~1;
_msc:=N.OD~2;

_ok:=__KAL.set_cal(N.P().KAL,_rok);

{? exec('czy_nrg_auto','nieobecnosc') & ~_ok
|| exec('dodaj_nbk','nieobecnosc',N.ref())
?};

:: Obsługa harmonogramów.
{? (TRIG_OFF.KAL_BUFF<>'T') & (N.NB().RN<>7034)
|| exec('kwal','grafik',N.P,N.OD,N.DO);
   exec('akt_buff','prc_plan','add',N)
?};

::R_SZYCH.index('R_TECH');
::R_SZYCH.prefix(_rok,_msc);
::{? ~R_SZYCH.first()
::|| return(~~)
::?};
::
::_add:=0;
::R_SZYCH.index('R_SZPR');
::R_SZYCH.prefix(N.P,_rok,_msc);
::{? ~R_SZYCH.first()
::|| R_SZYCH.blank();
::   _add:=1
::?};
::
::_kod:=N.NB().RN;
::_do:={? (N.DO~1=N.OD~1 & N.DO~2<>N.OD~2) | N.DO~1>N.OD~1 || date(N.OD~1,N.OD~2,0) || N.DO ?};
::{! _ind:=N.OD~3.._do~3
::|! _num:=('0'+$_ind)+2;
::   ($('R_SZYCH.NIE'+_num+':=_a'))(_kod);
::   ($('R_SZYCH.N'+_num+':=_a'))(__KAL.w_hours(date(_rok,_msc,_ind),date(_rok,_msc,_ind)));
::    exec('info','widok_rcp',_ind,3,'N')
::!};
::
::{? _add
::|| R_SZYCH.P:=N.P;
::   R_SZYCH.OSOBA:=N.P().OSOBA;
::   R_SZYCH.ROK:=_rok;
::   R_SZYCH.MC:=_msc;
::   R_SZYCH.add()
::|| R_SZYCH.put()
::?};

~~


\n_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz przed poprawieniem.
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.N='T'
|| return(1)
?};

exec('n_modb','nieobecnosc')


\n_puta
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz po poprawieniu
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY: ~~
::  OLD: \n_tr_put_po/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~_a | do_state()<>1
|| return()
?};

{? TRIG_OFF.N='T'
|| return()
?};

exec('__KAL','object');

{? N.NRG_AUTO<>bfld('NRG_AUTO')
|| {? exec('czy_nrg_auto','nieobecnosc')
   || {? ~__KAL.set_cal(N.P().KAL,N.OD~1)
      || exec('dodaj_nbk','nieobecnosc',N.ref())
      ?}
   || exec('del_ndx','#table',NBK,'UNIQUE',N.ref())
   ?}
|? exec('czy_nrg_auto','nieobecnosc') & __KAL.set_cal(N.P().KAL,N.OD~1)
|| exec('del_ndx','#table',NBK,'UNIQUE',N.ref())
?};

{? N.NB<>bfld('NB') | N.OD<>bfld('OD') | N.DO<>bfld('DO')
|| exec('n_dela','nieobecnosc',1);
   exec('n_adda','nieobecnosc',1)
?};

:: Obsługa harmonogramów.
{? (TRIG_OFF.KAL_BUFF<>'T') & (N.OD<>bfld('OD') | N.DO<>bfld('DO') | N.KOR<>bfld('KOR') | N.NB<>bfld('NB'))
|| exec('kwal','grafik',N.P,bfld('OD'),bfld('DO'));
   exec('kwal','grafik',N.P,N.OD,N.DO);
   exec('akt_buff','prc_plan','put',N)
?};
~~


\n_delb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz przed usunięciem.
::   WE:
::   WY: zgodna ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.N='T'
|| return(1)
?};

exec('akt_buff','prc_plan','del',N);
exec('del_ndx','#table',NBK,'UNIQUE',N.ref())


\n_dela
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz po usunięciu.
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY: ~~
::  OLD: \n_tr_del_po/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~_a | do_state()<>1
|| return()
?};

{? TRIG_OFF.N='T'
|| return()
?};

:: Obsługa harmonogramów.
{? (TRIG_OFF.KAL_BUFF<>'T') & (N.NB().RN<>7034)
|| exec('kwal','grafik',bfld('P'),bfld('OD'),bfld('DO'))
?};
::_rok:=(bfld('OD'))~1;
::_msc:=(bfld('OD'))~2;
exec('nezla_status','nieobecnosc',N);
::R_SZYCH.index('R_TECH');
::R_SZYCH.prefix(_rok,_msc);
::{? ~R_SZYCH.first()
::|| return(~~)
::?};
::
::_od:=bfld('OD');
::_do:=bfld('DO');
::
::R_SZYCH.index('R_SZPR');
::R_SZYCH.prefix(N.P,_rok,_msc);
::{? R_SZYCH.first()
::|| {! _ind:=_od~3.._do~3
::   |! _num:=('0'+$_ind)+2;
::      ($('R_SZYCH.N'+_num+':=0'))();
::      ($('R_SZYCH.NIE'+_num+':=0'))();
::      exec('info','widok_rcp',_ind,3,'*')
::   !};
::   R_SZYCH.put()
::?};
~~


\n_modb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Przed modyfikacją rekordu. Formuła wywoływana z wyzwalaczy "Dołącz - przed" i "Popraw - przed" dla tabeli N.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
P.cntx_psh();
N.FIRMA:=N.P().FIRMA;
P.cntx_pop();

{? N.UW='T' & N.NT<>0
|| {? N.NT*7<>N.NK
   || N.UW:='D';
      N.NT:=0
   ?}
?};

exec('n_rm_akt','nieobecnosc',N);

: Porządki - zerowanie pól, które są "niedostępne".
:Jeżeli __RUB nie istnieje to będzie utworzony.
exec('__RUB','object');
{? N.NB & __RUB.sys_attr(N.NB,114)
|| exec('blank','#field',N,,'ST','KDCH','RDOK','SDOK','NDOK','DD','DN','OP','PROC')
|? ~(N.NB & (__RUB.sys_attr(N.NB,12) | __RUB.sys_attr(N.NB,1314) | __RUB.sys_attr(N.NB,1318)))
|| exec('blank','#field',N,,'ST','KDCH','RDOK','SDOK','NDOK','DD','DN','OP','PROC','CU')
|| {? ~(N.NB & __RUB.sys_attr(N.NB,115))
   || exec('blank','#field',N,,'CU')
   ?}
?};

{? ~exec('czy_krotka_choroba','nieobecnosc')
|| exec('blank','#field',N,,'DK')
?};
1


\n_ah_rm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.41]
:: OPIS: Trigger add_przed i put_przed dla tabel N_AH
::   WE: _a - alias tabeli
::   WY:
::  OLD: \N_AH_RM/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
N_AH.ROK:=N_AH.DATA~1;
N_AH.MC:=N_AH.DATA~2;
1


\nbk_modb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed dołączeniem i poprawieniem wiersza tabeli NBK.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
N.cntx_psh();
P.cntx_psh();
STN.cntx_psh();
UD_SKL.cntx_psh();

NBK.P:=NBK.N().P;
NBK.OSOBA:=NBK.P().OSOBA;
NBK.UD_SKL:=NBK.P().WYDZIAL;
NBK.STN:=NBK.P().ST;
NBK.R:=NBK.N().NB;

UD_SKL.cntx_pop();
STN.cntx_pop();
P.cntx_pop();
N.cntx_pop();
1


\nbk_addb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz przed dołączeniem wiersza tabeli NBK.
::   WE:
::   WY: zgodna ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
exec('nbk_modb','nieobecnosc')


\nbk_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz przed poprawieniem wiersza tabeli NBK.
::   WE:
::   WY: zgodna ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
exec('nbk_modb','nieobecnosc')


\n_rm_akt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Aktualizacja przed zapisem pól ROK i MC
::   WE: _a [TABLE] - alias do tabeli
::  OLD: \N_ZC_N_RM/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_a.ROK:=_a.OD~1;
_a.MC:=_a.OD~2;
1


\n_nrg_auto_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Po redakcji pola NRG_AUTO tabeli N
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
{? N.NRG_AUTO='T'
|| exec('n_czas','nieobecnosc')
?};
1


\dodaj_nbk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Tworzy zapis w tabeli NBK
::   WE: _a [_N] - wskazanie nieobecności
::   WY: wynik dołączania rekordu
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
NBK.cntx_psh();
NBK.clear();
NBK.index('UNIQUE');
{? NBK.find_key(_a)
|| _ret:=1
|| NBK.blank();
   NBK.N:=_a;
   _ret:=NBK.add()
?};
NBK.cntx_pop();
_ret


\kod_zus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła wyszukuje kod wykorzystywany w dokumentach ZUS z klasy podanej pierwszym argumentem i wartości drugim.
::       Jeżeli wyszukanie rekordu nie powiodło się, to odpowiedni zapis zostanie dodany do słownika.
::   WE: _a [STRING] - Rodzaj w słowniku S_ZUS.
::       _b [STRING] - Kod w słowniku S_ZUS.
::   WY: Wskazanie znalezionego lub utworzonego rekordu.
::  OLD: \kod_zus/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
S_ZUS.cntx_psh();
S_ZUS.index('S_ZUS');
S_ZUS.prefix(_a);
{? ~S_ZUS.find_key(_b,)
|| S_ZUS.blank();
   S_ZUS.RODZAJ:=_a;
   S_ZUS.KOD:=_b;
   S_ZUS.add()
?};
_ret:=S_ZUS.ref();
S_ZUS.cntx_pop();
_ret


\kod_swd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Ustala domyślny kod świadczenia dla wskazanej nieobecności.
::   WE: _a [INTEGER] - Kod nieobecności (numer rubryki).
::   WY: Wskazanie rekordu z kodem świadczenia.
::  OLD: \kod_swd/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0)
|| _kod:=
      {? __RUB.sys_attr(_a,14331) || 'choroba - wynagrodzenie'; '331'
      |? __RUB.sys_attr(_a,14313) || 'choroba - zasiłek'; '313'
      |? __RUB.sys_attr(_a,14321) || 'świadczenie rehabilitacyjne'; '321'
      |? __RUB.sys_attr(_a,14322) || 'świadczenie rehabilitacyjne'; '322'
      |? __RUB.sys_attr(_a,14311) || 'urlop macierzyński'; '311'
      |? __RUB.sys_attr(_a,14319) || 'urlop macierzyński w trakcie rodzicielskiego'; '319'
      |? __RUB.sys_attr(_a,14325) || 'urlop macierzyński w trakcie dod. macierz.'; '325'
      |? __RUB.sys_attr(_a,14327) || 'urlop macierzyński trakcie ojcowskiego'; '327'
      |? __RUB.sys_attr(_a,14312) || 'opieka'; '312'
      |? __RUB.sys_attr(_a,14314) || 'wypadek - zasiłek'; '314'
      |? __RUB.sys_attr(_a,14152) || 'nieobecność nieuspr.'; '152'
      |? __RUB.sys_attr(_a,14111) || 'urlop bezpłatny - wn. pracownika'; '111'
::    Usunięto podpowiadanie kodu 350 (PR/WRT/XP/21.37/2112/0049 - propozycja SPIS)
      |? __RUB.sys_attr(_a,14151) || 'uspr., bez wynagr.'; '151'
      |? __RUB.sys_attr(_a,14121) || 'urlop wychowawczy'; '121'
::    Urlop opiekuńczy - 23.25_ZUS01 - Kody ZUS od 2023.08.05
      |? __RUB.sys_attr(_a,14131) || 'urlop opiekuńczy'; '131'
      || ''
      ?}
:: !!! W wywołaniach powyżej zwracany kod jest stały, nie korzysta z wartości atrybutu (__RUB.sys_val()).
|| _kod:=''
?};
{? _kod<>''
|| exec('kod_zus','nieobecnosc','S',_kod)
|| null()
?}


\procent
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [2010B]
:: OPIS: Ustalenie procentu dla nieobecności,
::   WE:  _a  [INTEGER/REFERENCE] - Rubryka określająca nieobecność (numer lub wskazanie).
::       [_b] [TABLE]             - Alias tabeli [domyślnie: N].
::   WY: INTEGER - procent
::  OLD: \procent/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_rub:={? var_pres('_a')=type_of(null()) || _a || __RUB.REF[_a] ?};
_TAB:={? var_pres('_b')=type_of(N) || _b || N ?};

_par:=params_get();
_nieob:=
   {? var_pres('_par')>100 & var_pres('fld',_par)>100 & var_pres('NB',_par.fld)=type_of(null())
   || _par.fld.NB
   || null()
   ?};

_dt:={? _TAB.OD<>date(0,0,0) || _TAB.OD || date() ?};
{? {? (__RUB.sys_attr(_rub,115,_dt) | __RUB.sys_attr(_rub,1314,_dt) | __RUB.sys_attr(_rub,1904,_dt)) & _nieob=_rub
   || ~_TAB.PROC
   || 1
   ?}
|| {? __RUB.sys_attr(_rub,1293,_dt)
   || __RUB.sys_val(1293,_dt,0)
   |? __RUB.sys_attr(_rub,1295,_dt)
   || __RUB.sys_val(1295,_dt,0)
   |? __RUB.sys_attr(_rub,1291,_dt)
   || __RUB.sys_val(1291,_dt,0)
   |? __RUB.sys_attr(_rub,1292,_dt)
   || __RUB.sys_val(1292,_dt,0)
   |? __RUB.sys_attr(_rub,1294,_dt)
   || __RUB.sys_val(1294,_dt,0)
   |? __RUB.sys_attr(_rub,1296,_dt)
   || __RUB.sys_val(1296,_dt,0)
   |? __RUB.sys_attr(_rub,1318,_dt)
   || __RUB.sys_val(1318,_dt,0)
   ?}*100
|| _TAB.PROC
?}


\x_okres_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [2010]
:: OPIS: Przed redagowaniem pól: ZC_N.OD, ZC_N.NK, ZC_N.DO, N.OD, N.NK, OS_N.OD, OS_N.NK.
::   WE:
::   WY: 1
::  OLD: \__N_ODDO/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
_TAB:=cur_tab(1,1);
_par:=params_get();
_tdt:=type_of(date());
{? var_pres('_par')>100 & var_pres('fld',_par)>100 &
   var_pres('OD',_par.fld)=_tdt & var_pres('DO',_par.fld)=_tdt & var_pres('NK',_par.fld)=type_of(0)
|| _fld:=_par.fld;
   _fld.OD:=_TAB.OD;
   _fld.NK:=_TAB.NK;
   _fld.DO:=_TAB.DO;
   _fld.UW:=_TAB.UW
?};
1


\x_do_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.22]
:: OPIS: Przed redagowaniem pól: N.DO, OS_N.DO
::   WE:
::   WY: 0/1 - pole zablokowane/dostępne
::----------------------------------------------------------------------------------------------------------------------
exec('x_okres_be','nieobecnosc');
cur_tab(1,1).UW<>'T'


\n_czas
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła wylicza liczbę dni kalendarzowych, godzin roboczych i godzin nominalnych.
::   WE: [_a] [INTEGER] - Tryb wsadowy:
::          0 - Nie [domyślnie].
::          1 - Tak.
::       [_b] [TABLE] - alias tabeli: N lub OS_N, wpp przyjęta zostanie N
::   WY:
::  OLD: \krug/nknunrng.fml
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;

_TAB:={? var_pres('_b')<>type_of(SYSLOG) | (_b<>N & _b<>OS_N) || N || _b ?};
_rn:={? _TAB=N || "N.NB().RN" || "OS_N.R().RN" ?};

{? _TAB.OD<=_TAB.DO
|| _TAB.NK:=_TAB.DO-_TAB.OD+1;
   {? _TAB=N
   || {? _TAB.NRG_AUTO='T'
      || _TAB.NR:=__KAL.w_days(_TAB.OD,_TAB.DO);
         _TAB.NG:=__KAL.w_hours(_TAB.OD,_TAB.DO);
         {? __KAL.isValOk()
         || _TAB.NG:={? __RUB.sys_attr(_rn(),122722,_TAB.OD) | __RUB.sys_attr(_rn(),122742,_TAB.OD)
                     || exec('licz_go_macrodz','nieobecnosc',_TAB.OD,_TAB.DO)
                     || exec('nominal','godziny',_TAB.OD,_TAB.DO)
                     ?}
         || _TAB.NR:=_TAB.NG:=0
         ?}
      ?}
   || _TAB.NR:=__KAL.w_days(_TAB.OD,_TAB.DO);
      _TAB.NG:=__KAL.w_hours(_TAB.OD,_TAB.DO)
   ?};
   1
|? _batch
|| 0
|| exec('alert','overlap')
?}


\licz_go_macrodz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51]
:: OPIS: Wylicza godziny robocze dla nieobecności z atrubutów 122722 i 122742 (macierzyński i rodzicielski praca).
::       Konieczny jest inny sposób wyliczenia godzin roboczych dla nieobecności w przypadku kiedy pracownik ma
::       kalendarz typu "grafik". W takim przypadku planujemy jedynie faktyczny czas pracy winikający z wymiaru pracy
::       w trakcie macierzyńskiego.
::       UWAGA - wymagane ustawienie bufora tabeli P
::   WE: _a [REFERENCE] - wskazanie na pracownika
::       _b [DATE]      - data od
::       _c [DATE]      - data do
::   WY:
::  OLD: \licz_go_macrodz/nknunrng.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_od:={? var_pres('_a')=type_of(date) || _a || return(_result) ?};
_do:={? var_pres('_b')=type_of(date) || _b || return(_result) ?};

{! _ind:=#_od..#_do
|! _data:=#_ind;
   _result+=exec('nominal','godziny',_data,_data,,,,1,,,{? __KAL.grafik(_data)='T' || 2 || 1 ?})
!};
_result


\czy_krotka_choroba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GL [8.70]
:: OPIS: Na podstawie daty rozpoczęcia nieobecności, formuła sprawdza, czy to może być "krótka" choroba. Weryfikacja
::       dotyczy bieżącego rekordu tabeli N.
::   WE:
::   WY: 1 - Tak, to może być "krótka" choroba.
::       0 - Nie, to nie może być "krótka" choroba.
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
{? N.OD<>date(0,0,0) & N.OD>date(2003,1,1) & N.OD<date(2003,12,0)
|| KST_CHOR.cntx_psh();
   KST_CHOR.prefix();
   _again:=KST_CHOR.first();
   {!
   |? _again
   |! {? N.NB=KST_CHOR.WYN | N.NB=KST_CHOR.ZAS
      || _ret:=1;
         _again:=0
      || _again:=KST_CHOR.next()
      ?}
   !};
   KST_CHOR.cntx_pop()
?};
_ret


\czy_lista_z_nkor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [2009]
:: OPIS: Sprawdzenie listy, która zawiera skorygowaną nieobecność.
::   WE: [_a] [INTEGER] - Tryb wsadowy:
::          0 - Nie [domyślnie].
::          1 - Tak.
::       [_b] [STRING]  - Znak listy jeśli nie wypełnione to VAR.NAZWALIS.
::   WY:
::  OLD: \spr_kor_prac/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;
{? var_pres('_b')<>type_of('') | (var_pres('_b')=type_of('') & _b='') || _b:=VAR.NAZWALIS ?};

 _wyn:=0;
N.cntx_psh();
N.index('NIEOLSOD');
N.prefix('T',P.ref(),_b);
{? N.first()
|| {? ~_batch
   || FUN.emsg(
         'Lista płac dla: %1\n'
         'zawiera korygowane lub wycofane nieobecności.\n'
         'Akcja niedostępna.'@ [P.OSOBA().NAZWISKO+' '+P.OSOBA().PIERWSZE]
      )
   ?};
   _wyn:=1
?};
N.cntx_pop();
_wyn


\n_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła odpowiedzialna za dynamiczne ustawianie właściwości pól tabeli N. Formuła wywoływana jest w dwóch
::       kontekstach pracy:
::          - Po redagowaniu konkretnego pola, które determinuje właściwości wyświetlania innych pól.
::          - Przed wyświetleniem okna redagowania (przed właściwymi akcjami Dołącz, Popraw, Wyświetl), ustawia
::            właściwości wszystkich pól (wymagających tego).
::       Kontekst pracy jest określany na podstawie argumentu wywołania.
::   WE: [_a] [STRING] - Kontekst pracy:
::             '1' - Obsługa jednego pola [domyślnie].
::             '*' - Obsługa wszystkich pól.
::       [_b] [TABLE]  - Uchwyt tabeli, w oknie redagowania której znajdują sie pola. Jeżeli _a='1', parametr jest
::             opcjonalny - zostanie przyjęta bieżąca tabela.
::       [_c] [STRING] - Akronim okna, w którym mają być ustawione właściwości pól. Jeżeli _a='1', parametr jest
::             opcjonalny - zostanie przyjęte bieżące okno.
::       [_d] [STRING] - Akronim pola, którego wartość determinuje właściwości wyświetlania innych pól. Parametr ma
::             znaczenie wyłącznie dla _a='1'. [Domyślnie: bieżące pole].
::   WY: 0 - Błąd argumentów wywołania.
::       1 - Argumenty poprawne (właściwości ustawione).
::  OLD: \testkch/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_tryb:={? var_pres('_a')=type_of('') & (_a='1' | _a='*') || _a || '1' ?};
{? var_pres('_b')=type_of(N)
|| _tab:=_b
|? _tryb='1'
|| _tab:=cur_tab(1,1)
|| return(0)
?};
{? var_pres('_c')=type_of('')
|| _we:=_c
|? _tryb='1'
|| _we:=cur_win(1,1)
|| return(0)
?};
{? var_pres('_d')=type_of('')
|| _fld:=_d
|? _tryb='1'
|| _fld:=cur_afld()
|| _fld:=''
?};

_czy_choroba:=N.NB & __RUB.sys_attr(N.NB,12);
_partday:=exec('n_partday_bd','nieobecnosc');

{? _fld='' | _fld='NB'
|| _sval:=$_czy_choroba;
   _tab.efld_opt(_we,'enable='+_sval,N,'ST');
   _tab.efld_opt(_we,'enable='+_sval,N,'KDCH');
   _tab.efld_opt(_we,'enable='+_sval,N,'RDOK');
   _tab.efld_opt(_we,'enable='+_sval,N,'SDOK');
   _tab.efld_opt(_we,'enable='+_sval,N,'NDOK');
   _tab.efld_opt(_we,'enable='+_sval,N,'DD');
   _tab.efld_opt(_we,'enable='+_sval,N,'DN');
   _tab.efld_opt(_we,'enable='+_sval,N,'OP');
   {? N.NB & (__RUB.sys_attr(N.NB,1904) | __RUB.sys_attr(N.NB,1314))
   || _tab.efld_opt(_we,'enable=1',N,'PROC')
   || _tab.efld_opt(_we,'enable='+_sval,N,'PROC')
   ?};
   _sval:=$(__RUB.sys_attr(N.NB,114) | __RUB.sys_attr(N.NB,115));
   _tab.efld_opt(_we,'enable='+_sval,N,'CU');
   _sval:=$_partday;
   _tab.efld_opt(_we,'enable='+_sval,N,'PARTDAY')
?};

{? _fld='' | _fld='OD'
|| _sval:=$(_czy_choroba & exec('czy_krotka_choroba','nieobecnosc'));
   _tab.efld_opt(_we,'enable='+_sval,N,'DK')
?};

{? _fld='' | _fld='OD' | _fld='DO' | _fld='NK'
|| _sval:=$_partday;
   _tab.efld_opt(_we,'enable='+_sval,N,'PARTDAY');
   exec('n_efld_opt','nieobecnosc','1',_tab,_we,'PARTDAY')
?};

{? _fld='' | _fld='PARTDAY'
|| _sval:=$(N.PARTDAY='N');
   _tab.efld_opt(_we,'enable='+_sval,N,'NRG_AUTO')
?};

1


\n_nb_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.22]
:: OPIS: Przed redagowaniem pola N.NB.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
_par:=params_get();
{? var_pres('_par')>100 & var_pres('fld',_par) & var_pres('NB',_par.fld)=type_of(null)
|| _par.fld.NB:=N.NB
?};
1


\n_nb_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola N.NB.
::   WE:
::   WY: 1
::  OLD: \kod_swd/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? N.NB
|| _rub:=N.NB().RN;
   params_set(params_get());
   N.PROC:=exec('procent','nieobecnosc',_rub);
   N.KDSW:=exec('kod_swd','nieobecnosc',_rub);
   {? ~(N.NB & (__RUB.sys_attr(N.NB,122112) | __RUB.sys_attr(N.NB,12112))) & N.KDCH().KOD='B' || N.KDCH:=null() ?};
   {? __RUB.sys_attr(_rub,19001,N.OD)
   || _par:=params_get();
      {? var_pres('_par')>100 & var_pres('fld',_par) & var_pres('NB',_par.fld)=type_of(null)
      || {? _par.fld.NB=null & N.NB<>null
         || N.UW:='T'
         ?}
      ?}
   ?};
   exec('n_efld_opt','nieobecnosc')
|| __CHK.err_empty('Składnik'@);
   0
?}


\n_dk_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GL [8.70]
:: OPIS: Przed redagowaniem pola N.DK.
::   WE:
::   WY:
::  OLD: \testkch/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
exec('czy_krotka_choroba','nieobecnosc')


\n_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Po odświeżeniu" okna WER tabeli N w grupie. Ustawia akcje i przyciski.
::   WE: [_a] [STRING] - Akronim okna [domyślnie:WER].
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ws:={? var_pres('_a')=type_of('') || _a || 'WER' ?};

{? grp_empty(N,'WER')
|| POLA_GRP.REAL_1:=POLA_GRP.REAL_2:=POLA_GRP.REAL_3:=0;
   POLA_GRP.TXT_1:='';
   N.blank(1)
?};


_ag:={? N.RODZAJ='K' || 'PU' || '' ?};
_par:=params_get();
{? var_pres('_par')>100 &
   var_pres('cfg',_par)>100 &
   var_pres('done',_par.cfg)>100 &
   var_pres('noempty',_par.cfg.done)=type_of('') & var_pres('empty',_par.cfg.done)=type_of('')
|| _ag+=_par.cfg.done.noempty+':'+_par.cfg.done.empty
?};
N.actions_grayed(_ws,_ag);
~~


\n_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Funkcja wykorzystywana do zweryfikowania poprawności danych redagowanych w tabeli nieobecności.
::       Wykorzystywana przez funkcje odpowiedzialne za dołączanie i poprawianie nieobecności.
::   WE: _a [INTEGER] - Tryb modyfikacji zapisu:
::       1 - Popraw
::       0 - Dołącz
::   WY: Wartością zwracaną jest 1 gdy dane są poprawne lub akronim nieprawidłowo wypełnionego pola.
::  OLD: \sprawdz/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_put:=_a;
_fld:="{? N.UW='T' & _a='DO' || 'DT' || _a ?}";

{? N.NK<N.OP
|| N.OP:=N.NK
?};
{? N.NK<N.DN
|| N.DN:=N.NK
?};

{? (_chk:=__CHK.record(N,,'NB','OD','DO'))<>''
|| return(_fld(_chk))
?};

{? N.DO<N.OD
|| exec('alert','overlap');
   return('OD')
?};

{? N.OD<P.DZA
|| FUN.emsg('Nieobecność nie może rozpoczynać się przed datą zatrudnienia pracownika.'@);
   return('OD')
?};

{? +N.LT & exec('czy_lista_z_nkor','nieobecnosc',,N.LT)
|| FUN.emsg(
      'Wprowadzona lista płac zawiera korygowane lub wycofane nieobecności.\n'
      'Lista ta nie zostanie ponownie obliczona.'@
   );
   return('LT')
|? +N.LT & N.OD~2<>N.DO~2
|| FUN.emsg(
      'Jeżeli nieobecność ma wpisany znak listy płac,\n'
      'to data końca tej nieobecności musi pochodzić z miesiąca,\n'
      'w którym nieobecność się rozpoczęła.'@
   );
   return(_fld('DO'))
|? N.NB().RN=16 & N.OD>=date(2003,1,1)
|| FUN.emsg('Nieobecność "%1" nie może być użyta po 1 stycznia 2003 roku.\nWybierz inną nieobecność.'@ [N.NB().RT]);
   return('NB')
?};
{? N.N_KOR<>null()
|| _err:=0;
   _od:=N.OD;
   _do:=N.DO;
   N.cntx_psh();
   N.clear();
   {? N.seek(N.N_KOR,)
   || _err:=~(N.OD<=_od & _do<=N.DO)
   ?};
   N.cntx_pop();
   {? _err
   || FUN.emsg('Wprowadzone korekty nie mogą rozpoczynać się przed ani kończyć po korygowanej nieobecności.'@);
      return('OD')
   ?}
?};

::sprawdzanie czy nieobecnosc moze zostac rozliczona
{? +N.LT
|| O.cntx_psh();
   O.index('LISTYMIE');
   O.prefix(exec('ref_firma','ustawienia'));
   _rok:=#((3+N.LT)+2);
   _rok+={? _rok<70 || 2000 || 1900 ?};
   _mc:=#((5+N.LT)+2);
   _lt:=N.LT+3;
   {? O.find_key(_rok,_mc,_lt,)
   || _dane:=(O.R*12+O.M)-(N.OD~1*12+N.OD~2);
      {? _dane>60
      || FUN.emsg(
            'Nieobecność dotyczy okresu sprzed %1 miesięcy i nie może zostać rozliczona na liście płac o symbolu %2.\n'
            'Sprawdź daty nieobecności lub wskaż poprawną listę, na której ma zostać rozliczona.'@
            [$_dane,N.LT]
         );
         O.cntx_pop();
         return('OD')
      ?}
   ?};
   O.cntx_pop()
|? _dane:=(date()~1*12+date()~2)-(N.OD~1*12+N.OD~2); _dane>60
|| FUN.emsg(
      'Nieobecność dotyczy okresu sprzed %1 miesięcy i nie może zostać rozliczona na najbliższej liście płac.\n'
      'Sprawdź daty nieobecności lub wskaż listę, na której ma zostać rozliczona.'@
      [$_dane]
   );
   return('OD')
?};

::    sprawdzanie nieobecności na część dnia
{? N.PARTDAY='T' & N.OD<>N.DO
|| FUN.emsg('Jeżeli nieobecność obejmuje tylko część dnia,\n'+
      'to data końca tej nieobecności musi być taka sama jak data jej rozpoczęcia.'@);
   return(_fld('DO'))
?};
_part:=N.PARTDAY='T';
_ref:={? _put || N.ref() || null() ?};
_tab:=exec('getNieobInDays','nieobecnosc',N.P,N.OD,N.DO,_ref);
_size:=_tab.size()+1;
{? (__RUB.sys_attr(N.NB,122722) | __RUB.sys_attr(N.NB,122742))
|| _size-=1
?};

N.cntx_psh();
{? _tab.first()
|| {!
   |? {? N.seek(_tab.REF,,1)
      || {? (__RUB.sys_attr(N.NB,122722) | __RUB.sys_attr(N.NB,122742))
         || _size-=1
         || _part+=N.PARTDAY='T'
         ?}
      ?};
      _tab.next()
   !}
?};
N.cntx_pop();
{? (_part<>0) & (_part<>_size)
|| FUN.emsg('Istnieje kilka nieobecności w wybranym zakresie dat.\n'+
   'Wszystkie nieobecności, które występują w jednym dniu\n'+
   'muszą być wprowadzone jako nieobecności na część dnia.'@);
   return('OD')
?};

:: Sprawdzamy konflikty czasu pracy dla wprowadzanej nieobecności
{? exec('test_par','parametr',246,'T') & exec('lic_or','#b_domain','PRC')
|| exec('konflikty','nieobecnosc',N.P,N.OD,N.DO,1,0,,1,_put)
?};

_ret:=exec('n','overlap',{? _put || N.ref() || null() ?});
{? (type_of(_ret)=type_of(0) & ~_ret) | (type_of(_ret)=type_of('') & _ret<>'')
|| return(_ret)
?};

{? exec('info_zw','personel','N') & ~FUN.ask('Czy na pewno wprowadzić kolidującą nieobecność?'@)
|| return(_fld('DO'))
?};

{? __RUB.sys_attr(N.NB,11522) | __RUB.sys_attr(N.NB,11542)
|| FUN.info(
      'Wprowadzono nieobecność "%1".\n'
      'Należy przejść do umów o pracę i zarejestrować przebieg zatrudnienia\n'
      'z zaznaczonym polem "Praca w trakcie urlopu macierzyńskiego".\n'
      'Uzupełnione też muszą być pola "Wymiar zatrudnienia" i "Kwota" (płaca zasadnicza).'@
      [N.NB().RT]
   )
?};

:: Kontrola wprowadzenia pełnych godzin dla opieki Art 188 na część dnia
:: Kontrola wprowadzenia pełnych godzin dla nieobecności "siła wyższa"
{? N.PARTDAY='T' & (__RUB.sys_attr(N.NB,1162,N.OD) | __RUB.sys_attr(N.NB,1181,N.OD)) & N.NG<>ceil(N.NG)
|| _err:='Dla wybranego rodzaju nieobecności dopuszczalne jest podawanie tylko pełnych godzin nieobecności.'@;
   FUN.emsg(_err);
   return('NG')
?};

:: Kontrola kodu niezdolności do pracy z kodem nieobecności
{? N.KDCH().KOD='B' & ~(__RUB.sys_attr(N.NB,12112) | __RUB.sys_attr(N.NB,122112))
|| __RUB.seek(__RUB.sys_kod(12112));
   {? FUN.ask('%1\n%2\n%3'
         [  'Wybrany kod niezdolności do pracy z pola \"Kod choroby\" nie odpowiada wybranej nieobecności.'@,
            'Sugerowane jest wypełnienie pola "Składnik" wartością: %1 - %2.'@[$R.RN,R.RT],
            'Czy zmienić rodzaj nieobecności?'@
         ]
      )
   || N.NB:=R.ref();
      win_disp();
      return('NB')
   ?}
?};

{? R.RN=4 & N.OD~1=2022
|| _txt:='Nieobecność "%1" nie powinna być użyta po %2 roku.\n'
      'jeśli nie jest to kontynuacja okresu zasiłkowego z 2021 roku.\n'
      'Możesz zmienić na nieobecność o kodzie %3 "%4".'@[__RUB.RT[4],date(2022,1,1)$6,'30',__RUB.RT[30]];
   {? FUN.choice(_txt,,'Zmień kod',,,,'Bez zmian')
   || N.NB:=__RUB.REF[30];
      N.PROC:=exec('procent','nieobecnosc',N.NB);
      win_disp();
      return('NB')
   ?}
|? R.RN=4 & N.OD~1>2022
|| _txt:='Nieobecność "%1" nie może być użyta po %2 roku.\n'
      'Wybierz nieobecność o kodzie %3 "%4".'@[__RUB.RT[4],date(2022,1,1)$6,'30',__RUB.RT[30]];
   FUN.emsg(_txt);
   N.NB:=__RUB.REF[30];
   N.PROC:=exec('procent','nieobecnosc',N.NB);
   win_disp();
   return('NB')
?};

:: Sprawdzenie czy nie występuje praca poza siedzibą w czasie nieobecności:
{? N.PARTDAY<>'T' & exec('jest_ppsfn','ppsf',N.OD,N.DO,N.P,1) &
   ~FUN.ask('%1.\n%2'['W trakcie nieobecności występuje praca poza siedzibą firmy'@,'Czy kontynuować?'@])
|| return('OD')
?};

:: 23.25_ZUS01 - rezygnacja z podpowiedzi dla atrybutu 14319 (komunikat o niewypełnieniu pola)
{? __RUB.sys_attr(N.NB,12274) & ~N.KDSW
|| {? ~FUN.ask('Nie wypełniono kodu świadczenia. Czy kontynuować?')
   || return('KDSW')
   ?}
?};

{? N.NK<(N.DN+N.OP*0.25)
|| 'DN'
|| 1
?}


\n_params
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Funkcja tworzy tablicę z elementami nazwanymi wykorzystywaną podczas dołączania, poprawiania i usuwania
::       nieobecności. Tablica zastępuje dotychczasowe zmienne globalne.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=obj_new('NB','OD','DO','NK','UW','PARTDAY');
_fld.NB:=null();
_fld.OD:=_fld.DO:=date(0,0,0);
_fld.NK:=0;
_fld.UW:='';
_fld.PARTDAY:='';
_fld


\n_nb_icon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła ustawia ikonę w polu N.NB().RN.
::   WE: _a [STRING] - Akronim okna wertowania.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
N.win_fml(_a,N,'NB','RN','ICON_BEFORE',
   "  {? __RUB.sys_attr(N.NB,1921) || 'xwin16.png:54'
      |? __RUB.sys_attr(N.NB,1922) || 'xwin16.png:55'
      |? __RUB.sys_attr(N.NB,1923) || 'xwin16.png:53'
      |? __RUB.sys_attr(N.NB,1924) || 'xwin16.png:57'
      |? __RUB.sys_attr(N.NB,1925) || 'xwin16.png:58'
      || 'xwin16.png:83'
      ?}
   "
)


\czy_nrg_auto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdza, czy czas nieobecności jest określany na podstawie kalendarza.
::   WE:
::   WY: 1 - wyliczaj z kalendarza
::       0 - może być określony przez użytkownika
::----------------------------------------------------------------------------------------------------------------------
N.NRG_AUTO='T'


\n_nr_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed redakcją pola NR tabeli N.
::   WE:
::   WY: zgodna ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
N.PARTDAY='N' & ~exec('czy_nrg_auto','nieobecnosc')


\n_ng_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed redakcją pola NG tabeli N.
::   WE:
::   WY: zgodna ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
~exec('czy_nrg_auto','nieobecnosc')


\n_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Rekord - przed" dla tabeli N.
::       Aktualizuje zawartość wolnych pól z informacjami z dyscypliny pracy
::   WE: _a [NUMBER] - Rekord bieżący? [0 - nie / 1 - tak]
::   WY:
::  OLD: \NBrekprz/kali.fml
::  OLD: \N_POD/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.POR:=N.POD+N.POZ;
{? cur_win(1,1)='SLO'
|| return(0)
?};

POLA_GRP.REAL_1:=POLA_GRP.REAL_2:=POLA_GRP.REAL_3:=0;
POLA_GRP.TXT_1:='X';

{? ~N.size()
|| POLA_GRP.REAL_1:=POLA_GRP.REAL_2:=POLA_GRP.REAL_3:=0;
   POLA_GRP.TXT_1:=''

|? N.NB=KST_PAR.URL_CHOR
:  Urlop na żądanie
|| _akt:=KST_PAR.URL_LIM;
   _rok:=N.OD~1;
   STAZ.cntx_psh();
   STAZ.index('_STAZE');
   STAZ.prefix(exec('ref_firma','ustawienia'),N.P().OSOBA);
   {? STAZ.last()
   || {!
      |? {? STAZ.DZ~1=_rok
         || _akt-=STAZ.WUZ
         ?};
         STAZ.prev()
      !}
   ?};
   STAZ.cntx_pop();
   {? _akt<0 || _akt:=0 ?};
   _wyk:=0;
   N.cntx_psh();
   N.index('NIPRACNB');
   N.prefix('N',N.P,KST_PAR.URL_CHOR().RN);
   {? N.first()
   || {!
      |? {? N.OD~1=_rok
         || _wyk+=N.NR
         ?};
         N.next()
      !}
   ?};
   N.cntx_pop();
   POLA_GRP.REAL_1:=_akt;
   POLA_GRP.REAL_2:=_wyk;
   POLA_GRP.REAL_3:=_akt-_wyk;
   POLA_GRP.TXT_1:='R'

|? N.NB=KST_PAR.URLOP | __RUB.sys_attr(N.NB,1114)
:  Urlop wypoczynkowy i oddelegowanie
|| KART_URL.cntx_psh();
   KART_URL.index('PRAC_ROK');
   KART_URL.prefix(N.P);
   {? KART_URL.find_key(N.OD~1)
   || {? 2004<=N.OD~1
      || POLA_GRP.REAL_1:=KART_URL.URL_WYKG+KART_URL.URL_POZG;
         POLA_GRP.REAL_2:=KART_URL.URL_WYKG;
         POLA_GRP.REAL_3:=KART_URL.URL_POZG;
         POLA_GRP.TXT_1:='G'
      || POLA_GRP.REAL_1:=KART_URL.URL_WYK+KART_URL.URL_POZ;
         POLA_GRP.REAL_2:=KART_URL.URL_WYK;
         POLA_GRP.REAL_3:=KART_URL.URL_POZ;
         POLA_GRP.TXT_1:='R'
      ?}
   ?};
   KART_URL.cntx_pop()

|? __RUB.sys_attr(N.NB,1113)
: Urlop dodatkowy
|| KART_URL.cntx_psh();
   KART_URL.index('PRAC_ROK');
   KART_URL.prefix(N.P);
   {? KART_URL.find_key(N.OD~1)
   || {? 2004<=N.OD~1
      || POLA_GRP.REAL_1:=KART_URL.NSP_WYKG+KART_URL.NSP_POZG;
         POLA_GRP.REAL_2:=KART_URL.NSP_WYKG;
         POLA_GRP.REAL_3:=KART_URL.NSP_POZG;
         POLA_GRP.TXT_1:='G'
      || POLA_GRP.REAL_1:=KART_URL.NSP_WYK+KART_URL.NSP_POZ;
         POLA_GRP.REAL_2:=KART_URL.NSP_WYK;
         POLA_GRP.REAL_3:=KART_URL.NSP_POZ;
         POLA_GRP.TXT_1:='R'
      ?}
   ?};
   KART_URL.cntx_pop()

:  Dyscyplina pracy
|| DS.cntx_psh();
   DS.index('DYSCYPLI');
   DS.prefix(N.P,N.OD~1,N.NB);
   {? DS.first()
   || POLA_GRP.REAL_1:=DS.NN;
      POLA_GRP.REAL_2:=DS.NW;
      POLA_GRP.REAL_3:=DS.NP;
      POLA_GRP.TXT_1:=DS.NR
   ?};
   DS.cntx_pop()
?};

_kod:=POLA_GRP.TXT_1;
_prec:=0;
{? _kod='K'
|| POLA_GRP.TXT_1:='Dni kalendarzowe'@
|? _kod='R'
|| POLA_GRP.TXT_1:='Dni robocze'@
|? _kod='G'
|| POLA_GRP.TXT_1:='Godziny robocze'@;
   _prec:=2
|? _kod='X'
|| POLA_GRP.TXT_1:='Brak danych'@
?};

: Ustal format wyświetlania dla pól POLA_GRP.REAL_?.
_format:=
   {? _kod='' | _kod='X'
   || "'empty=1'"
   || $('\'out_prec='+$_prec+'\'')
   ?};

{! _lp:=1 .. 3
|! POLA_GRP.fld_fml('REAL_'+$_lp,'DISPLAY_FORMAT',_format)
!};

: Ustal format wyświetlania dla pola POLA_GRP.TXT_1.
POLA_GRP.fld_fml('TXT_1','DISPLAY_FORMAT',$('\'empty='+$(_kod='')+'\''));

EDIT_VAR.DT:={? N.UW='T' || N.NT || N.NK ?};

_nbk:=0;
{? N.NRG_AUTO='T'
|| NBK.cntx_psh();
   NBK.index('UNIQUE');
   NBK.prefix();
   _nbk:=NBK.find_key(N.ref());
   NBK.cntx_pop()
?};

{? _nbk<>0
|| Color.fnd_kol('N#NIEO#01')

|? N.RODZAJ='K'
|| LSW.cntx_psh();
   LSW.index('PN');
   LSW.prefix(P.ref(),N.ref());
   _color:={? LSW.first() || 'N#NIEO#03' || 'N#NIEO#02' ?};
   LSW.cntx_pop();
   Color.fnd_kol(_color)
?}


\n_dolacz_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Dołącz" w oknach tabeli N. Jeżeli rekord jest poprawny następuje próba zapisu.
::       Gdy zapis zakończony sukcesem, aktualizacja kartotek: dyscypliny pracy, kart urlopowych.
::       Po aktualizacji kartotek wywoływane są funkcje "dzielące" nieobecność: n_rozpisz*.
::       Formuła wykorzystywana również przy tworzeniu nieobecności na podstawie wniosków z portalu.
::   WE: _a [REFERENCE] - Wskazanie wniosku urlopowego (opcjonalnie).
::   WY:
::  OLD: \dodaj/nieobecn.fml
::  OLD: \czy_mod/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
:: Funkcja \czy_mod/nieobecn.fml zdeaktualizowała się. O dostępie do akcji Dołącz / Popraw / Usuń będzie decydował
:: dostęp do odpowiedniej czynności.

_nwu:=(var_pres('_a')=type_of(NWU) & _a=NWU);

_ret:=0;

N.blank();
EDIT_VAR.DT:=0;

exec('n_efld_opt','nieobecnosc','*',N,'RED');

_fld:=exec('n_params','nieobecnosc');
params_set('fld',_fld);

{? _nwu
|| N.NB:=NWU.R;
   N.OD:=NWU.OD;
   N.DO:=NWU.DO;
   exec('n_czas','nieobecnosc');
   {? NWU.G<>0
   || _lgr:=__KAL.w_hours(NWU.OD,NWU.DO);
      N.NG:={? NWU.PARTDAY='N'
            || _lgr
            || {? __RUB.sys_attr(NWU.R,1162,NWU.OD)
               || NWU.G
               || {? NWU.G>_lgr || _lgr || NWU.G ?}
               ?}
            ?}
   ?};
   N.PARTDAY:=NWU.PARTDAY;
   N.KOMENT:=NWU.KOMENT;
   exec('n_nb_ae','nieobecnosc',N,1)
|| N.OD:=date()
?};
EDIT_VAR.POR:=0;

{!
|? {? N.edit("exec('n_ae','nieobecnosc',0)")
   || {? N.add()
      || win_disp();
         _ret+=1;
::         !!! Brakujące funkcje (projekty)
::         exec('ndos_p','projekty');
         {? _nwu
         || exec('polacz','wnioski_urlopowe',N.ref())
         ?};
         exec('n_add_after','nieobecnosc');
         0
      || 1
      ?}
   ?}
!};

_ret


\n_add_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Po dodaniu rekordu do tabeli N - w ramach akcji "Dołącz" lub wprowadzania nieobecności na podstawie wniosku.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('p_info_update_add','osoba');
:: Aktualizacja 12.51_NRU01 - Nowe rodzaje urlopów (zmiany w KP)
{? exec('upgrade2226_nru01','wnioski_urlopowe')
:: Urlop opiekuńczy:
|| {? __RUB.sys_attr(N.NB,119)
   || exec('nwopo_n_ae','wnioski_urlopowe',0)
   ?}
?};
N.cntx_psh();
_zm_rok:=N.DO~1;
exec('n_rozpisz','nieobecnosc',0,0);
N.cntx_pop();
N.get();
_zm_rok-=N.DO~1;
exec('kart_url_update_add_n','kart_url',_zm_rok);
FUNKCJE.OBLICZDS(N.OD~1);
exec('n_limity','nieobecnosc',N.OD~1,N.NB);
{? &_zm_rok
|| FUNKCJE.OBLICZDS(N.OD~1+1)
|| exec('n_limity','nieobecnosc',N.OD~1+1,N.NB)
?};
exec('ekw_info','nieobecnosc',N.NB,N.DO);
{? exec('n_rozliczalna','nieobecnosc')
|| exec('nw_aktualizuj','nieobecnosc');
   exec('nw_select','nieobecnosc')
?};
~~


\n_popraw_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Funkcja wywoływana przez akcję "Popraw" (niestandardową) okienek wertowania tabeli nieobecności. Sprawdzane
::       są warunki konieczne do spełnienia przy usuwaniu nieobecności nieobecność nie jest jeszcze rozliczona
::       na liście płac lub lista płac, na której rozliczono nieobecność nie została zamknięta.
::       Jeżeli rekord jest poprawny (wywołanie \\n_ae/nieobecnosc.fml) to następuje próba zapisu.
::       Gdy zapis zakończony sukcesem, aktualizacja kartotek: dyscypliny pracy, kart urlopowych.
::       Po aktualizacji kartotek wywoływane są funkcje "dzielące" nieobecność: n_rozpisz*.
::   WE:
::   WY:
::  OLD: \popraw/nieobecn.fml
::  OLD: \czy_mod/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
:: Funkcja \czy_mod/nieobecn.fml zdeaktualizowała się. O dostępie do akcji Dołącz / Popraw / Usuń będzie decydował
:: dostęp do odpowiedniej czynności.

_org:=exec('n_params','nieobecnosc');
_fld:=exec('n_params','nieobecnosc');
params_set('fld',_fld);

_org.NB:=N.NB;
_org.OD:=N.OD;
_org.DO:=N.DO;
_org.UW:=N.UW;
EDIT_VAR.DT:={? N.UW='D' || N.NK || N.NT ?};

_kod:=N.NB().RN;
_nr:=N.NR;

{? ~exec('n_zablokowana','nieobecnosc',1,1)
|| {!
   |? exec('n_efld_opt','nieobecnosc','*',N,'RED');
      {? N.edit("exec('n_ae','nieobecnosc',1)")
      || _zmiana:=_org.NB<>N.NB | _org.OD<>N.OD | _org.DO<>N.DO;
         {? _zmiana
         || N.POD:=N.POZ:=N.STD:=N.WART:=N.POTR1:=N.POTR2:=N.POTR3:=N.POTR4:=0
         ?};
         {? N.put()
         || win_disp();
:: !!! Brakujące funkcje (projekty, ...)
::            {? _org.OD<>N.OD | _org.DO<>N.DO
::            || exec('ndos_p','projekty')
::            ?};
            {? _zmiana
            || exec('p_info_update_put','osoba',,_kod,_org.OD,_org.DO);
::             Aktualizacja 22.26_NRU01 - Nowe rodzaje urlopów (zmiany w KP)
               {? exec('upgrade2226_nru01','wnioski_urlopowe')
::                Urlop opiekuńczy:
               || {? __RUB.sys_attr(N.NB,119) | __RUB.sys_attr(_org.NB,119)
                  || exec('nwopo_n_ae','wnioski_urlopowe',1)
                  ?}
               ?}
            ?};
            N.cntx_psh();
            _zm_rok:=N.DO~1;
            exec('n_rozpisz','nieobecnosc',0,0);
            N.cntx_pop();
            N.get();
            _zm_rok-=N.DO~1;
            exec('kart_url_update_put_n','kart_url',_org);
            FUNKCJE.OBLICZDS(N.OD~1);
            {? _org.NB=N.NB
            || exec('n_limity','nieobecnosc',N.OD~1,N.NB)
            || exec('n_limity','nieobecnosc',N.OD~1,_org.NB,N.NB)
            ?};
            {? &_zm_rok
            || FUNKCJE.OBLICZDS(N.OD~1+1);
               {? _org.NB=N.NB
               || exec('n_limity','nieobecnosc',N.OD~1+1,N.NB)
               || exec('n_limity','nieobecnosc',N.OD~1+1,_org.NB,N.NB)
               ?}
            ?};
            {? _org.NB<>N.NB |
               (_org.OD~1*12+_org.OD~2)<>(N.OD~1*12+N.OD~2) |
               (_org.DO~1*12+_org.DO~2)<>(N.DO~1*12+N.DO~2)
            || exec('tz_usun','nieobecnosc',N.NB<>KST_PAR.URLOP | N.NB<>KST_PAR.URL_CHOR,,,_org.OD);
               _nsk:='s_ch'+$(_org.OD~1);
               {? SK_CHO.name<>_nsk || SK_CHO.use(_nsk) ?};
               SK_CHO.index('SK_CHO');
               SK_CHO.prefix(N.ref);
               {? SK_CHO.first
               || {! |? SK_CHO.del !}
               ?};
               exec('nw_aktualizuj','nieobecnosc');
               exec('nw_select','nieobecnosc')
            |? _org.NB<>N.NB | _org.OD<>N.OD | _org.DO<>N.DO
            || exec('nw_aktualizuj','nieobecnosc')
            ?};
            exec('ekw_info','nieobecnosc',N.NB,N.OD,N.NR,_org.NB,_org.DO,_nr);

            0
         || 1
         ?}
      ?}
   !}
?}


\n_usun_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Funkcja wywoływana przez akcję "Usuń" okna wertowania nieobecności (niestandardowa akcja okienka).
::       Sprawdzane są warunki konieczne do spełnienia przy  usuwaniu nieobecności - nieobecność nie jest jeszcze
::       rozliczona na liście płac lub lista płac, na której rozliczono nieobecność nie została zamknięta.
::       Następnie usuwane jest rozliczenie, modyfikowany schemat waloryzacji, aktualizowana jest dyscyplina pracy
::       i karta urlopowa.
::   WE:
::   WY:
::  OLD: \usun/nieobecn.fml
::  OLD: \czy_mod/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
:: Funkcja \czy_mod/nieobecn.fml zdeaktualizowała się. O dostępie do akcji Dołącz / Popraw / Usuń będzie decydował
:: dostęp do odpowiedniej czynności.

:: Kontrola rozliczenia nieobecności na liście
{? +N.LT
|| {? N.LT<>VAR.NAZWALIS
   || FUN.emsg('Aby usunąć nieobecność należy wybrać listę "%1".'@ [N.LT]);
      return(0)
   |? O.Z='T'
   || FUN.emsg('Lista zamknięta. Usunięcie niemożliwe.'@);
      return(0)
   ?}
?};

_ok:=1;
{? +N.LT & ~FUN.ask('Nieobecność uwzględniona na liście płac.\nCzy na pewno kontynuować?'@)
|| return(0)
?};

{? ~(exec('del_ask','#table') & exec('tz_usun','nieobecnosc'))
|| return(0)
?};

:_nkor:=params_get().nkor;
_nkor:=N.N_KOR;
_fld:=exec('n_params','nieobecnosc');
params_set('fld',_fld);

_fld.NB:=N.NB;
_fld.OD:=N.OD;
_fld.DO:=N.DO;

_nsk:='s_ch'+$(N.OD~1);
{? SK_CHO.name()<>_nsk
|| SK_CHO.use(_nsk)
?};
SK_CHO.index('SK_CHO');
SK_CHO.prefix(N.ref());
{? SK_CHO.first()
|| {! |? SK_CHO.del() !}
?};

NW.cntx_psh();
NW.index('CHP');
NW.prefix(N.ref());
{? NW.first() & NW.del()
|| _NPierw:=NW.CHW;
   {!
   |? NW.prefix(N.ref());
      {? NW.first()
      || NW.CHP:=_NPierw;
         NW.clear();
         NW.put()
      ?}
   !}
?};
NW.index('CHW');
NW.prefix(N.ref());
{? NW.first() || {! |? NW.del() !} ?};
NW.cntx_pop();

:: Usunięcie korygujących zapisów w LSW
LSW.index('PN');
LSW.prefix(P.ref(),N.ref());
{? LSW.first()|| {! |? LSW.del() !} ?};
exec('polacz','wnioski_urlopowe',null(),N.ref());
_nb:=N.NB().RN;
_od:=N.OD;
_do:=N.DO;
_nr:=N.NR;
_typn:=exec('n_rozliczalna','nieobecnosc',2);
{? N.del(,1)
|| win_disp();
:: !!! Brakujące funkcje (projekty, wnioski urlopowe, ...)
::   exec('ndos_p','projekty');
   exec('p_info_update_del','osoba',,_nb,_od,_do);
:: Aktualizacja 12.51_NRU01 - Nowe rodzaje urlopów (zmiany w KP)
   {? exec('upgrade2226_nru01','wnioski_urlopowe')
::    Urlop opiekuńczy:
   || {? __RUB.sys_attr(_nb,119)
      || exec('nwopo_n_ae','wnioski_urlopowe',2)
      ?}
   ?};
   exec('nw_aktualizuj','nieobecnosc',,,_typn);
   exec('kart_url_update_del_n','kart_url',_fld);
   FUNKCJE.OBLICZDS(_fld.OD~1);
   exec('n_bd','nieobecnosc');
   exec('n_limity','nieobecnosc',_fld.OD~1,_fld.NB);
   {? var_pres('__ref_n')>0
:     Usuwana jest korekta.
   || exec('ekw_info','nieobecnosc',_fld.NB,_do,_nr,__ref_n)
   || exec('ekw_info','nieobecnosc',_fld.NB,_do)
   ?};
:: Zaktualizowanie rodzaju nieobecności korygowanej, jeśli po usunięciu nie będzie miała innych korekt
   {? _nkor>0
   || N.cntx_psh();
      N.clear();
      {? N.seek(_nkor)
      || _n_kor:=#N.ref();
         N.cntx_psh();
         N.index('NIEOTREE');
         N.prefix(_n_kor);
         _update:={? ~N.first() || 'T' || 'N' ?};
         N.cntx_pop();
         {? _update='T'
         || N.RODZAJ:='X'; N.put()
         ?}
      ?};
      N.cntx_pop()
   ?}
?};
~~


\suma_nk_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Przed wyświetleniem pola SUMA.NK.
::       Formuła służy do obliczenia sumy zaznaczonych rekordów. Dokładnie sumowane są pola NK, NR i NG.
::       Formuła odwołuje się do tabeli aktualnie wyświetlanego okna. Wykorzystywana jest na rzecz tabeli N.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=cur_tab(1,1);
_sel_size:=_TAB.sel_size();
_fml:='\'empty='+$(_sel_size=0)+'\'';
SUMA.fld_fml('NK','DISPLAY_FORMAT',$_fml);
SUMA.fld_fml('NR','DISPLAY_FORMAT',$_fml);
SUMA.fld_fml('NG','DISPLAY_FORMAT',$_fml);
{? _sel_size
|| _sql:=
      'select sum(TAB.NK) NK, sum(TAB.NR) NR, sum(TAB.NG) NG '+
      'from :_a TAB '+
      'where reference_num(TAB.REFERENCE) in (select SEL.REF from :_b SEL)';
   _SUMA:=sql(_sql,_TAB,_TAB.sel_aget());
   SUMA.NK:=_SUMA.NK;
   SUMA.NR:=_SUMA.NR;
   SUMA.NG:=_SUMA.NG
?};
1


\tz_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Funkcja usuwa dane o rozliczeniu nieobecności (tabela zasiłkowa).
::   WE: [_a] [INTEGER]      - Tryb wsadowy:
::             0 - Nie [domyślnie].
::             1 - Tak.
::       [_b] [INTEGER]      - Usuwanie tylko przy zerowej podstawie.
::             0 - Nie [domyślnie].
::             1 - Tak.
::       [_c] [STRING]       - Rodzaj rozliczenia: E(tat)/Z(lecenie).
::       [_d] [DATE/INTEGER] - Okres (data lub rok), w którym zapisy będą usuwane. Jeżeli nie podano, to przyjmuje się
::             datę z bieżącej nieobecności.
::   WY: 0 - Jeżeli dla _a=0, operator odpowiedział negatywnie na pytanie o usunięcie rozliczenia nieobecności.
::       1 - W pozostałych sytuacjach.
::  OLD: \usun/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;
_podst0:=var_pres('_b')=type_of(0) & _b;
_rok:=
   {? var_pres('_d')=type_of(date())
   || _d~1
   |? var_pres('_d')=type_of(0)
   || _d
   || N.OD~1
   ?};

{? var_pres('_c')<>type_of('')
|| exec('tz_usun','nieobecnosc',_batch,_podst0,'E',_rok)
   &
   exec('tz_usun','nieobecnosc',_batch,_podst0,'Z',_rok)
|| {? N.POD=0 & N.POZ=0
   || N.STD:=0;
      N.put()
   ?};
   TZ.use('tabz'+form(_rok,-4,0,'99'));
   TZ.index('ZASTAB');
   TZ.prefix(_c,N.ref());
   {? {? _podst0 || N.POD=0 | N.POZ=0 || 1 ?} & TZ.first()
   || {? _batch | FUN.ask('Nieobecność jest rozliczona.\nCzy usunąć powiązane rekordy?'@)
      || {! |? TZ.del() !}
      || return(0)
      ?}
   ?};
   1
?}


\n_rozliczalna
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Funkcja sprawdza, czy dla bieżącej nieobecności mogą istnieć zapisy w tabeli zasiłkowej.
::   WE: [_a] [INTEGER] - Kod spodziewanego wyniku:
::             1 - Wynik jest liczbą [domyślnie].
::             2 - Wynik jest kodem.
::       [_b] - Wyświetlać komunikat o braku schematu?
::             0 - Nie [domyślnie].
::             1 - Tak.
::   WY: zależy od parametru wejściowego:
::       _a=1
::          0 - Nieobecność nie może mieć zapisów w tabeli zasiłkowej.
::          1 - Nieobecność może mieć zapisy w tabeli zasiłkowej.
::       _a=2
::          'C' - Nieobecność jest chorobą (i może mieć zapisy w tabeli zasiłkowej).
::          'U' - Nieobecność jest urlopem (i może mieć zapisy w tabeli zasiłkowej).
::          ''  - Nieobecność nie może mieć zapisów w tabeli zasiłkowej.
::  OLD: \ROZLprz/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
_ksw:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_msg:=var_pres('_b')=type_of(0) & _b;

_odp:=
   {? __RUB.sys_attr(N.NB,129,N.OD)
   || 'C'
   |? __RUB.sys_attr(N.NB,113,N.OD) | __RUB.sys_attr(N.NB,131,N.OD) | __RUB.sys_attr(N.NB,135,N.OD)
      | __RUB.sys_attr(N.NB,117,N.OD)
   || 'U'
   || ''
   ?};
{? _odp='' & _msg
|| FUN.emsg('Dla tej nieobecności schemat rozliczenia nie jest tworzony.'@)
?};
{? _ksw=1
|| _odp<>''
|| _odp
?}


\n_stawka
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Określa wysokość stawki dziennej wynagrodzenia / zasiłku w zależności od wysokości podstawy
::       i kodu nieobecności.
::   WE: [_a] [INTEGER] - Kod nieobecności (parametr obecnie nie jest używany).
::        _b  [REAL]    - Wysokość podstawy.
::       [_c] [INTEGER] - Zapisać zmiany?
::             0 - Nie [domyślnie].
::             1 - Tak.
::   WY:
::  OLD: \stawka/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
N.STD:=(N.PROC/100*_b/30)$2;
N.WART:=N.STD*(N.NK-N.DN-N.DK-N.OP*0.25);
{? var_pres('_c')=type_of(0) & _c
|| N.put()
?}


\n_aktualizuj_podstawy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ATA [2009]
::       RWR [12.30]
:: OPIS: Funkcja aktualizująca pola dotyczące podstawy zasiłków i stawek dziennych, wykonywana z poziomu schematu
::       waloryzacji. Dodatkowo wyliczane są określone pola informacyjne zmiennej TZ_EDIT.
::       Uwaga: Procedura wykorzystywana również w wydruku "Rozliczenie nieobecności".
::   WE: [_a] [INTEGER] - Aktualizacja BEZ zapisu buforów na dysk, parametr ma znaczenie tylko dla nieobecności
::             typu C (choroby), dla typu U (urlopy) zapis nie jest wykonywany.
::          0 - Zapisy są wykonywane [domyślnie].
:           1 - Zapisy NIE są wykonywane.
::       [_b] [INTEGER] - Aktualizacja odpowiednich pól zmiennej TZ_EDIT?
::          0 - Wartości pól NIE są zmienianie [domyślnie].
::          1 - Wartości pól są zmieniane (nie jest zapamiętywany i odtwarzany kontekst)
::       [_c] - opcjonalny 1 wyliczenia z \wynchor podczas naliczania listy, 0 lub brak to edycja nieobecności
::   WY: ~~
::  OLD: \akt_npod/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~{? var_pres('_a')=type_of(0) || _a=1 || 0 ?}
|| _put:="~exec(\'n_zablokowana\',\'nieobecnosc\')"
|| _put:="0"
?};

_cntx:={? var_pres('_b')=type_of(0) || _b=1 || 0 ?};
_c:={? var_pres('_c')=type_of(1) || _c || 0 ?};

{? ~_cntx
|| TZ_EDIT.cntx_psh()
?};

{? NW.CHW<>null() & NW.CHW().get()
|| N.POD:=N.POZ:=N.STD:=0;
   _typn:=exec('n_rozliczalna','nieobecnosc',2);
   TZ.cntx_psh();
   TZ.use('tabz'+form(N.OD~1,-4,0,'9.'));
   TZ.index('PNRM');
   TZ.prefix(N.ref());
   {? _typn='C'
   || EDIT_VAR.POR:=0;
      TZ_EDIT.SET:=TZ_EDIT.LMCE:=TZ_EDIT.PMWE:=TZ_EDIT.SO:=TZ_EDIT.RME:=TZ_EDIT.WALKW:=TZ_EDIT.WALKWZC:=0;
      TZ_EDIT.WAL:='';
      TZ_EDIT.WSP:=0;
      TZ_EDIT.SUZ:=TZ_EDIT.LMCZ:=TZ_EDIT.PMWZ:=0;
      TZ_EDIT.RDP:=0;

      _dn:=TZ.first();
      {!
      |? _dn
      |! {? TZ.W<>'N'
         || {? TZ.R='E'
            || TZ_EDIT.SET+=TZ.KW;
               TZ_EDIT.LMCE+=1

            |? TZ.R='Z'
            || TZ_EDIT.SUZ+=TZ.KW;
               TZ_EDIT.LMCZ+=1
            ?}
         ?};
         _dn:=TZ.next()
      !};
      &_dn;
:     Usuwanie składników rozliczenia na podstawie zapisów w tabeli TZ
      exec('sk_cho_aktualizuj_np_tz','skladniki_okresowe');

      {? TZ_EDIT.LMCE>0 | TZ_EDIT.LMCZ>0
      || {? TZ_EDIT.LMCE>0
         || TZ_EDIT.PMWE:=TZ_EDIT.SET/TZ_EDIT.LMCE$2
         ?};
         {? TZ_EDIT.LMCZ>0
         || TZ_EDIT.PMWZ:=TZ_EDIT.SUZ/TZ_EDIT.LMCZ$2
         ?};
         {? TZ_EDIT.PMWE>0
         || TZ_EDIT.SO:=exec('dod_do_pd_skl_okr','lista_licz',0,,#N.ref())$2
         ?};

         TZ_EDIT.RME:=TZ_EDIT.PMWE+TZ_EDIT.SO;
         TZ_EDIT.WAL:=NW.WAL;
         TZ_EDIT.WSP:=NW.WSP;
         TZ_EDIT.WALKW:={? TZ_EDIT.WAL='T' || (TZ_EDIT.RME*TZ_EDIT.WSP/100)$2 || TZ_EDIT.RME ?};
::       Poprawka SPIS ER/WRT/XP/12.51/2211/0013 Brak waloryzacji podstawy chorobowej z umowy zlecenia
::       Dodano nowe pole zmiennej w emisji 23.25 TZ_EDIT.WALKWZC
         TZ_EDIT.WALKWZC:={? TZ_EDIT.WAL='T' || (TZ_EDIT.PMWZ*TZ_EDIT.WSP/100)$2 || TZ_EDIT.PMWZ ?};

         _podst:=TZ_EDIT.WALKW+TZ_EDIT.WALKWZC;
         _nod:=N.OD;
         _ndo:=N.DO;
         N.cntx_psh();
         N.index('NIEOBECN');
         N.prefix('N',P.ref());
         {? __RUB.sys_attr(N.NB,129,N.OD)
         || _ciag_od:=exec('data_ciaglosci','nieobecnosc',1)
         || _ciag_od:=date(0,0,0)
         ?};
         {? _ciag_od<>date(0,0,0) & _ciag_od<>_nod
         || {? N.find_key(_ciag_od) || _ndo:=N.DO ?}
         ?};
         N.cntx_pop();
         TZ_EDIT.KWMIN:=
            {? _podst
            || {? _put() || exec('wyr_minwyn_wynchor','lista_licz',_ndo,_podst,N.DO) || NW.KWMIN ?}
            || 0
            ?};

         NW.KWMIN:=TZ_EDIT.KWMIN;
         N.POD:=TZ_EDIT.WALKW+TZ_EDIT.KWMIN;
         N.POZ:=TZ_EDIT.WALKWZC;
         TZ_EDIT.RDP:=N.POD+N.POZ;
         EDIT_VAR.POR:=TZ_EDIT.RDP
      || NW.KWMIN:=0
      ?};

      exec('n_stawka','nieobecnosc',N.NB().RN,EDIT_VAR.POR,0);
      {? _put()
      || NW.put()
      ?};

:     N zapisujemy zawsze nawet jeśli jest wyrównanie po poprawce ER/WRT/XP/12.41/1503/0075
      {? _put()
      || LSW.cntx_psh();
         LSW.index('PN');
         LSW.prefix(P.ref(),N.ref());
         {? LSW.first()
         || exec('wyr_kor_nie_wynchor','lista_licz',_c)
         ?};
         LSW.cntx_pop();
         N.put()
      ?}

   |? _typn='U'
   || TZ_EDIT.SNO:=TZ_EDIT.SPR:=TZ_EDIT.SET:=TZ_EDIT.LMCE:=0;
      TZ_EDIT.STG:=0;

      {? __RUB.sys_attr(N.NB,117)
      || _dn:=TZ.first();
         {!
         |? _dn
         |! {? TZ.W='T' & TZ.R='E'
            || {? TZ.NO
               || TZ_EDIT.SNO+=TZ.NO;
                  TZ_EDIT.SPR+=TZ.PR;
                  TZ_EDIT.SET+=TZ.KW;
                  TZ_EDIT.LMCE+=1
               ?}
            ?};
            _dn:=TZ.next()
         !};
         &_dn;
         {? TZ.last & ~TZ.NO
         || _mc:=TZ.M
         || _mc:=#0
         ?};
         {? TZ_EDIT.SET>0 | _mc>#0
         || TZ_EDIT.SO:=exec('dod_do_pd_skl_okr','lista_licz',0,,#N.ref())$2;
            SK_CHO.cntx_psh();
            _mask1:='s_ch'+$(N.OD~1);
            {? _mask1<> SK_CHO.name()
            || SK_CHO.use(_mask1)
            ?};
            SK_CHO.index('SK_CHO');
            SK_CHO.prefix(N.ref(),_mc,'M');

            _wsk_ekw:=_umowa:=0;
            {? SK_CHO.first()
            || {!
               |? {? SK_CHO.O='W'
                  || _wsk_ekw:=SK_CHO.KW
                  |? SK_CHO.O='E'
                  || _umowa+=SK_CHO.KW
                  ?};
                  SK_CHO.next()
               !}
            ?};
            SK_CHO.cntx_pop();
            {? _wsk_ekw
            || {? TZ_EDIT.SPR & TZ_EDIT.LMCE
               || TZ_EDIT.STG:=(TZ_EDIT.SET*TZ_EDIT.SNO/TZ_EDIT.SPR/TZ_EDIT.LMCE)$2
               ?};
               TZ_EDIT.STG+=(TZ_EDIT.SO+_umowa)$2;
               TZ_EDIT.STG:=TZ_EDIT.STG/_wsk_ekw$2;
               _norma:=exec('norma','godziny',N.OD);
               TZ_EDIT.STG/=_norma;
               TZ_EDIT.STG:=TZ_EDIT.STG$2;
               N.WART:=N.NG*TZ_EDIT.STG$2
            ?}
         ?}
      || _dn:=TZ.first();
         {!
         |? _dn
         |! {? TZ.W='T' & TZ.R='E'
            || TZ_EDIT.SNO+=TZ.NO;
               TZ_EDIT.SPR+=TZ.PR;
               TZ_EDIT.SET+=TZ.KW;
               TZ_EDIT.LMCE+=1
            ?};
            _dn:=TZ.next()
         !};
         &_dn;
         {? TZ_EDIT.SPR>0
         || {? __RUB.sys_attr(N.NB,1318,N.OD)
            || TZ_EDIT.STG:=(TZ_EDIT.SET/TZ_EDIT.SPR)$2;
               N.WART:=N.NG*TZ_EDIT.STG*N.PROC/100$2
            || TZ_EDIT.STG:=TZ_EDIT.SET/TZ_EDIT.SPR$2;
               N.WART:=N.NG*TZ_EDIT.STG$2
            ?}
         ?}
      ?};
      {? _put()
      || N.put()
      ?}
   ?};
   TZ.cntx_pop()
?};
{? ~_cntx
|| TZ_EDIT.cntx_pop()
?};
~~


\nw_find_chp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Dla nieobecności "wtórnej" wskazanej przez argument _a wyszukuje w schemacie waloryzacji nieobecność
::       "pierwotną".
::   WE: _a [REFERENCE] - Ref nieobecności "pierwotnej", dla której wyszukiwana jest nieobecność "pierwotna".
::   WY: Ref znalezionej nieobecności "pierwotnej" lub null().
::  OLD: \zn_chp/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
NW.cntx_psh();
NW.index('CHW');
NW.prefix(_a);
_chp:={? NW.first() || NW.CHP || null() ?};
NW.cntx_pop();
_chp


\nw_var_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Wywoływana, gdy zachodzi konieczność aktualizacji zawartości okienek w trakcie edycji i przeglądania schematu
::       waloryzacji nieobecności
::   WE: [_a] [INTEGER] - Wartości zerowe?
::             0 - Nie (prezentowane będą wartości z bieżącego rekordu) [domyślnie].
::             1 - Tak (prezentowane będą wartości puste).
::   WY: ''
::  OLD: \akt_info/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
_blank:=var_pres('_a')=type_of(0) & _a;
EDIT_VAR.CHP_NB:={? _blank || null() || NW.CHP().NB ?};
EDIT_VAR.CHP_KDSW:={? _blank || null() || NW.CHP().KDSW ?};
EDIT_VAR.CHW_NB:={? _blank || null() || NW.CHW().NB ?};
EDIT_VAR.CHW_KDSW:={? _blank || null() || NW.CHW().KDSW ?};
POLA_GRP.REAL_1:={? _blank || 0 || NW.CHP().POD+NW.CHP().POZ ?};
''


\nw_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła odpowiedzialna za dynamiczne ustawianie właściwości pól tabeli NW. Formuła wywoływana jest w dwóch
::       kontekstach pracy:
::          - Po redagowaniu konkretnego pola, które determinuje właściwości wyświetlania innych pól.
::          - Przed wyświetleniem okna redagowania (przed właściwymi akcjami Dołącz, Popraw, Wyświetl), ustawia
::            właściwości wszystkich pól (wymagających tego).
::       Kontekst pracy jest określany na podstawie argumentu wywołania.
::   WE: [_a] [STRING] - Kontekst pracy:
::             '1' - Obsługa jednego pola [domyślnie].
::             '*' - Obsługa wszystkich pól.
::       [_b] [TABLE]  - Uchwyt tabeli, w oknie redagowania której znajdują sie pola. Jeżeli _a='1', parametr jest
::             opcjonalny - zostanie przyjęta bieżąca tabela.
::       [_c] [STRING] - Akronim okna, w którym mają być ustawione właściwości pól. Jeżeli _a='1', parametr jest
::             opcjonalny - zostanie przyjęte bieżące okno.
::       [_d] [STRING] - Akronim pola, którego wartość determinuje właściwości wyświetlania innych pól. Parametr ma
::             znaczenie wyłącznie dla _a='1'. [Domyślnie: bieżące pole].
::   WY: 0 - Błąd argumentów wywołania.
::       1 - Argumenty poprawne (właściwości ustawione).
::----------------------------------------------------------------------------------------------------------------------
_tryb:={? var_pres('_a')=type_of('') & (_a='1' | _a='*') || _a || '1' ?};
{? var_pres('_b')=type_of(N)
|| _tab:=_b
|? _tryb='1'
|| _tab:=cur_tab(1,1)
|| return(0)
?};
{? var_pres('_c')=type_of('')
|| _we:=_c
|? _tryb='1'
|| _we:=cur_win(1,1)
|| return(0)
?};
{? var_pres('_d')=type_of('')
|| _fld:=_d
|? _tryb='1'
|| _fld:=cur_afld()
|| _fld:=''
?};

{? _fld='' | _fld='WAL'
|| _sval:=$(NW.WAL='T');
   _tab.efld_opt(_we,'enable='+_sval,NW,'WSP');
   _tab.efld_opt(_we,'mark='+_sval,NW,'WSP')
?};

1


\nw_chx_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła po redagowaniu pól NW.CHP i NW.CHW.
::   WE:
::   WY:
::  OLD: \czy_chpw/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
exec('nw_var_set','nieobecnosc');
{? ~chk_fld(1)
|| FUN.emsg('Nieobecność musi być określona.'@);
   0
|? ~exec('n_rozliczalna','nieobecnosc')
|| FUN.emsg('%1 nie podlega rozliczeniu.'@ [N.NB().RT]);
   0
|| 1
?}


\nw_wal_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola NW.WAL.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('nw_efld_opt','nieobecnosc')


\nw_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Otwarcie okienka selekcji schematu waloryzacji bieżącej nieobecności.
::   WE: [_a] [INTEGER] - Czy wymusić pokazanie okna (pokazać nawet jeżeli nie ma rozliczenia)?
::          0 - Nie [domyślnie].
::          1 - Tak.
::   WY:
::  OLD: \wyswietl/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
_force:=var_pres('_a')=type_of(0) & _a;

{? N.size() & exec('n_rozliczalna','nieobecnosc',1,1)
|| NW.win_sel('WER_P');
   NW.win_edit('RED');
   {!
   |? N.cntx_psh();
      _chp:=exec('nw_find_chp','nieobecnosc',N.ref());
      {? ~_chp
      || _chp:=N.ref()
      ?};
      NW.index('CHP');
      NW.prefix(_chp);
      {? _force | NW.size()>1
      || NW.select(,1)
      ?};
      N.cntx_pop();
      NW.index('CHW');
      NW.prefix(N.ref);
      {? ~NW.first()
      || FUN.emsg('Brak informacji o sposobie rozliczenia nieobecności.'@);
         _force:=1
      |? NW.size()>1
      || FUN.emsg('Dozwolony jest tylko jeden zapis o sposobie rozliczenia bieżącej nieobecności.'@);
         _force:=1
      ?}
   !}
?};
~~


\nw_dolacz_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Obsługa akcji "Dołącz" dla tabeli NW.
::   WE:
::   WY:
::  OLD: \dodaj/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~NW.get()
|| NW.blank();
   NW.CHP:=NW.CHW:=N.ref()
?};
_Chp:=NW.CHP;
_Chw:=NW.CHW;
exec('nw_var_set','nieobecnosc');
exec('nw_efld_opt','nieobecnosc','*',NW,'RED');
{!
|? {? NW.edit("exec('nw_ae','nieobecnosc',0)")
   || {? {? _Chp & _Chp<>NW.CHP
         || FUN.ask('Zmienić chorobę "pierwotną"?'@)
         || 1
         ?}
         &
         {? _Chw & _Chw<>NW.CHW
         || FUN.ask('Zmienić chorobę "wtórną"?'@)
         || 1
         ?}
      || NW.cntx_psh();
         NW.clear();
         {? _add:=NW.add()
         || _wal:=NW.WAL;
            _wsp:=NW.WSP;
            NW.index('CHP');
            NW.prefix(NW.CHP);
            {!
            |? NW.WAL:=_wal;
               NW.WSP:=_wsp;
               NW.put();
               exec('n_aktualizuj_podstawy','nieobecnosc');
               NW.next()
            !}
         ?};
         NW.cntx_pop();
         NW.get();
         ~_add
      || 1
      ?}
   ?}
!};
{? ~NW.size()
|| sel_exit()
?}


\nw_popraw_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Obsługa akcji "Popraw" dla tabeli NW.
::   WE:
::   WY:
::  OLD: \popraw/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
_Chp:=NW.CHP;
_Chw:=NW.CHW;
_wa0:=NW.WAL;
_ws0:=NW.WSP;
NW.CHW();
{? ~exec('n_zablokowana','nieobecnosc',1)
|| exec('nw_efld_opt','nieobecnosc','*',NW,'RED');
   {!
   |? {? NW.edit("exec('nw_ae','nieobecnosc',1)")
      || {? {? _Chp<>NW.CHP
            || FUN.ask('Zmienić chorobę "pierwotną"?'@)
            || 1
            ?}
            &
            {? _Chw<>NW.CHW
            || FUN.ask('Zmienić chorobę "wtórną"?'@)
            || 1
            ?}
         || NW.cntx_psh();
            NW.clear();
            {? _a:=NW.put()
            || _wal:=NW.WAL;
               _wsp:=NW.WSP;
               {? _wal<>_wa0 | _wsp<>_ws0
               || NW.index('CHP');
                  NW.prefix(NW.CHP);
                  {!
                  |?
                     N.cntx_psh();
                     NW.CHW();
                     _blok:=exec('n_zablokowana','nieobecnosc');
                     N.cntx_pop();
                     {? ~_blok
                     || NW.WAL:=_wal;
                        NW.WSP:=_wsp;
                        NW.put();
                        exec('n_aktualizuj_podstawy','nieobecnosc')
                     ?};
                     NW.next()
                  !}
               ?}
            ?};
            NW.cntx_pop();
            NW.get();
            ~_a
         || 1
         ?}
      ?}
   !};
   {? ~NW.size()
   || sel_exit()
   ?}
?}


\nw_usun_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Obsługa akcji "Usuń" dla tabeli NW.
::   WE:
::   WY:
::  OLD: \usun/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
NW.CHW().OD;
{? ~exec('n_zablokowana','nieobecnosc',1) & exec('del_ask','#table')
|| do();
   exec('tz_usun','nieobecnosc',1);
   N.POD:=N.POZ:=N.STD:=N.WART:=N.POTR1:=N.POTR2:=N.POTR3:=N.POTR4:=0;
   N.put();
   NW.del();
   end();
   {? ~NW.size()
   || exec('nw_var_set','nieobecnosc',0)
   ?}
?}


\nw_rozliczenie_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [8.60]
::       RWR [12.30]
:: OPIS: Obsługa akcji grupowej "Rozliczenie - przed" w schemacie waloryzacji (tabela NW).
::       Utworzenie tabeli pomocniczej oraz zmiennych formułowych potrzebnych przy grupowej akcji.
::   WE:
::   WY: 1
::  OLD: \rozl_grup_przed/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
N.cntx_psh();
:Grupowa Zamiana Wartości
gzw:=obj_new('BUF','LOG','OK','N');
:Bufor na rekordy źródłowe. Należy zadbać o unikalność rekordów.
gzw.BUF:=obj_new('TAB','WS','WE','GRP');
:W tabeli będą prezentowane "zjednoczone" rekordy typu E i Z. Pole R w tej tabeli zawsze będzie miało wartość E,
:i będzie tutaj dla zgodności z mechanizmami edycji tabeli TZ, gdzie również prezentowane są "zjednoczone" rekordy.
gzw.BUF.TAB:=tab_tmp(2,
   'R','STRING[1]','R',
   'M','DATE',MS.name(TZ,'M'),
   'NO','INTEGER',MS.name(TZ,'NO'),
   'PR','INTEGER',MS.name(TZ,'PR'),
   'W','STRING[1]',MS.name(TZ,'W'),
   'KWE','REAL',MS.name(TZ_EDIT,'KWE'),
   'KWZ','REAL',MS.name(TZ_EDIT,'KWZ'),
   'STATE','STRING[1]','Status (etat)',
   'STATZ','STRING[1]','Status (zlecenia)'
);

gzw.BUF.TAB.fld_fml('R','BLANK',"'E'");
gzw.BUF.TAB.fld_fml('M','AFTER_EDIT',"exec('tz_m_ae','nieobecnosc')");
gzw.BUF.TAB.fld_fml('W','BLANK',"'T'");
gzw.BUF.TAB.fld_fml('STATE','BLANK',"'A'");
gzw.BUF.TAB.fld_fml('STATZ','BLANK',"'A'");

:Okienko wertowania
_ws:=gzw.BUF.TAB.mk_sel('Rozliczenie (tryb kopiowania)'@);
gzw.BUF.TAB.win_fld(_ws,,'M',,,10,,,,,MS.comment(TZ,'M'));
gzw.BUF.TAB.win_fld(_ws,,'NO',,,6,,,,,MS.comment(TZ,'NO'));
gzw.BUF.TAB.win_fld(_ws,,'PR',,,6,,,,,MS.comment(TZ,'PR'));
gzw.BUF.TAB.win_fld(_ws,,'W',,,-3,,,,,MS.comment(TZ,'W'),2,,"'T'","'N'","'P'");
gzw.BUF.TAB.win_fld(_ws,TZ_EDIT,'KWE',,,16,2,,,,MS.comment(TZ_EDIT,'KWE'));
gzw.BUF.TAB.win_fld(_ws,TZ_EDIT,'KWZ',,,16,2,,,,MS.comment(TZ_EDIT,'KWZ'));

:Modyfikacja danych wymaga odpowiednich uprawnień - dostępu do czynności PPL_PLL_RSKP (rejestracja składników
:płacowych).

{! _empty:=0 .. 1
|! gzw.BUF.TAB.win_act(_ws,_empty,'Dołącz',,,,
      "  TZ_EDIT.KWE:=0;
         TZ_EDIT.STATE:='';
         TZ_EDIT.KWZ:=0;
         TZ_EDIT.STATZ:='';
         1
      "
   );
   task_attach('PPL_PLL_RSKP')
!};
gzw.BUF.TAB.win_act(_ws,,'Popraw');
task_attach('PPL_PLL_RSKP');
gzw.BUF.TAB.win_act(_ws,,'Usuń',,,,,,,1);
task_attach('PPL_PLL_RSKP');
{! _empty:=0 .. 1
|! gzw.BUF.TAB.win_act(_ws,_empty,'Formuła','K&opiuj'@@,,,"sel_exit()",,,,,,'O');
   task_attach('PPL_PLL_RSKP')
!};
gzw.BUF.TAB.win_act(_ws,,'Formuła','Legenda'@@,,,"exec('legenda','color','@TZ#E#')",,,,,,'L',,'target=window');
gzw.BUF.TAB.win_act(_ws,,'Szukaj');
{! _empty:=0 .. 1
|! gzw.BUF.TAB.win_act(_ws,_empty,'Rekord',,,,
      "  TZ_EDIT.KWE:=cur_tab().KWE;
         TZ_EDIT.STATE:=cur_tab().STATE;
         TZ_EDIT.KWZ:=cur_tab().KWZ;
         TZ_EDIT.STATZ:=cur_tab().STATZ;
         0
      ",
:     Formuła po redagowaniu ma dwa zadania:
:        - standardowe sprawdzenie wypełnienia pól (realizowane przez \tz_ae/nieobecnosc.fml)
:        - weryfikacja unikalności
      " _tab:=cur_tab();
         _odp:=exec('tz_ae','nieobecnosc');
         {? _odp=''
         || {? _tab.KWE<>TZ_EDIT.KWE || _tab.STATE:={? -_tab.STATE=_tab.STATE || 'p' || 'P' ?} ?};
            {? _tab.KWZ<>TZ_EDIT.KWZ || _tab.STATZ:={? -_tab.STATZ=_tab.STATZ || 'p' || 'P' ?} ?};
            _tab.KWE:=TZ_EDIT.KWE;
            _tab.KWZ:=TZ_EDIT.KWZ
         ?};
         _odp
      "
   )
!};
gzw.BUF.TAB.win_btn(_ws,'text='+'Dołącz'@,'menu:D');
task_attach('PPL_PLL_RSKP');
gzw.BUF.TAB.win_btn(_ws,'text='+'Popraw'@,'menu:P');
task_attach('PPL_PLL_RSKP');
gzw.BUF.TAB.win_btn(_ws,'text='+'Usuń'@,'menu:U');
task_attach('PPL_PLL_RSKP');
gzw.BUF.TAB.win_btn(_ws,'text='+'K&opiuj'@,'menu:O');
task_attach('PPL_PLL_RSKP');
gzw.BUF.WS:=_ws;

_grp:=gzw.BUF.TAB.grp_make('Rozliczenie (tryb kopiowania)'@,,,,,
   "_a='sel_exit' | FUN.ask('Czy na pewno chcesz zrezygnować z kopiowania danych?'@)",,'normal');
gzw.BUF.TAB.grp_sel(_grp,,_ws,,,,,,,,,,'maximized');
gzw.BUF.GRP:=_grp;

gzw.BUF.TAB.win_sel(_grp);

:Okienko redagowania
_we:=gzw.BUF.TAB.mk_edit();
gzw.BUF.TAB.win_esep(_we,'Dane podstawowe'@);
gzw.BUF.TAB.win_efld(_we,,'M',,,,,,,,MS.comment(TZ,'M'));
gzw.BUF.TAB.win_efld(_we,,'NO',,,6,,1,,,MS.comment(TZ,'NO'));
gzw.BUF.TAB.win_efld(_we,,'PR',,,6,,1,,,MS.comment(TZ,'PR'));
gzw.BUF.TAB.win_efld(_we,,'W',,,3,,,,,MS.comment(TZ,'W'),'check-box',,"'T'","'N'","'P'");
gzw.BUF.TAB.win_efld(_we,TZ_EDIT,'KWE',,,16,2,,,,MS.comment(TZ_EDIT,'KWE'));
gzw.BUF.TAB.win_efld(_we,TZ_EDIT,'KWZ',,,16,2,,,,MS.comment(TZ_EDIT,'KWZ'));
gzw.BUF.TAB.win_ebtn(_we,'text='+exec('text_red_ok','#window'),"'key:F2'");
gzw.BUF.TAB.win_ebtn(_we,'text='+'&Anuluj'@,"'key:Esc'");

gzw.BUF.TAB.efld_opt(_we,'mark=1',,'M');

gzw.BUF.TAB.win_edit(_we);
gzw.BUF.WE:=_we;

:Tabela z komunikatami o niepowodzeniach. Jeżeli wszystko będzie ok - błędy nie będą prezentowane. Z tworzeniem
:okienka poczekajmy do zakończenia przetwarzania.
gzw.LOG:=tab_tmp(,
   'OD','DATE',MS.name(N,'OD'),
   'DO','DATE',MS.name(N,'DO'),
   'KOD','INTEGER',MS.name(R,'RN'),
   'N','STRING[20]',MS.name(R,'RT'),
   'L','STRING[8]',MS.name(O,'LT'),
   'O','STRING[60]','Opis'@
);
:Stan przetwarzania:
: 0 - początek
: 1 - po akceptacji kopiowania
:-1 - rezygnacja z kopiowania
gzw.OK:=0;

:Uchwyt źródłowej nieobecności
gzw.N:=null();
1


\nw_rozliczenie_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Obsługa akcji "Rozliczenie - przed" w okienku WER tabeli NW.
::   WE:
::   WY:
::  OLD: \wyl_pods/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
{? NW.CHW<>null() & NW.CHW().get()
|| {? NW.sel_size()=0
   || exec('tz_select','nieobecnosc')

:     Obsługa akcji grupowej
   |? gzw.OK>=0
   || TZ.cntx_psh();
      TZ.use('tabz'+form(N.OD~1,-4,0,'9.'));
      TZ.index('PNRM');
      TZ.prefix(N.ref());

:     Ewentualne przygotowanie i edycja bufora. Może się zdarzyć, że na razie nie ma żadnego TZ - po to ta akcja grupowa
      {? gzw.OK=0
      || gzw.N:=N.ref();
         _dn:=TZ.first();
:        Wybrany (unikalny) indeks tabeli TZ gwarantuje, że dla danego miesiąca najpierw przeglądane będą rekordy E
:        a potem Z.
         {!
         |? _dn
         |! {? gzw.BUF.TAB.find_key('E',TZ.M)
            || _new:=0
            || gzw.BUF.TAB.blank();
               gzw.BUF.TAB.M:=TZ.M;
               gzw.BUF.TAB.NO:=TZ.NO;
               gzw.BUF.TAB.PR:=TZ.PR;
               gzw.BUF.TAB.W:=TZ.W;
               _new:=1
            ?};
            {? TZ.R='E'
            || gzw.BUF.TAB.KWE:=TZ.KW;
               gzw.BUF.TAB.STATE:=TZ.STATUS
            |? TZ.R='Z'
            || gzw.BUF.TAB.KWZ:=TZ.KW;
               gzw.BUF.TAB.STATZ:=TZ.STATUS
            ?};
            {? _new
            || gzw.BUF.TAB.add()
            || gzw.BUF.TAB.put()
            ?};
            &_new;
            _dn:=TZ.next()
         !};
         &_dn;
:        Prefix dla zgodności z tabelą TZ - pierwszym polem w indeksie jest teraz miesiąc, co ułatwi weryfikację
:        unikalności.
         gzw.BUF.TAB.prefix('E');
         gzw.OK:={? gzw.BUF.TAB.select() || 1 || -1 ?};
         gzw.BUF.TAB.prefix()
      ?};

:     Właściwe kopiowanie bufora
      {? gzw.OK>=0
      || gzw.LOG.blank();
         gzw.LOG.OD:=NW.CHW().OD;
         gzw.LOG.DO:=NW.CHW().DO;
         gzw.LOG.KOD:=N.NB().RN;
         gzw.LOG.L:=N.LT;
         gzw.LOG.N:=R.RT;
         {? exec('n_zablokowana','nieobecnosc')
         || gzw.LOG.O:='Wybierz listę płac uwzględnioną w rozliczeniu'@;
            gzw.LOG.add()
         || exec('sk_m_tworz','skladniki_okresowe','C');
            do();
            {? TZ.first()
            || {! |? TZ.del() !}
            ?};
            _dn:=gzw.BUF.TAB.first();
            {!
            |? _dn
            |! TZ.blank(1);

               TZ.R:='E';
               TZ.N:=N.ref();
               TZ.OS_N:=null();
               TZ.KW:=gzw.BUF.TAB.KWE;
               TZ.M:=gzw.BUF.TAB.M;
               TZ.NO:=gzw.BUF.TAB.NO;
               TZ.PR:=gzw.BUF.TAB.PR;
               TZ.W:=gzw.BUF.TAB.W;
               TZ.STATUS:={? gzw.N=N.ref() || gzw.BUF.TAB.STATE || -gzw.BUF.TAB.STATE ?};
               TZ.add();

               TZ.R:='Z';
               TZ.KW:=gzw.BUF.TAB.KWZ;
               TZ.STATUS:={? gzw.N=N.ref() || gzw.BUF.TAB.STATZ || -gzw.BUF.TAB.STATZ ?};
               TZ.add();

               _dn:=gzw.BUF.TAB.next()
            !};
            &_dn;

:           Jeżeli nie stoimy na nieobecności "źródłowej", to usuwamy (stare) składniki do niej przywiązane, i kopiujemy
:           z nieobecności źródłowej.
            {? gzw.N<>N.ref()
            || exec('sk_cho_aktualizuj_np_tz','skladniki_okresowe');
               exec('sk_cho_zapisz','skladniki_okresowe',gzw.N,1)
            ?};

:           Czas na ewentualne korekty składników - analiza każdego miesiąca z osobna
            _opis:='Zmiana w schemacie (kopiowanie danych)';
            _dn:=gzw.BUF.TAB.first();
            {!
            |? _dn
            |! exec('sk_m_wypelnij','skladniki_okresowe',gzw.BUF.TAB.M);
               {? gzw.BUF.TAB.KWE<>__sk_m.SUMY.S58.KW_N
               || _kwkor:=gzw.BUF.TAB.KWE-__sk_m.SUMY.S58.KW_N+__sk_m.SUMY.S54.KW_N;
                  {? exec('sk_cho_aktualizuj_po_korekcie','skladniki_okresowe',
                        N.ref(),gzw.BUF.TAB.M,__sk_m.KOR,'E',_kwkor,_opis)=0
                  || undo()
                  ?};
                  &_kwkor
               ?};
               {? gzw.BUF.TAB.KWZ<>__sk_m.SUMY.S78.KW_N
               || _kwkor:=gzw.BUF.TAB.KWZ-__sk_m.SUMY.S78.KW_N+__sk_m.SUMY.S74.KW_N;
                  {? exec('sk_cho_aktualizuj_po_korekcie','skladniki_okresowe',
                        N.ref(),gzw.BUF.TAB.M,__sk_m.KOR,'Z',_kwkor,_opis)=0
                  || undo()
                  ?};
                  &_kwkor
               ?};
               _dn:=gzw.BUF.TAB.next()
            !};
            &_dn;
            &_opis;

            exec('n_aktualizuj_podstawy','nieobecnosc');

            {? ~end()
            || gzw.LOG.O:='Rozliczenia nie udało się nadpisać'@;
               gzw.LOG.add()
            ?};
            win_disp();
            {? var_pres('__sk_m')>100
            || obj_del(__sk_m)
            ?}
         ?}
      ?};
      TZ.cntx_pop()
   ?}
?}


\nw_rozliczenie_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [8.60]
::       RWR [12.30]
:: OPIS: Obsługa akcji grupowej "Rozliczenie - po" w schemacie waloryzacji (tabela NW) - ewentualne wyświetlenie okna
::       tabeli tymczasowej z błędami przetwarzania.
::   WE:
::   WY:
::  OLD: \rozl_grup_po/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
{? gzw.OK>0
|| _h:=gzw.LOG.size();
   {? _h>0
   || {? _h<3 || _h:=3
      |? _h>30 || _h:=30
      ?};
      _ws:=gzw.LOG.mk_sel('Wykaz pozycji pominiętych w akcji grupowej'@,,,,,,_h);
      gzw.LOG.win_fld(_ws,,'OD',,,-10,,,,,MS.comment(N,'OD'));
      gzw.LOG.win_fld(_ws,,'DO',,,-10,,,,,MS.comment(N,'DO'));
      gzw.LOG.win_fld(_ws,,'KOD',,-5,,,,,,MS.comment(R,'RN'));
      gzw.LOG.win_fld(_ws,,'N',,,,,,,,MS.comment(R,'RT'));
      gzw.LOG.win_fld(_ws,,'L',,,,,,,,MS.comment(O,'LT'));
      gzw.LOG.win_fld(_ws,,'O',,,,,,,,'Opis przyczyny'@);
      gzw.LOG.win_sel(_ws);
      gzw.LOG.select()
   ?}
?};
obj_del(gzw);
&gzw;
N.cntx_pop();
N.get()


\nw_aktualizuj_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Aktualizuj" dla tabeli NW.
::   WE:
::   WY:
::  OLD: \aktschem/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
NW.cntx_psh();
NW.index('CHP');
NW.prefix(NW.CHP);
{? NW.first()
|| {!
   |? N.cntx_psh();
      NW.CHW();
      _blok:=exec('n_zablokowana','nieobecnosc');
      N.cntx_pop();
      {? ~_blok
      || exec('n_aktualizuj_podstawy','nieobecnosc')
      ?};
      NW.next()
   !}
?};
NW.cntx_pop()


\nw_bw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Wyświetl" dla tabeli NW.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('nw_efld_opt','nieobecnosc','*',NW,'RED');
NW.display()


\nw_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Rekord - przed" tabeli NW.
::   WE: _a [NUMBER] - Rekord bieżący? [0 - nie / 1 - tak]
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('nw_var_set','nieobecnosc')


\nw_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Obsługa akcji "Rekord - po" tabeli NW.
::   WE: _a [INTEGER] - Formuła wywołana dla akcji Popraw?
::          0 - Nie.
::          1 - Tak.
::   WY: Akronim pola o niepoprawnej wartości
::       0 jeśli podwojony jest klucz indeksowy,
::       1 jeśli rekord uznano za poprawny.
::  OLD: \sprawdz/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
_put:=_a;

{? ~NW.CHP
|| FUN.emsg('Choroba "pierwotna" musi być określona.'@);
   return('CHP')

|? ~NW.CHW
|| FUN.emsg('Choroba "wtórna" musi być określona.'@);
   return('CHW')

|| {? NW.WAL='T'
   || {? NW.WSP<100
      || FUN.emsg('Współczynnik nie może być mniejszy od 100.'@);
         return('WSP')
      ?}
   || NW.WSP:=0
   ?}
?};

_ret:=1;
NW.cntx_psh();
NW.index('NWP');
NW.prefix(NW.CHP,NW.CHW);

{? ~_put & NW.size()
|| FUN.emsg('Podany schemat rozliczenia już istnieje.'@);
   _ret:=0

|? _put
|| _ref:=NW.ref();
   {? NW.first() & NW.ref()<>_ref
   || FUN.emsg('Podany schemat rozliczenia już istnieje.'@);
      _ret:=0
   ?}
?};

NW.cntx_pop();
_ret


\n_find_chp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Wyszukuje nieobecność, "pierwotną" dla danej nieobecności.
::       Uwagi:
::          - Funkcja nie zachowuje kontekstu tabeli N.
::          - Zmiana kolejności argumentów _a <-> _b.
::   WE:  _a  [INTEGER] - Kod badanej nieobecności.
::        _b  [DATE]    - Data, od której badane są nieobecności.
::       [_c] [DATE]    - Data, do której są badane nieobecności (opcjonalny)
::   WY: Ref znalezionej nieobecności lub null().
::  OLD: \ciaglosc/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
_Nref:=N.ref();
{? var_pres('_a')=type_of(0)
|| _nkod:=_a
|| FUN.emsg('Błędna wartość argumentu \'%1\' funkcji \'%2\'.'@ ['_a','\\n_find_chp/nieobecnosc.fml']);
   return(null())
?};
{? var_pres('_b')=type_of(date())
|| _nod:=_b
|| FUN.emsg('Błędna wartość argumentu \'%1\' funkcji \'%2\'.'@ ['_b','\\n_find_chp/nieobecnosc.fml']);
   return(null())
?};

{? var_pres('_c')=type_of(date())
|| _ndo:=_c
|| N.cntx_psh();
   _dc:=exec('data_ciaglosci','nieobecnosc',N.NB().RN);
   N.cntx_pop();
   _RWY:={? var_pres('MAC',H)>0 & (__RUB.sys_attr(N.NB,122722) | __RUB.sys_attr(N.NB,122742)) || "H.RWY" || "H.WY" ?};
   H.cntx_psh();
   H.index('_HISTKOD');
   H.prefix(P.ref(),'Z');
   {? H.find_le(_dc)
   || _Wymiar:=_RWY();
      {!
      |? {? _Wymiar=_RWY()
         || _ndo:=H.OD;
            H.prev()
         ?}
      !}
   || _ndo:=date(0,0,0)
   ?};
   H.cntx_pop()
?};

{? _nod>=date(2004,7,1)
|| _choroba:=129
|| _choroba:=126
?};
_RetVal:=_Recall:=null();
{? _nod>=__STALE.D_ZAS & __RUB.sys_attr(_nkod,_choroba,_nod)
|| N.cntx_psh();
   _od:=N.OD;
   _kod:=N.NB().RN;
   _ref:=N.ref();
   _jest:=0;
   {!
   |? _prev:=N.prev();
      {? _prev & __RUB.sys_attr(N.NB().RN,_choroba,N.OD)
      || _jest:=1;
         0
      || _prev
      ?}
   !};
   {? _jest
   || {? N.OD<__STALE.D_ZAS
      || {? N.DO+1<>_od |
            {? __RUB.sys_attr(_kod,1225,N.OD) | __RUB.sys_attr(_kod,1227,N.OD)
            || N.NB().RN<>_kod
            || (__RUB.sys_attr(N.NB().RN,1225,N.OD) | __RUB.sys_attr(N.NB().RN,1227,N.OD)) |
               (__RUB.sys_attr(_kod,1221,N.OD) & __RUB.sys_attr(N.NB().RN,121,N.OD))
            ?}
         || _RetVal:=_ref
         ?}
      || {? _chp:=exec('nw_find_chp','nieobecnosc',N.ref())
         || N.cntx_psh();
            _war:=N.seek(_chp) & N.OD<__STALE.D_ZAS;
            N.cntx_pop();
            {? _war
            || {? N.DO+1<>_od |
                  {? __RUB.sys_attr(_kod,1225,N.OD) | __RUB.sys_attr(_kod,1227,N.OD)
                  || N.NB().RN<>_kod
                  || (__RUB.sys_attr(N.NB().RN,1225,N.OD) | __RUB.sys_attr(N.NB().RN,1227,N.OD)) |
                     (__RUB.sys_attr(_kod,1221,N.OD) & __RUB.sys_attr(N.NB().RN,121,N.OD))
                  ?}
               || _RetVal:=_ref
               ?}
            ?}
         ?}
      ?}
   ?};
   N.cntx_pop()
?};

_jest:=0;
{? __RUB.sys_attr(_nkod,_choroba,_nod)
|| {!
   |? _prev:=N.prev();
      {? _prev & __RUB.sys_attr(N.NB,_choroba,N.OD)
      || _jest:=1;
         0
      || _prev
      ?}
   !}
|| _jest:=N.prev()
?};
{? _jest & _RetVal=null()
|| _kod:=N.NB().RN;
   {? __RUB.sys_attr(_nkod,_choroba,N.OD) | __RUB.sys_attr(_nkod,1225,N.OD) | __RUB.sys_attr(_nkod,1227,N.OD)
   || _MOffset:=(_nod~1*12+_nod~2)-(N.OD~1*12+N.OD~2);
      {? {? N.OD<date(1999,9,1) & _nod<date(1999,9,1)
         || 1
         |? ~exec('sprawdz_2022','nieobecnosc',_Nref) & date(2022,1,1)<=_nod
         || 1
         |? date(1999,9,1)<=N.OD & date(1999,9,1)<=_nod
         || 3
         || -1
         ?}>=_MOffset
      || {? {? _nod>=date(2004,7,1)
            || __RUB.sys_attr(_kod,_choroba,N.OD)
            || {? __RUB.sys_attr(_nkod,1225,N.OD) | __RUB.sys_attr(_nkod,1227,N.OD)
               || _kod=_nkod
               || __RUB.sys_attr(_kod,_choroba,N.OD)
               ?}
            ?}
         || {? _chp:=exec('nw_find_chp','nieobecnosc',N.ref())
            || _RetVal:={? N.seek(_chp) || N.ref() || null() ?}
            || _RetVal:=N.ref();
               _Recall:=exec('n_find_chp','nieobecnosc',_kod,N.OD,_ndo)
            ?}
         || _Recall:=exec('n_find_chp','nieobecnosc',_nkod,_nod,_ndo)
         ?}
      ?}
   || {? _kod=_nkod & N.DO+1=_nod
      || _RetVal:=N.ref();
         _Recall:=exec('n_find_chp','nieobecnosc',_kod,N.OD,_ndo)
      ?}
   ?}
?};
{? _Recall
|| _RetVal:=_Recall
?};
_RetVal


\nw_aktualizuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Aktualizuje zapisy w schemacie waloryzacji nieobecności.
::   WE: [_a] [REFERENCE] - Wskazanie rekordu nieobecności. Formuła ma działać dla bieżącej nieobecności bez względu
::             na to czy jest znak listy oraz dla bieżącej ma nie zerować rozliczenia.
::       [_b] [INTEGER]   -  Wywołanie z korekt nieobecności:
::             0 - Nie [domyślnie].
::             1 - Tak.
::      [_c] - opcjonalny 'C', 'U' lub pusty '' do określenia typu rozliczenia
::  OLD: \test_pow/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null()) || _a || null() ?};
_korekty:=var_pres('_b')=type_of(0) & _b;
::Parametr _c dodany w poprawka ER/WRT/XP/12.51/2005/0037 Zmiana pola LT dla rozliczonego wyrównania
::Po poprawce SPIS ER/WRT/XP/12.51/2212/0018, ER/WRT/XP/21.37/2212/0008, ER/WRT/XP/22.26/2301/0002
::Poprawianie nieobecności zasiłkowa na niezasiłkowa błędny schemat rozliczenia po korekcie kodu
::nieobecności - błędna nieobecność pierwotna
::nie ma już ten parametr _c znaczenia, trzeba odbudować schemat waloryzacji dla różnych rodzajów nieobecności
::przy dodawaniu/poprawianiu nieobecności
N.cntx_psh();
N.index('NIEOBECN');
N.prefix('N',P.ref());
{? N.first()
|| {!
   |? {? N.ref()<>_ref & exec('n_zablokowana','nieobecnosc')
::       Pomiń nieobecności rozliczone na zamkniętych listach płac.
      || ~~
      |? exec('n_rozliczalna','nieobecnosc')
::       Aktualizuj powiązania pierwotna - wtórna.
      || _NieoAkt:=N.ref();
         _kod:=N.NB().RN;
         _NPierw:=exec('n_find_chp','nieobecnosc',_kod,N.OD);
         N.seek(_NieoAkt);
         {? ~_NPierw
         || _NPierw:=N.ref()
         ?};
         {? _NPierw<>N.ref() & _NPierw<>exec('nw_find_chp','nieobecnosc',N.ref()) & N.ref()<>_ref & ~_korekty
         || exec('tz_usun','nieobecnosc',1,0,'E')
         ?};
         NW.index('CHW');
         NW.prefix(N.ref());
         {? NW.first()
         || NW.CHP:=_NPierw;
            {? __RUB.sys_attr(_kod,1222,N.OD)
            || NW.WSP:=exec('find_wsp_wal','nieobecnosc',N.OD,N.ref(),_korekty);
               NW.WAL:='T'
            || NW.WSP:=0;
               NW.WAL:='N'
            ?};
            NW.put()
         || NW.blank();
            NW.CHP:=_NPierw;
            NW.CHW:=N.ref();
            {? __RUB.sys_attr(_kod,1222,N.OD)
            || NW.WSP:=exec('find_wsp_wal','nieobecnosc',N.OD,N.ref(),_korekty);
               NW.WAL:='T'
            || _wsp:=NW.WSP;
               NW.cntx_psh();
               NW.index('CHP');
               NW.prefix(_NPierw);
               {? NW.find_le(N.OD)
               || _wal:=NW.WAL;
                  {? NW.WAL='T'
                  || _wsp:=NW.WSP
                  ?}
               || _wal:='N'
               ?};
               NW.cntx_pop();
               NW.WAL:=_wal;
               NW.WSP:=_wsp
            ?};
            NW.add()
         ?};
         exec('n_aktualizuj_podstawy','nieobecnosc',_korekty)
      || NW.index('CHW');
         NW.prefix(N.ref());
         {? NW.first()
         || {! |? NW.del() !}
         ?}
      ?};
      N.next()
   !}
?};
N.cntx_pop();
N.get()


\tz_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Funkcja umożliwia przeglądanie tabeli zasiłkowej dla bieżącej nieobecności.
::   WE:
::   WY: 1
::  OLD: \ROZL/rozl_tz.fml
::  OLD: \tze_wsp_bd/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
: Funkcja \tze_wsp_bd/rozl_tz.fml zdeaktualizowała się. Obecnie ukrywanie pól związanych z waloryzacją realizowane jest
: poprzez DISPLAY_FORMAT i 'empty=1'.

:Typ nieobecności: C - choroba, U - urlop
_typn:=exec('n_rozliczalna','nieobecnosc',2);
{? type_of(_typn)<>type_of('') | (_typn<>'C' & _typn<>'U')
|| return(0)
?};
:
:Wartość początkowa pola TZ.R
EDIT_VAR.RODZ_TZ:='E';
TZ_EDIT.blank();
TZ_EDIT.N:=N.ref();
TZ_EDIT.R:=N.NB;
exec('n_aktualizuj_podstawy','nieobecnosc',1,1);

SK_CHO.cntx_psh();
SK_CHO.use('s_ch'+form(N.OD~1,-4,0,'9.'));
SK_CHO.clear();
TZ.cntx_psh();
TZ.use('tabz'+form(N.OD~1,-4,0,'9.'));
TZ.index('PNRM');
TZ.prefix(N.ref(),'E');
{? _typn='C'
:  Choroby
|| _ws:='WERCP';
   _we:='REDEZ';
   _ha:={? exec('n_zablokowana','nieobecnosc') || 'DUP:D' || '' ?};

   _df:='\'empty='+$(TZ_EDIT.WAL<>'T')+'\'';
   TZ_EDIT.fld_fml('WSP','DISPLAY_FORMAT',$_df);
   TZ_EDIT.fld_fml('WALKW','DISPLAY_FORMAT',$_df);
   TZ_EDIT.fld_fml('WALKWZC','DISPLAY_FORMAT',$_df);

:  W okienku wertowania prezentowane są rekordy typu E oraz kwoty z odpowiadających im rekordów typu Z. Sprawdźmy, czy
:  każdy rekord Z ma swój odpowiednik E, a jeżeli nie - utwórzmy go.
   TZ.prefix(N.ref(),'Z',);
   _dn:=TZ.first();
   {!
   |? _dn
   |! _mc:=TZ.M;
      _no:=TZ.NO;
      _pr:=TZ.PR;
      _kwal:=TZ.W;
      TZ.cntx_psh();
      TZ.prefix(N.ref(),'E',_mc);
      {? ~TZ.first()
      || TZ.blank();
         TZ.R:='E';
         TZ.N:=N.ref();
         TZ.OS_N:=null();
         TZ.M:=_mc;
         TZ.NO:=_no;
         TZ.PR:=_pr;
         TZ.W:=_kwal;
         TZ.add()
      ?};
      TZ.cntx_pop();
      &_kwal;
      &_pr;
      &_no;
      &_mc;
      _dn:=TZ.next()
   !};
   &_dn;
   TZ.prefix(N.ref(),'E',)

|? _typn='U'
:  Urlopy
|| _ws:='WERUP';
   _we:='REDE';
   _ha:={? exec('n_zablokowana','nieobecnosc') || 'DUP:D' || '' ?}
?};
TZ.win_sel(_ws);
TZ.win_edit(_we);
TZ.select(,,,_ha);
TZ.cntx_pop();
SK_CHO.cntx_pop();
&_ha;
&_typn;
1


\tz_dolacz_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Obsługa akcji "Dołącz - przed" tabeli TZ dla chorób pracowników.
::   WE:
::   WY:
::  OLD: \dolacz_przed/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
TZ.blank();
TZ.N:=TZ_EDIT.N;
TZ.OS_N:=null();
TZ_EDIT.KWE:=0;
TZ_EDIT.STATE:='';
TZ_EDIT.KWZ:=0;
TZ_EDIT.STATZ:='';
{? TZ.edit("exec('tz_ae','nieobecnosc')")
|| exec('sk_m_tworz','skladniki_okresowe','C');

   do();

   TZ.R:='E';
   TZ.KW:=TZ_EDIT.KWE;
   TZ.STATUS:='P';
   TZ.add();

   TZ.cntx_psh();
   TZ.clear();
   TZ.R:='Z';
   TZ.KW:=TZ_EDIT.KWZ;
   TZ.STATUS:='P';
   TZ.add();
   TZ.cntx_pop();

   {? exec('sk_cho_aktualizuj_po_korekcie','skladniki_okresowe',
         TZ.N,TZ.M,__sk_m.KOR,'E',TZ_EDIT.KWE,'Zmiana w schemacie')=0
   || undo()
   ?};
   {? exec('sk_cho_aktualizuj_po_korekcie','skladniki_okresowe',
         TZ.N,TZ.M,__sk_m.KOR,'Z',TZ_EDIT.KWZ,'Zmiana w schemacie')=0
   || undo()
   ?};

   exec('n_aktualizuj_podstawy','nieobecnosc',0,1);

   {? ~end()
   || FUN.emsg('Aktualizacja wartości korekty nie powiodła się. Wszystkie zmiany wycofane.'@)
   ?};

   {? var_pres('__sk_m')>100
   || obj_del(__sk_m);
      &__sk_m
   ?}

?};
~~


\tz_popraw_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Obsługa akcji "Popraw - przed" tabeli TZ dla chorób pracowników.
::   WE:
::   WY: ~~
::  OLD: \popraw_przed/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
:Wartości przed zmianami;
:Wyłączenie kolorowania pól.
_kwal:=TZ.W;
_kwe:=TZ_EDIT.KWE;
TZ_EDIT.STATE:='';
_kwz:=TZ_EDIT.KWZ;
TZ_EDIT.STATZ:='';
_g_nom:=TZ.NO;
_g_prac:=TZ.PR;

{? TZ.edit("exec('tz_ae','nieobecnosc')")
|| exec('sk_m_tworz','skladniki_okresowe',exec('n_rozliczalna','nieobecnosc',2));

   do();
   exec('sk_m_wypelnij','skladniki_okresowe',TZ.M);

:  Sprawdzamy, czy to co było przed korektą w TZ jest spójne z tym co jest teraz w SK_CHO.
   {? __sk_m.SUMY.S58.KW_N<>_kwe | __sk_m.SUMY.S78.KW_N<>_kwz
   || undo('Rekord został poprawiony z innego stanowiska.'@)
   ?};

:  Wysokość korekt (z uwzględnieniem wcześniejszych).
   _kore:=TZ_EDIT.KWE-_kwe+__sk_m.SUMY.S54.KW_N;
   _korz:=TZ_EDIT.KWZ-_kwz+__sk_m.SUMY.S74.KW_N;

:  Jeżeli zmieniła się kwalifikacja lub pieniądze w etacie - aktualizujemy bieżący rekord.
   {? _kwal<>TZ.W | _kwe<>TZ_EDIT.KWE | _g_nom<>TZ.NO | _g_prac<>TZ.PR
   || TZ.KW:=TZ_EDIT.KWE;
:     Jeżeli status był małą literą (po korekcie), to nadal będzie małą.
      _status:={? _kore<>0 | _kwal<>TZ.W | _g_nom<>TZ.NO | _g_prac<>TZ.PR || 'P' || 'A' ?};
     _status:={? _kore=0 || _status || 'W' ?};
      TZ.STATUS:={? -TZ.STATUS=TZ.STATUS || -_status || _status ?};
      TZ.put()
   ?};

:  Jeżeli zmieniła się kwalifikacja lub pieniądze zlecenia - aktualizujemy odpowiedni rekord.
   {? _kwal<>TZ.W | _kwz<>TZ_EDIT.KWZ | _g_nom<>TZ.NO | _g_prac<>TZ.PR
   || _mc:=TZ.M;
      _no:=TZ.NO;
      _pr:=TZ.PR;
      _kwala:=TZ.W;
      TZ.cntx_psh();
      TZ.index('PNRM');
      TZ.prefix(TZ_EDIT.N,'Z',_mc);
      {? TZ.first()
      || TZ.KW:=TZ_EDIT.KWZ;
         TZ.W:=_kwala;
:        Jeżeli status był małą literą (po korekcie), to nadal będzie małą.
         _status:={? _korz=0 || 'A' || 'P' ?};
         TZ.STATUS:={? -TZ.STATUS=TZ.STATUS || -_status || _status ?};
         TZ.put()
      || TZ.blank(1);
:        Formuła na wartość początkową pola TZ.KW zeruje pola TZ_EDIT.KWE i TZ_EDIT.KWZ, a tego nie chcemy w tej chwili.
         TZ.R:='Z';
         TZ.N:=TZ_EDIT.N;
         TZ.KW:=TZ_EDIT.KWZ;
         TZ.M:=_mc;
         TZ.NO:=_no;
         TZ.PR:=_pr;
         TZ.W:=_kwala;
:        Nowy rekord - samodzielny status (nie skopiowany).
         _status:={? _korz=0 || 'A' || 'P' ?};
         TZ.STATUS:=_status;
         TZ.add()
      ?};
      TZ.cntx_pop();
      &_kwala;
      &_pr;
      &_no;
      &_mc
   ?};

:  Jeżeli zmieniła się kwalifikacja lub pieniądze - aktualizujemy składniki i zmienne.
   {? _kwal<>TZ.W | _kwe<>TZ_EDIT.KWE | _kwz<>TZ_EDIT.KWZ | _g_nom<>TZ.NO | _g_prac<>TZ.PR
   || {? _kwe<>TZ_EDIT.KWE &
         exec('sk_cho_aktualizuj_po_korekcie','skladniki_okresowe',
            TZ.N,TZ.M,__sk_m.KOR,'E',_kore,'Zmiana w schemacie',__sk_m.TYPN)=0
      || undo()
      ?};
      {? _kwz<>TZ_EDIT.KWZ &
         exec('sk_cho_aktualizuj_po_korekcie','skladniki_okresowe',
            TZ.N,TZ.M,__sk_m.KOR,'Z',_korz,'Zmiana w schemacie',__sk_m.TYPN)=0
      || undo()
      ?};
      exec('n_aktualizuj_podstawy','nieobecnosc',0,1)
   ?};
   &_korz;
   &_kore;

   {? ~end()
   || FUN.error('Aktualizacja wartości korekty nie powiodła się. Wszystkie zmiany wycofane.'@)
   ?};

   {? var_pres('__sk_m')>100
   || obj_del(__sk_m);
      &__sk_m
   ?}

?};
~~


\tz_usun_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Obsługa akcji grupowej "Usuń - przed" tabeli TZ dla chorób pracowników.
::   WE:
::   WY:
::  OLD: \usun_gprzed/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
exec('del_ask','#table')


\tz_usun_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Obsługa akcji "Usuń - przed" tabeli TZ dla chorób pracowników.
::   WE:
::   WY:
::  OLD: \usun_przed/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
_grupa:=TZ.sel_size();

{? TZ.sel_size() | exec('del_ask','#table')
|| TZ.cntx_psh();
   TZ.index('PNRM');
   TZ.prefix(TZ.N,'Z',TZ.M);
   {? TZ.first()
   || TZ.del()
   ?};
   TZ.cntx_pop();
   TZ.del()
?};

{? _grupa<=1
|| exec('n_aktualizuj_podstawy','nieobecnosc',0,1)
?};

~~


\ekw_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Formuła przypomina o konieczności weryfikacji liczby godzin ekwiwalentu. Wywoływana w akcjach zmieniających
::       nieobecności (popraw, usuń, korekta, ....). Do formuły przekazywane są parametry związane z nieobecnością:
::       - "bieżąca", czyli ta, która zostaje w bazie PO akcji Dołącz, Popraw, korekTa.
::         Za "bieżącą" uznawana jest też nieobecność usuwana (czyli PRZED akcją Usuń).
::       - "poprzednia", czyli ta, która była w bazie PRZED akcją Popraw, ta, która jest korygowana. Nieobecność nie
::         jest wskazywana np. dla akcji Usuń.
::   WE:  _a  [REFERENCE] - Ref rubryki nieobecności "bieżącej". Parametr obowiązkowy.
::        _b  [DATE]      - Data końca nieobecności "bieżącej". Parametr obowiązkowy.
::       [_c] [INTEGER]   - Liczba dni roboczych nieobecności "bieżącej". Parametr jest wymagany, jeżeli podane są
::             następne parametry związane z nieobecnością "poprzednią".
::       [_d] [REFERENCE] - Ref "poprzedniej" nieobecności lub ref "poprzedniej" rubryki.
::       [_e] [DATE]      - Data końca nieobecności "poprzedniej".
::          Parametr wymagany i istotny jeżeli _d wskazuje rubrykę.
::       [_f] [INTEGER]   - Liczba dni roboczych nieobecności "poprzedniej".
::          Parametr wymagany i istotny jeżeli _d wskazuje rubrykę.
::   WY:  1 - Weryfikacja liczby godzin ekwiwalentu jest wymagana.
::        0 - Weryfikacja liczby godzin ekwiwalentu nie jest wymagana.
::       -1 - Błąd argumentów wywołania.
::  OLD: \ekw_info/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_err:="FUN.error('Błąd parametrów wywołania.\n[%1]'@ [_a],'nieobecnosc.fml\\ekw_info')";

{? var_pres('_a')=type_of(null()) & ref_name(_a)=R.name()
|| _nbb:=_a
|| _err('NBB');
   return(-1)
?};
{? var_pres('_b')=type_of(date())
|| _dob:=_b
|| _err('DOB');
   return(-1)
?};

_rok:=_dob~1;

: Nieobecność nie kończy się w roku zwolnienia - nie mówmy o ekwiwalencie.
{? P.DZ~1<>_rok
|| return(0)
?};

: Ustalmy stan bieżący - ekwiwalent do wypłaty.
_ekw:=0;
H_UM.cntx_psh();
H_UM.index('OD');
H_UM.prefix(P.ref());
{? H_UM.last()
|| {!
   |? {? H_UM.DO~1=_rok
      || _ekw+=H_UM.EKW;
         _ekw+=H_UM.EKW_NSP
      ?};
      H_UM.prev() & H_UM.DO~1>=_rok
   !}
?};
H_UM.cntx_pop();

: Jeżeli nie ma wpisanego ekwiwalentu - komunikatu nie będzie.
{? _ekw=0
|| return(0)
?};

: Ustalmy stan bieżący - urlop pozostały.
_pozg:=0;
KART_URL.cntx_psh();
KART_URL.index('PRAC_ROK');
KART_URL.prefix(P.ref(),_rok);
{? KART_URL.first()
|| _pozg:=KART_URL.URL_POZG
?};
KART_URL.cntx_pop();

: Bilans wychodzi na 0 - komunikatu nie będzie (ewentualna informacja o wyczerpaniu lub przekroczeniu pojawi się
: z innego miejsca).
{? _pozg=0
|| return(0)
?};

_info:="FUN.emsg('Liczba godzin ekwiwalentu może wymagać weryfikacji.'@)";

{? _=2
: Wywołanie tylko z nieobecnością "bieżącą" - obsługa akcji Usuń.
|| {? __RUB.sys_attr(_nbb,111,_dob)
   || _info();
      return(1)
   || return(0)
   ?}
?};

{? var_pres('_c')=type_of(0)
|| _nrb:=_c
|| _err('NRB');
   return(-1)
?};

{? var_pres('_d')=type_of(null())
|| _refname:=ref_name(_d);
   {? _refname=R.name()
   || _nbp:=_d;
      {? var_pres('_e')=type_of(date())
      || _dop:=_e
      || _err('DOP');
         return(-1)
      ?};
      {? var_pres('_f')=type_of(0)
      || _nrp:=_f
      || _err('NRP');
         return(-1)
      ?}

   |? _refname=N.name()
   || N.cntx_psh();
      N.prefix();
      {? N.seek(_d)
      || _nbp:=N.NB;
         _dop:=N.DO;
         _nrp:=N.NR
      || _nbp:=null()
      ?};
      N.cntx_pop();
      {? _nbp=null()
      || _err('_d - brak wskazanej nieobecności');
         return(-1)
      ?}
   || _err('_d='+_refname);
      return(-1)
   ?}

|| _err('_d - typ');
   return(-1)
?};

_bylurlop:=__RUB.sys_attr(_nbp,111,_dop);
_jesturlop:=__RUB.sys_attr(_nbb,111,_dob);
{? (_bylurlop & ~_jesturlop) | (_bylurlop & _jesturlop & _nrb<_nrp)
|| _info();
   1
|| 0
?}


\n_limity
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Na podstawie informacji zawartych w dyscyplinie pracy oraz karcie urlopowej (dla urlopów) wyświetla komunikat
::       o przekroczeniu lub wykorzystaniu limitu nieobecności dla wskazanych lub wszystkich nieobecności.
::       Formuła wywoływana jest dla bieżącego rekordu tabeli P.
::   WE: [_a] [INTEGER]           - Rok, którego dotyczy sprawdzenie - parametr opcjonalny
::       [_b] [INTEGER/REFERENCE] - Rubryka (numer lub ref) nieobecności do zbadania - parametr opcjonalny.
::       [_c] [INTEGER/REFERENCE] - Rubryka (numer lub ref) nieobecności do zbadania - parametr opcjonalny.
::       [_d] [INTEGER/REFERENCE] - Rubryka (numer lub ref) nieobecności do zbadania - parametr opcjonalny.
::       [_e] [INTEGER/REFERENCE] - Rubryka (numer lub ref) nieobecności do zbadania - parametr opcjonalny.
::       [_f] [INTEGER/REFERENCE] - Rubryka (numer lub ref) nieobecności do zbadania - parametr opcjonalny.
::       [_g] [INTEGER/REFERENCE] - Rubryka (numer lub ref) nieobecności do zbadania - parametr opcjonalny.
::       ...
::   WY:
::  OLD: \OBLDSmsg/kali.fml
::----------------------------------------------------------------------------------------------------------------------
_rok:=
   {? ~(var_pres('_a')=type_of(0) & _a)
   || {? VAR.JESTLIST || O.R || date()~1 ?}
   || _a
   ?};
:Rubryki przekazane parametrami mogą być numerem lub refem, ale my będziemy posługiwali się refem.
_nb:='';
{? _>=2
|| {! _arg:=2.._
   |! _val:=_[_arg];
      {? type_of(_val)=type_of(null())
      || _nb+=','+$#_val
      |? type_of(_val)=type_of(0) & 1<=_val & _val<=VAR.MAXRUB
      || _nb+=','+$#__RUB.REF[_val]
      ?}
   !};
   {? +_nb
   || _nb+=','
   ?}
?};
_nb:={? +_nb || $('\''+_nb+'\'*(\',\'+$#_a+\',\')') || "1" ?};

R.cntx_psh();
R.index('RUBKLLP');
R.prefix('N');
_rub:={? R.last() || R.LP ?};
R.cntx_pop();
{? ~_rub || return() ?};

R.cntx_psh();

_msg:=obj_new(_rub);
{! _lp:=1..obj_len(_msg) |! _msg[_lp]:='' !};
KART_URL.index('PRAC_ROK');
KART_URL.prefix(P.ref(),_rok);
_karta:=KART_URL.first();
_lim:=_poz:=0;
_lim1:=_poz1:=0;

{? _nb(KST_PAR.URLOP) | _nb(KST_PAR.URL_CHOR)
|| {!
   |? _again:=0;
      {? exec('kart_url_find','kart_url',_rok)
      || _lim:={? 2004<=_rok || EDIT_VAR.RAZEMG || EDIT_VAR.RAZEM ?};
         _poz:={? 2004<=_rok || KART_URL.URL_POZG || KART_URL.URL_POZ ?};
         {? (_lim | _karta) & _poz<0
:           Specjalna obsługa ekwiwalentu dla przekroczonego limitu i wywołania interaktywnego.
         || _err:=0;
:           Wskaźnik błędu polegającego na różnicy w liczbie godzin ekwiwalentu w H_UM i rozliczonego na liście.
            _ekw:=0;
:           Liczba godzin ekwiwalentu "do wykorzystania", czyli takiego, który jest wprowadzony w H_UM i jeszcze nie
:           jest rozliczony na listach płac.
            _tab:=tab_tmp(1,
               'REF','INTEGER','H_UM.ref()',
               'OD','DATE','Od',
               'DO','DATE','Do',
               'EKWU_WYP','REAL','Ekwiwalent wypoczynkowy(umowa)',
               'EKWU_NSP','REAL','Ekwiwalent dodatkowy(umowa)',
               'LT','STRING[8]','Lista rozliczająca',
               'CRC','INTEGER','CRC',
               'EKWL','REAL','Ekwiwalent (lista)',
               'ERR','INTEGER','Błąd rozliczenia'
            );
            _ndx:=obj_new(2);
            _ndx[1]:=_tab.index('?');
            _ndx[2]:=_tab.ndx_tmp(,,'ERR',,,'OD',,);

            H_UM.cntx_psh();
            H_UM.index('OD');
            H_UM.prefix(P.ref());
            {? H_UM.last()
            || {!
               |? {? H_UM.DO~1=_rok & H_UM.EKW>0
                  || _tab.blank();
                     _tab.REF:=#H_UM.ref();
                     _tab.OD:=H_UM.OD;
                     _tab.DO:=H_UM.DO;
                     _tab.EKWU_WYP:=H_UM.EKW;
                     _tab.EKWU_NSP:=H_UM.EKW_NSP;
                     _tab.LT:=H_UM.LT;
                     _tab.CRC:=H_UM.crc();

                     _ekww:=0;
                     _ekwnsp:=0;
                     {? H_UM.LT=''
:                       Nie ma znaku listy - ekwiwalent nie jest rozliczony
                     || _ekww:=H_UM.EKW
                     || _lt:=-H_UM.LT;
                        O.cntx_psh();
                        O.index('LISTYPZN');
                        O.prefix(exec('ref_firma','ustawienia'),_lt);
                        {? O.first()
:                          Znak listy jest - sprawdzamy, czy na wskazanej liście ekwiwalent już jest rozliczony.
                        || _ekww:=H_UM.EKW;
                           _ekwnsp:=H_UM.EKW_NSP;
                           LS.cntx_psh();
                           LS.use(_lt);
                           LS.index('PRACNRRU');
:                          !!! Odwołanie bezpośrednio do kodu rubryki.
                           LS.prefix(P.ref(),72);
                           {? LS.first()
                           || {! |? _tab.EKWL+=LS.KW; LS.next() !}
                           ?};
                           LS.cntx_pop();
                           {? _tab.EKWL & _tab.EKWL<>_ekww+_ekwnsp
                           || _tab.ERR:=1;
                              _err+=1
                           ?}

:                          Znak listy jest, ale listy jeszcze nie ma.
                        || _ekww:=H_UM.EKW
                        ?};
                        O.cntx_pop()
                     ?};
                     {? _ekww>0
                     || _ekw+=_ekww-_tab.EKWL;
                        _tab.add()
                     ?}
                  ?};
                  H_UM.prev() & H_UM.DO~1>=_rok
               !}
            ?};

            {? _err
:              W danych występuje niezgodność liczby godzin ekwiwalentu w H_UM i na liście płac. W karcie urlopowej mamy
:              więc uwzględnioną liczbę godzin z umowy (H_UM), podczas gdy w rzeczywistości pracownik dostał pieniądze
:              za inną (na liście) liczbę godzin. Rozsądek podpowiada, aby poprawić liczbę godzin ekwiwalentu w umowie
:              na zgodną z listą płac, ale w tej chwili ograniczamy się do zakomunikowania o całej sytuacji.
            || _tab.index(_ndx[2]);
               _tab.prefix(1);
               {? _tab.first() &
                  FUN.ask(
                     'Liczba godzin ekwiwalentu do wypłaty nie jest zgodna\n'
                     'z liczbą godzin ekwiwalentu na liście płac.\n\n'
                     'Dane powinny zostać poprawione, ponieważ \n'
                     'ilość godzin ekwiwalentu do wypłaty (na umowie)\n'
                     'ma wpływ na limit wykorzystanego urlopu (w karcie urlopowej).\n\n'
                     'Chcesz zobaczyć szczegóły?'@
                  )
               || _wh:=_tab.size();
                  {? _wh<3 || _wh:=3 |? _wh>30 || _wh:=30 ?};
                  _ws:=_tab.mk_sel('Ekwiwalent - różnice'@,'N',,'#ekwrw',,,_wh);
                  _tab.win_fld(_ws,,'OD',,,,,,'Umowa: od'@,,MS.comment(H_UM,'OD'));
                  _tab.win_fld(_ws,,'DO',,,,,,'Umowa: do'@,,MS.comment(H_UM,'DO'));
                  _tab.win_fld(_ws,,'EKWU_WYP',,,,2,,'Umowa: ekwiwalent wypoczynkowy'@,,MS.comment(H_UM,'EKW'));
                  _tab.win_fld(_ws,,'EKWU_NSP',,,,2,,'Umowa: ekwiwalent dodatkowy'@,,MS.comment(H_UM,'EKW_NSP'));
                  _tab.win_fld(_ws,,'LT',,,,,,'Lista: znak'@,,MS.comment(H_UM,'LT'));
                  _tab.win_fld(_ws,,'EKWL',,,,2,,'Lista: ekwiwalent'@,,'Faktyczna liczba godzin na liście płac'@);
                  _tab.win_sel(_ws);
                  _tab.select()
               ?}

            |? _ekw>0
:              Limit urlopu jest przekroczony i wprowadzono ekwiwalent, który nie jest jeszcze rozliczony - zaproponujmy
:              zmniejszenie ekwiwalentu.
            || _fgs:=
                  "  {? _a=1
                     || '1 godzina'@
                     |? '234'*($_a+1) & 1+($_a+2)<>'1'
                     || $_a+' godziny'@
                     || $_a+' godzin'@
                     ?}
                  ";

               _nekw:=_poz+_ekw;
               {? _nekw<0
               || _nekw:=0
               ?};
               _txt:=
                  'Wprowadzony urlop (%1) powoduje przekroczenie limitu o %2.\n'
                  'Jednocześnie wprowadzona jest informacja o wypłacie ekwiwalentu za %3.\n'
                  'Czy zmniejszyć liczbę godzin ekwiwalentu do %4?'
                  [_fgs(N.NG),_fgs(-_poz),_fgs(_ekw),$_nekw];
               {? FUN.ask(_txt)
               || do();
:                 Aktualizacja ekwiwalentu w H_UM.
                  _dekw:=_ekw-_nekw;
                  {? _tab.first()
                  || {!
                     |? {? _tab.EKWU_WYP-_tab.EKWL>0
                        || {? H_UM.seek(_tab.REF,) & H_UM.crc()=_tab.CRC
                           || {? H_UM.EKW<_dekw
                              || _dekw-=H_UM.EKW;
                                 H_UM.EKW:=0
                              || H_UM.EKW-=_dekw;
                                 _dekw:=0
                              ?};
                              H_UM.put()
                           || undo()
                           ?}
                        ?};
                        _dekw>0 & _tab.next()
                     !}
                  ?};
:                 Aktualizacja karty urlopowej.
                  exec('aktualizuj','kart_url',P.ref());
                  {? end()
                  || _again:=1
                  || FUN.emsg('Zmiana liczby godzin ekwiwalentu i aktualizacja karty urlopowej nie powiodła się.'@)
                  ?}
               ?}
            ?};
            H_UM.cntx_pop();
            obj_del(_ndx); &_ndx;
            obj_del(_tab); &_tab
         ?};

         {? (~_again & (_lim | _karta) & _poz<0) |
            (~_again & _lim & _poz=0)
         || _msg[KST_PAR.URLOP().LP]:=
               '%1 %2 roboczych nieobecności\n\'%3\' (Kod %4) został %5'@
                [$_lim,{? 2004<=_rok || 'godzin'@ || 'dni'@ ?},R.RT,$R.RN,
                {? _poz=0 || 'wyczerpany'@ || 'przekroczony'@ ?}]
         ?}
      ?};
      _again
   !};

:  ---------------------------------------------------------------------------------------------------------------------

   _uz:=0;
:  Zliczanie w bieżącym roku wykorzystanego urlopu na żądanie (_uz):
:  - u poprzednich pracodawców;
   STAZ.cntx_psh();
   STAZ.index('_STAZE');
   STAZ.prefix(exec('ref_firma','ustawienia'),P.OSOBA);
   {? STAZ.last()
   || {!
      |? {? STAZ.DZ~1=_rok
         || _uz+=STAZ.WUZ
         ?};
         STAZ.prev()
      !}
   ?};
   STAZ.cntx_pop();
:  - z nieobecności.
   N.cntx_psh();
   N.index('NIPRACNB');
   N.prefix('N',P.ref(),KST_PAR.URL_CHOR().RN);
   {? N.find_ge(date(_rok,1,1)) & N.OD<=date(_rok,12,0)
   || {!
      |? _uz+=N.NR;
         N.next() & N.OD<=date(_rok,12,0)
      !}
   ?};
   N.cntx_pop();

   {? KST_PAR.URL_LIM & KST_PAR.URL_LIM<=_uz
   || _msg[KST_PAR.URL_CHOR().LP]:=
         {? KST_PAR.URL_LIM=_uz
         || '%1 %2 roboczych nieobecności\n\'%3\' (Kod %4) został wyczerpany'@
            [$KST_PAR.URL_LIM,'dni'@,R.RT,$R.RN]
         || '%1 %2 roboczych nieobecności\n\'%3\' (Kod %4) został przekroczony'@
            [$KST_PAR.URL_LIM,'dni'@,R.RT,$R.RN]
         ?}
   ?}
::sprawdzenie limitu urlopu dodatkowego
|? _rn_nsp:=__RUB.sys_kod(1113,,1);
   _rn_nsp<>0 & _nb(__RUB.ref(_rn_nsp))
|| _rn_reh:=__RUB.sys_kod(1171,,1);
   {? _rn_reh<>0
   || DS.cntx_psh();
      DS.index('DYSCYPLI');
      DS.prefix(P.ref(),_rok,__RUB.ref(_rn_reh));
      {? DS.first()
      || {? DS.NP<=0
         || _okres:=
            {? DS.NR='K' || 'dni kalendarzowych'@
            |? DS.NR='R' || 'dni roboczych'@
            |? DS.NR='G' || 'godzin roboczych'@
            || 'dni'@
            ?};
            _msg[DS.NB().LP]:=
            {? DS.NP=0
            || '%1 %2 nieobecności\n\'%3\' (Kod %4) został wyczerpany'@
               [$(DS.NN+DS.NZ),_okres,R.RT,$R.RN]
            || '%1 %2 nieobecności\n\'%3\' (Kod %4) został przekroczony'@
               [$(DS.NN+DS.NZ),_okres,R.RT,$R.RN]
            ?}
         ?}
      ?};
      DS.cntx_pop()
   ?};
   {!
   |? _again:=0;
      {? exec('kart_url_find','kart_url',_rok)
      || _lim:=EDIT_VAR.RAZ_NSP;
         _poz:=KART_URL.NSP_POZ;
         {? (_lim | _karta) & _poz<0
:           Specjalna obsługa ekwiwalentu dla przekroczonego limitu i wywołania interaktywnego.
         || _err:=0;
:           Wskaźnik błędu polegającego na różnicy w liczbie godzin ekwiwalentu w H_UM i rozliczonego na liście.
            _ekw:=0;
:           Liczba godzin ekwiwalentu "do wykorzystania", czyli takiego, który jest wprowadzony w H_UM i jeszcze nie
:           jest rozliczony na listach płac.
            _tab:=tab_tmp(1,
               'REF','INTEGER','H_UM.ref()',
               'OD','DATE','Od',
               'DO','DATE','Do',
               'EKWU_WYP','REAL','Ekwiwalent wypoczynkowy(umowa)',
               'EKWU_NSP','REAL','Ekwiwalent dodatkowy(umowa)',
               'LT','STRING[8]','Lista rozliczająca',
               'CRC','INTEGER','CRC',
               'EKWL','REAL','Ekwiwalent (lista)',
               'ERR','INTEGER','Błąd rozliczenia'
            );
            _ndx:=obj_new(2);
            _ndx[1]:=_tab.index('?');
            _ndx[2]:=_tab.ndx_tmp(,,'ERR',,,'OD',,);

            H_UM.cntx_psh();
            H_UM.index('OD');
            H_UM.prefix(P.ref());
            {? H_UM.last()
            || {!
               |? {? H_UM.DO~1=_rok & H_UM.EKW_NSP>0
                  || _tab.blank();
                     _tab.REF:=#H_UM.ref();
                     _tab.OD:=H_UM.OD;
                     _tab.DO:=H_UM.DO;
                     _tab.EKWU_WYP:=H_UM.EKW;
                     _tab.EKWU_NSP:=H_UM.EKW_NSP;
                     _tab.LT:=H_UM.LT;
                     _tab.CRC:=H_UM.crc();

                     _ekww:=0;
                     _ekwnsp:=0;
                     {? H_UM.LT=''
:                       Nie ma znaku listy - ekwiwalent nie jest rozliczony
                     || _ekwnsp:=H_UM.EKW_NSP
                     || _lt:=-H_UM.LT;
                        O.cntx_psh();
                        O.index('LISTYPZN');
                        O.prefix(exec('ref_firma','ustawienia'),_lt);
                        {? O.first()
:                          Znak listy jest - sprawdzamy, czy na wskazanej liście ekwiwalent już jest rozliczony.
                        || _ekww:=H_UM.EKW;
                           _ekwnsp:=H_UM.EKW_NSP;
                           LS.cntx_psh();
                           LS.use(_lt);
                           LS.index('PRACNRRU');
:                          !!! Odwołanie bezpośrednio do kodu rubryki.
                           LS.prefix(P.ref(),72);
                           {? LS.first()
                           || {! |? _tab.EKWL+=LS.KW; LS.next() !}
                           ?};
                           LS.cntx_pop();
                           {? _tab.EKWL & _tab.EKWL<>_ekww+_ekwnsp
                           || _tab.ERR:=1;
                              _err+=1
                           ?}

:                          Znak listy jest, ale listy jeszcze nie ma.
                        || _ekwnsp:=H_UM.EKW_NSP
                        ?};
                        O.cntx_pop()
                     ?};
                     {? _ekwnsp>0
                     || _ekw+=_ekwnsp-_tab.EKWL;
                        _tab.add()
                     ?}
                  ?};
                  H_UM.prev() & H_UM.DO~1>=_rok
               !}
            ?};

            {? _err
:              W danych występuje niezgodność liczby godzin ekwiwalentu w H_UM i na liście płac. W karcie urlopowej mamy
:              więc uwzględnioną liczbę godzin z umowy (H_UM), podczas gdy w rzeczywistości pracownik dostał pieniądze
:              za inną (na liście) liczbę godzin. Rozsądek podpowiada, aby poprawić liczbę godzin ekwiwalentu w umowie
:              na zgodną z listą płac, ale w tej chwili ograniczamy się do zakomunikowania o całej sytuacji.
            || _tab.index(_ndx[2]);
               _tab.prefix(1);
               {? _tab.first() &
                  FUN.ask(
                     'Liczba godzin ekwiwalentu do wypłaty nie jest zgodna\n'
                     'z liczbą godzin ekwiwalentu na liście płac.\n\n'
                     'Dane powinny zostać poprawione, ponieważ \n'
                     'ilość godzin ekwiwalentu do wypłaty (na umowie)\n'
                     'ma wpływ na limit wykorzystanego urlopu (w karcie urlopowej).\n\n'
                     'Chcesz zobaczyć szczegóły?'@
                  )
               || _wh:=_tab.size();
                  {? _wh<3 || _wh:=3 |? _wh>30 || _wh:=30 ?};
                  _ws:=_tab.mk_sel('Ekwiwalent - różnice'@,'N',,'#ekwrw',,,_wh);
                  _tab.win_fld(_ws,,'OD',,,,,,'Umowa: od'@,,MS.comment(H_UM,'OD'));
                  _tab.win_fld(_ws,,'DO',,,,,,'Umowa: do'@,,MS.comment(H_UM,'DO'));
                  _tab.win_fld(_ws,,'EKWU_WYP',,,,2,,'Umowa: ekwiwalent wypoczynkowy'@,,MS.comment(H_UM,'EKW'));
                  _tab.win_fld(_ws,,'EKWU_NSP',,,,2,,'Umowa: ekwiwalent dodatkowy'@,,MS.comment(H_UM,'EKW_NSP'));
                  _tab.win_fld(_ws,,'LT',,,,,,'Lista: znak'@,,MS.comment(H_UM,'LT'));
                  _tab.win_fld(_ws,,'EKWL',,,,2,,'Lista: ekwiwalent'@,,'Faktyczna liczba godzin na liście płac'@);
                  _tab.win_sel(_ws);
                  _tab.select()
               ?}

            |? _ekw>0
:              Limit urlopu jest przekroczony i wprowadzono ekwiwalent, który nie jest jeszcze rozliczony - zaproponujmy
:              zmniejszenie ekwiwalentu.
            || _fgs:=
                  "  {? _a=1
                     || '1 godzina'@
                     |? '234'*($_a+1) & 1+($_a+2)<>'1'
                     || $_a+' godziny'@
                     || $_a+' godzin'@
                     ?}
                  ";

               _nekw:=_poz+_ekw;
               {? _nekw<0
               || _nekw:=0
               ?};
               _txt:=
                  'Wprowadzony urlop (%1) powoduje przekroczenie limitu o %2.\n'
                  'Jednocześnie wprowadzona jest informacja o wypłacie ekwiwalentu za %3.\n'
                  'Czy zmniejszyć liczbę godzin ekwiwalentu do %4?'
                  [_fgs(N.NG),_fgs(-_poz),_fgs(_ekw),$_nekw];
               {? FUN.ask(_txt)
               || do();
:                 Aktualizacja ekwiwalentu w H_UM.
                  _dekw:=_ekw-_nekw;
                  {? _tab.first()
                  || {!
                     |? {? _tab.EKWU_NSP-_tab.EKWL>0
                        || {? H_UM.seek(_tab.REF,) & H_UM.crc()=_tab.CRC
                           || {? H_UM.EKW_NSP<_dekw
                              || _dekw-=H_UM.EKW_NSP;
                                 H_UM.EKW_NSP:=0
                              || H_UM.EKW_NSP-=_dekw;
                                 _dekw:=0
                              ?};
                              H_UM.put()
                           || undo()
                           ?}
                        ?};
                        _dekw>0 & _tab.next()
                     !}
                  ?};
:                 Aktualizacja karty urlopowej.
                  exec('aktualizuj','kart_url',P.ref());
                  {? end()
                  || _again:=1
                  || FUN.emsg('Zmiana liczby godzin ekwiwalentu i aktualizacja karty urlopowej nie powiodła się.'@)
                  ?}
               ?}
            ?};
            H_UM.cntx_pop();
            obj_del(_ndx); &_ndx;
            obj_del(_tab); &_tab
         ?};

         {? ((~_again & (_lim | _karta) & _poz<0) |
            (~_again & _lim & _poz=0)) & __RUB.seek(_rn_nsp)
         || _msg[R.LP]:=
               '%1 %2 roboczych nieobecności\n\'%3\' (Kod %4) został %5'@
               [$_lim,'dni'@,R.RT,$R.RN,{? _poz=0 || 'wyczerpany'@ || 'przekroczony'@ ?}]
         ?}
      ?};
      _again
   !}
?};

DS.cntx_psh();
DS.index('DYSCYPLI');
DS.prefix(P.ref(),_rok);
{? DS.first()
|| {!
   |? {? DS.NP<=0 &
         DS.NB<>KST_PAR.URLOP &
         DS.NB<>KST_PAR.URL_CHOR &
         _nb(DS.NB)
      || _okres:=
            {? DS.NR='K' || 'dni kalendarzowych'@
            |? DS.NR='R' || 'dni roboczych'@
            |? DS.NR='G' || 'godzin roboczych'@
            || 'dni'@
            ?};
         _msg[DS.NB().LP]:=
            {? DS.NP=0
            || '%1 %2 nieobecności\n\'%3\' (Kod %4) został wyczerpany'@
               [$(DS.NN+DS.NZ),_okres,R.RT,$R.RN]
            || '%1 %2 nieobecności\n\'%3\' (Kod %4) został przekroczony'@
               [$(DS.NN+DS.NZ),_okres,R.RT,$R.RN]
            ?}
      ?};
      DS.next()
   !}
?};
DS.cntx_pop();

R.cntx_pop();

_cnt:=0;
{! _lp:=1 .. obj_len(_msg)
|! _cnt+=+_msg[_lp]<>0
!};
{? _cnt
|| _text:='Dopuszczalny limit'@;
{! _lp:=1 .. obj_len(_msg)
|! {? +_msg[_lp]
|| _text+={? _cnt>1 || '\n'+gsub(_msg[_lp],'\n',' ') || ' '+_msg[_lp] ?}+','
?}
!};
_text:=(_text-1)+'.';
FUN.emsg(_text)
?};
obj_del(_msg);
1


\n_rozpisywalna
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Formuła sprawdza, czy dla danej nieobecności może być wywołana odpowiednia funkcja.
::   WE: [_a] [INTEGER] - Źródło akcji:
::             0 - Funkcja wywołana automatycznie z okna wertowania [domyślnie].
::             1 - Funkcja wywołana na żądanie operatora jako akcja menu.
::       [_b] [STRING]  - Określenie kryterium:
::          brak - choroby "wynagradzane" i "zasiłkowe"
::          'wyn' - choroby "wynagradzane"
::          'zas' - choroby "zasiłkowe"
::          'szp' - zasiłek szpital
::          '' - wszystkie nieobecności (tylko kontrola rozliczenia na liście)
::   WY:
::  OLD: \czy_rozp/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_auto:=var_pres('_a')=type_of(0) & _a;
_typ:={? var_pres('_b')=type_of('') || _b || 'wyn/zas/szp' ?};

_RetVal:=0;
_ok:=
   {? _typ='wyn/zas'
   || ~__RUB.sys_attr(N.NB,122122,N.OD) &
      (__RUB.sys_attr(N.NB,1221,N.OD) | __RUB.sys_attr(N.NB,1222,N.OD) | __RUB.sys_attr(N.NB,121,N.OD))
   |? _typ='wyn/zas/szp'
   || (__RUB.sys_attr(N.NB,1221,N.OD) | __RUB.sys_attr(N.NB,1222,N.OD) | __RUB.sys_attr(N.NB,121,N.OD))
   |? _typ*'zas'
   || ~__RUB.sys_attr(N.NB,122122,N.OD) & (__RUB.sys_attr(N.NB,1221,N.OD) | __RUB.sys_attr(N.NB,1222,N.OD))
   |? _typ*'szp'
   || __RUB.sys_attr(N.NB,122121,N.OD)| __RUB.sys_attr(N.NB,122122,N.OD)
   || __RUB.sys_attr(N.NB,121,N.OD)
   ?};
{? _typ<>''
|| KST_CHOR.clear();
   {? KST_CHOR.first()
   || {? _ok
      || _RetVal:=1
      |? _auto
      || _kody:=
            {? 7+_typ='wyn/zas'
            || '121,1221,1222'
            |? _typ*'zas'
            || '1221,1222'
            |? _typ*'szp'
            || '122122'
            |? _b*'ch_s'
            || '122121'
            || '121'
            ?};
         FUN.emsg('Ta nieobecność nie podlega rozpisaniu.\n(tylko nieobecności z atrybutem %1).'@ [_kody])
      ?}
   || FUN.emsg(
         'Brak informacji o sposobie rozpisania nieobecności.\n'
         '(uzupełnij dane w tabeli \'Choroby wynagradzane\').'@
      )
   ?}
?};
{? _RetVal & exec('n_zablokowana','nieobecnosc',_auto)
|| {? _RetVal & _auto
   || FUN.emsg('Rozpisanie nieobecności niemożliwe.\n(nieobecność rozliczona na listach).'@)
   ?};
   _RetVal:=0
?};
_RetVal


\n_zablokowana
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Formuła sprawdza czy bieżąca nieobecność może być modyfikowana. Zapis może być zmieniany tylko w przypadku,
::       gdy nie istnieją informacje o rozliczeniu, lub są dla istniejących spełnione kryteria "czylista". Jeżeli
::       wywołana zostanie z argumentem typu liczbowego, to w przypadku niespełnienia kryteriów, wyświetlane są
::       odpowiednie komunikaty.
::   WE: [_a] [INTEGER] - Wyświetlanie komunikatów:
::          0 - Nie [domyślnie]. Komunikaty będą wyświetlane.
::          1 - Tak. Komunikaty nie będą wyświetlane.
::       [_b] [INTEGER] - Wywołanie z akcji "Popraw" dla nieobecności.
::   WY: 1 - Blokada modyfikacji - nieobecność nie może być modyfikowana.
::       0 - Brak blokady - nieobecność może być modyfikowana.
::  OLD: \blokada/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_message:=var_pres('_a')=type_of(0) & _a;
_nput:=var_pres('_b')=type_of(0) & _b;
_RetVal:=
  {? VAR.JESTLIST
  || {? N.LT=''
     || 1
     |? _nput & VAR.NAZWALIS<>N.LT
     || -1
     || exec('o_writable','lista_plac',N.LT,_message)
     ?}
   || {? N.LT<>''
      || {? _nput
         || -2
         || exec('o_writable','lista_plac',N.LT,_message)
         ?}
      || 1
      ?}
   ?};
{? _message & _RetVal<0
|| FUN.emsg(
      {? _RetVal=-1
      || 'Lista płac %1 nie rozlicza nieobecności.\n(wybierz listę płac uwzględnioną w rozliczeniu)'@ [VAR.NAZWALIS]
      |? _RetVal=-2
      || 'Nieobecność została rozliczona.\n(wybierz odpowiednią listę płac)'@
      || ''
      ?})
?};
_RetVal<=0


\ciaglosc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Od aktualnej nieobecności "cofa się", sprawdzając czy ciągłość choroby jest zachowana. Warunki "ciągłości":
::          - poprzednie nieobecności są ciągłe chronologicznie (patrz opis parametru _c);
::          - poprzednie nieobecności są nieobecnościami chorobowymi (atrybut 126).
::   WE:  _a  [DATE]    - Data początku badanej nieobecności.
::        _b  [ARRAY]   - Tablica, w której zapisywany będzie wynik. Trzy lub cztery elementy:
::             1 - Liczba dni kalendarzowych;
::             2 - Liczba dni roboczych.
::             3 - Liczba godzin roboczych.
::             4 - Początek nieobecności.
::       [_c] [INTEGER] - Uwzględniać kontynuację choroby?
::             0 - Nie [domyślnie]. Do ustalenia daty rozpoczęcia choroby pod uwagę wzięte będą jedynie nieobecności
::                 następujące po sobie bezpośrednio - data końca nieobecności jest o dzień wcześniejsza od daty
::                 początku następującej po niej nieobecności.
::             1 - Tak. Przy ustalaniu daty rozpoczęcia choroby pod uwagę wzięte będą również nieobecności spowodowane
::                 tą samą chorobą, jeżeli przerwa pomiędzy ustaniem poprzedniej a powstaniem ponownej niezdolności
::                 do pracy nie przekraczała 60 dni. Taka okoliczność jest oznaczana przez lekarza prowadzącego
::                 na zwolnieniu lekarskim ZUS ZLA poprzez wpisanie kodu "A".
::       [_d] [INTEGER] - Czy w danych zbiorczych o długości okresu składkowego (elementy tablicy _b) pomijać
::             informacje o ostatniej nieobecności?
::             0 - Nie [domyślnie].
::             1 - Tak.
::       [_e] [INTEGER] - wywołana dla funkcji kontrolującej okres zasiłkowy
::             0 - Nie [domyślnie].
::             1 - Tak.
::   WY: Początek okresu ciągłości.
::  OLD: \data_cia/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_data:=_a;
_arr:=_b;

_ile_dni:={? var_pres('_c')=type_of(0) & _c || 61 || 1 ?};
_pomin:=var_pres('_d')=type_of(0) & _d;
_l180:=var_pres('_e')=type_of(0) & _e;

KST_CHOR.clear();
{? ~KST_CHOR.first()
|| FUN.emsg('Brak informacji o sposobie rozpisania nieobecności.\n(uzupełnij dane w tabeli "Choroby wynagradzane")'@)
?};

_d0:=date(0,0,0);
_RetVal:=_d0;

N.cntx_psh();
N.index('NIEOBECN');
N.prefix('N',P.ref());
{? N.find_key(_data)
|| _RetVal:=_data;
   _nref:=N.ref();
   {? ~_pomin | __RUB.sys_attr(N.NB,126,N.OD) | (__RUB.sys_attr(N.NB,1322,N.OD) & N.NEZLA<>null)
   || _arr[1]:=N.NK;
      _arr[2]:=N.NR;
      _arr[3]:=N.NG
   || _arr[1]:=0;
      _arr[2]:=0;
      _arr[3]:=0
   ?};
   {? _arr4:=obj_len(_arr)=4
   || _arr[4]:=
         {? __RUB.sys_attr(N.NB,1221,N.OD)
         || N.OD
         || _d0
         ?}
   ?};
   _kodch:=N.KDCH().KOD;
   {!
   |? {? N.prev() & N.DO+_ile_dni>=_RetVal
      || _curKod:=N.KDCH().KOD;
         {? (__RUB.sys_attr(N.NB,126,N.OD) | (__RUB.sys_attr(N.NB,1322,N.OD) & N.NEZLA<>null))
            &
            (_ile_dni=1 | {? exec('sprawdz_2022','nieobecnosc',_nref)
                          || _RetVal-1=N.DO | _kodch*'A'
                          || ~(_kodch*'B' & _curKod<>_kodch & ~(_curKod*'A'))
                          ?}
            )
         || _arr[1]+=N.NK;
            _arr[2]+=N.NR;
            _arr[3]+=N.NG;
            {? _arr4 & __RUB.sys_attr(N.NB,1221,N.OD)
            || _arr[4]:=N.OD
            ?};
            _kodch:=_curKod;
            _RetVal:=N.OD;
            1
         || _ile_dni>1
         ?}
      ?}
   !}
?};
N.cntx_pop();
N.get();
_RetVal


\data_ciaglosci
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Dla bieżącej nieobecności bada ciągłość w ramach wskazanego rodzaju (_a) i właściwej grupy (choroba, opieka,
::       macierzyński).
::       Uwaga: Funkcja nie zachowuje kontekstu tabeli N.
::   WE: [_a] [INTEGER] - Rodzaj choroby:
::          0 - Tylko choroby - wynagrodzenie [domyślnie].
::          1 - Wszystkie choroby wypłacane.
::       [_b] [DATE] - Data zmiany wymiaru zatrudnienia.
::   WY: Początek okresu ciągłości.
::  OLD: \spr_ciag/wynchor.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) & _a
|| _choroba:="__RUB.sys_attr(_a,129,N.OD) | __RUB.sys_attr(_a,1241,N.OD)"
|| _choroba:="__RUB.sys_attr(_a,121,N.OD) | __RUB.sys_attr(_a,1241,N.OD)"
?};
{? var_pres('_b')=type_of(date())
|| _z_wym:=1;
   _d_zm:=_b
|| _z_wym:=0
?};
_ret:=N.OD;
_kod_sw:=
   "  {? __RUB.sys_attr(N.NB,126,N.OD) | __RUB.sys_attr(N.NB,1241,N.OD)
      || 1
      |? __RUB.sys_attr(N.NB,1225,N.OD)
      || 2
      |? __RUB.sys_attr(N.NB,1227,N.OD)
      || 3
      ?}
   ";
_kod_N:=_kod_sw();
N.cntx_psh();
{!
|? {? N.prev() & (~_z_wym | N.OD>=_d_zm)
   || {? _choroba(N.NB) & N.DO+1=_ret & _kod_N=_kod_sw()
      || _ret:=N.OD
      ?};
      1
   ?}
!};
N.cntx_pop();
_ret


\find_wsp_wal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [2008]
:: OPIS: Funkcja wyszukuje współczynnik waloryzacji w tabeli WSP_WAL lub wartość pola NW.WSP w tabeli NW
::       dla podanej daty N.OD oraz refa tabeli N.
::   WE:  _a  [DATE]      - Data początku nieobecności.
::        _b  [REFERENCE] - Ref nieobecności N.
::       [_c] [INTEGER]   - Tryb wsadowy (bez komunikatów):
::          0 - Nie [domyślnie].
::          1 - Tak.
::   WY:  Wartość współczynnika waloryzacji.
::  OLD: \find_wsp/nieowal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(date()) || return(100) ?};
{? var_pres('_b')<>type_of(null()) || return(100) ?};
_nod:=_a;
_nref:=_b;
_batch:=var_pres('_c')=type_of(0) & _c;

_wsp:=100;

_rok:=_nod~1;
_mc:=_nod~2;
_kwartal:=(_mc+2)%3;

N.cntx_psh();
{!
|? {? N.prev()
   || {? __RUB.sys_attr(N.NB,1222,N.OD)
      || _nod:=N.OD;
         _nref:=N.ref();
         1
      ?}
   ?}
!};
{? _nod<>_a
|| NW.cntx_psh();
   NW.index('CHW');
   NW.prefix(_nref);
   {? NW.first()
   || _wsp:=NW.WSP$2
   ?};
   NW.cntx_pop()
?};
N.cntx_pop();

{? _nod=_a
|| WSP_WAL.cntx_psh();
   WSP_WAL.index('WSP_WAL');
   WSP_WAL.prefix();
   {? WSP_WAL.find_key(_rok,_kwartal)
   || _wsp:=WSP_WAL.WSP$2
   |? ~_batch
   || FUN.emsg(
         'Brak współczynnika waloryzacji świadczenia rehabilitacyjnego\n'
         'w roku: %1 kwartał: %2.\n'
         'Uzupełnij odpowiednie informacje.'@
         [$_rok,$_kwartal]
      )
   ?};
   WSP_WAL.cntx_pop()
?};
{? _wsp<100
|| 100
|| _wsp
?}


\n_dnop_akt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Formuła aktualizuje liczbę dni płatnych -25% i bezpłatnych.
::   WE: _a [INTEGER] - Tryb wsadowy:
::             0 - Nie.
::             1 - Tak.
::       _b [DATE]    - Data początku nieobecności.
::       _c [DATE]    - Data końca nieobecności.
::   WY:
::  OLD: \akt_opoz/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~_a
|| return(0)
?};

N.cntx_psh();
N.index('NIEOBECN');
N.prefix('N',P.ref());
{? N.find_key(_b)
|| _dop:=N.OP;
   _dnp:=N.DN;
   {!
   |? {? N.DO<=_c
      || {? _dnp
         || {? _dnp<=N.NK
            || N.DN:=_dnp;
               _dnp:=0
            || _dnp-=N.NK;
               N.DN:=N.NK
            ?}
         || N.DN:=0
         ?};
         {? _dop
         || {? _dop<=N.NK
            || N.OP:=_dop;
               _dop:=0
            || _dop-=N.NK;
               N.OP:=N.NK
            ?}
         || N.OP:=0
         ?};
         N.put()
      ?} & N.next()
   !}
?};
N.cntx_pop();
N.get()


\n_dni_choroby
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Zlicza dni choroby, za które wynagrodzenie wypłaca zakład pracy. Przeglądane są zapisy w kartotece okresów
::       zatrudnienia i nieobecności.
::       Wymagane prawidłowe wypełnienie buforów tabel: P i OSOBA.
::   WE:  _a  [INTEGER] - Badany rok.
::       [_b] [DATE]    - Dzień badania stanu (data końca nieobecności) [domyślnie:N.DO].
::   WY: Liczba dni choroby opłacanej przez pracodawcę.
::  OLD: \spr_wyk/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_rok:=_a;
_data:={? var_pres('_b')=type_of(date()) || _b || N.DO ?};

_RetVal:=0;

STAZ.cntx_psh();
STAZ.index('_STAZE');
STAZ.prefix(exec('ref_firma','ustawienia'),OSOBA.ref());
{? STAZ.last()
|| {!
   |? {? STAZ.DZ~1=_rok
      || _RetVal+=STAZ.WC
      ?};
      STAZ.prev() & STAZ.DZ~1>=_rok
   !}
?};
STAZ.cntx_pop();

KST_CHOR.clear();
{? ~KST_CHOR.first()
|| return(_RetVal)
?};

_tab:=tab_tmp(1,'OD','DATE','OD','DO','DATE','DO');

N.cntx_psh();
N.index('NIOSOBNB');
KST_CHOR.first();
{!
|? N.prefix('N',exec('ref_firma','ustawienia'),P.OSOBA,KST_CHOR.WYN().RN);
   {? N.last()
   || {!
      |? {? N.OD~1=_rok & N.OD<=_data
         || _tab.OD:=N.OD;
            _tab.DO:={? _data>=N.DO || N.DO || _data ?};
            _tab.add(1)
         ?};
         N.prev() & N.OD~1>=_rok
      !}
   ?};
   KST_CHOR.next()
!};

{? _tab.first()
|| _od:=_tab.OD;
   {!
   |? {? _tab.DO>=_od
      || _RetVal+=
            {? _tab.OD>_od
            || (_tab.DO-_tab.OD)+1
            || (_tab.DO-_od)+1
            ?};
         _od:=_tab.DO+1
      ?};
      _tab.next()
   !}
?};
N.cntx_pop();
N.get();

_RetVal


\n_dni_nieobecnosci
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PKOSO [2011]
:: OPIS: Zlicza dni nieobecności z podanego roku o podanym kodzie.
::       Wymagane prawidłowe wypełnienie buforów tabel: P i OSOBA.
::       Uwaga: zmiana typu argumentu _a, rezygnacja z argumentu _c.
::   WE: _a [DATE]    - Dzień badania stanu (data końca nieobecności).
::       _b [INTEGER] - Kod nieobecności.
::   WY: Ilość dni kalendarzowych danej nieobecności.
::  OLD: \wylicz_ilosc/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(date())
|| _data:=_a
|| FUN.emsg('Błędna wartość argumentu \'%1\' funkcji \'%2\'.'@ ['_a','\\n_dni_nieobecnosci/nieobecnosc.fml']);
   return(0)
?};
{? var_pres('_b')=type_of(0)
|| _kod:=_b
|| FUN.emsg('Błędna wartość argumentu \'%1\' funkcji \'%2\'.'@ ['_b','\\n_dni_nieobecnosci/nieobecnosc.fml']);
   return(0)
?};

_RetVal:=0;
N.cntx_psh();
N.index('NIPRACNB');
N.prefix('N',P.ref(),_kod);
_data_p:=#0;
{? __RUB.sys_attr(_b,122111)
|| {? N.find_key(date(_data~1,1,1))
   || _n_do:=N.OD;
      {!
      |? {? N.OD=_n_do & __RUB.sys_attr(N.NB,122111) & N.DO<=_data
         || _data_p:=N.OD;
            _n_do:=N.DO+1;
            N.next()
         ?}
      !}
   ?}
?};

{? N.last()
|| {!
   |? {? N.OD~1=_data~1 & N.DO<=_data & N.OD>_data_p
      || _RetVal+=N.NK
      ?};
      N.prev() & N.OD~1>=_data~1
   !}
?};

H.cntx_psh();
H.index('_HISTKOD');
H.prefix(P.ref(),'Z');
N.index('NIOSOBNB');
N.prefix('N',exec('ref_firma','ustawienia'),P.OSOBA,_kod);
{? N.last()
|| {!
   |? {? N.OD~1=_data~1 & N.P<>P.ref() & N.DO<=_data & N.OD>_data_p
      || {? ~(H.find_le(N.DO) & (H.DO=date(0,0,0) | N.OD<=H.DO))
         || _RetVal+=N.NK
         ?}
      ?};
      N.prev() & N.OD~1>=_data~1
   !}
?};
H.cntx_pop();
N.cntx_pop();
N.get();
_RetVal


\n_rozpisz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [1998]
:: OPIS: Funkcja wywołująca odpowiednie akcje (rozpisanie / limitowanie).
::       Funkcje składowe (wywoływane przez 'n_rozpisz') nie kontrolują poprawności argumentów wywołania - wywołania
::       inne niż zaproponowane w wersji standardowej muszą być wykonywane z poprawną listą argumentów (patrz opis
::       każdej funkcji).
::       UWAGA: sprawdzenie listy która zawiera skorygowaną nieobecność.
::   WE: [_a] [INTEGER] - Źródło akcji:
::             0 - Funkcja wywołana automatycznie z okna wertowania [domyślnie].
::             1 - Funkcja wywołana na żądanie operatora jako akcja menu.
::       [_b] [INTEGER] - Zakres działania:
::             0 - Wykonane zostaną wszystkie funkcje składowe [domyślnie].
::             1 - Kontrola zmiany wymiaru zasiłku (90 dni).
::             2 - Kontrola przekroczenia limitu choroby wynagradzanej (35 dni).
::             3 - Podział nieobecności na przełomie miesięcy.
::             4 - Waloryzacja podstawy wymiaru świadczenia.
::             5 - Podział nieobecności typu choroba szpital.
::             6 - Podział nieobecności typu choroba oczekiwanie.
::       [_c] [INTEGER] -  Wywołanie z korekt nieobecności:
::             0 - Nie [domyślnie].
::             1 - Tak.
::  OLD: \funkcja/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? N.size()
|| _auto:=var_pres('_a')=type_of(0) & _a;
   _zakres:=var_pres('_b')=type_of(0) & _b;
   _korekty:=var_pres('_c')=type_of(0) & _c;
   _nod:=N.OD;
   _ndo:=N.DO;
   N.cntx_psh();
   N.index('NIEOBECN');
   N.prefix('N',P.ref());
   {? N.find_key(_nod)
   || {? {? _auto
         || exec('n_rozpisywalna','nieobecnosc',1)
         || 1
         ?}
      || {? _zakres=4 | _zakres=0
         || exec('n_rozpisz_waloryzacja','nieobecnosc',0,N.OD,N.DO)
         ?};
         {? _zakres=1 | _zakres=0
         || exec('n_rozpisz_zasilek100','nieobecnosc',0,N.OD,N.DO)
         ?};
         {? _zakres=6 | _zakres=0
         || exec('n_rozpisz_oczekiwanie','nieobecnosc',0,N.OD,N.DO)
         ?};
         {? _zakres=2 | _zakres=0
         || exec('n_rozpisz_wynzas','nieobecnosc',0,N.OD,N.DO)
         ?};
         {? _zakres=5 | _zakres=0
         || exec('n_rozpisz_szpital','nieobecnosc',0,N.OD,N.DO)
         ?}
      ?};
      {? _zakres=3 | _zakres=0
      || exec('n_rozpisz_miesiace','nieobecnosc',0,_nod,_ndo)
      ?};
      exec('nw_aktualizuj','nieobecnosc',,_korekty)
   ?};
   N.cntx_pop();
   N.get();
   exec('n_dnop_akt','nieobecnosc',1,_nod,_ndo)
?}


\n_rozpisz_waloryzacja
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Funkcja dzieli nieobecność w przypadku, gdy choroba trwa nieprzerwanie dłużej niż 180 dni kalendarzowych
::       i podstawa zasiłku może wymagać waloryzacji.
::   WE: [_a] [INTEGER] - Tryb wsadowy:
::             0 - Nie, działanie wymaga potwierdzenia.
::             1 - Tak, działanie nie wymaga ponownego potwierdzenia.
::        _b  [DATE]    - Data początku nieobecności.
::        _c  [DATE]    - Data końca nieobecności.
::   WY:
::  OLD: \limit_180/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;
_nod:=_b;
_ndo:=_c;

{? _batch | exec('n_rozpisywalna','nieobecnosc')
|| N.cntx_psh();
   _dni_nieo:=obj_new(4);
   _data_cia:=exec('ciaglosc','nieobecnosc',_nod,_dni_nieo,1,,1);
   _czyWiekszyLimit:=(N.KDCH().KOD*'B' & N.OD~1>=2009) | N.KDCH().KOD*'D';
   _limit:=
      {? _data_cia<__STALE.D_ZAS
      || {? _data_cia+180<__STALE.D_ZAS | (_dni_nieo[4]<__STALE.D_ZAS & _dni_nieo[4]<>date(0,0,0))
         || 180
         |? _czyWiekszyLimit
         || 270
         || KST_PAR.WALORYZ
         ?}
      |? _czyWiekszyLimit
      || 270
      || KST_PAR.WALORYZ
      ?};
   exec('czytaj','#stalesys',_data_cia,KST_PAR,'LIMPUU');
   _limitPL:={? KST_PAR.LIMPUU=0 & _data_cia>=date(2022,1,1) || 91 || KST_PAR.LIMPUU ?};
   _wersja:=0;
   {? ~_czyWiekszyLimit & _limitPL>0
   || _dni:={? P.DZ<>#0 & P.DZ<N.DO || N.DO-P.DZ+1 || 0 ?}; 'dni poza zatrudnieniem';
      {? _dni>0 & _dni>_limitPL
      || _nlimit:=_limit-(P.DZ-_data_cia)-1;
         _wersja:=1;
         _txt:='Nieobecność wykracza poza okres zatrudnienia.\nCzy uwzględniać limit %1 '
            'po ustaniu zatrudnienia?\n\n'
            'TAK - uwzględnia %1 dni limitu\n'
            'NIE - uwzględnia %2 dni limitu'@[$_limitPL,$KST_PAR.WALORYZ];
         {? _nlimit>_limitPL & FUN.ask(_txt) || _limit-=(_nlimit-_limitPL) ?}
         &_dni; &_nlimit
      ?}
   ?};
   {? _limit<_dni_nieo[1]
   || exec('nw_aktualizuj','nieobecnosc');
      NW.index('CHW');
      NW.prefix(N.ref());
      NW.first();
      _txt:='\nPrzekroczono limit czasu trwania okresu zasiłkowego%1'@
            [{? _wersja
            || '\nwynikającego z Art. 4 pkt 2 (art. 8 ust. 2 ustawy zasiłkowej).\n'@
            || '\nwynikającego z Art. 8 ust. 1 ustawy zasiłkowej.\n'@
            ?}];
      {? __RUB.sys_attr(N.NB,1222,N.OD)
      || {? NW.WAL<>'T'
         || NW.WAL:='T'
         ?};
         NW.WSP:=exec('find_wsp_wal','nieobecnosc',N.OD,N.ref());
         NW.put()
      || {? _batch | RAPLS.RAP=2
         |
         (~_batch
         &
         FUN.ask('%1\n%2'
            [  _txt,
               {? (_dni_nieo[1]-N.NK)<_limit
               || 'Czy rozpisać nieobecność?'@
               || 'Czy zamienić na nieobecność usprawiedliwioną bezpłatną?'@
               ?}
            ]
         ))
         || {? (_dni_nieo[1]-N.NK)<_limit
            || N.DO:=N.OD+(N.NK-_dni_nieo[1]+_limit)-1;
               exec('n_czas','nieobecnosc');
               N.put();
               N.OD:=N.DO+1;
               N.DO:=_ndo;
               N.PROC:=N.DK:=0;
               N.NB:=__RUB.ref(__RUB.sys_rub(1322,N.OD).RN,'N');
               N.KDSW:=exec('kod_zus','nieobecnosc','S','151');
               exec('n_czas','nieobecnosc');
               N.add()
            || N.PROC:=N.DK:=0;
               N.NB:=__RUB.ref(__RUB.sys_rub(1322,N.OD).RN,'N');
               N.KDSW:=exec('kod_zus','nieobecnosc','S','151');
               exec('n_czas','nieobecnosc');
               N.put()
            ?};

            _kod:=
               {? __RUB.sys_attr(N.NB,14313,N.OD) | __RUB.sys_attr(N.NB,14331,N.OD)
               || __RUB.sys_val(14313,N.OD,'')
               |? N.KDSW
               || N.KDSW().KOD
               || '350'
               ?};
            N.KDSW:=exec('kod_zus','nieobecnosc','S',_kod);
::       UWAGA, bez zmiany kodu dla wypadków
            {? {? _dni_nieo[4]=date(0,0,0)
               || _data_cia
               || _dni_nieo[4]
               ?}<__STALE.D_ZAS
            || _kod:=
                  {? __RUB.sys_attr(N.NB,1212,N.OD)
                  || __RUB.sys_rub(12213,N.OD).RN
                  |? __RUB.sys_attr(N.NB,12213,N.OD)
                  || 0
                  || __RUB.sys_rub(122112,N.OD).RN
                  ?};
               {? _kod
               || N.NB:=__RUB.ref(_kod,'N')
               ?}
            |? KST_CHOR.find_key(N.NB().RN)
            || N.NB:=KST_CHOR.ZAS
            ?};
            N.put()
         ?}
      ?}
   |? _batch
   || {? RAPLS.RAP=2
      || RAPLS.msg(
            P.T,
            P.OSOBA().NAZWISKO,
            OSOBA.PIERWSZE,
            'Świadczenie nie będzie waloryzowane.'@,
            '(choroba nie trwa dłużej niż %1 dni)'@[$_limit]
         )
      || FUN.info('%1\n%2'['Świadczenie nie będzie waloryzowane'@,'(choroba nie trwa dłużej niż %1 dni).'@[$_limit]])
      ?}
   ?};
   obj_del(_dni_nieo);
   N.cntx_pop();
   N.get();
   exec('n_dnop_akt','nieobecnosc',_batch,_nod,_ndo)
?}


\n_rozpisz_zasilek100
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Funkcja dzieli nieobecność w przypadku, gdy choroba trwa nieprzerwanie dłużej niż 90 dni kalendarzowych.
::       Przepisy są już
::   WE: [_a] [INTEGER] - Tryb wsadowy:
::             0 - Nie, działanie wymaga potwierdzenia.
::             1 - Tak, działanie nie wymaga ponownego potwierdzenia.
::        _b  [DATE]    - Data początku nieobecności.
::        _c  [DATE]    - Data końca nieobecności.
::   WY:
::  OLD: \limit_90/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;
_nod:=_b;
_ndo:=_c;

{? _batch | exec('n_rozpisywalna','nieobecnosc',_batch)
|| N.cntx_psh();
   _limit:=90;
   _dni_nieo:=obj_new(4);
   _data_cia:=exec('ciaglosc','nieobecnosc',_nod,_dni_nieo);
   {? __RUB.sys_attr(N.NB,125,N.OD)
   || {? _batch
      || FUN.emsg('Ta nieobecność nie wymaga rozpisywania.\n(zaktualizowany zostanie kod świadczenia)'@)
      ?};
      _kod:=
         {? __RUB.sys_attr(N.NB,14333,N.OD)
         || __RUB.sys_val(14333,N.OD,'')
         || __RUB.sys_val(14314,N.OD,'')
         ?};
      N.KDSW:=exec('kod_zus','nieobecnosc','S',_kod)
   |? _limit<_dni_nieo[1]
   || {? (_data_cia<__STALE.D_ZAS & _dni_nieo[4]<__STALE.D_ZAS & _dni_nieo[4]<>date(0,0,0)) | N.DO<__STALE.D_ZAS
      || {? _batch | RAPLS.RAP=2 | FUN.ask('Choroba trwa od ponad %1 dni.\nCzy rozpisać nieobecność?'@ [$_limit])
         || {? (_dni_nieo[1]-N.NK)<_limit
            || N.DO:=N.OD+(N.NK-_dni_nieo[1]+_limit)-1;
               exec('n_czas','nieobecnosc');
               N.put();
               N.OD:=N.DO+1;
               N.DO:=_ndo;
               N.DK:=0;
               exec('n_czas','nieobecnosc');
               N.add()
            ?};
            _kod:=
               {? __RUB.sys_attr(N.NB,14313,N.OD) | __RUB.sys_attr(N.NB,14331,N.OD)
               || __RUB.sys_val(14313,N.OD,'')
               |? N.KDSW
               || N.KDSW().KOD
               || '350'
               ?};
               N.KDSW:=exec('kod_zus','nieobecnosc','S',_kod);
               N.NB:=__RUB.ref(7,'N');
               N.put()
         ?}
      ?}
   |? _batch
   || FUN.emsg('Ta nieobecność nie będzie rozpisana.\n(choroba nie trwa dłużej niż %1 dni)'@ [$_limit])
   ?};
   obj_del(_dni_nieo);
   N.cntx_pop();
   N.get();
   exec('n_dnop_akt','nieobecnosc',_batch,_nod,_ndo)
?}


\n_rozpisz_wynzas
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Funkcja dzieli nieobecność w przypadku, gdy łączny czas trwania nieobecności chorobowych, przekroczy okres
::       za który wynagrodzenie wypłaca zakład pracy.
::   WE: [_a] [INTEGER] - Tryb wsadowy:
::             0 - Nie, działanie wymaga potwierdzenia.
::             1 - Tak, działanie nie wymaga ponownego potwierdzenia.
::        _b  [DATE]    - Data początku nieobecności.
::        _c  [DATE]    - Data końca nieobecności.
::   WY:
::  OLD: \limit_35/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;
_nod:=_b;
_ndo:=_c;

{? exec('n_rozpisywalna','nieobecnosc',_batch,'wyn')
|| _data_50:=P.OSOBA().UR_DATA;
   {? _data_50<>date(0,0,0)
   || _data_zm:=date(2009,2,1);
      _data_50:=((N.OD~1)-(_data_50~1))>=51;
      {? _data_50 & date(N.OD~1,N.OD~2,1)=date(2009,1,1)
      || return()
      ?};
      _limit:={? _data_50 & N.OD>=_data_zm || 14 || KST_PAR.CHOROBA ?}
   || _limit:=KST_PAR.CHOROBA
   ?};
   N.cntx_psh();

   _chk:=0;
   N.cntx_psh();
   _kod_org:=N.NB().RN;
   _kod_ch:=N.KDCH().KOD;
   {? N.prev() & N.DO+1=_nod
   || {? __RUB.sys_attr(N.NB,122112,N.OD) & __RUB.sys_attr(_kod_org,1211,N.OD) & N.KDCH().KOD*'B' & ~(_kod_ch*'B')
      || _chk:=__RUB.sys_rub(122111,N.OD).RN
      |? __RUB.sys_attr(N.NB,12112,N.OD) & __RUB.sys_attr(_kod_org,12112,N.OD) & N.KDCH().KOD*'B' & ~(_kod_ch*'B')
      || _chk:=__RUB.sys_rub(12111,N.OD).RN
      |? __RUB.sys_attr(N.NB,12211,N.OD) & (__RUB.sys_attr(_kod_org,1211,N.OD) | __RUB.sys_attr(_kod_org,12211,N.OD))
         & ~(N.KDCH().KOD*'B') & _kod_ch*'B'
      || _chk:=__RUB.sys_rub(122112,N.OD).RN
      |? __RUB.sys_attr(N.NB,12112,N.OD) & __RUB.sys_attr(_kod_org,12111,N.OD) & N.KDCH().KOD*'B' & _kod_ch*'B'
      || _chk:=__RUB.sys_rub(12112,N.OD).RN
      |? __RUB.sys_attr(N.NB,122112,N.OD) & __RUB.sys_attr(_kod_org,1211,N.OD)
      || _chk:=__RUB.sys_rub(122112,N.OD).RN
      |? __RUB.sys_attr(N.NB,122111,N.OD) & __RUB.sys_attr(_kod_org,12111,N.OD)
      || _chk:=__RUB.sys_rub(122111,N.OD).RN
      |? __RUB.sys_attr(N.NB,1212,N.OD) & __RUB.sys_attr(_kod_org,12213,N.OD)
      || _chk:=__RUB.sys_rub(1212,N.OD).RN
      |? __RUB.sys_attr(N.NB,122122,N.OD) & __RUB.sys_attr(_kod_org,12111,N.OD)
      || _chk:=__RUB.sys_rub(122111,N.OD).RN
      |? __RUB.sys_attr(N.NB,122121,N.OD) & __RUB.sys_attr(_kod_org,12111,N.OD)
      || _chk:=__RUB.sys_rub(122111,N.OD).RN
      |? __RUB.sys_attr(N.NB,122113,N.OD) & __RUB.sys_attr(_kod_org,12113,N.OD)
      || _chk:=__RUB.sys_rub(122113,N.OD).RN
      |? __RUB.sys_attr(N.NB,122113,N.OD) & __RUB.sys_attr(_kod_org,12111,N.OD)
      || _chk:=__RUB.sys_rub(122111,N.OD).RN
      |? __RUB.sys_attr(N.NB,122114,N.OD) & __RUB.sys_attr(_kod_org,12114,N.OD)
      || _chk:=__RUB.sys_rub(122114,N.OD).RN
      |? __RUB.sys_attr(N.NB,122114,N.OD) & __RUB.sys_attr(_kod_org,12111,N.OD)
      || _chk:=__RUB.sys_rub(122111,N.OD).RN
      ?}
   ?};
   N.cntx_pop();

   {? _chk
   || {? _batch | RAPLS.RAP=2 | FUN.ask('Nieobecność jest kontynuacją choroby.\nCzy zmienić kod nieobecności?'@)
      || _do:=N.OD-1;
         {!
         |? {? (_do+1)=N.OD & exec('n_rozpisywalna','nieobecnosc',0,'wyn')
            || N.NB:=__RUB.ref(_chk,'N');
               N.PROC:=exec('procent','nieobecnosc',N.NB);
               _kod:=
                  {? __RUB.sys_attr(N.NB,12211,N.OD)
                  || __RUB.sys_val(14313,N.OD,'')
                  |? __RUB.sys_attr(N.NB,125,N.OD)
                  || __RUB.sys_val(14314,N.OD,'')
                  || '350'
                  ?};
               N.KDSW:=exec('kod_zus','nieobecnosc','S',_kod);
               _do:=N.DO;
               N.put() & N.next()
            ?}
         !}
      ?}

   |? _limit<(_nieo_wyk:=exec('n_dni_choroby','nieobecnosc',N.OD~1,N.DO))
   || {? _batch | RAPLS.RAP=2 | FUN.ask('Limit %1 dni został przekroczony.\nCzy rozpisać nieobecność?'@ [$_limit])
      || {? {? (_nieo_wyk-N.NK)<_limit
            || N.DO:=N.OD+(N.NK-_nieo_wyk+_limit)-1;
               {? {? N.DO=date(N.DO~1,12,0)
                  || 0
                  |? (N.OD~1)<>(N.DO~1)
                  || {? date(N.DO~1,1,1)+_limit<_ndo
                     || N.DO:=date(N.DO~1,1,1)+_limit-1;
                        1
                     ?}
                  || 1
                  ?}
               || exec('n_czas','nieobecnosc');
                  N.put();
                  N.OD:=N.DO+1;
                  N.DO:=_ndo;
                  N.DK:=0;
                  exec('n_czas','nieobecnosc');
                  N.add()
               ?}
            || 1
            ?}
         || {? KST_CHOR.find_key(N.NB().RN)
            || N.NB:=KST_CHOR.ZAS;
               N.PROC:=exec('procent','nieobecnosc',N.NB)
            ?};
            _kod:=
               {? __RUB.sys_attr(N.NB,12211,N.OD)
               || __RUB.sys_val(14313,N.OD,'')
               |? __RUB.sys_attr(N.NB,125,N.OD)
               || __RUB.sys_val(14314,N.OD,'')
               || '350'
               ?};
            N.KDSW:=exec('kod_zus','nieobecnosc','S',_kod);
            N.put()
         ?}
      ?}

   |? _batch
   || FUN.emsg('Ta nieobecność nie będzie rozpisana.\n(limit %1 dni nie został przekroczony)'@ [$_limit])
   ?};
   N.cntx_pop();
   N.get();
   exec('n_dnop_akt','nieobecnosc',_batch,_nod,_ndo)
?}


\n_rozpisz_szpital
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MRY [2018]
:: OPIS: Rozpisanie nieobecności zasilek szpital 70% i 80 %
::   WE: [_a] [INTEGER] - Tryb wsadowy:
::             0 - Nie, działanie wymaga potwierdzenia.
::             1 - Tak, działanie nie wymaga ponownego potwierdzenia.
::        _b  [DATE]    - Data początku nieobecności.
::        _c  [DATE]    - Data końca nieobecności.
::  OLD: \limit_szpital/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;
_nod:=_b;
_ndo:=_c;
_przelom22:=(N.OD~1<>N.DO~1 & N.OD~1>=2022);

{? exec('n_rozpisywalna','nieobecnosc',_batch,'szp')
   &
   (__RUB.sys_attr(N.NB,122121,N.OD) | __RUB.sys_attr(N.NB,122122,N.OD))
|| _data_50:=P.OSOBA().UR_DATA;
   {? _data_50<>date(0,0,0)
   || _data_zm:=date(2009,2,1);
      _data_50:=((N.OD~1)-(_data_50~1))>=51;
      {? _data_50 & date(N.OD~1,N.OD~2,1)=date(2009,1,1) || return() ?};
      _limit:={? _data_50 & N.OD>=_data_zm || 14 || KST_PAR.CHOROBA ?};
      _lim30:=KST_PAR.CHOROBA-_limit
   || _limit:=KST_PAR.CHOROBA;
      _lim30:=0
   ?};
:: Wykorzystane dni choroby wynagrodzenia
   N.cntx_psh();

   _chk:=0;
   N.cntx_psh();
   _kod_org:=N.NB().RN;
   {? N.prev() & ({? exec('sprawdz_2022','nieobecnosc',N.ref()) || N.DO+1=_nod || 1 ?})
   || {? _limit<=0 & __RUB.sys_attr(N.NB,122,N.OD)
         &
         (__RUB.sys_attr(_kod_org,122122,N.OD) | __RUB.sys_attr(_kod_org,122121,N.OD))
      || _chk:={? exec('sprawdz_2022','nieobecnosc',N.ref())
               || __RUB.sys_rub(122121,N.OD).RN
               || __RUB.sys_rub(122122,N.OD).RN
               ?}
      |? __RUB.sys_attr(N.NB,122,N.OD)
      || _chk:={? exec('sprawdz_2022','nieobecnosc',N.ref())
               || __RUB.sys_rub(122121,N.OD).RN
               || __RUB.sys_rub(122122,N.OD).RN
      ?}
      ?}
   ?};
   _dni_nieo:=obj_new(4);
   _data_cia:=exec('ciaglosc','nieobecnosc',_nod,_dni_nieo);
   {? _data_cia<=date(2021,12,31) & N.find_le(date(2021,12,31)) & __RUB.sys_attr(N.NB,121,N.OD)
   || _chk:=__RUB.sys_rub(122122,N.OD).RN
   ?};
   N.cntx_pop();
   {? _chk & (_limit<>14;1)
   || {? _batch & _kod_org<>_chk | RAPLS.RAP=2
         |
         FUN.ask('%1\n%2'['Nieobecność jest kontynuacją choroby.'@,'Czy zmienić kod nieobecności?'@])
      || _do:=N.OD-1;
         {!
         |? {? (_do+1)=N.OD & exec('n_rozpisywalna','nieobecnosc',0,'szp')
            || N.NB:=__RUB.ref(_chk,'N');
               N.PROC:=exec('procent','nieobecnosc',N.NB);
               N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD,''));
               _do:=N.DO;
               N.put() & N.next()
            ?}
         !}
      ?}
   || _nieo_wyk:=exec('n_dni_choroby','nieobecnosc',N.OD~1);
      {? _nieo_wyk<_limit
      || {? N.NK+_nieo_wyk>_limit
         ||
:: Podział na dwie nieobecności wynagrodzenia chorobowego i zaskiłku za czas pobytu w szpitalu (70% i 80%)
            {? _batch | RAPLS.RAP=2
               |
               FUN.ask('%1\n%2'['Limit %1 dni został wykorzystany.'@[$_limit],'Czy rozpisać nieobecność?'@])
            || N.DO:=N.OD+_limit-_nieo_wyk-1;
               exec('n_czas','nieobecnosc');
               N.NB:=__RUB.ref(__RUB.sys_rub(12111,N.OD).RN,'N');
               N.PROC:=exec('procent','nieobecnosc',N.NB);
               N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14331,N.OD));
               N.put();
:: Pozostała część powyżej 14 dni to zasiłek szpital 80% do 33 dnia, od 34 dnia zasiłek za czas choroby
               N.NB:=__RUB.ref({? _limit=14
                               || __RUB.sys_rub(122122,N.OD).RN
                               || {? exec('sprawdz_2022','nieobecnosc',N.ref())
                                  || __RUB.sys_rub(122121,N.OD).RN
                                  || __RUB.sys_rub(122122,N.OD).RN
                                  ?}
                               ?},'N');
               _dni1:=(_ndo-N.DO);
               {? _limit=14 & _dni1>_lim30
               ||  _od1:=N.DO+1;
                   _do1:=_ndo+1;
                   N.OD:=N.DO+1;
                   N.DO:=_od1+19-1;
                     {? {? N.DO=date(N.DO~1,12,0)
                        || 0
                        |? (N.OD~1)<>(N.DO~1)
                        || {? date(N.DO~1,1,1)+_limit-14<_ndo || N.DO:=date(N.DO~1,1,1)+_limit-1; 1 ?}
                        || 1
                        ?}
                     || exec('n_czas','nieobecnosc');
                        N.PROC:=exec('procent','nieobecnosc',N.NB);
                        N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
                        N.DK:=0;
                        N.add();
                        _spr:=$N.NB+$N.KDSW;
:: Reszta zasiłku szpital 70%
                        N.NB:=
                           {? exec('sprawdz_2022','nieobecnosc',N.ref())
                           || __RUB.ref(__RUB.sys_rub(122121,N.OD).RN,'N')
                           || __RUB.ref(__RUB.sys_rub(122122,N.OD).RN,'N')
                           ?};
                        N.PROC:=exec('procent','nieobecnosc',N.NB);
                        N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
:: Jeśli po zmianie przepisów 2022.1.1 nie następuje zmiana nieobecności, to nie dzielę zapisu
                        {? &_spr=$N.NB+$N.KDSW
                        || N.DO:=_ndo;
                           N.DK:=0;
                           exec('n_czas','nieobecnosc');
                           N.put()
                        || N.OD:=N.DO+1;
                           N.DO:=_ndo;
                           N.DK:=0;
                           exec('n_czas','nieobecnosc');
                           N.add()
                        ?};
                        {? _przelom22 || exec('n_rozpisz_szpital','nieobecnosc',_batch,N.OD,N.DO) ?}
                     ?}
               ||  N.PROC:=exec('procent','nieobecnosc',N.NB);
                   N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
                   N.OD:=N.DO+1;
                   N.DO:=_ndo;
                   N.DK:=0;
                   exec('n_czas','nieobecnosc');
                   N.add();
                   {? _przelom22 || exec('n_rozpisz_szpital','nieobecnosc',_batch,N.OD,N.DO) ?}
               ?}
            ?}
         || {? _batch | RAPLS.RAP=2
               |
               FUN.ask('%1\n%2'
                  [  'Limit %1 dni nie został wykorzystany.'@[$_limit],
                     'Czy zamienić %1 na %2.'@[N.NB().RT,__RUB.sys_rub(12111,N.OD).RT]
                  ]
               )
            || N.NB:=__RUB.ref(__RUB.sys_rub(12111,N.OD).RN,'N');
               N.PROC:=exec('procent','nieobecnosc',N.NB);
               N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14331,N.OD));
               N.put()
            ?}
         ?};
         1
      || _nieo_wyk:=
            exec('n_dni_nieobecnosci','nieobecnosc',N.OD-1,__RUB.sys_rub(122122,N.DO).RN)+
            exec('n_dni_nieobecnosci','nieobecnosc',N.OD-1,__RUB.sys_rub(122111,N.DO).RN)+
            exec('n_dni_nieobecnosci','nieobecnosc',N.OD-1,__RUB.sys_rub(122112,N.DO).RN)+
            exec('n_dni_nieobecnosci','nieobecnosc',N.OD-1,__RUB.sys_rub(122113,N.DO).RN)+
            exec('n_dni_nieobecnosci','nieobecnosc',N.OD-1,__RUB.sys_rub(122114,N.DO).RN);
:: Wykorzystano więcej choroby wynagrodzenia niż limit -  wprowadzamy zasiłek za pobyt w szpitalu 70% lub 80%
:: 122122 - szpital 80 % (rubryka 30),
:: 122111 - zasiłek chorobowy 80% (rubryka 8),
:: 122112 - Choroba 100% (rubryka 7),
:: 122113 - Kwarantanna zas. (rubryka 7122),
:: 122114 - Izolacja zas. (rubryka 7125)
         {? _lim30<_nieo_wyk
         || {? _lim30=0
            || {? _batch | RAPLS.RAP=2
                  |
                  FUN.ask('%1\n%2'['Limit %1 dni został przekroczony.'@[$_limit],'Czy rozpisać nieobecność?'@])
               ||
:: Dla limitu choroby 33 dni
                  {? {? (_nieo_wyk-N.NK)<_lim30 & (_nieo_wyk-N.NK)>0
                     || N.DO:=N.OD+(N.NK-_nieo_wyk+_lim30)-1;
                        {? {? N.DO=date(N.DO~1,12,0)
                           || 0
                           |? (N.OD~1)<>(N.DO~1)
                           || {? date(N.DO~1,1,1)+_lim30<_ndo || N.DO:=date(N.DO~1,1,1)+_lim30-1; 1 ?}
                           || 1
                           ?}
                        || exec('n_czas','nieobecnosc');
                           N.put();
                           N.OD:=N.DO+1;
                           N.DO:=_ndo;
                           N.DK:=0;
                           exec('n_czas','nieobecnosc');
                           N.add()
                        ?}
                     || 1
                     ?}
                  || N.NB:=
                        {? exec('sprawdz_2022','nieobecnosc',N.ref())
                        || __RUB.ref(__RUB.sys_rub(122121,N.OD).RN,'N')
                        || __RUB.ref(__RUB.sys_rub(122122,N.OD).RN,'N')
                        ?};
                     N.PROC:=exec('procent','nieobecnosc',N.NB);
                     N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
                     N.put()
                  ?}
               ?}
            ||
:: Dla limitu choroby 14 dni sprawdzamy wpisaną nieobecność - jesśi zasiłek szpital 80% to
:: zamień na zasiłek szpital 70%, jeśli zasiłek szpital 70% to nic nie rób
               {?
                  {? ~exec('sprawdz_2022','nieobecnosc',N.ref())
                  || 0
                  |? (_nieo_wyk)<_lim30 & (_nieo_wyk-N.NK)>0
                  || {? _batch | RAPLS.RAP=2
                        |
                        FUN.ask('%1\n%2'['Limit %1 dni został przekroczony.'@[$_lim30],'Czy rozpisać nieobecność?'@])
                     || N.DO:=N.OD+(N.NK-_nieo_wyk+_lim30)-1;
                        {? {? N.DO=date(N.DO~1,12,0)
                           || 0
                           |? (N.OD~1)<>(N.DO~1)
                           || {? date(N.DO~1,1,1)+_lim30<_ndo || N.DO:=date(N.DO~1,1,1)+_lim30-1; 1 ?}
                           || 1
                           ?}
                        || exec('n_czas','nieobecnosc');
                           N.put();
                           N.OD:=N.DO+1;
                           N.DO:=_ndo;
                           N.DK:=0;
                           exec('n_czas','nieobecnosc');
                           N.add()
                        ?}
                     ?}
                  || {? ~__RUB.sys_attr(N.NB,122121,N.OD)
                     || {? _batch | RAPLS.RAP=2
                           |
                           FUN.ask('%1\n%2'
                              [  'Limit %1 dni został przekroczony.'@[$_lim30],
                                 'Czy zamienić %1 na %2.'@[N.NB().RT,__RUB.sys_rub(122121,N.OD).RT]
                              ]
                           )
                         || 1
                         || 0
                         ?}
                     ?}
                  ?}
               || N.NB:=__RUB.ref(__RUB.sys_rub(122121,N.OD).RN,'N');
                  N.PROC:=exec('procent','nieobecnosc',N.NB);
                  N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
                  N.put()
               ?}
            ?}
         |? _nieo_wyk=_lim30
         || {? _lim30=0
            || {? exec('sprawdz_2022','nieobecnosc',N.ref()) & __RUB.sys_attr(N.NB,122122,N.OD)
               || {? _batch | RAPLS.RAP=2
                     |
                     FUN.ask('%1\n%2'
                        [  'Limit %1 dni został przekroczony.'@[$_limit],
                           'Czy zamienić %1 na %2.'@
                              [  N.NB().RT,
                                 {? _limit=14 || __RUB.sys_rub(122122,N.OD).RT || __RUB.sys_rub(122121,N.OD).RT ?}
                              ]
                        ]
                     )
                  || N.NB:=__RUB.ref(
                        {? _limit=14
                        || __RUB.sys_rub(122122,N.OD).RN
                        || __RUB.sys_rub(122121,N.OD).RN
                        ?},'N'
                     );
                     N.PROC:=exec('procent','nieobecnosc',N.NB);
                     N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
                     N.put()
                  ?}
               ?}
            || {? exec('sprawdz_2022','nieobecnosc',N.ref()) & __RUB.sys_attr(N.NB,122122,N.OD)
               || {? _batch | RAPLS.RAP=2
                     |
                     FUN.ask('%1\n%2'
                        [  'Limit %1 dni został przekroczony.'[$_limit],
                           'Czy zamienić %1 na %2.'@[N.NB().RT,__RUB.sys_rub(122121,N.OD).RT]
                        ]
                     )
                  || N.NB:=__RUB.ref(__RUB.sys_rub(122121,N.OD).RN,'N');
                     N.PROC:=exec('procent','nieobecnosc',N.NB);
                     N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
                     N.put()
                  ?}
               ?}
            ?}
         ||
:: Limit 19 dni nie został przekroczony sprawdzam czy z obecną nieobecnością jest już przekroczenie
            {? (_nieo_wyk+N.NK)>_lim30 & exec('sprawdz_2022','nieobecnosc',N.ref())
            || {? _batch | RAPLS.RAP=2
                  |
                  FUN.ask('%1\n%2'['Limit %1 dni został przekroczony.'@[$_lim30],'Czy rozpisać nieobecność ?'@])
               || N.DO:=N.OD+_lim30-_nieo_wyk-1;
                  {? {? N.DO=date(N.DO~1,12,0)
                     || 0
                     |? (N.OD~1)<>(N.DO~1)
                     || {? date(N.DO~1,1,1)+_lim30<_ndo || N.DO:=date(N.DO~1,1,1)+_lim30-1; 1 ?}
                     || 1
                     ?}
                  || exec('n_czas','nieobecnosc');
                     N.NB:=__RUB.ref(__RUB.sys_rub(122122,N.OD).RN,'N');
                     N.PROC:=exec('procent','nieobecnosc',N.NB);
                     N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
                     N.put();
:: Po przekroczeniu limitu zawsze kod zasiłek szpital 70%
                     N.OD:=N.DO+1;
                     N.DO:=_ndo;
                     N.DK:=0;
                     exec('n_czas','nieobecnosc');
                     N.NB:=
                        {? N.OD~1<2022
                        || __RUB.ref(__RUB.sys_rub(122121,N.OD).RN,'N')
                        || __RUB.ref(__RUB.sys_rub(122122,N.OD).RN,'N')
                        ?};
                     N.PROC:=exec('procent','nieobecnosc',N.NB);
                     N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
                     N.add()
                  ?}
               ?}
            ||
:: Limit 19 dni nie został przekroczony po dodaniu wprowadzanej nieobecności
               {? ~__RUB.sys_attr(N.NB,122122,N.OD)
               || {? _batch | RAPLS.RAP=2
                     |
                     FUN.ask('%1\n%2'
                        [  'Limit %1 dni nie został przekroczony.'@[$_lim30],
                           'Czy zamienić %1 na %2.'@
                              [  N.NB().RT,
                                 {? _limit=14
                                 || __RUB.sys_rub(122122,N.OD).RT
                                 || {? exec('sprawdz_2022','nieobecnosc',N.ref())
                                    || __RUB.sys_rub(122121,N.OD).RT
                                    || __RUB.sys_rub(122122,N.OD).RT
                                    ?}
                                 ?}
                              ]
                        ]
                    )
                  || N.NB:=__RUB.ref(
                        {? _limit=14
                        || __RUB.sys_rub(122122,N.OD).RN
                        || {? exec('sprawdz_2022','nieobecnosc',N.ref())
                           || __RUB.sys_rub(122121,N.OD).RN
                           || __RUB.sys_rub(122122,N.OD).RN
                           ?}
                        ?},'N'
                     );
                     N.PROC:=exec('procent','nieobecnosc',N.NB);
                     N.KDSW:=exec('kod_zus','nieobecnosc','S',__RUB.sys_val(14313,N.OD));
                     N.put()
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};
   N.cntx_pop();
   N.get();
   exec('n_dnop_akt','nieobecnosc',_a,_b,_c)
?}


\n_rozpisz_miesiace
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Funkcja dzieli nieobecności z podanego zakresu dat, jeżeli obejmują one swoim zakresem przełom miesięcy.
::   WE:  [_a] [INTEGER] - Tryb wsadowy:
::             0 - Nie, działanie wymaga potwierdzenia.
::             1 - Tak, działanie nie wymaga ponownego potwierdzenia.
::        _b  [DATE]    - Data początku nieobecności.
::        _c  [DATE]    - Data końca nieobecności.
::   WY:
::  OLD: \rozpisz/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;
_nod:=_b;
_ndo:=_c;

{? ~exec('n_zablokowana','nieobecnosc',_a)
|| N.cntx_psh();
   N.index('NIEOBECN');
   N.prefix('N',P.ref());
   {? N.find_key(_nod)
   || {!
      |? {? date(N.OD~1,N.OD~2,1)<date(N.DO~1,N.DO~2,1)
         || _do:=N.DO;
            N.DO:=date(N.OD~1,N.OD~2,0);
            exec('n_czas','nieobecnosc');
            N.put();
            N.OD:=N.DO+1;
            N.DO:=_do;
            N.DK:=0;
            exec('n_czas','nieobecnosc');
            {? ~(__RUB.sys_attr(N.NB,115,N.OD) | __RUB.sys_attr(N.NB,1314,N.OD))
            || N.PROC:=exec('procent','nieobecnosc',N.NB)
            ?};
            {? N.add()
            || {? N.OD=date(2009,2,1) & P.OSOBA().UR_DATA<>date(0,0,0) & ((N.OD~1)-(P.OSOBA().UR_DATA~1))>=51
               || exec('n_rozpisz_wynzas','nieobecnosc',_batch,N.OD,N.DO)
               ?};
               1
            ?}
         || N.next() & N.DO<=_ndo
         ?}
      !}
   ?};
   N.cntx_pop();
   N.get();
   exec('n_dnop_akt','nieobecnosc',_batch,_nod,_ndo)
?}


\tz_r_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [2010]
:: OPIS: Wartość początkowa pola TZ.R.
::   WE:
::   WY:
::  OLD: \__rd_tz/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.RODZ_TZ


\tz_kw_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Wartość początkowa pola TZ.KW. Procedura zeruje również wolne pola wykorzystywane podczas edycji rekordu tabeli
:        TZ.
::   WE:
::   WY:
::  OLD: \tz_kw_bl/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
TZ_EDIT.KWE:=TZ_EDIT.KWZ:=0


\tz_m_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed redagowaniem pola TZ.M. Redakcja jest możliwa dla akcji "Dołącz" lub (bez względu na akcję) dla
::       rozliczeń chorób osób (nie pracowników).
::   WE:
::   WY:
::  OLD: \tz_m_be/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
-menu_txt()='dołącz' | TZ.R='O'


\tz_m_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Po redagowaniu pola TZ.M - ustalenie wartości pól TZ.NO i TZ.PR.
::       Formuła wykorzystywana również w trybie kopiowania rekordów (stąd odwołania do cur_tab()).
::       Uwagi:
::       - Dla rekordów rodzaju E - etat i Z - zlecenia (a więc związanych z pracownikiem i jego płacami) w polu M
::         zapisywany jest PIERWSZY dzień miesiąca;
::       - Dla rekordów rodzaju O (a więc związanych z osobą - rozliczenie nieobecności umowy-zlecenie) w polu M
::         zapisywany jest OSTATNI dzień miesiąca.
::   WE:
::   WY: 1/0
::  OLD: \tz_m_ae/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab();
{? _tab.M=date(0,0,0)
|| __CHK.err_fld(TZ,'M');
   0
|| _od:=date(_tab.M~1,_tab.M~2,1);
   _do:=date(_tab.M~1,_tab.M~2,0);
   {? _tab.R='E' | _tab.R='Z'
   || __KAL.set_cal({? P.KAL || P.KAL().NAZWA || 'standard' ?},_od~1);
      _tab.M:=_od;
      {? exec('n_rozliczalna','nieobecnosc',2)='U'
      || _tab.NO:=exec('nominal','godziny',_od,_do)
      || _tab.NO:=__KAL.w_days(_od,_do);
         _tab.PR:=_tab.NO;
         _tab.PR-=exec('dnpzazw','nieobecnosc',_od,_do,'dr');
         _tab.PR-=exec('licz_nie_wynchor','lista_licz',_od,_do)
      ?}
   |? _tab.R='O'
   || __KAL.set_cal('standard');
      _tab.M:=_do;
      _tab.NO:=__KAL.w_days(_od,_do);
      _tab.PR:=_tab.NO-exec('licz_nie','os_nieob',_od,_do);
      ~~
   ?};
   {? _tab.PR<0
   || _tab.PR:=0
   ?};
   1
?}


\tz_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Obsługa akcji "Rekord - przed" dla tabeli TZ okienek:
::          WERCP - choroba pracownika;
::          WERCO - choroba osoby.
::       Ustawienie wartości zmiennych wykorzystywanych w okienku wertowania i redakcji.
::   WE: _a [NUMBER] - Rekord bieżący? [0 - nie / 1 - tak]
::   WY: 0
::  OLD: \rek_przed/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
{? TZ.R='O'
|| TZ_EDIT.KWE:=0;
   TZ_EDIT.KWZ:=TZ.KW;
   TZ_EDIT.STATZ:=''
|| TZ_EDIT.KWE:=TZ.KW
?};
TZ_EDIT.STATE:=TZ.STATUS;
{? TZ.R='E'
|| TZ.cntx_psh();
   TZ.index('PNRM');
   TZ.prefix(TZ.N,'Z',TZ.M);
   {? TZ.first()
   || TZ_EDIT.KWZ:=TZ.KW;
      TZ_EDIT.STATZ:=TZ.STATUS
   || TZ_EDIT.KWZ:=0;
      TZ_EDIT.STATZ:=''
   ?};
   TZ.cntx_pop()
?};
{? TZ_EDIT.STATE<>'A' | (TZ_EDIT.STATZ<>'' & TZ_EDIT.STATZ<>'A') || exec('flddisp','color','TZ#X#REK#P') ?}


\tz_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Obsługa akcji "Rekord - po" dla tabeli TZ oraz dla tabeli tymczasowej realizującej tryb kopiowania danych.
::   WE:
::   WY:
::  OLD: \rek_po/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab();

:Weryfikacja unikalności.
:Obsługa akcji "Rekord - po" wywoływana jest z okienka. Przyjmuje się więc, że w okienku są wyświetlane odpowiednie
:rekordy (jeżeli chodzi o rodzaj i wskazywaną nieobecność). Zakłada się jednocześnie, że w bieżącym indeksie
:(z ewentualnie nałożonym prefixem) pierwszym polem jest pole określające miesiąc.
_odp:='';
_mc:=_tab.M;
_ref:={? -menu_txt()='popraw' || _tab.ref() || null() ?};
_tab.cntx_psh();
{? _tab.find_key(_mc) & _tab.ref()<>_ref
|| _odp:='M'
?};
_tab.cntx_pop();
&_ref;
&_mc;
{? _odp='M'
|| FUN.emsg('Miesiąc musi być unikalny.'@);
   return(_odp)
?};

:Pracownicy - redakcja z poziomu TZ i/lub tabeli tymczasowej realizującej tryb kopiowania danych
{? _tab.R='E'
|| {? TZ_EDIT.KWE<0
   || return(__CHK.err_fld(TZ_EDIT,'KWE',1,'Wartość nie może być ujemna.'@))
   |? TZ_EDIT.KWZ<0
   || return(__CHK.err_fld(TZ_EDIT,'KWZ',1,'Wartość nie może być ujemna.'@))
   ?}

:Osoby - tylko z poziomu TZ
|? _tab.R='O'
|| {? TZ_EDIT.KWZ<0
   || return(__CHK.err_fld(TZ_EDIT,'KWZ',1,'Wartość nie może być ujemna.'@))
   ?}
?};

: Korekta zleceń dla urlopów
{? exec('n_rozliczalna','nieobecnosc',2)='U' & TZ_EDIT.KWZ>0
|| FUN.emsg('Dla urlopów korekta wartości zleceń jest nieuwzględniana.\nWprowadzona kwota zostanie wyzerowana.'@);
   TZ_EDIT.KWZ:=0
?};

_kwal:={?_tab.NO>0 || _tab.PR/_tab.NO>=0.5 ?};
{? ( (_kwal & _tab.W<>'T') | (~_kwal & _tab.W='T') ) &
   FUN.choice(
      'Wartość pola "Kwalifikacja" nie koresponduje z wartościami pól "Norma" i "Przepracował".\n'
      'Czy na pewno akceptujesz bieżącą wartość?'@,0,'&Tak'@,,,,'&Nie'@)=0
|| return('W')
?};
:Dla umów-zleceń kopiowania rekordów nie ma - akcja wywoływana jest tylko na rzecz tabeli TZ.
{? _tab.R='O'
|| {? TZ.OS_N=null()
   || TZ.OS_N:=OS_N.ref()
   ?};
:  Redagowanie kwoty odbywało się w wolnym polu (TZ_EDIT.KWZ) - wymagana jest aktualizacja pola TZ.KW.
   TZ.KW:=TZ_EDIT.KWZ;
   TZ.STATUS:='P'
?};
''


\dnpzazw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Formuła dla bieżącego pracownika wylicza w zadanym okresie liczbę dni/godzin nieprzepracowanych
::       przed datą zatrudnienia i/lub po dacie zwolnienia. Wymaga wcześniejszego ustalenia kalendarza.
::   WE: [_a] [DATE]   - Początek analizowanego okresu (data od) [domyślnie: początek bieżącego m-ca].
::       [_b] [DATE]   - Koniec analizowanego okresu (data do) [domyślnie: koniec bieżącego m-ca].
::       [_c] [STRING] - Rodzaj zwracanej wartości:
::          'dr' - dni robocze [domyślnie]
::          'dk' - dni kalendarzowe
::          'gr' - godziny robocze
::   WY: Liczba nieprzepracowanych dni/godzin.
::  OLD: \dnpzazw/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
_od:={? var_pres('_a')=type_of(date()) || _a || date(,,1) ?};
_do:={? var_pres('_b')=type_of(date()) || _b || date(,,0) ?};
{? _od>_do || _od==_do ?};
_to:={? var_pres('_c')=type_of('') & (_c='gr' | _c='dr' | _c='dk') || _c || 'dr' ?};

_fun:=
   {? _to='dr' || "__KAL.w_days(_a,_b)"
   |? _to='dk' || "_b-_a+1"
   |? _to='gr' || "__KAL.w_hours(_a,_b)"
   ?};

_odp:=0;
:Zatrudnienie
{? _od<P.DZA & P.DZA<=_do
|| _odp+=_fun(_od,P.DZA-1)
?};
:Zwolnienie
{? P.DZ<>date(0,0,0) & _od<=P.DZ & P.DZ<_do
|| _odp+=_fun(P.DZ+1,_do)
?};
:
_odp


\tz_edit_kwx_color
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Formuła odpowiedzialna za wybór sposobu kolorowania pól TZ_EDIT.KWE i TZ_EDIT.KWZ z poziomu TZ i tabeli
::       tymczasowej realizującej tryb kopiowania danych.
::   WE: _a [STRING] - Rodzaj kwoty:
::             E - etat
::             Z - zlecenie
::   WY: Kod kolorowania
::  OLD: \kol_kw/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
:Znaczenie i przekodowanie statusu:
:A - automat
:P - poprawka
:a - kopia automatu - pokazujemy Kopia
:p - kopia poprawki, lub poprawka kopii automatu - pokazujemy Poprawka

_status:={? _a='E' || {? TZ_EDIT.STATE='W' || 'P' || '' ?} |? _a='Z' || TZ_EDIT.STATZ || '?' ?};
{? _status='a' || _status:='K'
|? _status='p' || _status:='P'
|? _status='' || _status:='A'
?};

'TZ#'+cur_tab().R+'#KW'+_a+'#'+_status


\tz_edit_kwe_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed wyświetleniem pola TZ_EDIT.KWE. Formuła wykonywana podczas wertowania tabeli TZ (zarówno dla pracowników
::       jak i dla osób w zleceniach) oraz tabeli tymczasowej realizującej tryb kopiowania danych.
::   WE:
::   WY:
::  OLD: \tze_kwe_bd/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
exec('flddisp','color','TZ#'+cur_tab().R+'#KWE#')


\tz_edit_kwz_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed wyświetleniem pola TZ_EDIT.KWZ
::   WE:
::   WY:
::  OLD: \tze_kwz_bd/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
exec('flddisp','color','TZ#E#KWZ#')


\tz_drukrozln_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Wydruk rozliczenia nieobecności. Procedura wywoływana z dwóch miejsc:
::       - z poziomu tabeli nieobecności;
::       - z okienek wertowania (WERCP, WERUP) tabeli TZ.
::   WE:
::   WY:
::  OLD: \tz_wercx_w/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
rep_exec('ppl_roznb')


\tz_legenda_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Obsługa akcji "Legenda" dla tabeli TZ (wszystkie okienka wertowania).
::   WE:
::   WY:
::  OLD: \legenda/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','@TZ#'+TZ.R+'#','TZ#X#REK#P')


\n_partday_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Przed redagowaniem pola PARTDAY tabeli N
::   WY: 0/1
::  OLD: \partday_be/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('n_partday_bd','nieobecnosc')
|| params_get().fld.PARTDAY:=N.PARTDAY;
   1
?}


\n_partday_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Przed wyświetleniem pola PARTDAY tabeli N
::   WY: 0/1
::  OLD: \partday_bd/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
N.NB<>null() & N.OD=N.DO & __RUB.sys_attr(N.NB,199,N.OD) & N.UW='D'


\n_partday_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Po redagowaniu pola PARTDAY tabeli N
::  OLD: \partday_ae/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_before:=params_get().fld.PARTDAY;
{? _before<>N.PARTDAY
|| {? N.PARTDAY='T' & N.NRG_AUTO='T'
   || N.NRG_AUTO:='N';
      N.NR:=1
   |? N.PARTDAY='N' & N.NRG_AUTO='N'
   || N.NRG_AUTO:='T';
      exec('n_czas','nieobecnosc',1)
   ?};
   exec('n_efld_opt','nieobecnosc')
?};
1


\n_nrg_auto_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Przed redagowaniem pola N.NRG_AUTO.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
N.PARTDAY='N'


\licz_kal_dgr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Formula dla bieżącego pracownika wylicza w zadanym okresie liczbę dni/godzin nieprzepracowanych z powodu
::       określonych nieobecności. Wymaga wcześniejszego ustalenia kalendarza.
::   WE:  _a  [DATE]   - początek analizowanego okresu (data od) [domyślnie początek bieżącego m-ca]
::        _b  [DATE]   - koniec analizowanego okresu (data do) [domyślnie koniec bieżącego m-ca]
::       [_c] [STRING] - rodzaj zwracanej wartości
::                      'd' - dni [domyslnie]
::                      'g' - godziny
::       [_d] [STRING] - lista kodow nieobecnosci - domyślnie wszystkie
::   WY: liczba nieprzepracowanych dni/godzin
::  OLD: \dnph/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
exec('__RUB','object');
_R:=__RUB.sys_rub(1);

_od:={? var_pres('_a')<>type_of(date()) || date(,,1) || _a ?};
_do:={? var_pres('_b')<>type_of(date()) || date(,,0) || _b ?};
{? _od>_do
|| _od==_do
?};
{? var_pres('_d')=type_of('') & _d<>''
|| _rn:=','+_d+',';
   {? _R.first()
   || {!
      |? {? _rn*(','+$_R.RN+',')
         || _R.next()
         || _R.del()
         ?}
      !}
   ?}
?};

_licz:=
   {? var_pres('_c')=type_of('') & _c='g'
   || "__KAL.w_hours(_a,_b)"
   || "__KAL.w_days(_a,_b)"
   ?};

_odp:=0;
N.cntx_psh();
N.index('NIPRACNB');
_loop:=_R.first();
{!
|? _loop
|! N.prefix('N',P.ref(),_R.RN);
   {? N.find_le(_od)
   || {!
      |? {? N.OD<=_do & _od<=N.DO
         || _odp+=_licz(MS.max(N.OD,_od),MS.min(_do,N.DO))
         ?};
         N.next()
      !}
   ?};
   _loop:=_R.next()
!};
N.cntx_pop();
_odp


\dni_url_wych
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [12.10]
:: OPIS: Wyliczenie ilości dni urlopu wychowawczego w podanym zakresie dat dla bieżącego pracownika.
::   WE: _a  [DATE] - data początku badanego okresu (ubezpieczeniowego)
::       _b  [DATE] - data końca badanego okresu (ubezpieczeniowego)
::      [_c] [STRING] - czy zwracać informacje o liczbie dni kalendarzowych 'K'(domyślnie) czy roboczych 'R'?
::   WY: _wynik - liczba dni kalendarzowych urlopu wychowawczego w podanym okresie
::  OLD: \dni_url_wych/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_lod:={? var_pres('_a')=type_of(date()) || _a || date() ?};
_ldo:={? var_pres('_b')=type_of(date()) || _b || date() ?};
_typ:={? var_pres('_c')=type_of('')     || _c || 'K'    ?};

{? _typ<>'K' & _typ<>'R' || _typ:='K' ?};

_wynik:=0;
N.cntx_psh();
N.index('NIPRACNB');
N.prefix('N',P.ref(),3);
{? N.last()
|| {!
   |? {? N.OD<=_ldo & N.DO>=_lod
      || _wod:={? N.OD<_lod || _lod || N.OD ?};
         _wdo:={? _ldo<N.DO || _ldo || N.DO ?};
         _wynik+={? _typ='R'
                 || __KAL.w_days(_wod,_wdo)
                 || (_wdo-_wod)+1
                 ?}
      ?};
      N.prev() & N.DO>=_lod
   !}
?};
N.cntx_pop();
_wynik


\czy_jest
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2011]
:: OPIS: Sprawdza, czy pracownik jest nieobecny.
::   WE: _a - ref pracownika
::       _b - data, jesli pominieta lub typu innego niz date, to przyjeta zostanie data biezaca
::       ... - kody nieobecnosci, jesli pominiete sprawdzane beda wszystkie rodzaje
::   WY: 1 - pracownik nieobecny, 0 - pracownik obecny
::  OLD: \czy_jest/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_date:={? var_pres('_b')<>type_of(date) || date || _b ?};

{? ~exec('jest_prac','obiegi',_a,_date)
|| return(1)
?};

exec('__RUB','object');

_n_code:='';
{? _>2
|| {! _arg:=3.._
   |! _val:=_[_arg];
      {? type_of(_val)=type_of(0)
      || _n_code+=','+$_val
      ?}
   !};
   _n_code+=','
|| _n_code:=','+__RUB.sys_sql(1,_date)+','
?};

N.cntx_psh;
N.index('NIEOBECN');
N.prefix('N',_a);
{? N.last()
|| {!
   |? {? _date<=N.DO & _date>=N.OD & _n_code*(','+$N.NB().RN+',') & (N.PARTDAY<>'T') &
         ~(__RUB.sys_attr(N.NB,122722,_date) | __RUB.sys_attr(N.NB,122742,_date))
      || N.cntx_pop;
         return(1)
      ?};
      N.prev() & date(N.OD~1,N.OD~2,1)>=date(_date~1,_date~2,1)
   !}
?};
N.cntx_pop;

0


\nbk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyświetla listę nieobecności bez kalendarza.
::   WE: _a [STRING] - symbol dziedziny produktu
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
exec('__KAL','object');

_REP:=tab_tmp(1,
   'N','STRING[16]','Nieobecność'@,
   'RN','INTEGER','Kod'@,
   'RT','STRING['+$MS.fld_len('R','RT')+']','Nazwa'@,
   'OD','DATE','Data od'@,
   'DO','DATE','Data do'@,
   'NK','INTEGER','Dni kalendarzowe'@,
   'NR','INTEGER','Dni robocze'@,
   'NG','REAL','Godziny robocze'@,
   'T','STRING['+$MS.fld_len('P','T')+']','Numer teczki'@,
   'NAZWISKO','STRING['+$MS.fld_len('OSOBA','NAZWISKO')+']','Nazwisko'@,
   'PIERWSZE','STRING['+$MS.fld_len('OSOBA','PIERWSZE')+']','Imię'@,
   'SYMBOL','STRING['+$MS.fld_len('UD_SKL','SYMBOL')+']','Jednostka organizacyjna'@,
   'ST','STRING['+$MS.fld_len('STN','ST')+']','Stanowisko'@
);
_REP.index(_REP.ndx_tmp(,,'OD',,,'NAZWISKO',,,'PIERWSZE',,));
_wnd:=_REP.mk_sel('Zaktualizowane nieobecności'@,'P',0,'#grpnieobkalrep',,,,,'U');
_REP.win_fld(_wnd,,'RN',,,-3,,,,,MS.comment('R','RN'));
_REP.win_fld(_wnd,,'RT',,,-20,,,,,MS.comment('R','RT'));
_REP.win_fld(_wnd,,'OD',,,-10,,,,,'Data rozpoczęcia'@);
_REP.win_fld(_wnd,,'DO',,,-10,,,,,'Data zakończenia'@);
_REP.win_fld(_wnd,,'NK',,,-5,,,,,MS.comment('N','NK'));
_REP.win_fld(_wnd,,'NR',,,-5,,,,,MS.comment('N','NR'));
_REP.win_fld(_wnd,,'NG',,,-8,2,,,,MS.comment('N','NG'));
_REP.win_fld(_wnd,,'T',,,-10,,,,,MS.comment('P','T'));
_REP.win_fld(_wnd,,'NAZWISKO',,,-20,,,,,MS.comment('OSOBA','NAZWISKO'));
_REP.win_fld(_wnd,,'PIERWSZE',,,-20,,,,,MS.comment('OSOBA','PIERWSZE'));
_REP.win_fld(_wnd,,'SYMBOL',,,-16,,,,,MS.comment('UD_SKL','SYMBOL'));
_REP.win_fld(_wnd,,'ST',,,-30,,,,,MS.comment('STN','ST'));
_REP.win_act(_wnd,,'Wyświetl',,,,"
   {? N.seek(cur_tab(1,1).N)
   || N.win_edit('RED');
      N.display()
   ?}
");
_REP.win_sel(_wnd);
params_set('REP',_REP);

N.cntx_psh();
P.cntx_psh();
OSOBA.cntx_psh();
UD_SKL.cntx_psh();
STN.cntx_psh();

N.clear();
P.clear();
OSOBA.clear();
UD_SKL.clear();
STN.clear();

NBK.cntx_psh();
NBK.clear();
NBK.index('WIDOK');
NBK.f_set(,,
   'NBK.P in (select :_a.REF from :_a order by :_a.REF)',
   exec('dostepne_p','schemat',_a,'P,K,T')
);

_loop:=NBK.f_first();
{!
|? _loop
|! {? NBK.POMIN='N'
   || exec('nbk_jest_kal_akt','nieobecnosc')
   ?};
   _loop:=NBK.f_next()
!};
NBK.f_first();

_wnd:=NBK.grp_make('Nieobecności bez kalendarza'@,"",'#grpnoebkal',,,"",,'maximized');
NBK.grp_sel(_wnd,,'WER',,
   "  {? NBK.sel_size()=0
      || {? NBK.get()<>0
         || exec('nbk_jest_kal_akt','nieobecnosc')
         ?};
         NBK.f_rfresh();
         NBK.f_get()
      ?};
      NBK.actions_grayed('WER',
         {? NBK.sel_size()=0
         || {? NBK.POMIN='T'
            || 'AP'
            || {? NBK.JEST_KAL='N'
               || 'A'
               || ''
               ?}+
               'U'
            ?}
         || ''
         ?}
      )
   ",,,,
   "  params_set(params_get());
      1
   ",,,,
   'maximized'
);
NBK.win_sel(_wnd);
NBK.select();
{? _REP.first()
|| _REP.select()
?};

NBK.f_clear();
NBK.cntx_pop();
NBK.win_del(_wnd);

STN.cntx_pop();
UD_SKL.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();
N.cntx_pop();
~~


\nbk_jest_kal_akt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Aktualizuje znacznik JEST_KAL tabeli NBK
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_old:=__KAL.no_err(1);
{? __KAL.set_cal(NBK.P().KAL,NBK.N().OD~1)
|| {? NBK.JEST_KAL<>'T'
   || NBK.JEST_KAL:='T';
      NBK.put()
   ?}
|| {? NBK.JEST_KAL<>'N'
   || NBK.JEST_KAL:='N';
      NBK.put()
   ?}
?};
__KAL.no_err(_old)


\nbk_db
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyświetl dla nieobecności bez kalendarza
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
N.win_edit('RED');
N.display();
~~


\nbk_aktualizuj_ba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed "Aktualizuj" nieobecności.
::   WE:
::   WY: 1 - akcja po będzie wykonana
::       0 - akcja po nie zostanie wykonana
::----------------------------------------------------------------------------------------------------------------------
{? ~NBK.get()
|| return(0)
?};
{? NBK.sel_size()=0 & NBK.POMIN='T'
|| FUN.info('Pomijana nieobecność nie może być aktualizowana.'@)
?};
NBK.POMIN='N' & NBK.JEST_KAL='T'


\nbk_aktualizuj_aa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Po "Aktualizuj" nieobecności.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
N.clear();
NBK.N().P;
__KAL.set_cal(P.KAL,N.OD~1);
exec('n_czas','nieobecnosc');
{? N.put()
|| _par:=params_get();
   {? type_of(_par)>100 & var_pres('REP',_par)=type_of(SYSLOG)
   || _REP:=_par.REP;
      _REP.N:=$N.ref();
      _REP.RN:=N.NB().RN;
      _REP.RT:=N.NB().RT;
      _REP.OD:=N.OD;
      _REP.DO:=N.DO;
      _REP.NK:=N.NK;
      _REP.NR:=N.NR;
      _REP.NG:=N.NG;
      _REP.T:=N.P().T;
      _REP.NAZWISKO:=P.OSOBA().NAZWISKO;
      _REP.PIERWSZE:=OSOBA.PIERWSZE;
      _REP.SYMBOL:=P.WYDZIAL().SYMBOL;
      _REP.ST:=P.ST().ST;
      _REP.add()
   ?}
?};
~~


\nbk_pomin_ba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed "Pomiń" nieobecności.
::   WE:
::   WY: 1 - akcja po będzie wykonana
::       0 - akcja po nie zostanie wykonana
::----------------------------------------------------------------------------------------------------------------------
{? ~NBK.get()
|| return(0)
?};
{? NBK.sel_size()=0 & NBK.POMIN='T'
|| FUN.info('Nieobecność jest już oznaczona jako pomijana.'@)
?};
NBK.POMIN='N'


\nbk_pomin_aa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Po "Pomiń" nieobecności.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
NBK.POMIN:='T';
NBK.put();
~~


\nbk_uwzglednij_ba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed "Uwzglednij" nieobecności.
::   WE:
::   WY: 1 - akcja po będzie wykonana
::       0 - akcja po nie zostanie wykonana
::----------------------------------------------------------------------------------------------------------------------
{? ~NBK.get()
|| return(0)
?};
{? NBK.sel_size()=0 & NBK.POMIN='N'
|| FUN.info('Nieobecność jest już oznaczona jako uwzględniana.'@)
?};
NBK.POMIN='T'


\nbk_uwzglednij_aa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Po "Uwzglednij" nieobecności.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
NBK.POMIN:='N';
NBK.put();
~~


\plan_aktual
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK
:: OPIS: Aktualizacja nieobecnosci - po wczytaniu planu
::   WE: _a [REFERENCE] - wskazanie na pracownika
::       _b [DATE]      - poczatek okresu
::       _c [DATE]      - koniec okresu
::   WY: 0/1
::  OLD: \plan_aktual/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null()) || _a || return(0) ?};
 _pocz:={? var_pres('_b')=type_of(date)   || _b || return(0) ?};
  _kon:={? var_pres('_c')=type_of(date)   || _c || return(0) ?};

:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || return(0) ?};

:: zalozenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

_tabN:=exec('getNieobInDays','nieobecnosc',_p_ref,_pocz,_kon);
exec('nieob_aktual','nieobecnosc',_tabN);
_tabNWU:=exec('getNWUInDays','nieobecnosc',_p_ref,_pocz,_kon);
exec('nwu_aktual','nieobecnosc',_tabNWU);

{? _mydo || end() ?};
1


\nieob_aktual
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51]
:: OPIS: Aktualizacja nieobecnosci dla przekazanej tabeli refów
::   WE: _a  [DICT]   - tablica z refami nieobecności
::      [_b] [NUMBER] - czy pokazywać progresa (domyślnie nie)
::   WY: 0/1
::  OLD: \nieob_aktual/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(N) || _a || return(0) ?};
_prg:={? var_pres('_b')=type_of(0) || _b || 0         ?};

:: sprawdzamy czy mamy pole z refem w przekazanej tabeli
{? var_pres('REF',_tab)<0 || return(0) ?};

_kal_nazw:=__KAL.kal_nazw;
N.cntx_psh();
N.prefix();
{? _tab.first()
|| {? _prg || PROGRESS.set(_tab.size(),'Trwa aktualizacja nieobecności...'@) ?};
   _org:=exec('n_params','nieobecnosc');
   {!
   |? {? N.seek(_tab.REF)
      || _part:={? var_pres('PARTDAY',N)>0 || N.PARTDAY='T' || 0 ?};
         _status:=exec('getPlanStat4Pr','grafik',N.P,N.OD);
         {? (_status<>'Z' & _status<>'X') & (N.LT='') & (~_part) & N.NRG_AUTO='T'
         || _org.NB:=N.NB;
            _org.OD:=N.OD;
            _org.DO:=N.DO;
            _nr:=N.NR;
            _ng:=N.NG;
            __KAL.set_cal(N.P().KAL);
            N.NR:=__KAL.w_days(N.OD,N.DO);
            N.NG:=exec('nominal','godziny',N.OD,N.DO);
            {? (_nr<>N.NR | _ng<>N.NG) & N.put()
            || NieoRok:=N.OD~1;
               NieoKod:=N.NB;
               exec('kart_url_update_put_n','kart_url',_org)
            ?}
         ?}
      ?};
      {? _prg || PROGRESS.next() ?};
      _tab.next()
   !};
   {? _prg || PROGRESS.close() ?}
?};
N.cntx_pop();
{? var_pres('_kal_nazw')=type_of(null())
|| __KAL.set_cal(_kal_nazw)
?};
1


\nwu_aktual
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [19.22]
:: OPIS: Aktualizacja nieobecnosci dla przekazanej tabeli refów
::   WE: _a  [DICT]   - tablica z refami nieobecności
::      [_b] [NUMBER] - czy pokazywać progresa (domyślnie nie)
::   WY: 0/1
::  OLD: \nieob_aktual/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(N) || _a || return(0) ?};
_prg:={? var_pres('_b')=type_of(0) || _b || 0         ?};

:: sprawdzamy czy mamy pole z refem w przekazanej tabeli
{? var_pres('REF',_tab)<0 || return(0) ?};

_kal_nazw:=__KAL.kal_nazw;
NWU.cntx_psh();
NWU.prefix();
{? _tab.first()
|| {? _prg || PROGRESS.set(_tab.size(),'Trwa aktualizacja wniosków urlopowych...'@) ?};
   {!
   |? {? NWU.seek(_tab.REF)
      || _part:={? var_pres('PARTDAY',NWU)>0 || NWU.PARTDAY='T' || 0 ?};
         _status:=exec('getPlanStat4Pr','grafik',NWU.P,NWU.OD);
         {? ~_part & (_status<>'Z' & _status<>'X')
         || _nr:=NWU.NR;
            _ng:=NWU.NG;
            __KAL.set_cal(NWU.P().KAL);
            NWU.NR:=__KAL.w_days(NWU.OD,NWU.DO);
            NWU.NG:=exec('nominal','godziny',NWU.OD,NWU.DO);
            {? (_nr<>NWU.NR | _ng<>NWU.NG)
            || NWU.put()
            ?}
         ?}
      ?};
      {? _prg || PROGRESS.next() ?};
      _tab.next()
   !};
   {? _prg || PROGRESS.close() ?}
?};
NWU.cntx_pop();
{? var_pres('_kal_nazw')=type_of(null())
|| __KAL.set_cal(_kal_nazw)
?};
1


\getNieobInDays
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Zwraca tabelę z refami nieobecności w dniu
::   WE: _a - [REFERENCE]  - wskazanie na pracownika
::       _b - [DATE]       - poczatek okresu
::       _c - [DATE]       - koniec okresu
::       _d - [REFERENCE]  - wskazanie na pomijaną nieobecność
::   WY: tabela z nieobecnościami
::  OLD: \getNieobInDays/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null) ||  _a || null()      ?};
 _pocz:={? var_pres('_b')=type_of(date) ||  _b || date(0,0,0) ?};
  _kon:={? var_pres('_c')=type_of(date) ||  _c || date(0,0,0) ?};
  _ref:={? var_pres('_d')=type_of(null) || $_d || ''          ?};

_sql:=''+"select
            REFERENCE as REF
          from
            N
          where
            N.KOR='N' and N.P=:_a and N.DO>=to_date(:_b) and N.OD<=to_date(:_c)  and N.REFERENCE != ':_d'
         ";
_tab:=sql(_sql,_p_ref,_pocz,_kon,_ref);
_tab


\getNWUInDays
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [19.22]
:: OPIS: Zwraca tabelę z refami wniosków urlopowych w badanym okresie
::   WE: _a - [REFERENCE]  - wskazanie na pracownika
::       _b - [DATE]       - poczatek okresu
::       _c - [DATE]       - koniec okresu
::       _d - [REFERENCE]  - wskazanie na pomijany wniosek urlopowy
::   WY: tabela z wnioskami urlopowymi
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null) ||  _a || null()      ?};
 _pocz:={? var_pres('_b')=type_of(date) ||  _b || date(0,0,0) ?};
  _kon:={? var_pres('_c')=type_of(date) ||  _c || date(0,0,0) ?};
  _ref:={? var_pres('_d')=type_of(null) || $_d || ''          ?};

_sql:=''+"select
            REFERENCE as REF
          from
            NWU
          where
            NWU.P=:_a and NWU.DO>=to_date(:_b) and NWU.OD<=to_date(:_c)  and NWU.REFERENCE != ':_d'
         ";
_tab:=sql(_sql,_p_ref,_pocz,_kon,_ref);
_tab


\czyOkrWycz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MK [17.42]
:: OPIS: Funkcja sprawdza czy sugerować okresy wyczekiwania (czy pracownik nabył prawo do zasiłku chorobowego)
::   WE: _a - [REFERENCE]  - wskazanie na pracownika
::       _b - [REFERENCE]  - wskazanie na pracownika
::       _c - [DATE]       - poczatek okresu
::       _d - [INTEGER]    - przekazać liczbę dni z okresów zatrudnienia:
::             0 - Nie (domyslnie)
::             1 - Tak
::   WY: 1 - sugrwowany okresy wyczekiwania - nie nabył prawa do zasiłku
::       0 - bez okresu wyczekiwania - nabył prawo do zasiłku
::       lub liczba dni z okresów zatrudnienia (jeśli _d=1)
::
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null()) ||  _a || null() ?};
_osoba:={? var_pres('_b')=type_of(null()) ||  _b || null() ?};
_nOD:={? var_pres('_c')=type_of(date()) || _c || date(0,0,0) ?};
_staz:={? var_pres('_d')=type_of(0) || _d || 0 ?};

{? _p_ref=null() | _osoba=null() | _nOD=#0
|| return(0)
?};

:: Czy pracownik pracuje powyżej 30 dni
{? (_nOD-P.DZA)+1>30
|| return(0)
?};

:: Dni ciągłego ubezpieczenia z poprzednim okresem zatrudnienia jeżeli przerwa pomiędzy okresami jest krótsza niż 30 dni
_ubez:=(_nOD-P.DZA);
STAZ.cntx_psh();
STAZ.index('_STAZEDZ');
STAZ.prefix(exec('ref_firma','ustawienia'),_osoba);
_dalej:=1;
_dataU:=P.DZA;
:: W pierwszej kolejności okresy pracy w okresy pracy w bieżącej firmie
P.cntx_psh();
P.index('PRACOSBX');
P.prefix(exec('ref_firma','ustawienia'),'P',_osoba);
{? P.last()
||  {!
    |? {? P.ref()<>_p_ref
       || {? P.DZA<_dataU & (P.DZ=#0 | (P.DZ<>#0 & ((_dataU-(P.DZ+1))<=30) | P.DZ>_dataU))
          || _dz:={? P.DZ=date(0,0,0) | P.DZ>_dataU || _dataU-1 || P.DZ ?};
:: Korekta daty w przypadku nakładania się okresów zatrudnienia
             _pomS:=(_dz-P.DZA)+1;
             {? _pomS>0
             || _ubez+=_pomS;
                _dataU:=P.DZA
             ?}
          || {? P.DZ<>#0 & ((_dataU-(P.DZ+1))>30) || _dalej:=0 ?}
          ?}
       ?};
       _dalej & P.prev()
    !}
?};
P.cntx_pop();
_dalej:=1;
_pomStaz:=0;
:: Teraz okresy zatrudnienia z tabeli STAZ
{? STAZ.last()
||  {!
    |? {? STAZ.CI='T' & STAZ.DR<_dataU
       || {? (_dataU-(STAZ.DZ+1))<=30 | STAZ.DZ>_dataU
          || _dz:={? STAZ.DZ>_dataU || _dataU-1 || STAZ.DZ ?};
:: Korekta daty w przypadku nakładania się okresów zautrudnienia
             _pomS:=(_dz-STAZ.DR)+1;
             {? _pomS>0
             || _ubez+=_pomS;
                _pomStaz+=_pomS
             ?};
             _dataU:=STAZ.DR
          ?}
       || {? (_dataU-(STAZ.DZ+1))>30 || _dalej:=0 ?}
       ?};
       _dalej & STAZ.prev()
    !}
?};
STAZ.cntx_pop();
{? _staz
|| return(_pomStaz)
?};
{? _ubez>30
|| return(0)
?};

:: Jeżeli nie mineło 90 dni od ukończenia szkoły do daty zatrudnienia przysługuje prawo do zasiłku
_ubez:=0;
OS_SZKOL.cntx_psh();
OS_SZKOL.index('OD');
OS_SZKOL.prefix(_osoba);
{? OS_SZKOL.first()
|| {!
   |? {? OS_SZKOL.DO<>#0
      || _ubez:=(P.DZA-OS_SZKOL.DO)<90
      ?};
      ~_ubez & OS_SZKOL.next()
   !}
?};
OS_SZKOL.cntx_pop();
{? _ubez
|| return(0)
?};

:: Po 10 latach stażu przysługuje zawsze prawo do zasiłku
_staz:=exec('oblicz','staz',1,,N.OD~1,,N.OD);
{? _staz.lat[1]>9
|| return(0)
?};
&_staz;

:: Sprawdzamy okresy ubezpieczenia w umowach zleceniach
_ubez:=(_nOD-P.DZA);

_zlec:=0;
ZC_INFO.cntx_psh();
ZC_INFO.index(ZC_INFO.ndx_tmp(,1,'FIRMA',,,'OSOBA',,,'FC',,,'DW',,));
ZC_INFO.prefix(exec('ref_firma','ustawienia'),_osoba,'T');
{? ZC_INFO.last() & ZC_INFO.DW>P.DZA-30
|| _du:=_dw:=date(0,0,0);
   _dalej:=1;
   _UM:=tab_tmp(1,'DU','DATE',,'DW','DATE',);
:: Ustalenie czasu trwania ciągłego ubezpieczenia chorobowego w umowach cywilnoprawnych
   {!
   |? {? ZC_INFO.DU<P.DZA
      || {? _UM.size()
         || {? ZC_INFO.DW+1<_UM.DU
            || {? ZC_INFO.DW>P.DZA-30
               || _UM.first();
                  {! |? _UM.del() !};
                  _UM.DU:=ZC_INFO.DU;
                  _UM.DW:=ZC_INFO.DW;
                  _UM.add()
               || _dalej:=0
               ?}
            || {? ZC_INFO.DU<_UM.DU || _UM.DU:=ZC_INFO.DU ?};
               {? ZC_INFO.DW>_UM.DW || _UM.DW:=ZC_INFO.DW ?};
               _UM.put()
            ?}
         || _UM.DU:=ZC_INFO.DU;
            _UM.DW:=ZC_INFO.DW;
            _UM.add()
         ?}
      ?};
      _dalej & ZC_INFO.prev()
   !};

:: Ustalenie czy umowy cywilnoprawne pozwolą skrócić lub pominąć okres wyczekiwania
   {?_UM.DU<P.DZA
   || {? (P.DZA-_UM.DW)<30 | _UM.DW>P.DZA
      || _dz:={? _UM.DW>P.DZA || P.DZA-1 || _UM.DW ?};
:: Korekta daty w przypadku nakładania się okresów umów
         _pomS:=(_dz-_UM.DU)+1;
         {? _pomS>0
         || _ubez+=_pomS;
            _zlec+=_pomS
         ?};
         P.DZA:=_UM.DU
      || _dalej:=0
      ?}
   ?}
?};
ZC_INFO.ndx_drop();
ZC_INFO.cntx_pop();
{? _ubez>30
|| return(0)
|? _zlec
|| return(_zlec)
?};
-1


\konflikty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja sprawdza konflikty dla nieobecnosci w podanym zakresie dat
::   WE: [_a] - [REFERENCE/STRING] Wskazanie na pracownika lub symbol dziedziny produktowej. Formuła służy sprawdzeniu
::                         konfliktów dla konkretnego pracownika (przy wprowadzaniu nieobecności, imporcie e-ZLA) lub
::                         dla "wszystkich" pracowników. Sprawdzenie dla konkretnego pracownika ma miejsce, jeżeli
::                         parametr _a jest typu REFERENCE i jest różne od null(). W przeciwnym wypadku
::                         przyjmuje się, że parametr wskazuje dziedzinę produktową [domyślnie: 'PRC'].
::        _b  - [DATE] Data od
::        _c  - [DATE] Data do
::       [_d] - [INTEGER] Czy pokazywać okno z konfliktami:
::                            0 - nie pokazuje okna (domyślnie)
::                            1 - pokazuje okno jak są konflikty
::                            2 - pokazuje okno nawet jeśli brak konfliktów
::       [_e] - [INTEGER]     0 - sprawdzanie odbywa sie na każdy dzień z zakresu podanych dat
::                            1 - sprawdzanie odbywa sie tylko jeżeli w zakresie podanych dat
::                                wystepuje już nieobecność (domyślnie)
::       [_f] - [CLASS.JCQ] uchwyt do kolekcji komunikatów, jeżeli nie został podany - odpowiedni obiekt zostanie
::                            powołany, użyty i usunięty
::       [_g] - [INTEGER] Czy ustawiony bufor nieobecności
::       [_h] - [INTEGER] Akcja 0 - add/1 - put na nieobecności
::       [_i] - [INTEGER] Zwrócenie tabeli komunikatów o błędach (domyślnie 0)
::   WY: zależy od parametru wejściowego:
::       _i=0 (domyślnie)
::          0/1  - [INTEGER]  0 - jeżeli nie ma konfliktów
::                            1 - jeżeli jest choćby jeden konflikt
::       _i=1
::          obiekt o strukturze ('odbiory','wolne','odprac','wewy','kal_buff','partN')
::  OLD: \konflikty/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:=null();
_domain:='PRC';
{? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=P
|| _p_ref:=_a
|? var_pres('_a')=type_of('') & exec('domain_ref','#b_domain',_a)<>null()
|| _domain:=_a
?};
_od:={? var_pres('_b')=type_of(date()) || _b || date(0,0,0) ?};
_do:={? var_pres('_c')=type_of(date()) || _c || date(0,0,0) ?};
_show:={? var_pres('_d')=type_of(0) || _d || 0 ?};
_chk_N:={? var_pres('_e')=type_of(0) || _e || 1 ?};
_retTable:={? var_pres('_i')=type_of(0) || _i || 0 ?};

{? var_pres('_f')=var_pres('JCQ',@.CLASS)
:: Użycie zewnetrznej kolekcji komunikatów.
|| _KOMM:=_f
:: Powołanie nowej zmiennej do obsługi obiektu JCQ oraz utworzenie obiektu klasy JCQ i przypisanie go do zmiennej
|| _var:=VAR_DEL.new(,"obj_new(@.CLASS.JCQ)");
:: Dla wygody przypisujemy go do zmiennej lokalnej
   _KOMM:=($_var)();

   _width:=200;
   {? _p_ref=null()
   || _width:=MS.fld_len('OSOBA','NAZWISKO')+MS.fld_len('OSOBA','PIERWSZE')+MS.fld_len('P','T')+135
   ?};
   _KOMM.init(_width,,' Konflikty dla nieobecności (%1 - %2)'@[$_od,$_do],'')
?};

_N:={? var_pres('_g')=type_of(0) || _g || 0  ?};
_akcja:={? var_pres('_h')=type_of(0) || _h || 0 ?};
_dalej:=1;
_prac_ok:=_res:=0;

N.cntx_psh();
N.index('NIEOBECN');
P.cntx_psh();
P.prefix();

{? _p_ref<>null()
|| _PTMP:=tab_tmp(1,'REF','STRING[16]',);
   _PTMP.REF:=$_p_ref;
   _PTMP.add()
|| _PTMP:=exec('dostepne_p','schemat','PRC',P_FILTER.F_ZATR().KOD,P_FILTER.STATUS,UD_DEF.SYMBOL)
?};

_d0:=date(0,0,0);
{? _PTMP.first()
|| _size:=((#_do-#_od)+1)*_PTMP.size();
   PROGRESS.set(_size,'%1 %2'['Weryfikacja konfliktów nieobecności.'@,'Proszę czekać ...'@],'Przetwarzanie danych'@);
   {!
   |? {? P.seek(_PTMP.REF,) & P.DZA<=_do & (P.DZ=_d0 | P.DZ>=_od)
      || {? var_pres('_tabKOMM')<0
         || _tabKOMM:=obj_new('odbiory','wolne','odprac','wewy','kal_buff','partN')
         ?};
         _par:=obj_new('odbiory','wolne','odprac','wewy','kal_buff','partN');
         {! _ind:=1..obj_len(_par) |! _par[_ind]:=0 !};
         {! _ind:=1..obj_len(_tabKOMM) |! _tabKOMM[_ind]:='' !};
         _prac:=0;

:: Powołanie potrzebnych sekcji.
         _lp:=_KOMM.sect_beg(
            ' %1 %2 %3:'[P.OSOBA().NAZWISKO,P.OSOBA().PIERWSZE,'[nr teczki - %1]'@[form(P.T)]],
            'xwin16.png:100'
         );
         _KOMM.sect_end();
         _icon:='xwin16.png:83';

:: Pętla po dniach nieobecności.
         {! _ii:=#_od..#_do
         |! _kon:=0;
            _data:=#_ii;

:: Sprawdzamy czy jest nieobecnośc na dany dzień.
            {? _chk_N || N.prefix('N',P.ref()) ?};
            {? ~_chk_N | (N.find_le(_data) & N.DO>=_data)
            || _komm:=' '+$(_data);

:: Powołanie sekcji dnia.
               _section:=_KOMM.sect_beg(_komm,_icon);
               _KOMM.chngroot(_section,_lp);

:: Sprawdzenie czy dla nieobecności wprowadzonej na część dnia jest wystarczająca liczba godzin w kalendarzu.
               _godz:=_godz1:=0;
               _ref_N:=null();
               _opis:='';
               {? _N
               || {? N.PARTDAY='T'
                  || _ref_N:={? _akcja || N.ref() || null() ?};
                     _godz:=N.NG;
                     _opis+=$N.NB().RN+' '+R.RT
                  || _ref_N:={? _akcja || N.ref() || null() ?};
                     _godz1:=100
                  ?}
               ?};
               _macprac:={? __RUB.sys_attr(N.NB,11522,N.OD) | __RUB.sys_attr(N.NB,11542,N.OD) || 1 || 0?};

               _tab_N:=exec('getNieobInDays','nieobecnosc',P.ref(),_data,_data,_ref_N);
               N.cntx_psh();
               {? _tab_N.first()
               || {!
                  |? {? N.seek(_tab_N.REF,,1)
                     || {?  N.PARTDAY='T'
                        || _godz+=N.NG;
                           _opis+={? +_opis || ', ' || '' ?}+$N.NB().RN+' '+R.RT
                        || _godz1+=100
                        ?}
                     ?};
                     _tab_N.next()
                  !}
               ?};
               N.cntx_pop();
               obj_del(_tab_N);

               __KAL.set_cal(P.KAL,_data~1);
               _plan:=__KAL.w_hours(_data,_data);
               {? _godz>_plan
               || _komm:='%1 - %2'
                     [  'Nieobecność na część dnia (%1)'@[_opis],
                        'brak wystarczającej liczby zaplanowanych godzin w kalendarzu pracownika (%1)'@[(*(60*_plan))$3]
                     ];
                  _prac+=1;
                  _kon+=1;
                  _par.partN+=1;
                  _lp_add:=_KOMM.add(_komm,'xwin16.png:53',,,"0");
                  _tabKOMM.partN:=_komm;
                  _KOMM.chngroot(_lp_add,_section)
               ?};

:: Sprawdzenie czy nie ma wprowadzonego wniosku o odbiór nadgodzin.
               _tab_odb:=exec('get_wodb','prc',P.ref(),null(),_data);
               _godz+=_godz1;
               {? _tab_odb.first()
               || {!
                  |? _godz+=(*_tab_odb.G/60);
                     _tab_odb.next()
                  !};
                  {? _godz>_plan
                  || _komm:='Odbiory za nadgodziny'@;
                     _prac+=1;
                     _kon+=1;
                     _par.odbiory+=1;
                     _lp_add:=_KOMM.add(' '+_komm,'xwin16.png:140',,,
                        "  _dt:="+$(#_data)+";
                           P.seek('"+$P.ref()+"',,1);
                           exec('wnioski_odbioru','prc_view',P.ref(),#_dt)
                        "
                     );
                     _tabKOMM.odbiory:=_komm;
                     _KOMM.chngroot(_lp_add,_section)
                  ?}
               ?};
               obj_del(_tab_odb);

:: Sprawdzenie czy nie ma wprowadzonego wniosku o udzielenie czasu wolnego.
               _czas:=exec('get_r_odn_czas','prc_graf',P.ref(),_data,,'G');
               {? _czas>0
               || _godz+=(_czas/60*0.001)/60;
                  {? _godz>_plan
               || _komm:='Wnioski o czas wolny'@;
                  _prac+=1;
                  _kon+=1;
                  _par.wolne+=1;
                  _lp_add:=_KOMM.add(' ' +_komm,'xwin16.png:190',,,
                     "  _dt:="+$(#_data)+";
                        P.seek('"+$P.ref()+"',,1);
                        exec('wnioski_odprac','prc_view',P.ref(),#_dt,1)
                     "
                  );
                  _tabKOMM.wolne:=_komm;
                  _KOMM.chngroot(_lp_add,_section)
                  ?}
               ?};

:: Sprawdzenie czy nie ma odpracowania.
               _czas_odp:=exec('get_r_odp_czas','prc',P.ref(),_data,,'GO');
               {? _czas_odp>0
               || _godz-=(_czas_odp/60*0.001)/60;
                  {? _godz>_plan
                  || _komm:='Planowane odpracownanie wyjścia prywatnego'@;
                     _prac+=1;
                     _kon+=1;
                     _par.odprac+=1;
                     _lp_add:=_KOMM.add(' '+_komm,'xwin16.png:134',,,
                        "  _dt:="+$(#_data)+";
                           P.seek('"+$P.ref()+"',,1);
                           exec('wnioski_odprac','prc_view',P.ref(),#_dt,0)
                        "
                     );
                     _tabKOMM.odprac:=_komm;
                     _KOMM.chngroot(_lp_add,_section)
                  ?}
               ?};

:: Sprawdzenie wykonanie w rejestrach we/wy.
               _wewy:=exec('get_wewy','prc_wewy',_data,P.ref());
               {? _wewy.first()
               || _przepr:={? _wewy.DWY=_wewy.DWE || _wewy.GWY-_wewy.GWE || (time(24,0,0)-_wewy.GWE)+_wewy.GWY ?};
                  {? (_godz=0 & _macprac=0) | (_przepr+_godz*60>_plan*60+time(0,0,0))
                  || _komm:='Zatwierdzone wejścia/wyjścia'@;
                     _prac+=1;
                     _kon+=1;
                     _par.wewy+=1;
                     _lp_add:=_KOMM.add(' '+_komm,'xwin16.png:120',,,
                        "  _dt:="+$(#_data)+";
                           P.seek('"+$P.ref()+"',,1);
                           exec('wejscia_wyjscia','prc_view',P.ref(),#_dt,'R_REJ_WX')
                        "
                     );
                     _tabKOMM.wewy:=_komm;
                     _KOMM.chngroot(_lp_add,_section)
                  ?}
               ?};
               obj_del(_wewy);

:: Sprawdzenie wykonania w buforze grafików.
               KAL_BUFF.cntx_psh();
               KAL_BUFF.index('PRZNODT');
               KAL_BUFF.prefix(P.ref(),'W','T',_data);

               {? KAL_BUFF.first()
               || _przepr:=
                     {? KAL_BUFF.DATA=KAL_BUFF.DATAW
                     || KAL_BUFF.KONIEC-KAL_BUFF.POCZATEK
                     || (time(24,0,0)-KAL_BUFF.POCZATEK)+KAL_BUFF.KONIEC
                     ?};
                  {? (_godz=0 & _macprac=0) | (_przepr+_godz*60>_plan*60+time(0,0,0))
                  || _komm:=' Niezatwierdzone wejścia/wyjścia'@;
                     _prac+=1;
                     _kon+=1;
                     _par.kal_buff+=1;
                     _lp_add:=_KOMM.add(
                        _komm,'xwin16.png:141',,,
                        "  _dt:="+$(#_data)+";
                           P.seek('"+$P.ref()+"',,1);
                           exec('wer_zatw','prc_mscrozlicz',"+$(_data~1)+","+$(_data~2)+",0,P.ref(),#_dt)
                        "
                     );
                     _tabKOMM.kal_buff:=_komm;
                     _KOMM.chngroot(_lp_add,_section)
                  ?}
               ?};
               KAL_BUFF.cntx_pop();
:: Zamknięcie sekcji.
               _KOMM.sect_end();
:: Usuwamy sekcje jeśli jest pusta
               {? _kon=0 || _KOMM.del(_section) ?}
            ?};
            PROGRESS.next()
         !};
:: Zliczenie konfliktów.
         {! _ind:=1..obj_len(_par) |! _res+=_par[_ind] !};
:: Usunięcie niepotrzebnych sekcji.
         {? _prac=0 || _KOMM.del(_lp) ?};
         obj_del(_par)
      ?};
      _PTMP.next()
   !};
   PROGRESS.close()
?};
P.cntx_pop();
N.cntx_pop();

:: Jeżeli są konflikty to je wyświetl (dla _show=2 zawsze wyświetla okno).
{? _show>0
|| _KOMM.select(,,,_show=2,'Szczegóły'@,{? _p_ref=null()|| 0 || 1 ?})
?};
:: Zwrócenie liczby konfliktów lub tablicy.
{? _retTable
|| _tabKOMM
|| _res
?}


\dodaj_wigilie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: pk [12.51]
:: OPIS: Dodaje nieobecnosc na część dnia dla dopełnienia wymiary przy planowaniu pracy w wigilię po godz. 14.
::   WE: _a - [date] data nieobecności
::       _b - [time] ilość godzin
::   WY:
::  OLD: \dodaj_wigilie/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
N.index('NIEOBECN');
N.prefix('N',P.ref());

N.blank();
N.P:=P.ref();
N.NB:=__RUB.ref(7034,'N');
N.OD:=_a;
N.DO:=_a;
exec('n_czas','nieobecnosc');
N.NG:=(*_b/60)$2;
N.PARTDAY:='T';
_kod:=exec('kod_zus','nieobecnosc','S','350');
N.KDSW:=_kod;

_wyn:=N.add();
{? exec('n_rozliczalna','nieobecnosc') || exec('nw_aktualizuj','nieobecnosc') ?};
_wyn


\usun_wigilie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: pk [12.51]
:: OPIS: Procedura usuwa zapis o nieobecności związanej z dopełnieniem pracy w wigilię.
::   WE: _a - data
::   WY: 1 - usunięto nieobecność
::       2 - nie było nieobecności
::  OLD: \usun_wigilie/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_wigilia:=_a;
N.index('NIPRACNB');
N.prefix('N',P.ref(),7034,_wigilia);

{? ~N.first() || return(2) ?};
_wyn:=0;
{!
|? {? +N.LT & (N.LT<>VAR.NAZWALIS | O.Z='T')
   || return(0)
   || {? exec('tz_usun','nieobecnosc')
      || _nsk:='s_ch'+$(N.OD~1);
         {? SK_CHO.name<>_nsk || SK_CHO.use(_nsk) ?};
         SK_CHO.index('SK_CHO');
         SK_CHO.prefix(N.ref());
         {? SK_CHO.first()
         || {! |? SK_CHO.del() !}
         ?};
         NieoRok:=N.OD~1;
         NieoKod:=N.NB;

         NW.cntx_psh();
         NW.index('CHP');
         NW.prefix(N.ref());
         {? NW.first() & NW.del()
         || _NPierw:=NW.CHW;
            {!
            |? NW.prefix(N.ref());
               {? NW.first()
               || NW.CHP:=_NPierw;
                  NW.clear();
                  NW.put()
               ?}
            !}
         ?};
         NW.index('CHW');
         NW.prefix(N.ref());
         {? NW.first() || {! |? NW.del() !} ?};
         NW.cntx_pop();
::    usuniecie korygujacych zapisow w LSW
         LSW.index('PN');
         LSW.prefix(P.ref(),N.ref());
         {? LSW.first()|| {! |? LSW.del() !} ?};
         {? ~N.count()
         || _ok:=N.del();
            _wyn:=1
         || return(0)
         ?}
      || return(0)
      ?}
   ?};
   N.next()
!};
_wyn


\nezla_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.51]
:: OPIS: Funkcja zmieniająca znacznik akceptacji zaimportowanej nieobecności.
::       Wywołanie - trigger del_po dla tabeli N i tabeli OS_N.
::   WE: _a [TAB]- tabela, na rzecz której jest wywoływana funkcja
::   WY:
::  OLD: \N_usun/kali_ei.fml
::----------------------------------------------------------------------------------------------------------------------
_TAB:={? var_pres('_a')=type_of(N) || _a || return(0) ?};
{? _TAB=N | _TAB=OS_N
|| NEZLA.cntx_psh();
   NEZLA.prefix();
   {? NEZLA.seek(bfld('NEZLA'))
   || _TAB.cntx_psh();
      {? NEZLA.F_ZATR='P'
      || _TAB.index('NIENEZLA');
         _TAB.prefix(NEZLA.ref())
      || _TAB.index('NEZLA');
         _TAB.prefix(exec('ref_firma','ustawienia'),NEZLA.ref())
      ?};
      {? ~_TAB.size()
      || NEZLA.STATUS:='N';
         NEZLA.DESCR:='Usunięto zaakceptowaną nieobecność.';
         NEZLA.put()
      ?};
      _TAB.cntx_pop()
   ?};
   NEZLA.cntx_pop()
?}


\n_rozpisz_oczekiwanie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.22]
:: OPIS: Podział nieobecności w przypadku przekroczenia 30 dni od daty zatrudnienia dla nieobecności
::       typu "choroba oczekiwanie".
::   WE: [_a] [INTEGER] - Tryb wsadowy:
::             0 - Nie, działanie wymaga potwierdzenia.
::             1 - Tak, działanie nie wymaga ponownego potwierdzenia.
::        _b  [DATE]    - Data początku nieobecności.
::        _c  [DATE]    - Data końca nieobecności.
::   WY:
::  OLD: \oczekiwanie/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;
_nod:=_b;
_ndo:=_c;
_chk:=0;

:: Ustalenie czy nieobecność "chroba oczekiwanie" nie jest wprowadzona jako kontynuacja innej nieobecności.
N.cntx_psh();
_kod_org:=N.NB().RN;
{? N.prev() & N.DO+1=_nod
|| {? (__RUB.sys_attr(N.NB,126,N.OD) | __RUB.sys_attr(N.NB,1225,N.OD))
      &
      __RUB.sys_attr(_kod_org,1241,N.OD)
   || _chk:=N.NB().RN
   |? (__RUB.sys_attr(N.NB,126,N.OD) & __RUB.sys_attr(_kod_org,126,N.OD))
      |
      (__RUB.sys_attr(N.NB,1225,N.OD) & __RUB.sys_attr(_kod_org,1225,N.OD))
   || _chk:=-1
   ?}
?};
N.cntx_pop();

{? _chk>0
|| {? _batch | RAPLS.RAP=2
      |
      FUN.ask('%1\n%2'
         [  'Nieobecność jest kontynuacją choroby %1 - %2.'@[$N.NB().RN,R.RT],
            'Czy zmienić kod nieobecności?'@
         ]
      )
   || _do:=N.OD-1;
      {!
      |? {? (_do+1)=N.OD
         || N.NB:=__RUB.ref(_chk,'N');
            N.PROC:=exec('procent','nieobecnosc',N.NB);
            _kod:=
               {? __RUB.sys_attr(N.NB,12211,N.OD)
               || __RUB.sys_val(14313,N.OD,'')
               |? __RUB.sys_attr(N.NB,125,N.OD)
               || __RUB.sys_val(14314,N.OD,'')
               || '350'
               ?};
            N.KDSW:=exec('kod_zus','nieobecnosc','S',_kod);
            _do:=N.DO;
            N.put() & N.next()
         ?}
      !}

   ?}
|? ~_chk
|| _start:=exec('czyOkrWycz','nieobecnosc',N.P,N.P().OSOBA,N.OD,0);
   _stop:=exec('czyOkrWycz','nieobecnosc',N.P,N.P().OSOBA,N.DO,0);
   _staz:=exec('czyOkrWycz','nieobecnosc',N.P,N.P().OSOBA,N.DO,1);
   _dt:=N.P().DZA+29;
   {? _start>0
   || {? (N.DO-(P.DZA-_start))<=30
      || _stop:=-1
      || _stop:=0;
         _dt-=_start
      ?}
   || {? _staz>0 || _dt-=_staz ?}
   ?};

   R.cntx_psh();
   {? __RUB.sys_attr(N.NB,126,N.OD) & ~__RUB.sys_attr(N.NB,125,N.OD) & _start
   || {? _stop=-1
      || _nb:=__RUB.ref(__RUB.sys_kod(1241),'N');
         _msg:='%1\n%2\n%3'
            [  'Na podstawie danych wprowadzonych do systemu\n'+
               'pracownikowi nie przysługuje prawo do wynagrodzenia za czas niezdolności do pracy z powodu choroby.'@,
               'Sugerowana nieobecność to: %1.'@[exec('record','#to_string',_nb,1)],
               'Czy zamienić nieobecność?'@
            ];
:: Cała wprowadzona nieobecność znajduje się w 30 dniowym okresie wyczekiwania, dlatego cała powinna zostać zamieniona
:: na nieobecność "choroba oczekiwanie".
         {? _batch | RAPLS.RAP=2 | FUN.ask(_msg)
         || N.NB:=_nb;
            N.KDSW:=exec('kod_zus','nieobecnosc','S','151');
            N.PROC:=exec('procent','nieobecnosc',N.NB);
            exec('n_czas','nieobecnosc');
            N.put()
         ?}
      || _ndo:=N.DO;
:: Pierwsza część wprowadzonej nieobecność znajduje się w 30 dniowym okresie wyczekiwania dlatego powinna być zamieniona
:: na nieobecność "choroba oczekiwanie".
         _oldn:=N.NB;
         _nb:=__RUB.ref(__RUB.sys_kod(1241),'N');
         _msg:='%1\n%2\n%3'
            [  'Na podstawie danych wprowadzonych do systemu\n'+
               'pracownikowi nie przysługuje prawo do wynagrodzenia za część niezdolności do pracy z powodu choroby.'@,
               'Sugerowana nieobecność do %1 to: %2.'@[_dt$1,exec('record','#to_string',_nb,1)],
               'Czy rozpisać nieobecność?'@
            ];
         _kdsw:=N.KDSW;
         {? _batch | RAPLS.RAP=2 | FUN.ask(_msg)
         || N.NB:=_nb;
            N.DO:=_dt;
            N.KDSW:=exec('kod_zus','nieobecnosc','S','151');
            N.PROC:=exec('procent','nieobecnosc',N.NB);
            exec('n_czas','nieobecnosc');
            N.put();
            N.OD:=N.DO+1;
            N.DO:=_ndo;
            N.DK:=0;
            N.NB:=_oldn;
            N.KDSW:=_kdsw;
            N.PROC:=exec('procent','nieobecnosc',N.NB);
            exec('n_czas','nieobecnosc');
            N.add()
         ?}
      ?}
   |? __RUB.sys_attr(N.NB,1241,N.OD) & _start
   || {? ~_stop
      ||
:: Pierwsza część nieobecność "Choroba oczekiwanie" znajduje się w 30 dniowym okresie wyczekiwania,
:: zamiana drugiej części na wynagrodzenie chorobowe.
         _nb:=__RUB.ref(__RUB.sys_kod(12111),'N');
         _msg:='%1\n%2\n%3'
            [  'Na podstawie danych wprowadzonych do systemu\n'+
               'pracownikowi przysługuje prawo do wynagrodzenia za część niezdolności do pracy z powodu choroby.'@,
               'Sugerowana nieobecność od %1 to: %2.'@[_dt$1,exec('record','#to_string',_nb,1)],
               'Czy rozpisać nieobecność?'@
            ];
         {? _batch | RAPLS.RAP=2 | FUN.ask(_msg)
         || _ndo:=N.DO;
            N.DO:=_dt;
            exec('n_czas','nieobecnosc');
            N.put();
            N.OD:=N.DO+1;
            N.DO:=_ndo;
            N.DK:=0;
            N.NB:=_nb;
            N.KDSW:=exec('kod_zus','nieobecnosc','S','331');
            N.PROC:=exec('procent','nieobecnosc',N.NB);
            exec('n_czas','nieobecnosc');
            N.add()
         ?}
      ?}
   |? __RUB.sys_attr(N.NB,1241,N.OD) & ~_start
   ||
:: Cała nieobecność "Choroba oczekiwanie" znajduje się poza 30 dniowym okresem wyczekiwania, zamiana całości na
:: wynagrodzenie chorobowe
      _nb:=__RUB.ref(__RUB.sys_kod(12111),'N');
      _msg:='%1\n%2\n%3'
         [  'Na podstawie danych wprowadzonych do systemu\n'+
            'pracownikowi przysługuje prawo do wynagrodzenia za czas niezdolności do pracy z powodu choroby.'@,
            'Sugerowana nieobecność to: %1.'@[exec('record','#to_string',_nb,1)],
            'Czy zamienić kod nieobecności?'@
         ];
      {? _batch | RAPLS.RAP=2 | FUN.ask(_msg)
      || N.NB:=_nb;
         N.KDSW:=exec('kod_zus','nieobecnosc','S','331');
         N.PROC:=exec('procent','nieobecnosc',N.NB);
         exec('n_czas','nieobecnosc');
         N.put()
      ?}
   ?};
   R.cntx_pop()
?};
exec('n_dnop_akt','nieobecnosc',_batch,_nod,_ndo);
~~


\n_wartosc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [18.42]
:: OPIS: Zlicza wartość dla podanych nieobecności dla podanego miesiąca nieobecnosci
::   WE: _a - [INTEGER] rok
::       _b - [INTEGER] miesiac
::       _c - [INTEGER] kod atrybutu dla składników płacowych opisujących nieobecność
::       [_d] - [DICT] - tymczasowa tabela z danymi wartości miesiąca rozliczającego.
::   WY: [REAL] - wartość świadczeń
::  OLD: \wartosc/urlop.fml
::----------------------------------------------------------------------------------------------------------------------
_rok:=_a;
_mc:=_b;
_rub:=_c;
{? var_pres('_d')>100
|| _tab_wyn:=_d;
   _ubezp:=1;
   _tab:=sql('select * from :_a where 1=2',_tab_wyn)
|| _ubezp:=0
?};
R.cntx_psh();
N.cntx_psh();
O.cntx_psh();
O.index('LISTYPZN');
N.index('NIEORM');
R.prefix();
_wyn:=0;
_tab_rub:=__RUB.sys_rub(_rub,date(_rok,_mc,0));
{? _tab_rub.first
|| {!
   |? {? R.seek(__RUB.ref(_tab_rub.RN))
      || N.prefix('N',P.ref,_rok,_mc,R.ref());
         {? N.first
         || {!
            |? _wyn+=_wartosc:=N.WART;
               {? _ubezp
               || O.prefix(exec('ref_firma','ustawienia'),-N.LT);
                  {? O.first()
                  || _tab.blank(1);
                     _tab.ROK:=O.R;
                     _tab.MC:=O.M;
                     _tab.WART:=_wartosc;
                     _tab.ATTR:=_rub;
                     _tab.add(1)
                  ?}
               ?};
               N.next
            !}
         ?}
      ?};
      _tab_rub.next
   !}
?};
{? _ubezp & _tab.first
|| {!
   |? _tab_wyn.prefix(_tab.ROK,_tab.MC,_tab.ATTR);
      {? _tab_wyn.first()
      || _tab_wyn.WART+=_tab.WART;
         _tab_wyn.put(1)
      || _tab_wyn.blank(1);
         _tab_wyn.ROK:=_tab.ROK;
         _tab_wyn.MC:=_tab.MC;
         _tab_wyn.WART:=_tab.WART;
         _tab_wyn.ATTR:=_tab.ATTR;
         _tab_wyn.add(1)
      ?};
      _tab.next
   !}
?};
R.cntx_pop();
N.cntx_pop();
O.cntx_pop();
obj_del(_tab_rub);
_wyn


\blokada_oblicz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [19.02]
:: OPIS: Sprawdzenie czy możliwe jest automatyczne naliczenie nieobecności.
::       Blokowane jest obliczanie w sytuacji, w której operator poprawiał dane w rozliczeniu nieobecności.
::   WE:
::   WY: 1 - Obliczanie wzbronione
::       0 - Brak blokady
::  OLD: \blokada_oblicz/rozl_tz.fml
::----------------------------------------------------------------------------------------------------------------------
TZ.cntx_psh();
TZ.use('tabz'+form(N.OD~1,-4,0,'9.'));
TZ.index('PNRM');
TZ.prefix(N.ref());
_blokada:=0;
{? TZ.first
|| {!
   |? {? TZ.STATUS<>'A'
      || _blokada:=1; 0
      || TZ.next()
      ?}
   !}
?};
TZ.cntx_pop();
_blokada


\chk_NR_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [19.42]
:: OPIS: Formuła zwraca schemat tabeli wykorzystywanej w fukcjach sprawdzających poprawność wypełnienia pola NR
::       w nieobecnościach, wnioskach urlopowych i pozycjach planu urlopowego
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(1,
   'OD','DATE','Data od'@,
   'DO','DATE','Data do'@,
   'P','STRING[16]','Wskazanie na pracownika'@,
   'REF','STRING[16]','Wskazanie na rekord źródłowy'@,
   'OK','STRING[1]','Czy rekord naprawiony?'@,
   'RN','INTEGER','Kod'@,
   'RT','STRING['+$MS.fld_len('R','RT')+']','Nazwa'@,
   'FIRMA','STRING['+$MS.fld_len('FIRMA','SYMBOL')+']','Firma (symbol)'@,
   'NK','INTEGER','Dni robocze wg kalendarza'@,
   'NR','INTEGER','Dni robocze nieobecności'@,
   'NGK','REAL','Godziny robocze wg kalendarza'@,
   'NGR','REAL','Godziny robocze nieobecności'@,
   'NRG_AUTO','STRING[1]','Czas wyliczony'@,
   'PARTDAY','STRING[1]','Na część dnia'@,
   'LT','STRING['+$MS.fld_len('N','LT')+']','Lista płac'@,
   'T','STRING['+$MS.fld_len('P','T')+']','Numer teczki'@,
   'NAZWISKO','STRING['+$MS.fld_len('OSOBA','NAZWISKO')+']','Nazwisko'@,
   'PIERWSZE','STRING['+$MS.fld_len('OSOBA','PIERWSZE')+']','Imię'@,
   'SYMBOL','STRING['+$MS.fld_len('UD_SKL','SYMBOL')+']','Jednostka organizacyjna'@,
   'ST','STRING['+$MS.fld_len('STN','ST')+']','Stanowisko'@
)


\chk_NR_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [19.42]
:: OPIS: Wyświetla okno tabeli wykorzystywanej w fukcjach sprawdzających poprawność wypełnienia pola NR
::       w nieobecnościach, wnioskach urlopowych i pozycjach planu urlopowego
::   WE: _a [DICT]      - tabela do wyświetlenia
::       _b [STRING]    - tabela, na rzecz której będzie wyświetlane okno
::       _c [FORMULA]   - formuła na rekord przed
::       _d [FORMULA]   - formuła na "Napraw" przed
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   _tab:={? var_pres('_a')=type_of(N)  || _a || return() ?};
 _owner:={? var_pres('_b')=type_of(N)  || _b || return() ?};
_fml_rb:={? var_pres('_c')=type_of("") || _c || return() ?};
_fml_nb:={? var_pres('_d')=type_of("") || _d || return() ?};

_title:={? _owner=N
        || 'Nieobecności'
        |? _owner=NWU
        || 'Wnioski urlopowe'
        |? _owner=URL_POZ
        || 'Pozycje planów urlopowych'
        || ''
        ?};

_wnd:=_tab.mk_sel(_title,'P',0,'#chkn_nr202001',,,,,'U','U');
_tab.win_fld(_wnd,,'OK',,,-3,,,'Naprawiony?',,'Czy rekord naprawiony?',2,,"'T'","'N'");
{? _owner=N | _owner=NWU
|| _tab.win_fld(_wnd,,'RN',,,-3,,,,,MS.comment('R','RN'));
   _tab.win_fld(_wnd,,'RT',,,-15,,,,,MS.comment('R','RT'))
?};
_tab.win_fld(_wnd,,'OD',,,-10,,,,,'Data rozpoczęcia'@);
_tab.win_fld(_wnd,,'DO',,,-10,,,,,'Data zakończenia'@);
{? _owner=N
|| _tab.win_fld(_wnd,,'NRG_AUTO',,,-12,,,,,MS.comment('N','NRG_AUTO'),2,,"'T'","'N'")
?};
{? _owner=N | _owner=NWU
|| _tab.win_fld(_wnd,,'PARTDAY',,,-3,,,,,MS.comment(2-!_owner,'PARTDAY'),2,,"'T'","'N'")
?};
_tab.win_fld(_wnd,,'NR',,,-18,,,,,MS.comment(2-!_owner,'NR'));
_tab.win_fld(_wnd,,'NK',,,-18,,,,,'Liczba dni roboczych wg kalendarza pracownika');
_tab.win_fld(_wnd,,'NGR',,,-8,2,,,,MS.comment(2-!_owner,'NG'));
_tab.win_fld(_wnd,,'NGK',,,-8,2,,,,'Liczba godzin roboczych wg kalendarza pracownika');
{? _owner=N | _owner=NWU
|| _tab.win_fld(_wnd,,'LT',,,-10,,,,,MS.comment('N','LT'))
?};
_tab.win_fld(_wnd,,'T',,,-10,,,,,MS.comment('P','T'));
_tab.win_fld(_wnd,,'NAZWISKO',,,-20,,,,,MS.comment('OSOBA','NAZWISKO'));
_tab.win_fld(_wnd,,'PIERWSZE',,,-15,,,,,MS.comment('OSOBA','PIERWSZE'));
_tab.win_fld(_wnd,,'SYMBOL',,,-10,,,,,MS.comment('UD_SKL','SYMBOL'));
_tab.win_fld(_wnd,,'ST',,,-20,,,,,MS.comment('STN','ST'));
_tab.win_fld(_wnd,,'FIRMA',,,,,,'Firma');

_tab.fld_fml('NR','BEFORE_DISPLAY',"
   {? cur_tab().NR<>cur_tab().NK || '255:0:0' || '31:188:91' ?}
");
_tab.fld_fml('NGR','BEFORE_DISPLAY',"
   {? cur_tab().NGR<>cur_tab().NGK || '255:0:0' || '31:188:91' ?}
");
_tab.win_act(_wnd,,'Rekord',,,,_fml_rb);
_tab.win_act(_wnd,,'Formuła','Napraw',,,_fml_nb);
_tab.win_sel(_wnd);
_tab.select()


\chkN_NR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [19.42]
:: OPIS: Sprawdza dla wszystkich nieobecności czy wartość pola NR zgadza się z dniami roboczymi z kalendarza pracownika
::   WE: _a [NUMBER] - czy wyświetlać okno ze znalezionymi nieobecnościami, dla których mamy różnicę 0-domyślnie / 1
::       _b [NUMBER] - czy tylko dla nieobecności z pustą listą płac?  0-domyślnie / 1
::       _c [NUMBER] - pomijaj nieobecności na część dnia?  0 / 1-domyślnie
::   WY: TAB
::----------------------------------------------------------------------------------------------------------------------
_showTab:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_emptyLT:={? var_pres('_b')=type_of(0) || _b || 0 ?};
 _noPart:={? var_pres('_c')=type_of(0) || _c || 1 ?};

_tab:=exec('chk_NR_tab','nieobecnosc');
VAR_DEL.delete('__N');
__N:=_tab;

:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || VAR_DEL.delete('__N'); return(_tab) ?};

:: zalozenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

exec('RAPLS','object');
exec('__KAL','object');
P.cntx_psh();
FIRMA.cntx_psh();
UD_SKL.cntx_psh();
STN.cntx_psh();
N.cntx_psh();
N.prefix();
N.for_each("__KAL.set_cal(N.P().KAL,N.OD~1);
            _nr:=__KAL.w_days(N.OD,N.DO);
            _ng:=exec('nominal','godziny',N.OD,N.DO);
            {? (N.NR<>_nr | N.NG<>_ng) & P.FIRMA=REF.FIRMA
            || N.P().OSOBA();
               __N.blank(1);
               __N.OK:='N';
               __N.REF:=$N.ref();
               __N.P:=$N.P;
               __N.T:=P.T;
               __N.OD:=N.OD;
               __N.DO:=N.DO;
               __N.FIRMA:=N.FIRMA().SYMBOL;
               __N.LT:=N.LT;
               __N.RN:=N.NB().RN;
               __N.RT:=N.NB().RT;
               __N.NRG_AUTO:=N.NRG_AUTO;
               __N.PARTDAY:=N.PARTDAY;
               __N.NR:=N.NR;
               __N.NK:=_nr;
               __N.NGR:=N.NG;
               __N.NGK:=_ng;
               __N.NAZWISKO:=OSOBA.NAZWISKO;
               __N.PIERWSZE:=OSOBA.PIERWSZE;
               __N.SYMBOL:=P.WYDZIAL().SYMBOL;
               __N.ST:=P.ST().ST;
               __N.add()
            ?}
            ",
1);
STN.cntx_pop();
UD_SKL.cntx_pop();
FIRMA.cntx_pop();

{? _mydo || end() ?};

{? _emptyLT | _noPart
:: kasujemy rekordy z wypełnioną listą płac lub na część dnia
|| params_set('emptyLT',_emptyLT,'noPart',_noPart);
   __N.for_each("
      _par:=params_get();
      {? (_par.emptyLT & __N.LT<>'') | (_par.noPart & __N.PARTDAY='T') || __N.del() ?}
   ")
?};

VAR_DEL.delete('__N');

{? _showTab
|| _fml_rb:="
     _ag:={? cur_tab().OK='T' | cur_tab().NRG_AUTO<>'T' | cur_tab().LT<>'' || 'N' || '' ?};
     cur_tab().actions_grayed(cur_win(),_ag)
   ";
   _fml_nb:="
      {? P.seek(cur_tab().P) & N.seek(cur_tab().REF)
      || _tabN:=exec('getNieobInDays','nieobecnosc',P.ref(),cur_tab().OD,cur_tab().DO);
         exec('nieob_aktual','nieobecnosc',_tabN,1);
         N.get();
         __KAL.set_cal(P.KAL,N.OD~1);
         _nr:=__KAL.w_days(N.OD,N.DO);
         {? N.NR=_nr
         || cur_tab().OK:='T';
            cur_tab().NR:=_nr;
            cur_tab().put();
            win_disp()
         || FUN.info('Naprawienie błędnego zapisu nie było możliwe.')
         ?}
      ?}
   ";
   exec('chk_NR_select','nieobecnosc',_tab,N,_fml_rb,_fml_nb)
?};
N.cntx_pop();
P.cntx_pop();
_tab


\chkNWU_NR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [19.42]
:: OPIS: Sprawdza dla wszystkich nieobecności czy wartość pola NR zgadza się z dniami roboczymi z kalendarza pracownika
::   WE: _a [NUMBER] - czy wyświetlać okno ze znalezionymi nieobecnościami, dla których mamy różnicę 0-domyślnie / 1
::       _b [NUMBER] - czy tylko dla wniosków z powiązaną nieobecnością z pustą listą płac?  0-domyślnie / 1
::       _c [NUMBER] - pomijaj wnioski na część dnia?  0 / 1-domyślnie
::   WY: TAB
::----------------------------------------------------------------------------------------------------------------------
_showTab:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_emptyLT:={? var_pres('_b')=type_of(0) || _b || 0 ?};
 _noPart:={? var_pres('_c')=type_of(0) || _c || 1 ?};

_tab:=exec('chk_NR_tab','nieobecnosc');
VAR_DEL.delete('__N');
__N:=_tab;

:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || VAR_DEL.delete('__N'); return(_tab) ?};

:: zalozenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

exec('RAPLS','object');
exec('__KAL','object');
P.cntx_psh();
FIRMA.cntx_psh();
UD_SKL.cntx_psh();
STN.cntx_psh();
NWU.cntx_psh();
NWU.prefix();
NWU.for_each("__KAL.set_cal(NWU.P().KAL,NWU.OD~1);
            _nr:=__KAL.w_days(NWU.OD,NWU.DO);
            _ng:=exec('nominal','godziny',NWU.OD,NWU.DO);
            {? (NWU.NR<>_nr | NWU.NG<>_ng) & P.FIRMA=REF.FIRMA
            || NWU.P().OSOBA();
               __N.blank(1);
               __N.OK:='N';
               __N.REF:=$NWU.ref();
               __N.P:=$NWU.P;
               __N.T:=P.T;
               __N.OD:=NWU.OD;
               __N.DO:=NWU.DO;
               __N.FIRMA:=P.FIRMA().SYMBOL;
               {? NWU.N<>null()
               || __N.LT:=NWU.N().LT
               ?};
               __N.RN:=NWU.R().RN;
               __N.RT:=NWU.R().RT;
               __N.PARTDAY:=N.PARTDAY;
               __N.NR:=NWU.NR;
               __N.NK:=_nr;
               __N.NGR:=NWU.NG;
               __N.NGK:=_ng;
               __N.NAZWISKO:=OSOBA.NAZWISKO;
               __N.PIERWSZE:=OSOBA.PIERWSZE;
               __N.SYMBOL:=P.WYDZIAL().SYMBOL;
               __N.ST:=P.ST().ST;
               __N.add()
            ?}
            ",
1);
STN.cntx_pop();
UD_SKL.cntx_pop();
FIRMA.cntx_pop();

{? _mydo || end() ?};

{? _emptyLT | _noPart
:: kasujemy rekordy z wypełnioną listą płac lub na część dnia
|| params_set('emptyLT',_emptyLT,'noPart',_noPart);
   __N.for_each("
      _par:=params_get();
      {? (_par.emptyLT & __N.LT<>'') | (_par.noPart & __N.PARTDAY='T') || __N.del() ?}
   ")
?};

VAR_DEL.delete('__N');

{? _showTab
|| _fml_rb:="
     _ag:={? cur_tab().OK='T' || 'N' || '' ?};
     cur_tab().actions_grayed(cur_win(),_ag)
   ";
   _fml_nb:="
      {? P.seek(cur_tab().P) & NWU.seek(cur_tab().REF)
      || _tabNWU:=exec('getNWUInDays','nieobecnosc',P.ref(),NWU.OD,NWU.DO);
         exec('nwu_aktual','nieobecnosc',_tabNWU,1);
         NWU.get();
         __KAL.set_cal(P.KAL,NWU.OD~1);
         _nr:=__KAL.w_days(NWU.OD,NWU.DO);
         {? NWU.NR=_nr
         || cur_tab().OK:='T';
            cur_tab().NR:=_nr;
            cur_tab().put();
            win_disp()
         || FUN.info('Naprawienie błędnego zapisu nie było możliwe.')
         ?}
      ?}
   ";
   exec('chk_NR_select','nieobecnosc',_tab,NWU,_fml_rb,_fml_nb)
?};
NWU.cntx_pop();
P.cntx_pop();
_tab


\chkPLAN_NR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [19.42]
:: OPIS: Sprawdza dla wszystkich pozycji planu urlopowego czy wartość
::       pola NR zgadza się z dniami roboczymi z kalendarza pracownika
::   WE: _a [NUMBER] - czy wyświetlać okno ze znalezionymi nieobecnościami, dla których mamy różnicę 0-domyślnie / 1
::       _b [NUMBER] - czy tylko dla wniosków z powiązaną nieobecnością z pustą listą płac?  0-domyślnie / 1
::   WY: TAB
::----------------------------------------------------------------------------------------------------------------------
_showTab:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_emptyLT:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_tab:=exec('chk_NR_tab','nieobecnosc');
VAR_DEL.delete('__N');
__N:=_tab;

:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || VAR_DEL.delete('__N'); return(_tab) ?};

:: zalozenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

exec('RAPLS','object');
exec('__KAL','object');
P.cntx_psh();
FIRMA.cntx_psh();
UD_SKL.cntx_psh();
STN.cntx_psh();
URL_PLAN.cntx_psh();
URL_POZ.cntx_psh();
URL_POZ.prefix();
URL_POZ.for_each("__KAL.set_cal(URL_POZ.URL_PLAN().P().KAL,URL_POZ.OD~1);
            _nr:=__KAL.w_days(URL_POZ.OD,URL_POZ.DO);
            _ng:=exec('nominal','godziny',URL_POZ.OD,URL_POZ.DO);
            {? (URL_POZ.NR<>_nr | URL_POZ.NG<>_ng) & P.FIRMA=REF.FIRMA
            || URL_PLAN.P().OSOBA();
               __N.blank(1);
               __N.OK:='N';
               __N.REF:=$URL_POZ.ref();
               __N.P:=$P.ref();
               __N.T:=P.T;
               __N.OD:=URL_POZ.OD;
               __N.DO:=URL_POZ.DO;
               __N.FIRMA:=P.FIRMA().SYMBOL;
               __N.NR:=URL_POZ.NR;
               __N.NK:=_nr;
               __N.NGR:=URL_POZ.NG;
               __N.NGK:=_ng;
               __N.NAZWISKO:=OSOBA.NAZWISKO;
               __N.PIERWSZE:=OSOBA.PIERWSZE;
               __N.SYMBOL:=P.WYDZIAL().SYMBOL;
               __N.ST:=P.ST().ST;
               __N.add()
            ?}
            ",
1);
STN.cntx_pop();
UD_SKL.cntx_pop();
FIRMA.cntx_pop();

{? _mydo || end() ?};

{? _emptyLT
:: kasujemy rekordy z wypełnioną listą płac
|| __N.for_each("{? __N.LT<>'' || __N.del() ?}")
?};

VAR_DEL.delete('__N');

{? _showTab
|| _fml_rb:="
     _ag:={? cur_tab().OK='T' || 'N' || '' ?};
     cur_tab().actions_grayed(cur_win(),_ag)
   ";
   _fml_nb:="
      {? P.seek(cur_tab().P) & URL_POZ.seek(cur_tab().REF)
      || exec('urlPlan_aktual','grafik',P.ref(),URL_POZ.OD,URL_POZ.DO);
         URL_POZ.get();
         __KAL.set_cal(P.KAL,URL_POZ.OD~1);
         _nr:=__KAL.w_days(URL_POZ.OD,URL_POZ.DO);
         {? URL_POZ.NR=_nr
         || cur_tab().OK:='T';
            cur_tab().NR:=_nr;
            cur_tab().put();
            win_disp()
         || FUN.info('Naprawienie błędnego zapisu nie było możliwe.')
         ?}
      ?}
   ";
   exec('chk_NR_select','nieobecnosc',_tab,URL_POZ,_fml_rb,_fml_nb)
?};
URL_POZ.cntx_pop();
URL_PLAN.cntx_pop();
P.cntx_pop();
_tab


\potr_mc_lista
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.51]
:: OPIS: Zlicza wartość potrąceń dla podanych nieobecności dla bieżącej listy płac badanego miesiąca.
::   WE: _a - [INTEGER] kod atrybutu dla składników płacowych opisujących nieobecność
::       [_a] - [TABLICA] tablica określająca więcej niż jeden atrybut dla składników płacowych opisujących nieobecność
::       _b - rok
::       _c - mc
::   WY: alias tablicy 8 elementowej:
::                _TAB.POTR1 += N.POTR1
::                _TAB.POTR2 += N.POTR2
::                _TAB.POTR3 += N.POTR3
::                _TAB.POTR4 += N.POTR4
::                _TAB.POTR11 += N.POTR1 dla przestoju
::                _TAB.POTR12 += N.POTR2 dla przestoju
::                _TAB.POTR13 += N.POTR3 dla przestoju
::                _TAB.POTR14 += N.POTR4 dla przestoju
::  OLD: \potr_mc_lista/nieobecn.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _tab_rub:=__RUB.buf();
   _rub:=_a;
    _dodaj:="
      {? _b.first()
      || {!
         |? _a.RN:=_b.RN;
            _a.RT:=_b.RT;
            _a.R:=_b.R;
            _a.add();
            _b.next()
         !}
      ?}";
   {! _ind:=1..obj_len(_rub)
   |! _dodaj(_tab_rub,__RUB.sys_rub(_rub[_ind]))
   !}
|| _rub:=_a;
   _tab_rub:=__RUB.sys_rub(_rub)
?};
_lista:=('L'+($_b+2)+('00'+$_c+2));
_TAB:=obj_new('POTR1','POTR2','POTR3','POTR4','POTR11','POTR12','POTR13','POTR14');
{! _ind:=1..4
|! ($('_a.POTR'+$_ind+':=0'))(_TAB);
   ($('_a.POTR'+$(_ind+10)+':=0'))(_TAB)
!};
R.cntx_psh();
N.cntx_psh();
N.index('NIEOBECL');
R.prefix();
{? _tab_rub.first()
|| {!
   |? {? R.seek(__RUB.ref(_tab_rub.RN))
      || N.prefix('N',P.ref(),_lista);
         {? N.first()
         || {!
            |? {? N.NB().RN=_tab_rub.RN
               || _prz:=__RUB.sys_attr(N.NB,1314);
                  {! _ind:=1..4
                  |! ($('_a.POTR'+$_ind+'+=_b'))(_TAB,($('N.POTR'+$_ind))());
                     {? _prz
                     || ($('_a.POTR'+$(_ind+10)+'+=_b'))(_TAB,($('N.POTR'+$_ind))())
                     ?}
                  !}
               ?};
               N.next()
            !}
         ?}
      ?};
      _tab_rub.next()
   !}
?};
R.cntx_pop();
N.cntx_pop();
_TAB


\suma_dni_N
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [20.42]
:: OPIS: Wyliczenie dni kalendarzowych z tabeli nieobecnosci dla bieżącej listy (opcja) dla podanych dat i atrybutu
::   WE: _a - atrybut uwzgledniany
::       _b - data od
::       _c - data do
::       [_d] - znak listy
::       [_e] - opcjonalny atrybut wyklucza rubryki zawarte w atrybucie _a
::       [_f] G/R - domyślnie K: liczba dni kalendarzowych, G: liczba godzin roboczych, R: liczba dni roboczych
::       [_g] ewentualna lista atrybutow do wykluczenia: np: '1112,1113'
::       [_h] jeśli 1 - nie pobieraj dni nieobecnoiści PARTDAY
::   WY:   suma
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_pocz:=_b;
_koniec:=_c;
_rub:=__RUB.sys_rub(_a,_koniec);
_typ:={? var_pres('_f')=type_of('') || _f || 'K' ?};
_partday:=var_pres('_h')=type_of(0) & _h;

: wykluczenie rubryk z atrybutu _e
{? var_pres('_e')=type_of(0)
|| _bez_rub:=__RUB.sys_rub(_e,_koniec);
   {? _bez_rub.first
   || {!
      |? {? _rub.find_key(_bez_rub.RN) || _rub.del() ?};
         _bez_rub.next
      !}
   ?}
?};
{? var_pres('_g')=type_of('')
|| _lista:=_g+',';
   {!
   |? _ile:=_lista*',';
      _attr:=_ile-1+_lista;
      {? var_pres('_bez_rub')>100 || &_bez_rub ?};
      _bez_rub:=__RUB.sys_rub(#_attr,_koniec);
      {? _bez_rub.first
      || {!
         |? {? _rub.find_key(_bez_rub.RN) || _rub.del() ?};
            _bez_rub.next
         !}
      ?};
      _lista:=_ile-_lista;
      +_lista
   !}
?};

N.cntx_psh;
{? var_pres('_d')=type_of('')
|| N.index('NIEOBECL');
   _lista:=_d;
   N.prefix('N',P.ref,_lista);
   _ok:=N.last
|| N.index('NIEOBECN');
   N.prefix('N',P.ref);
   _ok:=N.find_le(_koniec)
?};
{? _ok
|| {!
   |? {? _rub.find_key(N.NB().RN)
      || {? N.OD<=_koniec & N.DO>=_pocz
         || {? N.OD>_pocz
            || _od:=N.OD
            || _od:=_pocz
            ?};
            {? N.DO>_koniec
            || _do:=_koniec
            || _do:=N.DO
            ?};
            {? _do>=_od
            || {? _typ='K'
               || {? ~(_partday & N.PARTDAY='T')
                  || _wyn+=_do-_od+1
                  ?}
               || {? N.OD>=_pocz & N.DO<=_koniec
                  || {? _typ='G'
                     || _wyn+=N.NG
                     || {? ~(_partday & N.PARTDAY='T')
                        || _wyn+=N.NR
                        ?}
                     ?}
                  || exec('kal_prac','personel',N.OD~1);
                     {? _typ='G'
                     || _godz:=__KAL.w_hours(_od,_do);
                        {? _godz>N.NG
                        || _godz:=N.NG
                        ?};
                        _wyn+=_godz
                     || {? ~(_partday & N.PARTDAY='T')
                        || _rob:=__KAL.w_days(_od,_do);
                           {? _rob>N.NR
                           || _rob:=N.NR
                           ?};
                           _wyn+=_rob
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ?}
      ?};
      N.prev & N.DO>=_pocz
   !}
?};
N.cntx_pop;
_wyn


\n_koment
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [20.42]
:: OPIS: Blokada edycji, jeśli zapis pochodzi z wniosku
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? -~menu_txt()='dołącz' || return(1) ?};
_ret:=1;
NWU.cntx_psh();
{? cur_tab(1,1)=N
|| NWU.index('STATUS');
   NWU.prefix(N.ref())
|| NWU.index('STATZLE');
   NWU.prefix(OS_N.ref())
?};
_ret:=~NWU.first();
NWU.cntx_pop();
_ret


\nezla_import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DG [22.26]
:: OPIS: Formuła importująca nieobecności z pliku csv.
::       Separator kolumn (,) i format daty (yyyy-mm-dd) są zgodne ze specyfikacją pliku dostępną na stronie:
::       http://www.zus.pl/ezla/eksport-e-zla-z-pue
::   WE: [_a][INTEGER] - czy wyświetlać komunikaty ekranowe (1 - tak / 0 - wpp)
::       [_b][INTEGER] - czy raport e-ZLA zawiera dokumenty w postaci plików XML (1 - tak / 0 - wpp)
::       [_c][STRING]  - ścieżka do katalogu z plikami: raport.xml, raport.csv oraz dokumentami e-ZLA XML
::       [_d][DATE]    - data wygenerowania raportu e-ZLA w PUE ZUS
::   WY:
::  OLD: \i_npue/kali_ei.fml
::----------------------------------------------------------------------------------------------------------------------
:: zmienne związane z wykorzystaniem formuły przez proces importujący e-ZLA (PER_IME)
_msg:=   {? var_pres('_a')=type_of(0) & ~_a || 0  || 1      ?};
_docXML:={? var_pres('_b')=type_of(0) & _b  || 1  || 0      ?};
_dirXML:={? var_pres('_c')=type_of('')      || _c || ''     ?};
_dtRAP:= {? var_pres('_d')=type_of(date())  || _d || date() ?};

_file_pth:={? ~_msg || _dirXML+exec('sep','#file')+'raport.csv' || '' ?};
_EZLAxml:=var_pres('EZLA_XML',NEZLA)>0;
:: tabela z listą plików, ktore znajdują się na ścieżce razem z plikami raport.csv/raport.xml
{? ~_msg & _docXML
|| _tabXML:=fdir(_dirXML,1,0);
   _docXML:=(type_of(_tabXML)<>type_of(~~))
?};

_f_zatr:=obj_new(2);
_f_zatr[1]:='P';
_f_zatr[2]:='Z';
_zn_prac:=
   "_prac:=null;
    {!
    |? {? _a>=P.DZA & (_a<=P.DZ | P.DZ=date(0,0,0))
         || H.cntx_psh();
            H.index('_HISTKOD');
            H.prefix(P.ref,'Z');
            {? H.last()
            || {!
               |? {? H.OD<=_a
                  || _prac:=P.ref;
                     0
                  || H.prev()
                  ?}
               !}
            ?};
            H.cntx_pop()
         ?};
         _prac=null & P.next()
    !};
    _prac";

:: Ustalenie ścieżki do pliku i wybór pliku do importu dokumentów e-ZLA.
_handle:=0;
_user:=
   {? _psep:=username()*'~' || _psep-1
   |? _psep:=username()*'.' || _psep-1
   || +username()
   ?}+username();
{? _msg
|| _naz_sciez:='Import e-ZLA';
   _sciez:=exec('get','#profile',,_user,_naz_sciez);
   _tmp_dir:=fmk_tmp_dir(0);
   {? type_of(_tmp_dir)<>type_of(~~)
   || _pth:=_tmp_dir.get_path();
      {? _pth<>''
      || _uploaded:=dlg_upload(_pth,0,'.csv');
         _sep:=exec('sep','#file',1);
         {? _uploaded<>''
         || _file_pth:=_pth+_sep+_uploaded;
            _handle:=fopen(_file_pth,'ur',,1)
         ?}
      ?}
   || FUN.emsg('Nie udało się utworzyć katalogu tymczasowego po stronie serwera.'@)
   ?}
|| _handle:=fopen(_file_pth,'ur',,1)
?};

{? _handle
|| _ile_ok:=0;
   _sep:=',';

   _add_err:=
      "  RAPLS.msg(_a,_b,_c,'('+$_d+' - '+$_e+') : ',_f)
      ";
:: aktualizacja tabeli z listą zaimportowanych i pominiętych wierszy
   _add_lst:="
      {? ~_a & var_pres('__LST_E')=type_of(SYSLOG)
      || __LST_E.blank();
         __LST_E.STATUS:=~_b;
         __LST_E.DT_GEN:=_c;
         __LST_E.EZLA:=_d;
         __LST_E.PRAC:=_e;
         __LST_E.PESEL:=_f;
         __LST_E.OD:=_g;
         __LST_E.DO:=_h;
         __LST_E.SZP_OD:=_i;
         __LST_E.SZP_DO:=_j;
         __LST_E.ST_ZAS:=_k;
         __LST_E.add()
      ?}";

   RAPLS.ustaw(2);

:: Tabela do importu e-ZLA
   _TAB:=tab_tmp(3,
      'OSOBA','STRING[11]','Identyfikator osoby',
      'REF','INTEGER','Wskazanie na osobę',
      'SERIA','STRING[4]','Seria dokumentu',
      'NUMER','STRING[10]','Nr dokumentu',
      'PESEL','STRING[11]','PESEL',
      'PIERWSZE','STRING[30]','Imię pierwsze',
      'NAZWISKO','STRING[40]','Nazwisko',
      'UB_W','STRING[10]','UB_W',
      'PASZPORT','STRING[20]','PASZPORT',
      'UR_DATA','DATE','Data urodzenia',
      'KOD','STRING[9]','Kod pocztowy',
      'MIASTO','STRING[40]','Miejscowość',
      'ULICA','STRING[50]','Ulica',
      'DOM','STRING[8]','Numer domu',
      'LOKAL','STRING[8]','Numer lokalu',
      'OD','DATE','Niezdolność do pracy od',
      'DO','DATE','Niezdolność do pracy do',
      'SZP_OD','DATE','Pobyt w szpitalu od',
      'SZP_DO','DATE','Pobyt w szpitalu do',
      'LEK_WSK','STRING[20]','Wskazania lekarskie',
      'KODY','STRING[20]','Kody',
      'NUM_STAT','STRING[20]','Numer statystyczny',
      'R_STPK','STRING[2]','Kod pokrewieństwa',
      'R_DA','DATE','Data urodzenia osoby pozostającej pod opieką',
      'ZAKL_RID','STRING[1]','Rodzaj identyfikatora płatnika',
      'ZAKL_ID','STRING[20]','Identyfikator płatnika',
      'ZAKL_N','STRING[50]','Nazwa skrócona',
      'Z_KOD','STRING[9]','Kod pocztowy płatnika',
      'Z_MIASTO','STRING[40]','Miejscowość płatnika',
      'Z_ULICA','STRING[50]','Ulica płatnika',
      'Z_DOM','STRING[8]','Numer domu płatnika',
      'Z_LOKAL','STRING[8]','Numer lokalu płatnika',
      'LEK_ID','STRING[20]','Identyfikator lekarza',
      'LEK_IM','STRING[40]','Imię lekarza',
      'LEK_NAZ','STRING[50]','Nazwisko lekarza',
      'D_WYST','DATE','Data wystawienia dokumentu',
      'ST_ZAS','STRING[50]','Status zaświadczenia',
      'DRUGIE','STRING[30]','Drugie imię',
      'STATUS','STRING[1]','Status',
      'DESCR','STRING[255]','Uwagi',
      'F_ZATR','STRING[1]','Forma zatrudnienia'
   );

   Cntx.psh(NEZLA,OSOBA);
   _pesel:=OSOBA.ndx_tmp(,1,'PESEL',,,'NAZWISKO',,);
   _paszport:=OSOBA.ndx_tmp(,1,'PASZPORT',,,'NAZWISKO',,);
:: Pominięcie pierwszej linii z nagłówkiem
   fread(_handle);
   {!
   |? (_tline:=fread(_handle))<>'\n'
   |! _err:=0;
      _TAB.blank();
      {? 1+_tline='"'
      || _tline:=1-_tline; _cudz:='""'; _ile:=2
      || _cudz:='"'; _ile:=1
      ?};
      {? _tline+1='"' || _tline:=_tline-1 ?};
      {! _ii:=3..(_TAB.fld_num()-4)
      |! _var:='';
         _acr:=_TAB.fld_acr(_ii);
         _res:='';

         {? 1+_tline='"'
         || _dlugosc:=+_tline;
            _pole:=0;
            {? _tline*('",')
            || {!
               |? _pole+=((_pole-_tline)*('",'));
                  _licz:=0;
                  {! _ind:=1.._pole+1
                  |! _string:=_ind+_tline;
                     {? _string+1='"' || _licz+=1 ?}
                  !};
                  _licz%*(2*_ile) & _ind<_dlugosc
               !}
            ?};
            _napis:=_pole+_tline;
            _tline:=_pole+1-_tline;
            _napis:=_ile-(_napis-(_ile));
            _wynik:='';
            {!
            |? _pozycja:=_napis*(_cudz+_cudz)
            |! _var+=_pozycja+_napis;
               _napis:=(_pozycja+(1+((_ile-1)*2)))-_napis
            !};
            _var+=_napis;
            ($('_a.'+_acr))(_TAB):=_var
         || {? _tline*_sep
            || _var:=((_tline*_sep)-1)+_tline
            |? +_tline
            || _var:=_tline
            ?};
            {? var_pres(_acr,_TAB)=27
            || _var:=|_var
            |? var_pres(_acr,_TAB)=21
            || _var:={? +_var || date(#(4+_var),#(2+(5-_var)),#(_var+2)) || date(0,0,0) ?}
            ?};
            ($('_a.'+_acr))(_TAB):=_var;
            _tline:={? (_tline*_sep) || (_tline*_sep)-_tline || '' ?}
         ?}
      !};
      _TAB.DESCR:='Pracownik';
      _TAB.F_ZATR:='P';
      _TAB.OSOBA:=
         {? +_TAB.PESEL
         || OSOBA.index(_pesel);
            _TAB.PESEL
         || OSOBA.index(_paszport);
            _TAB.PASZPORT
         ?};

      {? +_TAB.OSOBA & _TAB.OD<>#0 & _TAB.DO<>#0 & _TAB.D_WYST<>#0 & _TAB.SERIA<>'Seria'
      || _ok:=1;
         NEZLA.index('NEZLAN');
         NEZLA.prefix(exec('firma','ustawienia'),_TAB.SERIA,_TAB.NUMER);
         {? NEZLA.first()
         || {!
            |?
               {? NEZLA.ST_ZAS=_TAB.ST_ZAS
               || RAPLS.msg(_TAB.OSOBA,_TAB.NAZWISKO,_TAB.PIERWSZE,
                     'Dokument e-ZLA: seria %1, numer %2, status %3 już istnieje - zapis został pominięty.'@
                     [_TAB.SERIA,_TAB.NUMER,_TAB.ST_ZAS]);
                  _ok:=0
               ?};
               NEZLA.next & _ok
            !}
         ?};
         NEZLA.index('NEZLAS');
         {? _ok
         || OSOBA.prefix(_TAB.OSOBA);
            {? {? OSOBA.size()=1
               || OSOBA.first()
               || _exist:=0;
                  {? OSOBA.first()
                  || {!
                     |? _exist:=(-OSOBA.NAZWISKO=-_TAB.NAZWISKO);
                        ~_exist & OSOBA.next()
                     !}
                  ?};
                  _exist
               ?}
            || _prac:=null;
               _jest_pz:=0;
               {! _ind:=1..2
               |! {? _prac=null()
                  || P.index('PRACOSOB');
                     P.prefix(exec('ref_firma','ustawienia'),_f_zatr[_ind],OSOBA.ref());
                     {? P.first()
                     || _jest_pz:=1;
                        {? P.size()>1
                        || _prac:=_zn_prac(_TAB.D_WYST);
                           {? _prac<>null()
                           || _TAB.F_ZATR:=_f_zatr[_ind];
                              _TAB.DESCR:={? _TAB.F_ZATR='P' || 'Pracownik' || 'Zleceniobiorca' ?}
                           ?}
                        || {? _TAB.D_WYST>=P.DZA & (_TAB.D_WYST<=P.DZ | P.DZ=date(0,0,0))
                           || _prac:=P.ref();
                              _TAB.F_ZATR:=_f_zatr[_ind];
                              _TAB.DESCR:={? _TAB.F_ZATR='P' || 'Pracownik' || 'Zleceniobiorca' ?}
                           ?}
                        ?}
                     ?}
                  ?}
               !};

               {? _prac=null()
               || _TAB.DESCR:='Brak aktywnego pracownika lub zleceniobiorcy.';
                  _add_err(_TAB.OSOBA,_TAB.NAZWISKO,_TAB.PIERWSZE,_TAB.OD,_TAB.DO,
                     'Brak aktywnego pracownika lub zleceniobiorcy.'@
                  )
               ?};
                  {? _TAB.OD>_TAB.DO
                  || _err:=1;
                     _add_err(_TAB.OSOBA,_TAB.NAZWISKO,_TAB.PIERWSZE,_TAB.OD,_TAB.DO,
                        'Nieprawidłowe daty od i do dla nieobecności: %1 %2. Operacja importu została anulowana.'@
                           [  _TAB.OD$1,_TAB.DO$1
                           ]
                     )
                  ?};
                  {? _TAB.SZP_OD>_TAB.SZP_DO
                  || _err:=1;
                     _add_err(_TAB.OSOBA,_TAB.NAZWISKO,_TAB.PIERWSZE,_TAB.OD,_TAB.DO,
                        'Nieprawidłowe daty od i do dla nieobecności: %1 %2. Operacja importu została anulowana.'@
                           [  _TAB.SZP_OD$1,_TAB.SZP_DO$1
                           ]
                     )
               ?};
               {? ~_jest_pz
               || _err:=1;
                  _add_err(_TAB.OSOBA,_TAB.NAZWISKO,_TAB.PIERWSZE,_TAB.OD,_TAB.DO,
                     'Brak pracownika lub zleceniobiorcy. Operacja importu została anulowana.'@
                  )
               ?};

               {? ~_err
               || _TAB.REF:=#OSOBA.ref();
                  _TAB.STATUS:='N';
                  _overlap:=0;
                  _od:=_TAB.OD;
                  _do:=_TAB.DO;
                  _st_zas:=|_TAB.ST_ZAS;
                  _TAB.DESCR:=_TAB.DESCR+' (Status: '+_st_zas+' )';
                  _TAB.cntx_psh();
                  _TAB.prefix(_TAB.OSOBA,#OSOBA.ref());
                  {? _TAB.first()
                  || {!
                     |? {? _od<=_TAB.DO & _do>=_TAB.OD | _od<=_TAB.SZP_DO & _do>=_TAB.SZP_OD
                        || {? _TAB.ST_ZAS=_st_zas
                           || _overlap:=1;
                              0
                           || _TAB.next()
                           ?}
                        || _TAB.next()
                        ?}
                     !}
                  ?};
                  _TAB.cntx_pop();
                  {? (_TAB.SZP_OD>#0 | _TAB.SZP_DO>#0)
                     &
                     (_TAB.SZP_OD<_TAB.OD | _TAB.SZP_OD>_TAB.DO | _TAB.SZP_DO<_TAB.OD | _TAB.SZP_DO>_TAB.DO)
                  || _add_err(_TAB.OSOBA,_TAB.NAZWISKO,_TAB.PIERWSZE,_TAB.OD,_TAB.DO,
                        'Okres pobytu w szpitalu nie nastąpił w czasie trwania nieobecności.'@
                     );
                     _add_lst(_msg,0,_dtRAP,_TAB.SERIA+' '+_TAB.NUMER,_TAB.NAZWISKO+' '+_TAB.PIERWSZE,_TAB.OSOBA,
                        _TAB.OD,_TAB.DO,_TAB.SZP_OD,_TAB.SZP_DO,_st_zas
                     )
                  |? _overlap
                  || _add_err(_TAB.OSOBA,_TAB.NAZWISKO,_TAB.PIERWSZE,_TAB.OD,_TAB.DO,
                        'Nieobecność: %1 - %2 status: %3 koliduje z inną importowaną i zostanie pominięta.'@
                        [_TAB.OD$1,_TAB.DO$1,_st_zas]
                     );
                     _add_lst(_msg,0,_dtRAP,_TAB.SERIA+' '+_TAB.NUMER,_TAB.NAZWISKO+' '+_TAB.PIERWSZE,_TAB.OSOBA,
                        _TAB.OD,_TAB.DO,_TAB.SZP_OD,_TAB.SZP_DO,_st_zas
                     )
                  || _ile_ok+=_TAB.add()
                  ?}
               ?}
            || _add_err(_TAB.OSOBA,_TAB.NAZWISKO,_TAB.PIERWSZE,_TAB.OD,_TAB.DO,
                  'Nie znaleziono pracownika o podanym identyfikatorze.'@
               );
               _add_lst(_msg,0,_dtRAP,_TAB.SERIA+' '+_TAB.NUMER,_TAB.NAZWISKO+' '+_TAB.PIERWSZE,_TAB.OSOBA,
                  _TAB.OD,_TAB.DO,_TAB.SZP_OD,_TAB.SZP_DO,|_TAB.ST_ZAS
               )
            ?}
         || _add_lst(_msg,0,_dtRAP,_TAB.SERIA+' '+_TAB.NUMER,_TAB.NAZWISKO+' '+_TAB.PIERWSZE,_TAB.OSOBA,
               _TAB.OD,_TAB.DO,_TAB.SZP_OD,_TAB.SZP_DO,|_TAB.ST_ZAS
            )
         ?}
      |? +_TAB.OSOBA & _TAB.SERIA<>'Seria'
      || _add_err(_TAB.OSOBA,_TAB.NAZWISKO,_TAB.PIERWSZE,_TAB.OD,_TAB.DO,
            'Nieprawidłowa data rozpoczęcia lub zakończenia nieobecności.'@
         );
         _add_lst(_msg,0,_dtRAP,_TAB.SERIA+' '+_TAB.NUMER,_TAB.NAZWISKO+' '+_TAB.PIERWSZE,_TAB.OSOBA,
            _TAB.OD,_TAB.DO,_TAB.SZP_OD,_TAB.SZP_DO,|_TAB.ST_ZAS
         )
::       wiersz nierozpoznany z innych powodów
      || _add_lst(_msg,0,_dtRAP,_TAB.SERIA+' '+_TAB.NUMER,_TAB.NAZWISKO+' '+_TAB.PIERWSZE,_TAB.OSOBA,
            _TAB.OD,_TAB.DO,_TAB.SZP_OD,_TAB.SZP_DO,|_TAB.ST_ZAS
         )
      ?}
   !};
   fclose(&_handle);
:: dla procesu importującego e-ZLA (PER_IME) zachowujemy komunikaty w RAPLS (powiadomienia)
   {? _msg
   || RAPLS.raport(9);
      RAPLS.ustaw(0)
   ?};

   {? _ile_ok
   || {? {? _msg
         || FUN.ask('%1\n%2\n%3'
               [  'Operacja weryfikacji struktury pliku zakończona poprawnie.'@,
                  'Liczba zaimportowanych dokumentów: %1.'@[$_ile_ok],
                  'Czy kontynuować proces importu nieobecności?'@
               ]
            )
         || 1
         ?}
      || {? _TAB.first()
         || NEZLA.clear();
            {!
            |? {? OSOBA.seek(_TAB.REF,,1)
               || NEZLA.blank();
                  {! _ii:=2.._TAB.fld_num()
                  |! _acr:=_TAB.fld_acr(_ii);
                     {? var_pres(_acr,NEZLA)>0 || ($('NEZLA.'+_acr+':=_a.'+_acr))(_TAB) ?}
                  !};
                  _ok:=NEZLA.add();
                  _add_lst(_msg,_ok,_dtRAP,_TAB.SERIA+' '+_TAB.NUMER,_TAB.NAZWISKO+' '+_TAB.PIERWSZE,_TAB.OSOBA,
                     _TAB.OD,_TAB.DO,_TAB.SZP_OD,_TAB.SZP_DO,_TAB.ST_ZAS
                  );
::                dołączenie dokumentu e-ZLA - plik XML
                  {? _ok & _EZLAxml & _docXML & _tabXML.first()
                  || _loop:=0;
                     {!
                     |? _serno:=form(NEZLA.SERIA)+form(NEZLA.NUMER)+'.xml';
                        _pesel:=form(NEZLA.OSOBA().PESEL);
                        {? _tabXML.TYPE='f' & -(_serno)=-(_tabXML.NAME+(+_serno)) &
                           ((_pesel<>'' & ((+_pesel)+_tabXML.NAME)=_pesel) | _pesel='')
                        || _loop:=NEZLA.bl_put('EZLA_XML',_dirXML+'\\'+_tabXML.NAME,,,_tabXML.NAME,1)
                        ?};
                        ~_loop & _tabXML.next()
                     !}
                  ?}
               ?};
               _TAB.next()
            !}
         ?}
      ?}
   |? _msg
   || FUN.emsg('%1\n%2'['Operacja importu nieobecności została zakończona.'@,'Brak pozycji w pliku do zaimportowania'@])
   ?};
   OSOBA.ndx_drop();
   Cntx.pop(NEZLA,OSOBA)
|? _msg
|| _err:=1;
   FUN.emsg('Brak pliku %1 w lokalizacji %2'@[_name_plk,_przp])
|| return(0)
?};
1


\sprawdz_2022
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [21.14]
:: OPIS: Sprawdzenie, czy choroba pierwotna powstała przed 1.1.2022
::       Argumentem jest wskazanie na N lub para wskazanie na P i data nieobecności
::   WE: _a [REFERENCE] - wskazanie na N lub wskazanie na P
::       [_b [DATA] - data nieobecności]
::   WY: 0 lub 1
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
{? _=1 & var_pres('_a')=type_of(null())
|| N.cntx_psh();
   N.prefix();
   {? N.seek(_a)
   || {? N.OD<date(2022,1,1) || _ret:=1 ?};
      {? ~_ret
      || N.index('NIEOBECN');
         N.prefix(N.KOR,N.P);
         _exit:=0;
         {! |?
            _data:=N.OD;
            {? N.prev() & __RUB.sys_attr(N.NB,126,N.OD) & _data-1=N.DO
            || {? N.OD<date(2022,1,1)
               || _ret:=1;
                  _exit:=1
               ?}
            || _exit:=1
            ?};
            ~_exit
         !}
      ?}
   ?};
   N.cntx_pop()

|? _=2 & var_pres('_a')=type_of(null()) & var_pres('_b')=type_of(date()) & _b>#0
|| {? _b<date(2022,1,1) || _ret:=1 ?};
   {? ~_ret
   || N.cntx_psh();
      N.index('NIEOBECX');
      N.prefix('N',_a);
      {? N.find_ge(_b-1) & __RUB.sys_attr(N.NB,126,N.OD) & _b-1=N.DO
      || _ret:=exec('sprawdz_2022','nieobecnosc',N.ref())
      ?};
      N.cntx_pop()
   ?}
?};
_ret


\chw_wal_zc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [12.51]
:: OPIS: Funkcja wyszukuje współczynnik waloryzacji NW.WSP dla podanego refa tabeli N
::   WE: _a - ref tabeli nieobecności N
::       _b - wyliczona podstawa do sprawdzenia waloryzacji
::   WY: wartość pola NW.WSP podzielona przez 100, jesli ta wartość jest mniejsza niż 1 zwracane jest 1
::  OLD: \chw_wal_zc/umowy_zc.fml
::----------------------------------------------------------------------------------------------------------------------
::Poprawka SPIS ER/WRT/XP/12.51/2211/0013 Brak waloryzacji podstawy chorobowej z umowy zlecenia
{? var_pres('_a')<>type_of(null) || return(1) ?};
{? var_pres('_b')<>type_of(0) || return(1) ?};
_wal:=1;
NW.cntx_psh();
NW.index('CHW');
NW.prefix(_a);
{? NW.first() & NW.WAL='T'
|| _NZPod:=_MZKwal:=0;
   TZ.cntx_psh;
   TZ.use('tabz'+form(NW.CHW().OD~1,-4,0,'99'));
   TZ.index('ZASTAB');
   TZ.prefix('Z',NW.CHW);
   {? TZ.first()
   || {!
      |? {? TZ.W<>'N'
         || _NZPod+=TZ.KW;
            _MZKwal+=1
         ?};
         TZ.next()
      !}
   ?};
   TZ.cntx_pop();
   {? _MZKwal>0
   || _podstawa:=(_NZPod/_MZKwal)$2;
      {? _b=_podstawa | __KORZ=1 || _wal:=NW.WSP/100 ?}
   ?}
?};
NW.cntx_pop();
{? _wal<1 || 1 || _wal ?}


\n_urlopy_opiekuncze_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [12.51]
:: OPIS: Formuła akcji "urlopy Opiekuńcze" w okienkach wertowania tabeli N
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('nwopo_select','wnioski_urlopowe')

:Sign Version 2.0 jowisz:1045 2023/12/05 08:54:09 3862a28532778e57ce4c42e0dc37e0a1b905911fcfb8214fed00b4c095f19abd5f0b69c417b35987cb0de00a2697bc4b6a3463732a8fe7774d5e9de256e4ec3b016a5af3092117c03e72ce48b3e3f14e3c2c84a7406bb940a2ac7b9c2aa67d9b24cf06dd4c76b61580c0aa60fea7f344e06ab8400e8a99a77c23050d09273910
