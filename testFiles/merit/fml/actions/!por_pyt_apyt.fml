:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !por_pyt_apyt.fml
:: Utworzony: 24.02.2020
:: Autor: IS
::======================================================================================================================
:: Zawartość: Obsługa czynności POR_PYT_APYT - Powiadomienia o pytaniach
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [20.14]
:: OPIS: Powiadomienia o pytaniach - główna formuła czynności.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::# properties=LOOP,SERVICE
::# permissions=F_ZATR,UD_SKL
::
:: Czynność "Powiadomienia o pytaniach oczekujących na odpowiedź" zbieria informacje o nagłówkach pytań,
:: które zawierają pytania wymagające odpowiedzi.
:: Czynność przechodzi po kartotece pracowników i sprawdza czy pracownik znajduje się w kartotece osób obsługujących
:: pytania na portalu. Następnie dla znalezionej osoby obsługującej przechodzi po kartotece kompetencji osób
:: obsługujących i znajduje kategorie za które odpowiada znaleziona osoba obsługująca. Następnie przechodzi po
:: znalezionych kategoriach i sprawdza dla każdej z nich nagłówki pytań zliczając te, które wymagają odpowiedzi.
:: Zebraną liczbę pytań z podziałem na kategorie wysyła w powiadomieniu do pracownika będącego osobą obsługującą
:: pytania na portalu.
::
:: Parametr OD określa datę od której należy kwalifikować wątek pytania (wg. jego daty ostatniego pytania)
:: do wysłania w powiadomieniu. Wątki w których data ostatniego pytania jest wcześniejsza niż data OD nie będą brane
:: pod uwagę. Domyślnie przyjmuje wartość daty zerowej date(0,0,0), czyli nie zakłada ograniczenia na "przestarzałe"
:: pytania.
::# kind=WE, symbol=OD, type=DATE, name=Data początkowa badanego okresu, required=N
::
:: Parametr DO określa datę do której należy kwalifikować wątek pytania (wg. jego daty ostatniego pytania)
:: do wysłania w powiadomieniu. Wątki w których data ostatniego pytania jest późniejsza niż data DO nie będą brane
:: pod uwagę. Domyślnie przyjmuje wartość date().
::# kind=WE, symbol=DO, type=DATE, name=Data końcowa badanego okresu, required=N
::
:: Parametr wejściowy UD_SCH pozwala wskazać symbol schematu (typu PODZORG), który posłuży do ustalenia jednostki
:: organizacyjnej, przekazanej parametrem UD_SKL. Jeżeli parametr nie zostanie przekazany (ustawiony), to wybrany
:: zostanie schemat domyślny lub (jeżeli domyślny nie został określony) pierwszy (w kolejności alfabetycznej).
::# kind=WE, symbol=UD_SCH, type=STRING, name=Schemat organizacyjny, required=N, ^
::#    fml_val="exec('ud_sch_wybierz','schemat',,_a).SYMBOL"
::
:: Parametr wejściowy UD_SKL pozwala wskazać jednostkę organizacyjną, do której będzie ograniczony zakres przetwarzania.
:: Domyślnie przetwarzane będą wszystkie jednostki organizacyjne.
::# kind=WE, symbol=UD_SKL, type=STRING, name=Jednostka organizacyjna, required=N, ^
::#    fml_val="exec('ud_skl_wybierz','schemat',,,1,_a)"
::
:: Parametr wejściowy SQL_FROM umożliwia zbudowanie dodatkowych relacji na potrzeby dodatkowego warunku
:: (patrz SQL_WHERE).
:: Domyślnie przyjmuje wartość pustą.
::# kind=WE, symbol=SQL_FROM, type=STRING, name=Dodatkowe relacje filtra, required=N
::
:: Parametr wejściowy SQL_WHERE umożliwia dodatkowe ograniczenie listy współpracowników. Warunek może odwoływać się
:: do tabeli pracowników (poprzez alias "P" np. "P".ID>1000) oraz
:: do tabeli osób (poprzez alias "1OSOBA" np. "1OSOBA".PLEC='K').
:: Odwołania do innych tabel wymagają odpowiedniego użycia parametru SQL_FROM.
:: Domyślnie SQL_WHERE przyjmuje wartość pustą.
::# kind=WE, symbol=SQL_WHERE, type=STRING, name=Dodatkowy warunek filtra, required=N
::
:: Parametr wejściowy FML_TEST umożliwia dodatkową weryfikację wyboru współpracownika do przetwarzania. Jest treścią
:: formuły w formacie napisu. Jeżeli formuła zwróci wartość 0 to dany współpracownik nie będzie przetwarzany.
:: Formuła jest wykonywana przy ustawionych buforach tabel: P, OSOBA.
:: Domyślnie przyjmuje wartość '1'.
::# kind=WE, symbol=FML_TEST, type=STRING, name=Dodatkowy warunek wyboru, required=N
::
::----------------------------------------------------------------------------------------------------------------------
:: Parametry wyjściowe przyjmują wartości puste jeżeli znaleziony pracownik ma oczekujące na odpowiedź pytania,
:: ale nie udało się znaleźć właściwego dla niego adresu e-mail w tabelach USERS i OS_ADRES.
::# kind=WY, symbol=SUB, type=STRING, name=Temat, required=N
::# kind=WY, symbol=RCV, type=MEMO, name=Lista odbiorców, required=N
::# kind=WY, symbol=BODYH, type=MEMO, name=Treść w formacie HTML, required=N
::
::----------------------------------------------------------------------------------------------------------------------
params_set(_par:=params_get());
_mp:=_par.mp;
_in:=_par.in;
_out:=_par.out;
_service:=_mp.isService();

{? _mp.pathProc() | _mp.pathTodo()
:: Ustawienie domyślnej wartości parametru LOOP (żeby brama się nie zawiesiła).
|| _mp.save(exec('kind_out','#b_port'),'LOOP','N');

:: Ustalenie / odzyskanie klucza grupującego.
   _out.GRPKEY:=_mp.grpkey(_out.GRPKEY,_in.GRPKEY);

   {? ~_mp.loop()
::    Pierwszy obrót pętli - przygotujmy dane.
::    Usuwamy wszystkie dotychczasowe klucze, które mogły zostać zapamiętane przy poprzednim uruchomieniu czynności
::    (zakończonej _mp.keep()).
   || _mp.grpkeyDelAll();
      _winT:='Powiad. o pytaniach z portalu'@;
::    Przypisanie domyślnej wartości dacie OD i DO jeśli te nie mają wartości:
      {? var_pres('OD',_in)<>21
      || _in.OD:=date(0,0,0)
      ?};
      {? var_pres('DO',_in)<>21 | _in.DO=date(0,0,0)
      || _in.DO:=date()
      ?};

::    Sprawdzenie parametrów wejściowych:
      {? (_result:=exec('input_chk_get','personel_alerty',_service,_in,_winT,,1,1,0))=''
      || {? ~exec('first_run','!por_pyt_apyt',_in,_mp,_winT)
::       Jeśli nie znaleziono pracowników spełniających kryteria, zakończ czynność:
         || _out.RCV:=_out.BODYH:=_out.SUB:='';
            _mp.save(,_out);
            _mp.done();
            {? ~_service
            || FUN.info('Brak pracowników spełniających kryteria.'@)
            ?};
            return()
         ?}
      || {? ~_service
         || FUN.emsg(_result);
            _mp.cancel()
         || _mp.error(_result)
         ?};
         return()
      ?}
   ?};

:: Jeżeli coś było nie tak (z parametrami wejściowymi, z wyborem), to zostało obsłużone powyżej.
:: Tutaj jesteśmy już na etapie obsługi pętli.

   P.cntx_psh();
   P.prefix();
   do();
:: Podczytanie kluczowych wartości z GRPKEY:
   _grpPars:=json_par(_mp.grpkeyGet());
   _in.OD:=#_grpPars.OD;
   _in.DO:=#_grpPars.DO;
   _pUid:=_grpPars.PUID;

   {? _pUid<>~~
::    Przechodzę po pracownikach odłożonych w GRPKEY:
   || {? P.seek(_pUid)
      || _ret:=exec('run','!por_pyt_apyt',_in,_grpPars.MAIL);
::       Jeżeli RCV jest ciągiem pustym, to znaczy, że nie znaleziono adresu e-mail dla pracownika. Należy to sprawdzić
::       w procesie. W takim przypadku również BODYH i SUB będą ciągami pustymi.
         _out.RCV:=_ret.RCV;
         _out.BODYH:=_ret.BODYH;
         _out.SUB:=_ret.SUB;
         _mp.save(,_out)
      ?};
      {? _mp.grpkeyDel()
      || {? _mp.grpkeyGet()<>~~
::          Jeżeli jest jeszcze choć jeden element do przetworzenia, to pętla powinna być kontynuowana.
         || _mp.loop_continue()
         ?}
      ?}
   ?};
   _mp.done();
   end();
   P.cntx_pop()
?};
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [20.14]
:: OPIS: Powiadomienia o pytaniach - formuła opisu zadania.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
'Powiadomienia o pytaniach oczekujących na odpowiedź'@@


\first_run
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [20.14]
:: OPIS: Pierwsze uruchomienie czynności (pierwszy obrót pętli)
::   WE: _a [OBJ] - parametry wejściowe czynności (in)
::       _b [OBJ] - obiekt menedżera procesów (mp)
::       _c [STRING] - tytuł okienka
::   WY: 0/1 - Czy znaleziono pracowników do których należy wysłać powiadomienia?
::----------------------------------------------------------------------------------------------------------------------
_in:=_a;
_mp:=_b;
_winT:=_c;
_service:=_mp.isService();

P.cntx_psh();
:: Założenie odpowiednich filtrów na tabelę P wg. tego co podano w _in:
_fZatr:=spli_str('K,P,R,T,Z',',');
exec('fltr_p_ud_sql','personel_alerty',_service,_in,_fZatr);
obj_del(_fZatr);
:: Wygenerowanie tabeli z uidref pracowników, którzy mają pytania wymagajjące odpowiedzi:
_TAB:=exec('por_pyt_p','portal_alerty',_in.OD,_in.DO,_in.FML_TEST,'T');
P.f_clear();
P.cntx_pop();

:: Jeśli nie znaleziono takich pracowników zwróć 0:
{? ~_TAB.size()
|| return(0)
?};

:: Przepisanie dat OD, DO oraz tabeli uidref pracowników z blokadą do GRPKEY:
{? _TAB.first()
|| _bMail:=0;
   {!
   |? _par:=obj_new('PUID','OD','DO','MAIL');
::    Struktura tablicy nazwanej przekazywanej w formie JSON do GRPKEY:
::       * PUID [STRING] - P.uidref(), wskazanie na pracownika
::       * OD   [NUMBER] - _in.OD, data początkowa badanego okresu
::       * DO   [NUMBER] - _in.DO, data końcowa badanego okresu
::       * MAIL [STRING] - adres e-mail pracownika
::    Daty zapisywane w postaci numerycznej, tak aby po odczytaniu przekształcić z powrotem na typ DATE.
::    Możliwa do zapisania długość to 255 znaków. Obecna długość ciągu JSON to 195 znaków (do poniedziałku,
::    28 listopada 2738 roku).
      _par.PUID:=_TAB.PUID;
      _par.OD:=#_in.OD;
      _par.DO:=#_in.DO;
      _par.MAIL:=_TAB.MAIL;
      {? _TAB.MAIL='' || _bMail+=1 ?};
      _mp.grpkeyAdd(json_obj(_par));
      obj_del(_par);
      _TAB.next()
   !}
?};
:: Informacja o przygotowaniu danych
{? ~_service
|| FUN.info(
      _winT+'\n\n'+
      'Analiza danych zakończona.'@+'\n'+
      'Liczba zapisów spełniających kryteria: %1.'@ [$_TAB.size()]+'\n'+
      'Liczba pracowników bez adresu e-mail: %1.'@ [$_bMail]
   )
?};
1


\run
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [20.14]
:: OPIS: Formuła odpowiedzialna za przygotowanie danych do wysyłanego powiadomienia. Formuła zakłada, że jest ustawiony
::       bufor na konkretnych rekordach tabel P i BIPNAG.
::       Formuła zwraca tablicę nazwaną z elementami potrzebnymi do wysłania powiadomienia.
::   WE: _a [OBJ] - parametry wejściowe czynności (in)
::       _b [STRING] - e-mail pracownika
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_in:=_a;
_ret:=obj_new('RCV','BODYH','SUB');
_ret.RCV:=_ret.BODYH:=_ret.SUB:='';
:: Przypisanie przychodzącego adresu e-mail:
_ret.RCV:=_b;

:: Jeśli nie ma adresu e-mail, to dalsze wypełnianie nie ma sensu:
{? _ret.RCV<>''
|| _th:="'<th [[STYLE_TABLE_TH]]>'+_a+'</th>'";
   _td:="'<td [[STYLE_TABLE_TD]]>'+_a+'</td>'";
   _ret.SUB:='Powiadomienie o pytaniach oczekujących na odpowiedź'@;

   _ret.BODYH:=
      '<p><b>'+
         'Pytania, które oczekują na odpowiedź:'@+
      '</b></p>';

   _ret.BODYH+=
      '<table [[STYLE_TABLE]]>\n'
      '<tr [[STYLE_TABLE_TR]]>'+
         _th('Funkcjonalność - kod'@)+
         _th('Funkcjonalność - nazwa'@)+
         _th('Kategoria - kod'@)+
         _th('Kategoria - nazwa'@)+
         _th('Liczba pytań'@)+
         _th('Inne osoby obsługujące'@)+
      '</tr>\n';

   BIPPYTO.cntx_psh();
   BIPPYTO.index('P');
   BIPPYTK.cntx_psh();
   BIPPYTK.index('KAT');
   BIPKAT.cntx_psh();
   BIPPYTN.cntx_psh();
   BIPPYTN.index('VIEW');
   BIPPYTO.prefix(P.ref());
   {? BIPPYTO.first()
:: Idę po rekordach BIPPYTO (osoby odpowiedzialne za udzielanie odpowiedzi) związanych z pracownikiem:
   || {!
      |? BIPPYTK.prefix(BIPPYTO.ref());
         {? BIPPYTK.first()
::          Idę po rekordach BIPPYTK (kategorie za które dana osoba jest odpowiedzialna):
         || {!
            |? _lPyt:=0;
               BIPPYTK.BIPKAT();
               BIPPYTN.prefix(exec('ref_firma','ustawienia'),'T',BIPKAT.FUNKC,BIPKAT.KOD,);
::             Zliczam pytania spełniające kryterium daty ostatniej odpowiedzi:
               {? BIPPYTN.first()
               || {!
                  |? {? BIPPYTN.DTOP>=_in.OD & BIPPYTN.DTOP<=_in.DO
                     || _lPyt+=1
                     ?};

                     BIPPYTN.next()
                  !}
               ?};
::             Jeśli w kategorii są pytania, sprawdzam inne osoby z kat. i dodaję wiersz do tabeli:
               {? _lPyt
               || _osOdp:='';
                  BIPPYTK.cntx_psh();
                  BIPPYTK.index('BIPKAT');
                  BIPPYTK.prefix(BIPKAT.ref());
                  OSOBA.cntx_psh();
                  {? BIPPYTK.first()
                  || {!
                     |? {? BIPPYTK.OSOBA<>P.OSOBA
                        || _osOdp+='%1 %2, '[BIPPYTK.OSOBA().PIERWSZE,OSOBA.NAZWISKO]
                        ?};

                        BIPPYTK.next()
                     !}
                  ?};
                  OSOBA.cntx_pop();
                  BIPPYTK.cntx_pop();
                  {? +_osOdp
                  || _osOdp-=2
                  || _osOdp:='Jesteś jedyną osobą odpowiedzialną za odpowiadanie na pytania w tej kategorii.'@
                  ?};

                  _ret.BODYH+=
                     '<tr [[STYLE_TABLE_TR]]>'+
                        _td(BIPKAT.FUNKC)+
                        _td(exec('_funkc','portal_bip','NAZWA',BIPKAT.FUNKC))+
                        _td(BIPKAT.KOD)+
                        _td(BIPKAT.NAZWA)+
                        _td($_lPyt)+
                        _td(_osOdp)+
                     '</tr>\n'
               ?};

               BIPPYTK.next()
            !}
         ?};

         BIPPYTO.next()
      !}
   ?};
   BIPPYTN.cntx_pop();
   BIPKAT.cntx_pop();
   BIPPYTK.cntx_pop();
   BIPPYTO.cntx_pop();

   _ret.BODYH+=
      '</table><p>'+'Ta wiadomość została wygenerowana automatycznie - prosimy na nią nie odpowiadać.'@+'</p>'
?};

_ret

:Sign Version 2.0 jowisz:1045 2021/09/17 15:17:00 7696e12ebdd269c488de0c99289b40fd907ffa1adc69e56d1f974a76f32ae8ec5377c5bc2861506c9142f2bc59964e8fca707ace668b0ceb74b228eb8350f5465dd470e775ac75dc1736afb53e31a75b50d84ca80ea2806fa62d5a2b16593c4b8331c6dc7f9405765195c5322c3c2ae2ca8182350af21a2cfe74d098d2834df9
