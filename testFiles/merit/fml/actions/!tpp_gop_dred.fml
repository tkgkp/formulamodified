:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tpp_gop_dred.fml
:: Utworzony: 13.04.2016
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły czynności TPP_GOP_DRED - Redakcja grup operacji
::            Czynność jest potrzebna wyłącznie ze względu na uprawnienia.
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła główna czynności
::----------------------------------------------------------------------------------------------------------------------
::# permissions=ODDZ
~~


\grop_ttoper_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed wyświetleniem pola GROP.TTOPER
::  OLD: \grop_ttoper_bd/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
GROPP.index('GROP');
GROPP.prefix(GROP.ref());
{? -menu_txt()='dołącz' | ~GROPP.first()
|| 1
|| exec('findfnrd','color')
?}


\grop_ttoper_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed radakcją pola GROP.TTOPER
::  OLD: \grop_ttoper_be/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? VGROP.TTOPER<>null()
|| 0
|| VAR.TTOPER:=GROP.TTOPER;
   GROPP.index('GROP');
   GROPP.prefix(GROP.ref());
   -menu_txt()='dołącz' | ~GROPP.first()
?}


\grop_ttoper_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Po radakcji pola GROP.TTOPER
::----------------------------------------------------------------------------------------------------------------------
:: Modyfikacje tylko, gdy zmieniono wartość pola
{? VAR.TTOPER=GROP.TTOPER || return(1) ?};

PL_RES.cntx_psh();
:: Przepisanie znczników
GROP.NO_START:=TTOPER.NO_START;
:: Przepisanie zasobu
{? VGROP.GR_RES=null() & GROP.TTOPER<>null()
|| {? GROP.TTOPER().GRPOJ='S' & TTOPER.PLACE<>null()
   || PL_RES.index('FROM_STA');
      PL_RES.prefix(TTOPER.PLACE);
      {? PL_RES.first()
      || VGROP.GR_RES:=PL_RES.ref()
      ?}
   |? GROP.TTOPER().GRPOJ='G' & TTOPER.GRUPA<>null()
   || {? TTOPER.TWRKPLG<>null()
      || PL_RES.index('FROM_STA');
         PL_RES.prefix(TTOPER.TWRKPLG().ELEMENT);
         {? PL_RES.first()
         || VGROP.GR_RES:=PL_RES.ref()
         ?}
      || PL_RES.index('FROM_GNI');
         PL_RES.prefix(TTOPER.GRUPA);
         {? PL_RES.first()
         || VGROP.GR_RES:=PL_RES.ref()
         ?}
      ?}
   ?}
?};
PL_RES.cntx_pop();
1


\modGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: sprawdza czy program główny
::  OLD: \modGrOp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
GROP.TYP='G'


\grop_il_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redagowaniu pola GROP.IL
::  OLD: \grop_il_ae/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
exec('itsPositive','#field',1,,fld())


\addGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: dodanie grupy operacji lub klona grupy
::   WE: [_a] - dodanie (0-dom), kopia 1
::  OLD: \addGrOp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env_grop:=params_get().env_grop;

{? VGROP.STATUS='Z' | (VGROP.USERS<>null() & VGROP.USERS<>OPERATOR.USER)
|| FUN.info('Ustawiony filtr — nie można dołączać grup operacji.'@)
||
   VGROP.IL_STAN:=0;
   VGROP.GR_RES:=VGROP.FLTR_RES;
   VGROP.GR_CZAS:=time(0,0,0);
   VGROP.GR_OPIS:='';
   VGROP.GR_KOD:='';
   GROP.cntx_psh();
   GROP.prefix();
   {? _<1 || _a:=0 ?};
   {? _a=0
   || GROP.blank();
      GROP.DATA:=date();
      GROP.TTOPER:=VGROP.TTOPER
   || GROP.STATUS:='O';
      GROP.ILP:=0;
      GROP.AKC:='N'
   ?};
   _env_grop.GROP_IL:=0;
   exec('grop_efld_opt','zl_grop');
   {? GROP.edit("params_exec('chkGrOp','!tpp_gop_dred',0)")
   || do();
      _ok:=GROP.add();
      {? _ok
      || exec('aktStanGr','!tpp_gop_dred');
         exec('actualize_grop','!tpp_gop_dred',GROP.ref())
      ?};
      end();
      {? _ok
      || GROP.f_add();
         exec('addGrOpp','!tpp_gop_dred')
      ?}
   ?};
   GROP.cntx_pop()
?};
~~


\chkGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: rekord po GROP
::   WE:  _a - ile wydano materialu (domyslnie 0)
::  OLD: \chkGrOp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0 || _a:=0 ?};

_env_grop:=params_get().env_grop;

_czas:=exec('time2min','#convert',VGROP.GR_CZAS);

{? exec('itsPositive','#field',0,'T',_czas)=0
|| _ret:='GR_CZAS'
|| _can_continue:=1;
   {? -menu_txt()='popraw'
   || GROPP.index('GROP');
      GROPP.prefix(GROP.ref());
      {? GROPP.first()
      || {!
         |? _sum:=exec('gropp_sum','!tpp_gop_dred',GROPP.ZGP);
            _sum:=_sum-(GROPP.IL*_env_grop.GROP_IL)+(GROPP.IL*GROP.IL);
            {? _sum>GROPP.ZGP().ILOSC
            || FUN.info('Ilość ogółem w grupach operacji dla pozycji %1 przewodnika %2 (%3)\n'
                        'przekroczy ilość na przewodniku (%4).'@
                        [$GROPP.ZGP().NRP,GROPP.ZGP().NRZLP().NRPRZ,$_sum,$GROPP.ZGP().ILOSC]

               );
               _can_continue:=0;
               _ret:='IL'
            ?};
            _can_continue>0 & GROPP.next()
         !}
      ?}
   ?};
   {? _can_continue>0
   || {? VGROP.IL_STAN<2
      || _ret:=__CHK.record3(
            GROP,'KOD','Kod grupy'@,
            GROP,'TTOPER','Operacja'@,
            GROP,'IL',,
            VGROP,'GR_RES','Symbol zasobu'@
         )
      || _ret:=__CHK.record3(
            GROP,'KOD','Kod grupy'@,
            GROP,'TTOPER','Operacja'@,
            GROP,'IL',
         )
      ?}
   ?}
?};
_ret


\addGrOpp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: dołączenie pozycji do operacji grupowych
::  OLD: \addGrOpp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('czyModGrOp','!tpp_gop_dred')
|| ProgRef:=GROP.ref();
   GROP.cntx_psh();
   GROPP.cntx_psh();
   ZL.cntx_psh();
   ZGP.cntx_psh();
   ZGP.clear();

:: Tabela dostępnych stanowisk
   _tab_twrk:=sql('
      select
         TWRKPLC.REFERENCE as REF
      from
         GROPS join PL_RES join TWRKPLC
      where GROPS.GROP=:_a
   ',GROP.ref());
:: Tabela z wykluczonymi operacjami (które już są przypisane do grupy operacji)
   _tab_zgp:=sql('
      select
         ZGP.REFERENCE as REF,
         ZGP.ILOSC,
         sum(GROPP.IL*GROP.IL) as ILGRP
      from
         GROPP join GROP join ZGP
      group by
         ZGP.REFERENCE,ZGP.ILOSC
      having
         sum(GROPP.IL*GROP.IL)>=ZGP.ILOSC
      union
      select
         ZGP.REFERENCE as REF,
         ZGP.ILOSC,
         0 as ILGRP
      from
         GROPP join GROP join ZGP
      where
         GROPP.GROP=:_a
         and GROPP.ZL_WYR is NULL
   ',GROP.ref());
:: Tabela wykluczonych operacji w rozbiciu na wyroby
   _tab_wyr:=sql('
      select
         ZL_WYR.REFERENCE as REF
      from
         GROPP join GROP join ZL_WYR
      where GROPP.GROP=:_a
   ',GROP.ref());
   KOMM.init(250,,'Dodawanie operacji grupowych'@);
   _tab:=exec('zakrZgp','!tpp_gop_dred',GROP.TTOPER,_tab_twrk,_tab_zgp,_tab_wyr,GROP.ODDZ);
   exec('winZgp','!tpp_gop_dred',_tab);
   _tab.select();
::   ZGP.select();
::   exec('zakrZgp_del','!tpp_gop_dred');
   KOMM.select();

   ZGP.cntx_pop();
   ZL.cntx_pop();
   GROPP.cntx_pop();
   GROP.cntx_pop();
   win_disp()
?}


\editGrOpp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: poprawa pozycji do operacji grupowych
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRUPA='T' | exec('beGrOpp','!tpp_gop_dred')
|| {? VAR.GRUPA='T' | GROPP.edit()
   || {? VAR.GRUPA='T'
      || _dokl:={? GROPP.M<>null() || GROPP.M().DOKL || ST.DOKL ?};
         {? VAR.REAL=VAR.REAL$_dokl
         || GROPP.IL:=VAR.REAL;
            {? exec('gropp_il_chk','!tpp_gop_dred',VAR.REAL)
            || GROPP.put()
            ?}
         || KOMM.add(
               'Modyfikacja nieudana dla pozycji przewodnika %3- '
               'ilość po zaokrągleniu wg dokładności materiału (%1) różni się od ilości bazowej (%2).'
               [$(VAR.REAL$_dokl),$VAR.REAL,GROPP.ZGP().NRPRZ().NRPRZ]
            )
         ?}
      || GROPP.put()
      ?}
   ?}
?};
~~


\aktStanGr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: aktualizuje zapisy dla stanowiska jedynego stanowiska dla grupy operacji
::  OLD: \aktStanGr/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
exec('ileStanGr','!tpp_gop_dred');
{? VGROP.IL_STAN<=1
|| GROPS.cntx_psh();
   GROPS.index('GROP');
   GROPS.prefix(GROP.ref());
   {? GROPS.first()
   || _add:=0
   || _add:=1;
      GROPS.blank()
   ?};
   GROPS.PL_RES:=VGROP.GR_RES;
   GROPS.CZAS:=VGROP.GR_CZAS;
   GROPS.OPIS:=VGROP.GR_OPIS;
   GROPS.DATA:=GROP.DATA;
   GROPS.KOD:=VGROP.GR_RES().SYM;
   GROPS.IL:=GROP.IL;
   GROPS.PLAN:='T';
   GROPS.DEFAULT:='T';
   {? _add
   || GROPS.add()
   || GROPS.put()
   ?};
   GROPS.cntx_pop()
?};
1


\ileStanGr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: zlicza ile stanowisk ma grupa
::  OLD: \ileStanGr/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VGROP.IL_STAN:=0;
GROPS.cntx_psh();
GROPS.index('GROP');
GROPS.prefix(GROP.ref());
VGROP.IL_STAN:=GROPS.size();
GROPS.cntx_pop()


\czyModGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: czy mozna modyfikowac grupe operacji
::  OLD: \czyModGrOp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? GROP.STATUS='Z'
|| FUN.info('Grupa operacji zamknięta.'@);
   0
|? GROP.AKC='N'
|| 1
|? GROP.AKC='T'
|| FUN.info('Grupa operacji zaakceptowana.'@);
   0
|| FUN.emsg('Nie wybrano grupy operacji.'@);
   0
?}


\zakrZgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustawia zakres źrodłowych pozycji przewodnikow (operacji)
::   WE: _a - TTOPER.ref()
::       _b - tabela TWRKPLC.ref
::       [_c] - tabela ZGP.ref() - pozycje wykluczone (już dodane do GROP)
::       [_d] - tabela ZL_WYR.ref() - pozycje wykluczone (już dodane do GROP)
::       [_e] - tabela z listą operacji do dodania. Jeżeli przekazana to aktualizacja filtra, jeżeli nie przekazana, to
::              zostaje utworzona tabela
::       [_f] - oddział (domyślnie ST.ODDZ)
::       UWAGA: nie jest kontrolowana obecnosc i typy argumentow
::   WY: tabela z listą dostępnych operacji do przypisania
::  OLD: \zakrZgp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_ttoper:=_a;
_tab_twrk:=_b;
_tab_zgp:={? var_pres('_c')>100 || _c || ~~ ?};
_tab_wyr:={? var_pres('_d')>100 || _d || ~~ ?};
_tab:=~~;
_create:=1;
{? var_pres('_e')>100
|| _tab:=_e;
   _create:=0
?};
_oddz:={? var_pres('_f')=type_of('') || _f || ST.ODDZ ?};

::ZGP.f_set(
::   'NRZLP(NRPRZ),NRP',
::   'left join TOPER using(ZGP.TOPER,TOPER.REFERENCE)',
::   '
::    ZGP.TPZ=\'N\'
::       and
::    (ZGP.STATUS=\':_a\' or ZGP.STATUS=\':_b\' or ZGP.STATUS=\':_c\')
::       and
::    ZGP.PL_GRP=\'T\'
::       and
::    (TOPER.OPER=:_d)
::       and
::    (ZGP.PLACE in (select REF from :_e))
::       and
::    (ZGP.REFERENCE not in (select REF from :_f))
::   ',
::   exec('status_pending','zl_guide'),
::   exec('status_waiting','zl_guide'),
::   exec('status_new','zl_guide'),
::   _ttoper,
::   _tab_twrk,
::   _tab_zgp
::);
:: Utworzenie tabeli z listą dostępnych operacji
{? _create
|| _sql:='
      select
         ZGP.REFERENCE as ZGP,
         ZGP.OPIS,
         ZGP.PLACE,
         TWRKPLC.KOD AS PLACE_K,
         ZGP.ILOSC,
         ZGH.NRPRZ as ZGH_NR,
         ZGP.NRP,
         CASE WHEN M1.KTM<>\'\' THEN M1.KTM ELSE M2.KTM END as KTM,
         MG.SYM as MAG,
         EANL.KOD as LOK,
         CASE WHEN ZGP.DOK is not NULL THEN ZL_WYR.REFERENCE ELSE NULL END as ZL_WYR,
         ZGP.NTIME,
         ZL.SYM as "Zlecenie",
         ZL.DTR as "Data realizacji zlecenia",
         TTOPER.KOD as "Operacja"
      from ZGP
      left join TOPER using(ZGP.TOPER,TOPER.REFERENCE)
      left join TTOPER using(TOPER.OPER,TTOPER.REFERENCE)
      left join TWRKPLC using(ZGP.PLACE,TWRKPLC.REFERENCE)
      left join ZGH using(ZGP.NRZLP,ZGH.REFERENCE)
      left join ZL using(ZGP.ZL,ZL.REFERENCE)
      left join ZL_WYR using(ZL_WYR.ZL,ZL.REFERENCE)
      left join M as M1 using(ZL_WYR.KTM,M1.REFERENCE)
      left join M as M2 using(ZL.KTM,M2.REFERENCE)
      left join MG using (ZL_WYR.MG,MG.REFERENCE)
      left join EANL using (ZL_WYR.EANL,EANL.REFERENCE)
      where
         ZGP.TPZ=\'N\'
         and (ZGP.STATUS=\':_a\' or ZGP.STATUS=\':_b\' or ZGP.STATUS=\':_c\')
         and ZGP.PL_GRP=\'T\'
         and (TOPER.OPER=:_d)
         and ((ZL_WYR.REFERENCE is NULL) or (ZL_WYR.REFERENCE is not NULL and ZGP.DOK is not NULL) or
              (ZL_WYR.REFERENCE is not NULL and ZGP.DOK is NULL and M1.REFERENCE=M2.REFERENCE))
         and ZL.ODDZ=\':_e\'
   ';
   _tab:=sql(_sql,exec('status_pending','zl_guide'),exec('status_waiting','zl_guide'),exec('status_new','zl_guide'),
             _ttoper,_oddz);

   {? ~sec_superuser() || _tab.fld_attr(,2) ?};
   _tab.fld_attr('DATA',3)
?};
:: Nałożenie filtra
_tab.f_set(
   'ZGH_NR,NRP','',
   '
    (PLACE in (select REF from :_a))
      and
    (ZGP not in (select REF from :_b))
      and
    (ZL_WYR not in (select REF from :_c))
   ',
   _tab_twrk,
   _tab_zgp,
   _tab_wyr
);
_tab


\zakrZgp_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Kasuje zakres zrodlowych pozycji przewodnikow (operacji)
::  OLD: \zakrZgp_del/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.f_clear();
~~


\editGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: edycja grupy operacji
::  OLD: \editGrOp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env_grop:=params_get().env_grop;

{? GROP.STATUS='Z'
|| FUN.info('Grupa operacji zamknięta.'@)
|? GROP.AKC='T'
|| FUN.info('Grupa operacji zaakceptowana.'@)
|| exec('setGropsInfo','zl_grop');
   exec('grop_efld_opt','zl_grop');
   _env_grop.GROP_IL:=GROP.IL;
   {? GROP.edit("params_exec('chkGrOp','!tpp_gop_dred',exec('ilewyd','!tpp_gop_dred'))")
   ||
      do();
      {? GROP.put()
      || exec('aktStanGr','!tpp_gop_dred')
      ?};
      end()
   ?}
?}


\ilewyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: ile wydano materialow na program
::  OLD: \ilewyd/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
_ret


\delGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: usuniecie grupy operacji
::  OLD: \delGrOp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? GROP.STATUS='Z'
|| FUN.info('Grupa operacji zamknięta.'@)
|? GROP.AKC='T'
|| FUN.info('Grupa operacji zaakceptowana.'@)
|| _grop:=GROP.ref();
   {? exec('blk_lock','#table','GROP',_grop,,,'Grupa operacji %1 jest blokowana'@[GROP.KOD])
   || GROPP.cntx_psh();
      GROPP.index('GROP');
      GROPP.prefix(GROP.ref());
      {? (GROPP.first()=0 & FUN.ask('Usunąć grupę?'@)) |
         (GROPP.first() & FUN.ask('Grupa posiada pozycje. Czy usunąć?'@))
      ||
         do();
         PX_OBJ.index('GROP');
         PX_OBJ.prefix(_grop);
         {? PX_OBJ.first() || PX_OBJ.del() ?};
         {? GROPP.first() || {! |? GROPP.del() !} ?};
         DocLib.del('GROP',_grop);
         _ok:=exec('grop_limity_del','zl_limit1',GROP.ref());
         {? _ok || _ok:=exec('delStanGr','!tpp_gop_dred') ?};
         {? _ok || _ok:=GROP.del(,1) ?};
         end();
         {? ~_ok || FUN.info('Nie można usunąć grupy operacji.'@) ?}
      ?};
      GROPP.cntx_pop()
   ?};
   exec('blk_unlock','#table','GROP',_grop)
?}


\delStanGr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: usuwa stanowiska przypisane do grupy
::  OLD: \delStanGr/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=1;
GROPS.cntx_psh();
GROPS.index('GROP');
GROPS.prefix(GROP.ref());
_can_continue:=1;
{? GROPS.first()
|| {!
   |? _next:=0;
      _ref_nxt:=null();
      GROPS.cntx_psh();
      {? GROPS.next()
      || _ref_nxt:=GROPS.ref()
      ?};
      GROPS.cntx_pop();

      PX_STAGE.cntx_psh();
      PX_STAGE.index('GROPS');
      PX_STAGE.prefix(GROPS.ref());
      {? PX_STAGE.first()
      || {!
         |? _can_continue:=exec('PX_STAGE_del','px_stage',PX_STAGE.ref());
            PX_STAGE.first() & _can_continue>0
         !}
      ?};
      PX_STAGE.cntx_pop();

      {? _can_continue>0
      || _can_continue:=GROPS.del(,1)
      ?};

      {? _ref_nxt<>null()
      || _next:=GROPS.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};
GROPS.cntx_pop();
_ret


\akcGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: akceptacja grup operacji
::  OLD: \akcGrOp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TPP_GOP_EAKC';
_args.UIDREF:=GROP.uidref();
{? GROP.sel_size()>0
|| _args.GRUPA:='T'
?};
_args.PROC_START:='T';
_args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'GROP',GROP.ref());
exec('mp_run','#b__box',_args);
~~


\akcGrOp_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: akceptacja grup operacji - przed grupą rekordów
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ilosc:=GROP.sel_size();

_ask:=FUN.ask(
      'Ilość zaznaczonych grup operacji: %1.'@[$_ilosc]+'\n\n'+
      'Czy akceptować je wszystkie?'@);
{? _ask>0
|| sel_nchk();
   VAR.GRUPA:='T';
   KOMM.init(255,,'Akceptowanie grup operacji'@);
   _result:=1
?};
_result


\akcGrOp_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: akceptacja grup operacji - po grupie rekordów
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\wycGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: wycofanie akceptacji grup operacji
::----------------------------------------------------------------------------------------------------------------------
{? GROP.STATUS='Z'
|| FUN.info('Grupa operacji jest zamknięta.'@);
   return()
?};

{? GROP.ILW<>0
|| FUN.info('Zarejestrowano wykonania do grupy operacji.'@);
   return(0)
?};

GROPP.cntx_psh();
{? GROP.AKC='T'
|| {? GROP.ILP<>0 | GROP.PLAN_PX<>'N' | GROP.PLAN_PO='T'
   || FUN.info('Grupa operacji zaplanowana, nie można wycofać akceptacji.'@)
   |? FUN.ask('Czy wycofać akceptację grupy operacji?'@)
   || do();
      GROP.AKC:='N';
      {? GROP.put()
      || GROPS.cntx_psh();
         GROPS.index('GROP');
         GROPS.prefix(GROP.ref());
         {? GROPS.first()
         || {!
            |? GROPS.AKC:='N';
               GROPS.put();
               GROPS.next()
            !}
         ?};
         GROPS.cntx_pop()
      ?};
      end()
   ?}
|| FUN.info('Grupa operacji nie jest zaakceptowana.'@)
?};
GROPP.cntx_pop()


\chkCzasGrOps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: sprawdza wypelnienie czasu dla zasobow operacji grupowej
::   WE: [_a] - INTEGER - 0/1/2 - tryb wyświetlania dialogów, jeżeli nie podany to
::                                  ustalany na podstawie VAR.GRUPA
::  OLD: \chkCzasGrOps/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=1;

_dialog:=1;
{? VAR.GRUPA='T'
|| _dialog:=2
?};
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

GROPS.cntx_psh();
GROPS.index('GROP');
GROPS.prefix(GROP.ref);
{? GROPS.first()
|| {! |?
      {? GROPS.CZAS=time(0,0,0)
      || {? _dialog=2
         || KOMM.add('Grupa operacji \'%1\' - nie podany czas operacji grupowej.'@[GROP.KOD])
         |? _dialog=1
         || FUN.info('Nie podany czas operacji grupowej.'@)
         ?};
         _ret:=0
      ?};
      _ret & GROPS.next()
   !}
|| {? _dialog=2
   || KOMM.add('Grupa operacji \'%1\' - nie przypisano zasobów do grupy operacji.'@[GROP.KOD])
   |? _dialog=1
   || FUN.info('Nie przypisano zasobów do grupy operacji.'@)
   ?};
   _ret:=0
?};
GROPS.cntx_pop();
_ret


\filtrGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: filtr na operacje grupowe (tabela GROP)
::  OLD: \filtrGrOp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VGROP.win_edit('FILTR');

_ref:=GROP.ref();
_status:=VGROP.STATUS;
_user:=VGROP.USERS;
_masz:=VGROP.FLTR_RES;
_oper:=VGROP.TTOPER;

{? VGROP.edit()
||
   {? (_masz<>VGROP.FLTR_RES | _status<>VGROP.STATUS | _user<>VGROP.USERS | _oper<>VGROP.TTOPER)
   || exec('grop_f_set','zl_grop')
   ?}
|| VGROP.STATUS:=_status;
   VGROP.USERS:=_user;
   VGROP.FLTR_RES:=_masz;
   VGROP.TTOPER:=_oper;
   ~~
?};

GROP.f_seek(_ref);
~~


\brGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: rekord przed dla grupy operacji
::  OLD: \brGrOp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
exec('rekprzed','color','GROP#01')


\legenda_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Legenda w oknie wertowania tabeli GROP
::  OLD: \legenda_grop/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','GROP#01','GROP#02')


\legenda_gropp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Legenda w oknie wertowania tabeli GROPP
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','#ZL#03','#ZL#05')


\gropp_il_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redakcji pola GROPP.IL
::   WY: 0 / 1
::  OLD: \gropp_il_ae/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
{? fld()<=0
|| FUN.info('Należy wpisać wartość większą od zera.'@)
|| _ok:=exec('gropp_il_chk','!tpp_gop_dred',fld())
?};
_ok


\gropp_il_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy nowa ilość na pozycji grupy (GROPP.IL) jest prawidłowa (nie przekroczy ilości na przewdonikach).
::       Działa na bierzącym buforze tabeli GROPP
::       Wykorzysywana w formule Po redakcji pola GROPP.IL oraz formułach walidujących
::   WE: _a - REAL - nowa ilość na pozycji
::       [_b] - INTEGER - tryb walidacji: 1 - tylko sprawdzać [0] - sprawdzać + aktualizacja dodatkowych pól
::       [_c] - INTEGER - czy wyświetlać komunikaty [1] - tak, 0 - nie
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_fld:=_a;
_ok:=0;
_chk_only:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_dialog:={? var_pres('_c')=type_of(0) || _c || 1 ?};

_sum:=exec('gropp_sum','!tpp_gop_dred',GROPP.ZGP);
GROPP.cntx_psh();
{? GROPP.get() || _sum-=(GROPP.IL*GROP.IL) ?};
GROPP.cntx_pop();
{? _sum+(_fld*GROP.IL)>GROPP.ZGP().ILOSC
|| {? _dialog>0
   || {? VAR.GRUPA='T'
      || _ok:=0;
         KOMM.add(
               'Modyfikacja nieudana dla pozycji przewodnika %3- '
               'ilość po modyfikacji (%1) przekroczyłaby ilość na przewodniku (%2).'
               [$(_sum+(_fld*GROP.IL)),$GROPP.ZGP().ILOSC,GROPP.ZGP().NRPRZ().NRPRZ]
            )
      ||
         {? FUN.ask(
               'Ilość ogółem w grupach operacji dla tej pozycji przewodnika (%1)\n'
               'przekroczy ilość na przewodniku (%2).\n\n'
               'Czy na pewno wpisać tę ilość?'@
               [$(_sum+(_fld*GROP.IL)),$GROPP.ZGP().ILOSC]
            )
         || _ok:=1
         ?}
      ?}
   || _ok:=0
   ?}
|| _ok:=1
?};

{? _ok & _chk_only=0
||
:: Czas planowany
   _ilZgh:=ZGP.ILOSC;
   _coef:={? _ilZgh=0 || 1 || GROPP.IL/_ilZgh ?};
   _ilH:={? _coef
         || {? ZGP.MTIME
            || ZGP.MTIME*_coef
            || ZGP.NTIME*_coef
            ?}
         || 0
         ?};
   GROPP.CZAS:=exec('min2time','#convert',_ilH*60);
   GROPP.CZASM:=exec('time2min','#convert',GROPP.CZAS)
?};
_ok


\gropp_il_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Format wyswietlania pola GROPP.IL
::  OLD: \gropp_il_fd/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
'out_prec='+{? GROPP.M<>null() || $GROPP.M().DOKL || $ST.DOKL ?}


\gropp_il_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Format redagowania pola GROPP.IL
::  OLD: \gropp_il_fe/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
'in_prec='+$GROPP.M().DOKL


\gropp_sum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca ilosc w grupach dla pozycji przewodnika
::   WE: _a - ZGP.ref() - nie jest sprawdzany typ i wartosc parametru
::  OLD: \gropp_sum/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_sum:=0;
GROPP.cntx_psh(); GROP.cntx_psh();
GROPP.index('ZGP');
GROPP.prefix(_a);
{? GROPP.first()
|| {!
   |? _sum+=GROPP.IL*GROPP.GROP().IL;
      GROPP.next()
   !}
?};
GROPP.cntx_pop(); GROP.cntx_pop();
_sum


\bvGrOpp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: przed wyswietleniem pozycji przewodnika
::  OLD: \bvGrOpp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
GROPP.ZGP().NRZLP();
GROPP.ZGP().TOPER();
''


\beGrOpp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: przed popraw dla GROPP
::  OLD: \beGrOpp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? GROP.TYP='G'
|| exec('czyModGrOp','!tpp_gop_dred')
|| FUN.info('Grupa operacji klonowana, edycja pozycji niemożliwa.'@);
   0
?}


\beGrOpp_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: przed popraw dla GROPP dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? exec('beGrOpp','!tpp_gop_dred')
|| _red:=VAR.mk_edit('Uzupełnij dane'@,,'begroppbg',,,'normal');
   VAR.win_efld(_red,,'REAL',,,,ST.DOKL,,'Ilość'@);
   exec('ok_esc','#window',VAR,_red);
   VAR.efld_opt(_red,'mark=1',,'REAL');
   VAR.win_edit(_red);
   _valid:="
      _res:='';
      {? VAR.REAL<=0
      || FUN.info('Należy wpisać wartość większą od zera.'@);
         _res:='REAL'
      ?};
      _res
   ";
    VAR.REAL:=0;
   {? VAR.edit(_valid)
   || sel_nchk();
      VAR.GRUPA:='T';
      KOMM.init(255,,'Modyfikacja pozycji grup operacji'@);
      _result:=1
   ?}
?};
_result


\beGrOpp_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: po popraw dla GROPP dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\bdGrOpp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: przed usun dla GROPP
::  OLD: \bdGrOpp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? GROP.TYP='G'
|| exec('czyModGrOp','!tpp_gop_dred')
|| FUN.info('Grupa operacji klonowana, usunięcie pozycji niemożliwe.'@);
   0
?}


\blGrop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: GROP.ref
::  OLD: \blGrop/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
GROP.ref()


\beGrOpKod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: przed redakcja GROPS.KOD
::   WY: 1
::  OLD: \beGrOpKod/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? GROPS.KOD=''
|| GROPS.KOD:=GROPS.PL_RES().SYM
?};
1


\addGrOps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: Dodaj dla zasobow grup operacji
::  OLD: \addGrOps/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? GROP.AKC=''
|| FUN.emsg('Nie wybrano grupy operacji.'@)
|? GROP.STATUS='Z'
|| FUN.info('Grupa operacji zamknięta.'@)
||
   GROPS.win_edit('RED');
   GROPS.blank();
   {? GROPS.edit("exec('chkGrOps','!tpp_gop_dred',0)")
   || {? GROPS.add() & GROPS.size()=1 & GROPS.KOD<>GROPS.GROP().KOD & FUN.ask('Aktualizować kod grupy operacji?'@)
      || GROP.KOD:=GROPS.KOD;
         GROP.put()
      ?}
   ?};
   exec('actualize_grops','!tpp_gop_dred',GROP.ref());
   exec('actualize_grop','!tpp_gop_dred',GROP.ref());
   grp_disp(GROP,'WER')
?};
0


\chkGrOps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: rekord po GROPS
::   WE: [_a] - [0] - dołącz, 1 - popraw
::  OLD: \chkGrOps/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_put:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_czas:=exec('time2min','#convert',GROPS.CZAS);

{? exec('itsPositive','#field',0,'T',_czas)=0
|| _ret:='CZAS'
|| _ret:=__CHK.record(GROPS,,'PL_RES','KOD')
?};
{? _ret=''
||
:: Sprawdzenie unikalności zasobu
   _ref:={? _put>0 || GROPS.ref() || null() ?};
   GROPS.cntx_psh();
   GROPS.index('GROPRES');
   GROPS.prefix(GROPS.GROP,GROPS.PL_RES);
   {? GROPS.first()
   || {? _put=0 | (_put>0 & {? _ref=GROPS.ref() || GROPS.next() || 1 ?} )
      || _ret:='PL_RES';
         FUN.info('Do grupy przypisano już zasób o symbolu \'%1\'.'@[GROPS.PL_RES().SYM])
      ?}
   ?};
   GROPS.cntx_pop()
?};
_ret


\editGrOps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: Popraw dla GROPS
::  OLD: \editGrOps/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_ok:=exec('chkEditGrOps','!tpp_gop_dred');
{? _ok
|| GROPS.cntx_psh();
   GROPS.win_edit('RED');
   {? GROPS.edit("exec('chkGrOps','!tpp_gop_dred',1)")
   || {? GROPS.put()
      || {? GROPS.size()=1 & GROPS.KOD<>GROPS.GROP().KOD & FUN.ask('Aktualizować kod grupy operacji?'@)
         || GROP.KOD:=GROPS.KOD;
            GROP.put()
         ?};
         grp_disp(GROP,'WER')
      ?}
   ?};
   GROPS.cntx_pop()
?};
grp_disp(GROP,'WER');
0


\chkEditGrOps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: sprawdza czy mozna edytowac rekord GROPS
::   WY: 0/1
::  OLD: \chkEditGrOps/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=1;
{? GROP.STATUS='Z'
|| FUN.info('Grupa operacji zamknięta.'@);
   _ret:=0
|? exec('grops_planned','po_ogr')
|| _ret:=0;
   FUN.info('Grupa operacji na zasobie %1 została już zaplanowana.'@[GROPS.PL_RES().SYM])
?};
{? _ret & GROPS.AKC='T'
|| FUN.info('Zasób zaakceptowany.'@);
   _ret:=0
?};
_ret


\delGrOps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: Usuwa powiazanie operacji grupowej z zasobem
::  OLD: \delGrOps/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_ok:=exec('chkEditGrOps','!tpp_gop_dred');
{? _ok
|| {? FUN.ask('Usunąć powiązanie z zasobem?'@)
   || _grop:=GROPS.GROP;

      PX_STAGE.cntx_psh();
      PX_STAGE.index('GROPS');
      PX_STAGE.prefix(GROPS.ref());
      {? PX_STAGE.first()
      || {!
         |? _can_continue:=exec('PX_STAGE_del','px_stage',PX_STAGE.ref());
            PX_STAGE.first() & _can_continue>0
         !}
      ?};
      PX_STAGE.cntx_pop();

      GROPS.del();
      exec('actualize_grops','!tpp_gop_dred',_grop);
      exec('actualize_grop','!tpp_gop_dred',_grop);
      GROP.f_rfresh()
   ?}
?};
grp_disp(GROP,'WER');
0


\bvCzasGrOper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: przed wyswietleniem czasu dla operacji grupowej
::  OLD: \bvCzasGrOper/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VGROP.IL_STAN<2


\bvGropsInfo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: przed wyswietleniem pol zmiennej VGROP w okienku dodawania/edycji GROP
::  OLD: \bvGropsInfo/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? VGROP.IL_STAN<2
|| ''
|| 0
?}


\beGropsInfo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: przed redakcją pól zmiennej VGROP w okienku dodawania/edycji GROP
::  OLD: \beGropsInfo/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='GR_RES'
|| {? VGROP.FLTR_RES<>null()
   || 0
   || {? VGROP.IL_STAN<2 & -menu_txt()='popraw'
      || _edit:=1;
         GROPS.cntx_psh();
         GROPS.index('GROP');
         GROPS.prefix(GROP.ref());
         {? GROPS.first() & GROPS.AKC='T' || _edit:=0 ?};
         GROPS.cntx_pop();
         _edit
      || VGROP.IL_STAN<2
      ?}
   ?}
|| {? VGROP.IL_STAN<2 & -menu_txt()='popraw'
   || _edit:=1;
      GROPS.cntx_psh();
      GROPS.index('GROP');
      GROPS.prefix(GROP.ref());
      {? GROPS.first() & GROPS.AKC='T' || _edit:=0 ?};
      GROPS.cntx_pop();
      _edit
   || VGROP.IL_STAN<2
   ?}
?}


\f3czas
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: F3 na polach TIME
::  OLD: \f3czas/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
undefine();
define('CZAS',exec('time2min','#convert',fld()),'Podaj czas operacji w minutach'@,,,10,2);
def_btn('text=%1'['Zapisz'@],'key:F2');
def_btn('text=%1'['Anuluj'@],'key:Esc');
{? def_edit("exec('itsPositive','#field',1,'T',DEFINE.CZAS)",FUN.TYT)
|| fld(exec('min2time','#convert',DEFINE.CZAS))
?};
undefine();
~~


\feGropsInfo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format redagowania pól zmiennej VGROP w okienku dodawania/edycji GROP
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='GR_CZAS'
|| 'hour_chars='+$exec('hour_chars','!tpp_gop_dred')
|| ''
?}


\fdGropsInfo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format wyświetlania pól zmiennej VGROP w okienku dodawania/edycji GROP
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='GR_CZAS'
|| 'hour_chars='+$exec('hour_chars','!tpp_gop_dred')
|| ''
?}


\aeVGropKod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: po redkacji pola VGROP.KOD
::  OLD: \aeVGropKod/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? GROP.KOD=''
|| GROP.KOD:=VGROP.GR_KOD
?};
1


\bvZasGr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: wyswietla zasob grupy
::  OLD: \bvZasGr/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VGROP.IL_STAN


\rfrGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: po odświeżeniu okienka GROP.WER w grupie
::  OLD: \rfrGrOpp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? GROP.sel_size()=0
|| {? GROP.f_size()=0 || _blank:=1 || _blank:=0 ?}
|| _blank:=0
?};

GROPP.index('GROP');
GROPP.prefix({? _blank || null() || GROP.ref() ?});
GROPP.first();
grp_disp(GROPP,'WER',1);

GROPS.index('GROP');
GROPS.prefix({? _blank || null() || GROP.ref() ?});
GROPS.first();
grp_disp(GROPS,'WER',1);

_grayed:=':';
{? GROP.AKC='T'
|| _grayed:='PU'+{? GROP.sel_size()=0 || 'A' || '' ?}+_grayed
|| _grayed:='W'+{? GROP.sel_size()=0 || 'N' || '' ?}+_grayed
?};
{? GROP.STATUS='Z'
|| _grayed:='PUW'+{? GROP.sel_size()=0 || 'NAZ' || '' ?}+_grayed
|| _grayed:={? GROP.sel_size()=0 || 'O' || '' ?}+_grayed
?};
::-------------------------------------------------------------------------
:: Tymczasowo (wersja 23.25) nie udostępniamy akcji R&ealizacja->Robo&cizna
GROP.actions('WER','E(C)',,1);
::-------------------------------------------------------------------------
GROP.actions_grayed('WER',_grayed);
~~


\rfrGrOpp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: po odświeżeniu okienka GROPP.WER w grupie
::----------------------------------------------------------------------------------------------------------------------
_grayed:=':';
{? GROP.AKC='T' || _grayed:='Dpu'+_grayed+'D' ?};
{? GROP.STATUS='Z' || _grayed:='Dpu'+_grayed+'D' ?};
GROPP.actions_grayed('WER',_grayed);
~~


\rfrGrOps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: po odświeżeniu okienka GROPS.WER w grupie
::----------------------------------------------------------------------------------------------------------------------
_grayed:=':';
{? GROPS.AKC='T' || _grayed:='PUA'+_grayed || _grayed:='W'+_grayed ?};
{? GROP.AKC='T' || _grayed:='DPUAW'+_grayed+'D' ?};
{? GROP.STATUS='Z' || _grayed:='DPUAW'+_grayed ?};
GROPS.actions_grayed('WER',_grayed);
~~


\bsGrOpp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed obsługą okienka GROPP.WER w grupie
::----------------------------------------------------------------------------------------------------------------------
{? grp_empty(GROP,'WER') || '#disable' || '' ?}


\bsGrOps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed obsługą okienka GROPS.WER w grupie
::----------------------------------------------------------------------------------------------------------------------
{? grp_empty(GROP,'WER') || '#disable' || '' ?}


\winZgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: przygotowuje okienko dodawania pozycji przewodnika do operacji grupowych
::   WE: _a - tabela tymczasowa z dostępnymi operacjami, dla którego utworzyć okno
::  OLD: \winZgp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
::_tab:=ZGP;
_winZgpGO:=_tab.mk_sel('Operacje'@,'P',0,'sadaydtua',1,,,,'U',,,,,'html_maximized');
_tab.win_fld(_winZgpGO,,'ZLECENIE',,,20,,,'Zlecenie'@);
_tab.win_fld(_winZgpGO,,'KTM',,,25,,,'Indeks materiałowy'@);
_tab.win_fld(_winZgpGO,,'ZGH_NR',,,,,,'Przewodnik'@);
_tab.win_fld(_winZgpGO,,'NRP',,,-3,,,'Pozycja'@);
_tab.win_fld(_winZgpGO,,'OPERACJA',,,20,,,'Operacja'@);
_tab.win_fld(_winZgpGO,,'OPIS',,,20,,,'Opis'@);
_tab.win_fld(_winZgpGO,,'PLACE_K',,,,,,'Stanowisko'@);
_tab.win_fld(_winZgpGO,,'NTIME',,,12,5,,'Norma czasowa'@);
_tab.win_fld(_winZgpGO,,'ILOSC',,,12,ST.DOKL_P,,'Ilość'@);
_tab.win_fld(_winZgpGO,VAR,'REAL2',,,12,ST.DOKL_P,,'W grupach'@);
_tab.win_act(_winZgpGO,,'Formuła','Wybierz'@@,,,"exec('addZgp2GrOp','!tpp_gop_dred')",,1,1,,"sel_exit()",'W');
_tab.win_act(_winZgpGO,,'Formuła','Grupy'@@,,,"exec('zgp_gropp','!tpp_gop_dred')",,,,,,'G');
_tab.win_act(_winZgpGO,0,'Formuła','Filtr'@@,,,"exec('zgp_filtr','!tpp_gop_dred')",,,,,,'F');
_tab.win_act(_winZgpGO,1,'Formuła','Filtr'@@,,,"exec('zgp_filtr','!tpp_gop_dred')",,1,,,,'F');
_formula:="
   _tab:=cur_tab(1,1);
   _zl:=exec('FindAndGet','#table',ZGP,_tab.ZGP,,\"ZGP.ZL\",null());
   ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_zl)
   || exec('zzam','zl_gen',0)
   ?};
   ZL.cntx_pop();
   ~~
";
_tab.win_act(_winZgpGO,,'Formuła','Dane źródłowe &zlecenia'@@,,,_formula,,,,,,'Z');
_tab.win_act(_winZgpGO,,'Kolejność');
_formula:="exec('legenda','color','#ZGP#01','ZGP#02#','#ZL#05','#ZL#03')";
_tab.win_act(_winZgpGO,,'Formuła','Legenda'@@,,,,_formula,,,,,'L');
_tab.win_act(_winZgpGO,,'Rekord',,,,"exec('bvZgp','!tpp_gop_dred')");
_before:="
   ZGP.display();
   ~~
";
_tab.win_act(_winZgpGO,,'Wyświetl',,,,_before);
_tab.win_fml(_winZgpGO,,'OPERACJA',,'ICON_BEFORE',"exec('icon_status','zl_guide',ZGP.STATUS)",2);
_tab.win_fml(_winZgpGO,,'ZLECENIE',,'ICON_BEFORE',"ZGH.ZLEC(); exec('icon_stan','zl_head')",2);
::_fd:="
::   _tab:=cur_tab(1,1);
::   _format:='';
::   {? ZGP.seek(_tab.ZGP)
::   ||
::      ZGP.NRZLP().ZLEC();
::      _format:='out_prec='+$ZL.KTM().DOKL
::   ?};
::   _format
::";
::VAR.fld_fml('REAL2','DISPLAY_FORMAT',_fd);
_tab.win_sel(_winZgpGO);
~~


\addZgp2GrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: dodaje pozycje przewodnika do grupy operacji
::----------------------------------------------------------------------------------------------------------------------
:: Czy w grupie są już elementy, a jeżeli tak, to czy dla brygady czy nie
Cntx.psh(GROPP,ZGP);
GROPP.index('GROP');
GROPP.prefix(ProgRef);
{? GROPP.first()
|| _bryg:=GROPP.ZGP().BRYG
|| _bryg:=''
?};
Cntx.pop(GROPP,ZGP);

_can_continue:=1;
_il:=0;
_tab:=cur_tab(1,1);

:: Podczytanie ZGP
{? ~ZGP.seek(_tab.ZGP)
|| _can_continue:=0
?};

:: Sprawdzam czy ZGP nie jest już przypadkiem w planie - jeśli tak to nie mogę go dodać do grupy
{? _can_continue>0 & exec('zgp_planned','po_plan',ZGP.ref())>0
|| _can_continue:=0;
   _msg:='Pozycja przewodnika \'%1 - %2. %3\' znajduje się już w planie. Dodanie jej do grupy niemożliwe.'@
         [ZGP.NRZLP().NRPRZ,$ZGP.NRP,ZGP.OPIS];
   {? _tab.sel_size()=0
   || FUN.emsg(_msg)
   || KOMM.add(_msg,2,,1)
   ?}
?};

:: Sprawdzenie, czy ZGP nie ma już przypadkiem zarejestrowanego wykonania - jeśli tak to nie mogę go dodać do grupy
{? _can_continue>0
|| {? exec('spr_akord','zl_guide',ZGP.ref(),1)=0
   || _can_continue:=0;
      _msg:='Pozycja przewodnika \'%1 - %2. %3\' ma zarejestrowane wykonania. Dodanie jej do grupy niemożliwe.'@
            [ZGP.NRZLP().NRPRZ,$ZGP.NRP,ZGP.OPIS];
      {? _tab.sel_size()=0
      || FUN.emsg(_msg)
      || KOMM.add(_msg,2,,1)
      ?}
   ?}
?};

:: Sprawdzenie, czy grupa nie posiada już operacji z danego przewodnika - jeśli posiada to nie mogę go dodać do grupy
{? _can_continue>0
|| _zgp:=ZGP.ref();
   _zgh:=ZGP.NRPRZ;
   Cntx.psh(GROPP,ZGP);
   GROPP.index('GROP');
   GROPP.prefix(ProgRef);
   {? GROPP.first()
   || {!
      |?
         {? GROPP.ZGP().NRPRZ=_zgh & GROPP.ZGP<>_zgp
         || _can_continue:=0;
            _msg:='Pozycja przewodnika \'%1 - %2. %3\' - do grupy przypisana jest już operacja '
                  'pochodząca z tego przewodnika. Dodanie do grupy niemożliwe.'@
                  [ZGP.NRZLP().NRPRZ,$ZGP.NRP,ZGP.OPIS];
            {? _tab.sel_size()=0
            || FUN.emsg(_msg)
            || KOMM.add(_msg,2,,1)
            ?}
         ?};
         _can_continue>0 & GROPP.next()
      !}
   ?};
   Cntx.pop(GROPP,ZGP)
?};

{? _can_continue>0
||
:: Wlasciwe dodawania
   {? _tab.sel_size()=0
   || {? _bryg='' | _bryg=ZGP.BRYG
      || _valid:="
            _val:=cur_tab(1,1).VAL;
            {? _val<=0
            || FUN.info('Należy wpisać wartość większą od zera.'@);
               0
            || _sum:=exec('gropp_sum','!tpp_gop_dred',ZGP.ref());
               {? _sum+(_val*GROP.IL)>ZGP.ILOSC
               || {? FUN.ask(
                        'Ilość ogółem w grupach operacji dla tej pozycji przewodnika (%1)\n'
                        'przekroczy ilość na przewodniku (%2).\n\n'
                        'Czy na pewno wpisać tę ilość?'@
                        [$(_sum+(_val*GROP.IL)),$ZGP.ILOSC]
                     )
                  || 1
                  || 0
                  ?}
               || 1
               ?}
            ?}
         ";
::         _il:=exec('edit_number','#edit',0,'Podaj ilość dla jednego uruchomienia'@,ZGP.ZL().KTM().DOKL,,,_valid)
::       Wyznaczenie ilości pozostałej dla operacji
         _il:=exec('gropp_ilosc','!tpp_gop_dred',
            {? _tab.ZL_WYR<>'' || exec('FindAndGet','#table',ZL_WYR,_tab.ZL_WYR,,"ZL_WYR.KTM",null()) || null() ?});
         undefine();
         define('H1',~~,'Ilość uruchomień: %1'@[$GROP.IL]);
         define('VAL',_il,'Ilość dla jednego uruchomienia'@,,15,,ZGP.ZL().KTM().DOKL);
         define('H2',~~,'');
         _btn:=def_btn('text=%1'['Zapisz'@],'key:F2');
         def_bopt(_btn,'default=1');
         def_btn('text=%1'['Anuluj'@],'key:Esc');
         {? def_edit(_valid,FUN.TYT)
         || _il:=DEFINE.VAL
         || _il:=~~
         ?}

      || FUN.emsg(
            {? _bryg='T'
            || 'Operacja dodawana do tej grupy musi być wykonywana przez brygadę.'@
            || 'Operacja dodawana do tej grupy musi być wykonywana przez pojedynczego pracownika.'@
            ?}
         )
      ?}
   ?};

   {? _tab.sel_size()>0 | _il>0
   ||
      {? _bryg='' | _bryg=ZGP.BRYG
      ||
         GROPP.cntx_psh();
         GROPP.prefix();
         ZL.cntx_psh();
         ZL.prefix();

         ZGP.NRZLP().ZLEC();
         GROPP.GROP:=ProgRef;
         GROPP.ZL:=ZL.ref();
         {? _tab.ZL_WYR<>''
         || GROPP.ZL_WYR:=exec('FindAndGet','#table',ZL_WYR,_tab.ZL_WYR,,,null())
         ?};
         GROPP.M:={? GROPP.ZL_WYR<>null() || GROPP.ZL_WYR().KTM || ZL.KTM ?};
         GROPP.ZGP:=ZGP.ref();
         _p500120:=exec('get','#params',500120,2);
::       Wyznaczenie ilości pozostałej dla operacji (tutaj tylko gdy operacja grupowa)
         {? _p500120='T' & _tab.sel_size()>0
         || _il:=exec('gropp_ilosc','!tpp_gop_dred',GROPP.M)
         ?};
         GROPP.IL:=_il;

::       Czas planowany
         _ilZgh:=ZGP.ILOSC;
         _coef:={? _ilZgh=0 || 1 || GROPP.IL/_ilZgh ?};
         _ilH:={? _coef
               || {? ZGP.MTIME
                  || ZGP.MTIME*_coef
                  || ZGP.NTIME*_coef
                  ?}
               || 0
               ?};
         GROPP.CZAS:=exec('min2time','#convert',_ilH*60);
         GROPP.CZASM:=exec('time2min','#convert',GROPP.CZAS);

         _can_add:=1;
         _added:=0;
         _zl_wyr:=GROPP.ZL_WYR;
::       Sprawdzenie unikalności dołączanej pozycji
         GROPP.cntx_psh();
         GROPP.index('ZGP');
         GROPP.prefix(ZGP.ref(),ProgRef,_zl_wyr);
         {? GROPP.first()
         || _can_add:=0;
             KOMM.add('Operacja (%1 - %2) już występuje w grupie.'@[ZGP.NRZLP().NRPRZ,$ZGP.NRP])
         ?};

         GROPP.cntx_pop();
         {? _can_add>0
         || _added:=GROPP.add(1)
         ?};

         {? _added>0
         || exec('dir_update','zl_grop',GROPP.GROP);
            exec('termin_update','zl_grop',GROPP.GROP)
         ?};

         ZL.cntx_pop();
         GROPP.cntx_pop();
         ~~
      || KOMM.add(
            {? _bryg='T'
            || 'Operacja (%1 - %2) dodana do tej grupy musi być wykonywana przez brygadę.'@
               [ZGP.NRZLP().NRPRZ,$ZGP.NRP]
            || 'Operacja (%1 - %2) dodana do tej grupy musi być wykonywana przez pojedynczego pracownika.'@
               [ZGP.NRZLP().NRPRZ,$ZGP.NRP]
            ?}
         )
      ?}
   ?}
?};

{? _tab.sel_size()=0 & _il>0
|| sel_exit()
?}


\zgp_gropp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyswietla grupy operacji, do ktorych przypisana jest pozycja przewodnika
::       Działa na aktualnym buforze tabeli ZGP i ZL_WYR
::  OLD: \zgp_gropp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
GROP.cntx_psh(); GROPP.cntx_psh();
GROPP.index('ZL_WYR');
GROPP.prefix(ZL_WYR.ref(),ZGP.ref());
_wer:=exec('win_gropp','!tpp_gop_dred');
GROPP.win_sel(_wer);
GROPP.select();
GROP.cntx_pop(); GROPP.cntx_pop();
~~


\zl_gropp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Wyswietla grupy operacji, do ktorych przypisane jest zlecenie
::   WE: [_a] - INTEGER - 0/1 - rekurencja
::----------------------------------------------------------------------------------------------------------------------
{? ZL.RODZAJ<>'P'
|| _tab:=tab_tmp(3,
      'ZL','STRING[100]','Zlecenie',
      'KOD','STRING[100]','Kod',
      'GROPP','STRING[16]','Ref SQL pozycji grupy',
      'ZL_REF','STRING[16]','Ref SQL zlecenia',
      'AKC','STRING[1]','Akceptacja',
      'OPIS','STRING[100]','Kod',
      'IL','REAL','Ilość',
      'IL_URUCH','REAL','Ilość uruchomień',
      'IL_ALL','REAL','Ilość całkowita',
      'ZGP_NR','STRING[30]','Przewodnik',
      'ZGP_OP','STRING[100]','Operacja'
   );
   exec('zl_gropp_load','!tpp_gop_dred',_tab);
   _wer:=_tab.mk_sel('Grupy operacji'@,'N',0,'zl_gropzl',,,20,,'U');
   _tab.win_fld(_wer,,'AKC',,,-10,,,'Zaakceptowana'@,,,2,,"'T'","'N'");
   _tab.win_fld(_wer,,'ZL',,,15,,,'Zlecenie'@);
   _tab.win_fld(_wer,,'KOD',,,20,,,'Kod'@);
   _tab.win_fld(_wer,,'OPIS',,,20,,,'Opis'@);
   _tab.win_fld(_wer,,'ZGP_NR',,,20,,,'Przewodnik'@);
   _tab.win_fld(_wer,,'ZGP_OP',,,30,,,'Operacja'@);
   _tab.win_fld(_wer,,'IL',,,15,,,'Ilość'@);
   _tab.win_fld(_wer,,'IL_URUCH',,,15,,,'Ilość uruchomień'@);
   _tab.win_fld(_wer,,'IL_ALL',,,15,,,'Ilość całkowita'@);
   _tab.win_sel(_wer);

   _fd:="
      _dokl:=ST.DOKL;
      ZL.cntx_psh(); ZL.prefix();
      {? ZL.seek(cur_tab(1,1).ZL_REF)
      || {? ZL.KTM<>null()
         || _dokl:=ZL.KTM().DOKL
         ?}
      ?};
      ZL.cntx_pop();
      'out_prec=%1'[$_dokl]
   ";
   _tab.fld_fml('IL','DISPLAY_FORMAT',_fd);
   _tab.fld_fml('IL_URUCH','DISPLAY_FORMAT',_fd);
   _tab.fld_fml('IL_ALL','DISPLAY_FORMAT',_fd);
   _tab.select();
   ~~
|| exec('zl_gropp_simple','!tpp_gop_dred')
?};
~~


\zl_gropp_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Ładuje do tabelki dane do podlądu grup operacji dla zlecenia złożonego
::       Kontekst działania - ZL.ref
::   WE:  _a - tab_tmp - tablica tymczasowa
::       [_b] - INTEGER - 0/1 - rekurencja
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_rec:=0;
{? var_pres('_b')=type_of(0)
|| _rec:=_b
?};

ZGP.cntx_psh();
ZGH.cntx_psh();
GROP.cntx_psh();
GROPP.cntx_psh();
GROPP.index('ZL');

GROPP.prefix(ZL.ref());
{? GROPP.first()
|| {!
   |? _tab.blank();
      _tab.ZL:=ZL.SYM;
      _tab.ZL_REF:=$ZL.ref();
      _tab.GROPP:=$GROPP.ref();
      _tab.AKC:=GROPP.GROP().AKC;
      _tab.KOD:=GROP.KOD;
      _tab.OPIS:=GROP.OPIS;
      _tab.IL:=GROPP.IL;
      _tab.IL_URUCH:=GROP.IL;
      _tab.IL_ALL:=GROP.IL*GROPP.IL;
      _tab.ZGP_NR:=GROPP.ZGP().NRPRZ().NRPRZ;
      _tab.ZGP_OP:=GROPP.ZGP().OPIS;
      _tab.add();
      GROPP.next()
   !}
?};

ZL.cntx_psh();
ZL.index('TREEMTU');
ZL.prefix(ZL.ref());
{? ZL.first()
|| {? ZL.first()
   || {!
      |?
         exec('zl_gropp_load','!tpp_gop_dred',_tab,1);
         ZL.next()
      !}
   ?}
?};
GROP.cntx_pop();
GROPP.cntx_pop();
ZL.cntx_pop();
ZGP.cntx_pop();
ZGH.cntx_pop();
~~


\zl_gropp_simple
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Wyswietla grupy operacji, do ktorych przypisane jest zlecenie
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
GROP.cntx_psh(); GROPP.cntx_psh();
GROPP.index('ZL');
GROPP.prefix(ZL.ref());
_wer:=exec('win_gropp','!tpp_gop_dred');
GROPP.win_sel(_wer);
GROPP.select();
GROP.cntx_pop(); GROPP.cntx_pop();
~~


\win_gropp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Tworzy okienko GROPP
::   WY: STRING - akronim okienka
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_wer:=GROPP.mk_sel('Grupy operacji'@,'N',0,'zgp_gropp',,,20,,'U',,,,,'html_maximized');
GROPP.win_fld(_wer,GROP,'AKC',,,-10,,,'Zaakceptowana'@,,,2,,"'T'","'N'");
GROPP.win_fld(_wer,,'GROP','KOD');
GROPP.win_fld(_wer,,'GROP','OPIS',,20);
GROPP.win_fld(_wer,ZGH,'NRPRZ',,,20,,,'Przewodnik'@);
GROPP.win_fld(_wer,,'M','KTM',,20,,,'Produkt'@);
GROPP.win_fld(_wer,ZGP,'OPIS',,,30,,,'Operacja'@);
GROPP.win_fld(_wer,,'IL',,,15,,,'Ilość'@);
GROPP.win_fld(_wer,GROP,'IL',,,15,,,'Ilość uruchomień'@);
GROPP.win_fld(_wer,VGROP,'IL',,,15,,,'Ilość całkowita'@);
GROPP.win_act(_wer,,'Rekord',,,,"VGROP.IL:=GROPP.IL*GROPP.GROP().IL;GROPP.ZGP().NRPRZ();~~");
_wer


\zgp_gropp_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Wyswietla grupy operacji, do ktorych przypisane jest pozycja przewodnika
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
GROP.cntx_psh(); GROPP.cntx_psh();
GROPP.index('ZGP');
GROPP.prefix(ZGP.ref());
_wer:=exec('win_gropp','!tpp_gop_dred');
GROPP.win_sel(_wer);
GROPP.select();
GROP.cntx_pop(); GROPP.cntx_pop();
~~


\zgp_filtr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Filtr w oknie ZGP
::       Kontekst wywolania - rekord GROP
::  OLD: \zgp_filtr/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_choice:=FUN.choice('Zakres danych:'@,,'Nierozpisane &oper. zas. grupy'@,'Wszystkie operacje'@);
{? _choice=1
||
:: Tabela z listą dostępnych stanowisk
   _tab_twrk:=sql('
      select
         TWRKPLC.REFERENCE as REF
      from
         GROPS join PL_RES join TWRKPLC
      where GROPS.GROP=:_a
   ',GROP.ref());
:: Tabela wykluczonych operacji
   _tab_zgp:=sql('
      select
         ZGP.REFERENCE as REF,
         ZGP.ILOSC,
         sum(GROPP.IL*GROP.IL) as ILGRP
      from
         GROPP join GROP join ZGP
      group by
         ZGP.REFERENCE,ZGP.ILOSC
      having
         sum(GROPP.IL*GROP.IL)>=ZGP.ILOSC
      union
      select
         ZGP.REFERENCE as REF,
         ZGP.ILOSC,
         0 as ILGRP
      from
         GROPP join GROP join ZGP
      where
         GROPP.GROP=:_a
         and GROPP.ZL_WYR is NULL
   ',GROP.ref());
:: Tabela wykluczonych operacji w rozbiciu na wyroby
   _tab_wyr:=sql('
      select
         ZL_WYR.REFERENCE as REF
      from
         GROPP join GROP join ZL_WYR
      where GROPP.GROP=:_a
   ',GROP.ref());
:: Tabela wynikowa z listą dostępnych operacji
   _tab:=cur_tab(1,1);
   exec('zakrZgp','!tpp_gop_dred',GROP.TTOPER,_tab_twrk,_tab_zgp,_tab_wyr,_tab,GROP.ODDZ)
|? _choice=2
||
:: Tabela z listą dostępnych stanowisk
   _tab_twrk:=sql('
      select TWRKPLC.REFERENCE as REF from TWRKPLC
   ');
:: Tabela wykluczonych operacji
   _tab_zgp:=sql('
      select
         ZGP.REFERENCE as REF
      from
         GROPP join GROP join ZGP
      where
         GROPP.GROP=:_a
         and GROPP.ZL_WYR is NULL
   ',GROP.ref());
:: Tabela wykluczonych operacji w rozbiciu na wyroby
   _tab_wyr:=sql('
      select
         ZL_WYR.REFERENCE as REF
      from
         GROPP join GROP join ZL_WYR
      where GROPP.GROP=:_a
   ',GROP.ref());
:: Tabela wynikowa z listą dostępnych operacji
   _tab:=cur_tab(1,1);
   exec('zakrZgp','!tpp_gop_dred',GROP.TTOPER,_tab_twrk,_tab_zgp,_tab_wyr,_tab,GROP.ODDZ)
?};
~~


\bvZgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: rekord przed dla tabeli tymaczasowej z listą dostępnych operacji
::  OLD: \bvZgp/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? ZGP.seek(_tab.ZGP)
|| VAR.REAL2:=exec('gropp_sum','!tpp_gop_dred',ZGP.ref());
   ZGP.NRZLP();
   ZL_WYR.seek(_tab.ZL_WYR,,,1);
::   {? ZGP.TOPER<>null()
::   || VAR.STRING2:=ZGP.TOPER().OPER().KOD
::   || VAR.STRING2:=''
::   ?};
   exec('przp_dsp','zl_guide');
   {? VAR.REAL2>ZGP.ILOSC
   || Color.rekprzed('ZGP#02#01')
   || ''
   ?}
?}


\grop_br
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wlasciwa akcja 'przed rekord' w oknie tabeli GROP
::  OLD: \grop_br/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VGROP.CZAS_GR:=time(0,0,0);
VGROP.PL_RES:=null();
VAR.A_GROP:=GROP.ref();
GROPS.cntx_psh();
GROPS.index('GROP');
GROPS.prefix(GROP.ref());
VGROP.IL_STAN:=GROPS.size();
{? GROPS.size()=1
|| GROPS.first();
   VGROP.CZAS_GR:=GROPS.CZAS;
   VGROP.PL_RES:=GROPS.PL_RES
?};
GROPS.cntx_pop();
{? GROP.STATUS='Z'
|| 'GROP#01#02'
|? GROP.AKC='T'
|| 'GROP#01#01'
|| ''
?}


\feGropsCzas
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format redagowania pola GROPS.CZAS
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='CZAS'
|| 'hour_chars='+$exec('hour_chars','!tpp_gop_dred')
|| ''
?}


\fdGropsCzas
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format wyświetlania pola GROPS.CZAS
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='CZAS'
|| 'hour_chars='+$exec('hour_chars','!tpp_gop_dred')
|| ''
?}


\vgrop_il_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Format wyświetlania zmiennej VGROP.IL
::   WY: STRING
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('gropp_il_fd','!tpp_gop_dred')


\hour_chars
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ilość godzin wyświetlanych/redagowanych w polach typu czas
::----------------------------------------------------------------------------------------------------------------------
4


\grop_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Wyświetla dane grupy operacji
::----------------------------------------------------------------------------------------------------------------------
exec('grop_display','zl_grop');
~~


\actualize_grops
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Aktualizacja pól w tabeli GROPS
::   WE: _a - GROP.ref()
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

GROP.cntx_psh(); GROPS.cntx_psh();
GROPS.index('GROP');
GROPS.prefix(_grop);
:: Jeżeli zostaje jeden zapis, to jest on zawsze "planowany" na całą ilość
{? GROPS.size()=1
|| {? GROPS.first()
   || GROPS.PLAN:='T';
      GROPS.IL:=GROPS.GROP().IL;
      GROPS.put()
   ?}
:: Jeżeli jest więcej zapisów niż 1, to zapis "planowany" zmieniamy na "nie planowany", a ilość zerowana
|| {? GROPS.first()
   || {!
      |? {? GROPS.PLAN='T' || GROPS.IL:=0; GROPS.PLAN:='N'; GROPS.put() ?};
         GROPS.next()
      !}
   ?}
?};
GROP.cntx_pop(); GROPS.cntx_pop();
~~


\actualize_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Aktualizacja ilości "planowanej" na GROP jako sumy ilości na GROPS
::   WE: _a - GROP.ref()
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

GROP.cntx_psh(); GROPS.cntx_psh();
GROPS.index('GROP');
GROPS.prefix(_grop);
_ilps:=0;
{? GROPS.first()
|| {!
   |? {? GROPS.PLAN='T'
      || _ilps+=GROPS.IL
      ?};
      GROPS.next()
   !}
?};

GROP.prefix();
{? GROP.seek(_grop)
|| GROP.ILPS:=_ilps;
   GROP.CZY_PLAN:={? GROP.ILPS>=GROP.IL || 'T' || 'N' ?};
   GROP.put()
?};

GROP.cntx_pop(); GROPS.cntx_pop();
~~


\trig_gropp_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.37]
:: OPIS: Wyzwalacz dla tabeli GROPP "po"
::   WE: _a - wynik akcji (parametr systemowy)
::       _b - 'add', 'put', 'del'
::----------------------------------------------------------------------------------------------------------------------
:: Wymuszenie trigerów dla rekordu ZGP w celu odświeżenia pól PROD_REJ.DOREJ i PROD_REJ.A w przypadku dopisania
:: albo usunięcia pozycji przewodnika z grupy operacji
{? _b='add'
|| exec('FindAndGet','#table',ZGP,GROPP.ZGP,,"put(,1)")
|? _b='del'
|| exec('FindAndGet','#table',ZGP,bfld('ZGP'),,"put(,1)")
?};
~~


\grops_default_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja 'Domyślny' w tabeli GROPS
::       Kontekst pracy - rekord GROPS
::   WE [_a] - INTEGER - 0/[1] - czy wyświetlać dialogi
::      [_b] - STRING - początek treści do komunikatu
::      [_c] - STRING - dodatkowa treść komunikatu doklejana na koniec
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_grop:=GROPS.GROP;

_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};
_msg_prefix:='';
{? var_pres('_b')=type_of('')
|| _msg_prefix:=_b
?};
_msg_suffix:='';
{? var_pres('_c')=type_of('')
|| _msg_suffix:=_c
?};

_result:=0;
_can_continue:=1;
{? _dialog>0
|| {? _msg_prefix<>''
   || _msg:='%1 i ustawić zasób: %2 jako domyślny w grupie?'@[_msg_prefix,GROPS.PL_RES().SYM]
   || _msg:='Czy ustawić zasób: %1 jako domyślny w grupie?'@[GROPS.PL_RES().SYM]
   ?};
   {? _msg_suffix<>''
   || _msg+=_msg_suffix
   ?};
   _can_continue:=FUN.ask(_msg)
?};

{? _can_continue>0
|| GROPS.cntx_psh();
   GROPS.index('GROP');
   GROPS.prefix(_grop);
   {? GROPS.first()
   || {!
      |? GROPS.DEFAULT:='N';
         _can_continue:=GROPS.put();
         GROPS.next() & _can_continue>0
      !}
   ?};
   GROPS.cntx_pop();
   {? _can_continue>0
   || GROPS.DEFAULT:='T';
      _can_continue:=GROPS.put()
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\grops_default_first
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Ustawia pierwszy zasób w grupie jako domyślny
::   WE: [_a] - GROP.ref() - grupa operacji
::       [_b] - INTEGER - 0/[1] - czy wyświetlać dialogi
::       [_c] - STRING - początek treści do komunikatu
::       [_d] - STRING - dodatkowa treść komunikatu doklejana na koniec
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};
_msg_prefix:='';
{? var_pres('_c')=type_of('')
|| _msg_prefix:=_c
?};
_msg_suffix:='';
{? var_pres('_d')=type_of('')
|| _msg_suffix:=_d
?};

_result:=0;
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
|| GROPS.cntx_psh();
   GROPS.index('DEFAULT');
   GROPS.prefix(GROP.ref(),'T');
   {? GROPS.first()=0
   || GROPS.index('GROP');
      GROPS.prefix(GROP.ref());
      {? GROPS.first()
      || _can_continue:=exec('grops_default_act','!tpp_gop_dred',_dialog,_msg_prefix,_msg_suffix)
      ?}
   ?};
   GROPS.cntx_pop();
   ~~
?};
GROP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\grop_set_dir
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Zmień zwrot w GROP
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_grupa:=0;
{? GROP.sel_size()>0
|| _grupa:=1
?};

_can_continue:=1;
{? _grupa=0
|| _names:=obj_new(2);
   _names[1]:='Do przodu'@;
   _names[2]:='Wstecz'@;
   _vals:=obj_new(2);
   _vals[1]:=1;
   _vals[2]:=-1;
   _edit:=exec('edit_radiobutton','#edit',GROP.DIR,'Zwrot planowania'@,_names,_vals);
   {? type_of(_edit)>0
   || {? FUN.ask('Zmiana zwrotu dotyczy także wszystkich zleceń wchodzących w skład grupy. Kontynuować?'@)
      || PX_VAR.ADD_DIR:=_edit
      || _can_continue:=0
      ?}
   || _can_continue:=0
   ?}
?};

{? _can_continue>0 & PX_VAR.ADD_DIR<>0
|| GROPP.cntx_psh();
   GROP.cntx_psh();
   ZL.cntx_psh();
   GROP.DIR:=PX_VAR.ADD_DIR;
   _can_continue:=GROP.put();
   {? _can_continue>0
   ||
      GROPP.index('GROP');
      {? GROPP.first()
      || {!
         |? {? GROPP.ZL<>null()
            || GROPP.ZL();
               ZL.PL_DIR:=PX_VAR.ADD_DIR;
               _can_continue:=ZL.put();
               {? _can_continue>0
               || exec('zl2obj','px_obj')
               ?}
            ?};
            GROPP.next() & _can_continue>0
         !}
      ?}
   ?};
   {? _can_continue>0
   || exec('grop2obj','px_obj')
   ?};
   ZL.cntx_pop();
   GROP.cntx_pop();
   GROPP.cntx_pop();
   ~~
?};
~~


\grop_set_dir_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Zmień zwrot w GROP - grupa przed
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;
_names:=obj_new(2);
_names[1]:='Do przodu'@;
_names[2]:='Wstecz'@;
_vals:=obj_new(2);
_vals[1]:=1;
_vals[2]:=-1;
_can_continue:=FUN.ask(
   'Zaznaczonych grup: %1.\n'
   'Zmiana zwrotu dotyczy wszystkich zleceń wszystkich zaznaczonych grup. Kontynuować?'@[$GROP.sel_size()]
);
{? _can_continue>0
|| _edit:=exec('edit_radiobutton','#edit',1,'Zwrot planowania'@,_names,_vals);
   {? type_of(_edit)>0
   || PX_VAR.ADD_DIR:=_edit
   || _can_continue:=0
   ?}
?};
_can_continue


\grop_set_dir_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Zmień zwrot w GROP - grupa po
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.ADD_DIR:=0;
~~


\grop_set_termin
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Zmień termin w GROP
::   WE: [_a] - GROP.ref() lub bieżący rekord
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| GROPP.cntx_psh();
   GROPP.index('TERMIN');
   GROPP.prefix(GROP.ref());
   GROPP.win_sel('TERMIN');
   GROPP.select();
   GROPP.cntx_pop();
   ~~
?};
GROP.cntx_pop();
~~


\grop_set_termin_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Zmień termin w GROP - grupa przed
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

~~


\grop_set_termin_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Zmień termin w GROP - grupa po
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

~~


\grop_plan_view
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Podgląd planu od strony grupy operacji
::   WE: [_a] - GROP.ref() lub bieżący rekord
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| GROPS.cntx_psh();
   GROPS.index('GROP');
   _ref_table_grops:=exec('ref_table','#table');
   {? GROPS.first()
   || {!
      |? _ref_table_grops.add(GROPS.ref());
         GROPS.next()
      !}
   ?};
   exec('select_grops_core','px_plan',_ref_table_grops);
   GROPS.cntx_pop();
   ~~
?};
GROP.cntx_pop();
~~


\grop_plan_delete_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Usuń plan w grupach operacji
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_grupa:=0;
{? GROP.sel_size()>0
|| _grupa:=1
?};

_del_px:=0;
_del_po:=0;
_can_continue:=1;

{? GROP.PLAN_PX<>'N'
|| _del_px:=1
?};
{? GROP.PLAN_PO='T'
|| _del_po:=1
?};
{? _del_px=0
|| _px_obj:=exec('get_grop_object','px_obj',GROP.ref());
   {? _px_obj<>null()
   || {? exec('get_ilosc_que','px_obj',exec('get_mainversion','px_ver'),_px_obj)>0
      || _del_px:=1
      ?}
   ?}
?};
{? _grupa=0
|| KOMM.init(250,,'Usuwanie grupy operacji z planów produkcji.'@);
   {? _del_px>0 & _del_po>0
   ||
      _choice:=FUN.choice(
         'Grupa: %1 znajduje się w planie strategicznym i operacyjnym. Z których planów usunąć grupę?'@
         [exec('GROP','#to_string')],,'Obu'@,'Plan strategiczny'@,'Plan operacyjny'@
      );
      {? _choice=0
      || _can_continue:=1
      |? _choice=1
      || _del_px:=1;
         _del_po:=1
      |? _choice=2
      || _del_px:=1;
         _del_po:=0
      |? _choice=3
      || _del_px:=0;
         _del_po:=1
      ?}
   |? _del_px>0
   ||
      _parts:=0;
      {? _del_px>0
      || PX_GRP.cntx_psh();
         GROPS.cntx_psh();
         GROPS.index('GROP');
         GROPS.prefix(GROP.ref());
         {? GROPS.first()
         || {!
            |? PX_GRP.index('GROPS');
               PX_GRP.prefix(exec('get_mainversion','px_ver'),GROPS.ref());
               _parts+=PX_GRP.size();
               GROPS.next()
            !}
         ?};
         GROPS.cntx_pop();
         PX_GRP.cntx_pop()
      ?};
      _can_continue:=FUN.ask(
         'Grupa: %1 znajduje się w planie strategicznym. Elementów kolejki zawierających grupę: %2.\n'
         'Usunąć cały plan tej grupy?'@[exec('GROP','#to_string'),$_parts]
      )
   |? _del_po>0
   || _can_continue:=FUN.ask(
         'Grupa: %1 znajduje się w planie operacyjnym. Usunąć plan tej grupy?'@[exec('GROP','#to_string')]
      )
   || _can_continue:=0;
      _msg:='Grupa: %1 nie jest zaplanowana strategicznie i operacyjnie.'@[exec('GROP','#to_string')];
      KOMM.add(_msg,2)
   ?}
?};
{? _del_po=0 & _del_px=0
|| _can_continue:=0
?};

{? _can_continue>0
|| exec('delete_plan','px_grop',,_del_px,_del_px,0)
?};
{? _grupa=0
|| exec('prenumber','px_grp',exec('get_mainversion','px_ver'),'G');
   KOMM.select()
?};
~~


\grop_plan_delete_act_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Usuń plan w grupach operacji - grupa przed
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(250,,'Usuwanie grupy operacji z planów produkcji.'@);
_msg:='Zaznaczonych grup operacji: %1. '
      'Jeżeli grupy są zaplanowane strategicznie lub operacyjnie ich plan zostanie usunięty. Kontynuować?'@
      [$GROP.sel_size()];
_can_continue:=FUN.ask(_msg);
sel_nchk();
_can_continue


\grop_plan_delete_act_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Usuń plan w grupach operacji - grupa po
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
exec('prenumber','px_grp',exec('get_mainversion','px_ver'),'G');
KOMM.select();
~~


\grop_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Kopiowanie grupy operacji razem z pozycjami (GROPP) i zasobami (GROPS) oraz zapotrzebowaniami (ZLIM)
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(250,,'Kopiowanie grupy operacji'@);

_tab:=tab_tmp(
   ,'KOD','STRING[10]','Kod grupy'@
   ,'DATA','DATE','Data'@
   ,'GROPP','STRING[1]','Pozycje'@
   ,'GROPS','STRING[1]','Zasoby'@
   ,'ZLIM','STRING[1]','Zapotrzebowania'@
   ,'ZLIMK','STRING[1]','Korekty surowców limitowanych'@
);
_tab.KOD:=GROP.KOD;
_tab.DATA:=date();
_tab.GROPS:='T';
_tab.GROPP:='T';
_tab.ZLIM:='T';
_tab.ZLIMK:='P';

_red:=_tab.mk_edit('Kopia grupy operacji'@,,'copygrop');
_tab.win_esep(_red,'Dane podstawowe'@);
_tab.win_efld(_red,,'KOD',,,13);
_tab.win_efld(_red,,'DATA');
_tab.win_esep(_red,'Parametry kopiowania'@);
_tab.win_efld(_red,,'GROPP',,,,,,,,,'check-box','check_label="%1"'['Tak, pozycje będą kopiowane'@],"'T'","'N'");
::_tab.win_efld(_red,,'GROPS',,,,,,,,,'check-box','check_label="%1"'['Tak, zasoby będą kopiowane'@],"'T'","'N'");
_tab.win_efld(_red,,'ZLIM',,,,,,,,,'check-box','check_label="%1"'['Tak, zapotrzebowania będą kopiowane'@],"'T'","'N'");
_tab.win_efld(_red,,'ZLIMK',,,,,,,,,'radio-buttons',,
   'Surowce w ilości pierwotnej'@,"'P'",
   'Surowce z uwględnieniem zaakceptowanych korekt'@,"'K'"
);
_tab.win_edit(_red);
exec('ok_esc','#window',_tab,_red);

_valid:="__CHK.record(cur_tab(1,1),,'KOD')";

{? _tab.edit(_valid)
|| _src:=GROP.ref();
   GROP.KOD:=_tab.KOD;
   GROP.DATA:=_tab.DATA;
   GROP.AKC:='N';
   GROP.CZY_PLAN:='N';
   GROP.CZY_POTW:='N';
   GROP.CZY_WYK:='N';
   GROP.PLAN_PX:='N';
   GROP.ILP:=0;
   GROP.ILPOTW:=0;
   GROP.ILPS:=0;
   GROP.ILW:=0;
   GROP.IDEAN:=exec('bl_idean','kody_kresk',GROP);
   {? GROP.add()
   ||
      do();

      GROPS.cntx_psh();
      GROPS.index('GROP');
      GROPS.prefix(_src);
      _grops_size:=GROPS.size();
      _grop_ilps:=0;
      _grop_czy_plan:='N';
      {? GROPS.first()
      || {!
         |? GROPS.GROP:=GROP.ref();
            {? GROPS.DEFAULT='T' || GROPS.IL:=GROP.IL || GROPS.IL:=0 ?};
            {? _grops_size=1 || GROPS.PLAN:='T' || GROPS.PLAN:='N' ?};
            {? GROPS.PLAN='T' || _grop_czy_plan:='T' ?};
            _grop_ilps+=GROPS.IL;
            GROPS.AKC:='N';
            GROPS.ILW:=0;
            GROPS.IDEAN:=exec('bl_idean','kody_kresk',GROPS);
            GROPS.cntx_psh(); GROPS.prefix(); GROPS.add(); GROPS.cntx_pop();
            GROPS.next()
         !}
      ?};
      GROP.CZY_PLAN:=_grop_czy_plan;
      GROP.ILPS:=_grop_ilps;
      GROP.put();
      GROPS.cntx_pop();

      {? _tab.GROPP='T'
      ||
         GROPP.cntx_psh();
         GROPP.index('GROP');
         GROPP.prefix(_src);
         {? GROPP.first()
         || {!
            |? GROPP.GROP:=GROP.ref();
               GROPP.cntx_psh();
               GROPP.prefix();
               {? GROPP.add()
               ||
::                Walidacja ilości na dodawanej pozycji
::                (czy po dodaniu pozycji ilość w grupach nie przekroczy ilości na przewodniku)
                  {? exec('gropp_il_chk','!tpp_gop_dred',GROPP.IL,1,0)=0
                  || _sum:=exec('gropp_sum','!tpp_gop_dred',GROPP.ZGP);
                     _msg:='Pozycja przewodnika %3 — ilość ogółem w grupach operacji (%1) '
                           'przekroczyła ilość na przewodniku (%2).\n\n'@
                           [$(_sum+(GROPP.IL*GROP.IL)),$GROPP.ZGP().ILOSC,GROPP.ZGP().NRPRZ().NRPRZ];
                      KOMM.add(_msg)
                  ?}
               ?};
               GROPP.cntx_pop();
               GROPP.next()
            !}
         ?};
         GROPP.cntx_pop()
      ?};

      {? _tab.ZLIM='T'
      || exec('openmask','zl_common',null(),_src);
         ZLIM.cntx_psh();
         ZLIM.index('GROPKM');
         _lim:=obj_new(2); _lim[1]:='T'; _lim[2]:='N';
         {! _it:=1.. 2
         |! ZLIM.prefix(_src,_lim[_it],0);
            {? ZLIM.first()
            || {!
               |? ZLIM.cntx_psh();
                  ZLIM.prefix();
                  {? _tab.ZLIMK='K' & ZLIM.LIMIT='T'
                  || ZLIM.LIL:=exec('sum_il','zl_limit',ZLIM.ref(),1)
                  ?};
                  {? ZLIM.LIL=0
                  || KOMM.add('Pozycja limitu na %1 z zerową ilością nie została skopiowana.'@[ZLIM.KTM().KTM])
                  || ZLIM.GROP:=GROP.ref();
                     ZLIM.IL_RW:=0;
                     ZLIM.IL_ZW:=0;
                     ZLIM.AKC:='N';
                     ZLIM.AKCU:=null();
                     ZLIM.add()
                  ?};
                  ZLIM.cntx_pop();
                  ZLIM.next()
               !}
            ?}
         !};
         ZLIM.cntx_pop()
      ?};

      end();

      GROP.f_add()
   ?}
?};
KOMM.select();
~~


\gropp_ilosc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wyznacza ilość dla pozycji przewodnika, na jaką można powołać grupę operacji dla zadanej liczby uruchiomień.
::       Działa na aktualnym rekordzie tabeli ZGP oraz GROP
::   WE: [_a] - M.ref() - produkt zlecenia, jak niepodany to brany domyślny produkt
::----------------------------------------------------------------------------------------------------------------------
_il:=0;
_ktm:={? var_pres('_a')=type_of(null()) & _a<>null() || _a || ZGP.ZL().KTM ?};
_sum:=exec('gropp_sum','!tpp_gop_dred',ZGP.ref());
_left:=ZGP.ILOSC-_sum;
{? _left<0 || _left:=0 ?};
{? _left>0
|| _ilx:={? GROP.IL>0 || GROP.IL || 1 ?};
   _dokl:=exec('jaka_dok_m','jm',_ktm);
   {? _dokl>0
   || _rm:=roundmet();
      roundmet(1);
      _il:=(_left/_ilx)$_dokl;
      roundmet(_rm)
   || _il:=exec('floor','#math',_left/_ilx)
   ?}
?};
_il


\grop_trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Trigger przed add dla tabeli GROP
::----------------------------------------------------------------------------------------------------------------------
GROP.ROK_MAX:=GROP.DATA~1;
1


\RestZK_fArch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Przywraca z archiwum zamówienia wewnętrzne do limitów grupy operacji
::       Wzorowane na: \RestZK_fArch/!tte_pzl_eotw.fml
::   WE: _a - GROP.ref()
::   WY: 0/1 (1-ok)
::----------------------------------------------------------------------------------------------------------------------
_grop:={? _>0 & type_of(_a)=type_of(GROP.ref()) || _a || null() ?};
_result:=0;
ZK_N.cntx_psh();
GROP.cntx_psh();
GROP.clear();
{? _grop<>null() & GROP.seek(_grop)
|| _names:=ZK_N.names();
   {? _names.size()>1
   || _maska:=ZK_N.name();
      _names.last();
      {!
      |? {? _names.NAME+2<>'__'
         || exec('openz','open_tab',_names.NAME+3);
            ZK_N.index('GRALW');
            ZK_N.prefix(GROP.ref(),'Z','T');
            {? ZK_N.first()
            || {!
               |? exec('zam_arch','zamsiw_wspolne',0);
                  ZK_N.next()
               !}
            ?}
         ?};
         _names.prev()
      !};
      exec('openz','open_tab',_maska+3)
   ?}
?};
ZK_N.cntx_pop();
GROP.cntx_pop();
_result


\ZlecZK_Ns2Arch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Przenosi do archiwum zamówienia wewnętrzne do limitów grupy operacji
::       Wzorowane na: \ZlecZK_Ns2Arch/!tpp_pzl_ezam.fml
::   WE: _a - GROP.ref()
::   WY: 0/1 (1-ok)
::----------------------------------------------------------------------------------------------------------------------
_grop:={? _>0 & type_of(_a)=type_of(GROP.ref()) || _a || null() ?};
_result:=0;
ZK_N.cntx_psh();
GROP.cntx_psh();
GROP.clear();
{? _grop<>null() & GROP.seek(_grop)
|| _mask:=ZK_N.name+3;
   {? _mask+2<>'__'
   || exec('openz','open_tab',ST.ODDZ+'__')
   ?};
   ZK_N.index('GRALW');
   ZK_N.prefix(GROP.ref(),'A','T');
   {? ZK_N.first()
   || {!
      |? exec('zam_arch','zamsiw_wspolne',0);
         ZK_N.next()
      !}
   ?};
   {? _mask+2<>'__'
   || exec('openz','open_tab',_mask)
   ?}
?};
ZK_N.cntx_pop();
GROP.cntx_pop();
_result


\prn_grop
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Wydruki dla grupy operacji
::----------------------------------------------------------------------------------------------------------------------
exec('rep_exec','#b_report','TPP_GOP_XXXX','tpp_grop_*','Wydruki dotyczące grupy operacji'@,1);
1


\prn_grops
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Wydruki dla zasobu grupy operacji
::----------------------------------------------------------------------------------------------------------------------
exec('rep_exec','#b_report','TPP_GOP_XXXX','tpp_grops_*','Wydruki dotyczące zasobu grupy operacji'@,1);
1

:Sign Version 2.0 jowisz:1048 2023/06/23 14:09:38 9d8ee862fbadd12f8b7d410e777436f37cf7b7112a2844faf75df2ae7880fa46c2b5d82c15338a0a68930d07a02689492b8590b79e71738b2ece0f5b198e1225dbd99ec446040ef3394836f4b09938058adbdf4068f4407726e55f6bc13dd63e2718ccc1523f615fd435844dd05b086f0a0ab68411ff261ffa88b7f0e03167be
