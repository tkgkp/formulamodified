:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tte_pzl_dzpx.fml
:: Utworzony: 13.08.2021
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły czynności TTE_PZL_DZPX - Generowanie zlecenia na podstawie planu strategicznego
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Formuła główna czynności generowania zleceń na podstawie planu strategicznego (TTE_PZL_DZPX)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::       context - [obj_new] obiekt służący do przekazywania kontekstu wywołania czynności
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

:: WŁAŚCIWOŚCI CZYNNOŚCI
::# permissions=ODDZ
::# parses=exec('parses','!tte_pzl_dzpx')
::# properties=LOOP,SERVICE

:: PARAMETRY WE:
::# kind=WE, symbol=ZTP, type=_ZTP, name=Typ zlecenia, required=N, fml_val="exec('ztp_select','zl_head','P')", fml_exp="exec('ztp_export','zl_head',_a)"
{? var_pres('ZTP',_in)<>type_of(~~) & var_pres('ZTP',_in)<>type_of(null()) || return() ?};
{? var_pres('ZTP',_in)=type_of(~~) || _in.ZTP:=null() ?};
::# kind=WE, symbol=PX_GRP, type=_PX_GRP, name=Grupa w kolejce planu, required=N, keyref=T
{? var_pres('PX_GRP',_in)<>type_of(~~) & var_pres('PX_GRP',_in)<>type_of(null()) || return() ?};
{? var_pres('PX_GRP',_in)=type_of(~~) || _in.PX_GRP:=null() ?};
::# kind=WE, symbol=ZL_NAD, type=_ZL, name=Zlecenie nadrzędne, required=N, keyref=N
{? var_pres('ZL_NAD',_in)<>type_of(~~) & var_pres('ZL_NAD',_in)<>type_of(null()) || return() ?};
{? var_pres('ZL_NAD',_in)=type_of(~~) || _in.ZL_NAD:=null() ?};
::# kind=WE, symbol=KIND, type=STRING, name=Kategoria zlecenia, required=N, keyref=N,fml_val="exec('kind_edit','!tte_pzl_dzpx',_a)"
{? var_pres('KIND',_in)<>type_of(~~) & var_pres('KIND',_in)<>type_of('') || return() ?};
{? var_pres('KIND',_in)=type_of(~~) || _in.KIND:='N' ?};


:: PARAMETRY WY:
::# kind=WY, symbol=ZL, type=_ZL, name=Zlecenie, required=N
{? var_pres('ZL',_out)<>type_of(~~) & var_pres('ZL',_out)<>type_of(null()) || return() ?};
::# kind=WY, symbol=ZL_MERGE, type=_ZL, name=Powiązane zlecenie, required=N
{? var_pres('ZL_MERGE',_out)<>type_of(~~) & var_pres('ZL_MERGE',_out)<>type_of(null()) || return() ?};
::# kind=WY, symbol=KATEGORIA, type=STRING, name=Kategoria zlecenia, required=N
{? var_pres('KATEGORIA',_out)<>type_of(~~) & var_pres('KATEGORIA',_out)<>type_of('') || return() ?};
::# kind=WY, symbol=PX_GRP, type=_PX_GRP, name=Element kolejki, required=N
{? var_pres('PX_GRP',_out)<>type_of(~~) & var_pres('PX_GRP',_out)<>type_of(null()) || return() ?};

:: Ustawiam wartość domyślną argumentu LOOP żeby brama się nie zawiesiła
_mp.save(exec('kind_out','#b_port'),'LOOP','N');

_key:=_out.GRPKEY:=_mp.grpkey(_out.GRPKEY,_in.GRPKEY);

{? type_of(_context)>100 & var_pres('KIND',_context)>0
|| _in.KIND:=_context.KIND
?};
_done:=0;

_obj:=params_exec('clean','!tte_pzl_dzpx',_mp,_in);
_can_continue:=_obj.RESULT;
_px_grp:=_obj.PX_GRP;

{? _can_continue>0
||
   _mp.save(exec('kind_out','#b_port'),'PX_GRP',_px_grp);

   {? _px_grp=null() & _mp.isService()=0 & _mp.akcja()<>'' &  _mp.isGroup()=0
   ||
      {? exec('zlisty','!tte_pzl_dzpx',,,'WYBIERZ')
      || _px_grp:=PX_VAR.PX_GRP
      ?}
   ?};

   {? _px_grp=null()
   || _can_continue:=0;
      {? _mp.isService()
      || _msg:='Błędna konfiguracja procesu — nie przekazano elementu kolejki.'@;
         _mp.error(_msg)
      || _mp.cancel()
      ?}
   ?};
   {? _in.ZTP=null()
   || {? ZLEC.ZTP<>null()
      || _in.ZTP:=ZLEC.ZTP
      || {? _mp.isService()
         || _msg:='Błędna konfiguracja procesu — nie przekazano typu zlecenia.'@;
            _mp.error(_msg)
         |? _mp.isGroup()
         || _in.ZTP:=exec('ztp_select','zl_head','P');
            {? _in.ZTP=null()
            || _can_continue:=0;
               _mp.cancel()
            ?}
         ?}
      ?}
   ?}
?};

{? _can_continue>0
||
   PX_GRP.cntx_psh();
   PX_GRP.prefix();
   PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   {? _mp.loop()=0 & _px_grp & PX_GRP.seek(_px_grp)
   || _what:=exec('PX_GRP','#to_string');
      {? exec('chk_oddział','!tte_pzl_dzpx')=0
      || _can_continue:=0;
         _msg:='Nie można powoływać zleceń z: %1, ponieważ zawiera elementy z różnych oddziałów.'@[_what];
         {? _mp.isService()
         || ~~
         |? _mp.isGroup()
         || KOMM.add(_msg,2,1)
         || FUN.emsg(_msg)
         ?};
         _mp.error(_msg)
      ?};
      {? _can_continue>0 & _in.ZL_NAD<>null()
      || _nad_rodzaj:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"RODZAJ",'');
         {? _nad_rodzaj='P'
         || _can_continue:=0;
            _msg:='Nie można dodawać zlecenia do zlecenia prostego.'@;
            {? _mp.isService()
            || ~~
            |? _mp.isGroup()
            || KOMM.add(_msg,2,1)
            || FUN.emsg(_msg)
            ?};
            _mp.error(_msg)
         ?};
         _nad_stan:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"ZL.STAN",'');
         {? _can_continue>0 & _nad_stan<>'N'
         || _can_continue:=0;
            _msg:='Nie można dodawać zlecenia do zlecenia w stanie innym niż w przygotowaniu.'@;
            {? _mp.isService()
            || ~~
            |? _mp.isGroup()
            || KOMM.add(_msg,2,1)
            || FUN.emsg(_msg)
            ?};
            _mp.error(_msg)
         ?}
      ?};

::    Dialog z użytkownikiem
      {? _can_continue>0
      ||
         {? _mp.isGroup()=0 & _mp.isService()=0
         || KOMM.init(250,,'Generowanie zleceń'@)
         ?};
         ZLEC.win_edit('ZL_GENPX');
         ZLEC.ZTP:=_in.ZTP;
         {? ZLEC.ZTP=null()
         || ZTP.cntx_psh();
            ZTP.prefix();
            {? ZTP.size()=1 & ZTP.first()
            || ZLEC.ZTP:=ZTP.first()
            ?};
            ZTP.cntx_pop()
         ?};
         ZLEC.COMPLEX:=_in.KIND;

         {? _mp.isGroup()=0 & _mp.isService()=0
         ||
            ZTP.f_clear();
            _typy:=exec('typy_zlecen','zl_head','P');
            ZTP.f_set('TYP',,'ZTP.REFERENCE in (select :_a.REF from :_a)',_typy);
            obj_del(_typy);
            ZTP.win_dict('SLO');
            _env_gen:=exec('env_gen','zl_gen');
            _env_gen.edit_ZTP:={? _in.ZTP<>null() || 0 || 1 ?};
            _env_gen.edit_COMPLEX:=1;
            {? _in.ZTP<>null()
            || ZLEC.ZTP:=_in.ZTP
            || {? ZTP.f_size()=1 & ZTP.f_first()
               || ZLEC.ZTP:=ZTP.ref()
               ?}
            ?};
            ZLEC.TKTL:=null();
            params_set('env_gen',_env_gen);

            {? ZLEC.edit("__CHK.record(ZLEC,,'ZTP')")
            || _can_continue:=1;
               _in.ZTP:=ZLEC.ZTP;
               _in.KIND:=ZLEC.COMPLEX
            || _can_continue:=0
            ?};
            ZTP.f_clear()
         ?}
      ?};

      {? _can_continue>0
      ||
         {? type_of(_context)>100 & var_pres('TAB',_context)>100
         || _tab:=_context.TAB
         || _tab:=exec('grupuj','!tte_pzl_dzpx',,,_in.KIND)
         ?};
         _ndx1:=_tab.ndx_tmp(,,'ODDZ',,,'M_REF',,,'KIND',,);
         _ndx2:=_tab.ndx_tmp(,,'ODDZ',,,'TKTL',,,'KIND',,,'M_ATR',,,'JM_SYM',,);

         PX_CONN.prefix(PX_GRP.ref());
         {? PX_CONN.first()
         || {!
            |? {? PX_CONN.PX_OBJ().ZL<>null()
               || _can_continue:=0;
                  _msg:='Nie można generować zleceń z elementów kolejki zawierających zlecenia.'@;
                  {? _mp.isService()
                  || ~~
                  |? _mp.isGroup()
                  || KOMM.add(_msg,2,1)
                  || FUN.emsg(_msg)
                  ?};
                  _mp.error(_msg)
               ?};
               PX_CONN.next()
            !}
         ?};

         _m_atr:='';
         _jm:='';
         {? PX_GRP.PX_TAG<>null()
         || _m_atr:=$PX_GRP.PX_TAG().M_ATR;
            _jm:=PX_GRP.PX_TAG().JM().KOD
         ?};

::       Podsumowanie generowania
         {? _can_continue>0 & _mp.isGroup()=0 & _mp.isService()=0
         || _wer:=exec('win_grupa','!tte_pzl_dzpx',_tab,_in.KIND);
            _tab.win_sel(_wer);
            _ndx4:=_tab.ndx_tmp(,,'KIND',,);
            _tab.index(_ndx4);
            _tab.prefix('G');

            _args_gen:=exec('auto_args','zl_gen');
            _args_gen.MERGE:=0;
            _env_gen.edit_IL:=0;
            _env_gen.edit_ZTP:=0;
            _env_gen.edit_COMPLEX:=0;

            params_set('args',_args_gen,'env_gen',_env_gen,'TAB',_tab);

            {? _tab.select()
            || _can_continue:=1
            || _can_continue:=0
            ?};
            _tab.ndx_drop(_ndx4)
         ?};

         {? _can_continue>0 & PX_CONN.first()
         || {!
            |?
               {? _in.KIND='W' & PX_GRP.PX_TEX().TKTL<>null()
               || _tab.index(_ndx2);
                  _tab.prefix(ST.ODDZ,$PX_GRP.PX_TEX().TKTL,'G',_m_atr,_jm)
               || _tab.index(_ndx1);
                  _tab.prefix(ST.ODDZ,$PX_CONN.M,'G')
               ?};
               {? _tab.first()
               || {!
                  |? {? _tab.M_REF<>''
                     ||
                        {? _tab.ZL=''
                        ||
::                         Nie ma zlecenia dla takiego KTM, generuję
                           {? var_pres('_args_zl')>100
                           || obj_del(_args_zl)
                           ?};
                           _args_zl:=exec('tab2args','!tte_pzl_dzpx',,_tab);
                           _args_zl.MERGE:=1;
                           {? _in.ZL_NAD<>null()
                           || _args_zl.MERGE:=0;
                              _args_zl.COMPLEX:='N'
                           ?};

                           _args_zl.ZL_NAD:=_in.ZL_NAD;
                           {? _in.ZTP<>null()
                           || _args_zl.ZTP:=_in.ZTP
                           ?};
::                           {? _mp.isGroup()
::                           || _args_zl.GRUPA:=1;
::                              _args_zl.DIALOG:=0
::                           || _args_zl.GRUPA:=0;
::                              _args_zl.DIALOG:=1
::                           ?};
                           _args_zl.GRUPA:=1;
                           _args_zl.DIALOG:=0;
                           _old_grupa:=VAR.GRUPA;
                           VAR.GRUPA:='T';
::                           {? _mp.isService()
::                           || _args_zl.DIALOG:=0
::                           ?};
                           _args_zl.SPLIT:=0;
                           _args_zl.GEN_ZLZAM:=0;
                           params_exec('auto_px','!tte_pzl_dzpx',_args_zl,PX_GRP.ref());
                           {? _args_zl.RESULT.tab.first()
                           || {!
                              |?
                                 ZL.cntx_psh();
                                 ZL.prefix();
                                 {? ZL.seek(_args_zl.RESULT.tab.SQL)
                                 || _tab.ZL:=$ZL.ref();
                                    _tab.put();

                                    _il_px_zl:=exec('min','#math',PX_GRP.ILOSC,ZL.IL);
                                    exec('add','px_zl',PX_GRP.ref(),ZL.ref(),_il_px_zl);

::                                  Generowanie ZLZAM
                                    _tab.cntx_psh();
                                    _ndx3:=_tab.ndx_tmp(,,'TREE',,);
                                    _tab.index(_ndx3);
                                    _tab.prefix(#_tab.ref());
                                    {? _tab.first()
                                    || {!
                                       |?
                                          exec('add_zleczam','zl_gen',ZL.ref(),_tab.IL,_tab.SRC);

                                          ZK_N.cntx_psh();
                                          ZK_P.cntx_psh();
                                          _mask:=ref_name(_tab.SRC);
                                          ZK_P.use(_mask);
                                          ZK_N.use(5+ZK_N.name()+(_mask+3));
                                          ZK_P.prefix();
                                          {? ZK_P.seek(_tab.SRC)
                                          || exec('aktznzkp','zamsiw_poz',ZK_P.ref(),1);
                                             exec('aktznzkn','zamsiw_nag',ZK_P.N,1)
                                          ?};
                                          ZK_N.cntx_pop();
                                          ZK_P.cntx_pop();

                                          {? _args_zl.ZL_MERGE<>null()
                                          ||
::                                           Jeżeli powiązano z innym zleceniem to modyfikuję opis zlecenia
                                             ZL.cntx_psh(); ZL.prefix();
                                             {? ZL.seek(_args_zl.ZL_MERGE)
                                             || ZL.OPIS+='+'+_tab.SYMBOL;
                                                ZL.put()
                                             ?};
                                             ZL.cntx_pop();
                                             ~~
                                          ?};
                                          _tab.next()
                                       !};

                                       {? _in.KIND='W'
                                       || {? exec('zlzam2zlwyr','zl_wyr',ZL.ref(),'Z')=0
                                          || {? _mp.isService()=0
                                             || _msg:='Dodanie produktów do zlecenia: %1 zakończone niepowodzeniem'@[ZL.SYM];
                                                KOMM.add(_msg,2,,1)
                                             ?}
                                          ?}
                                       ?}
                                    ?};
                                    _tab.ndx_drop(_ndx3);
                                    _tab.cntx_pop();
                                    {? _args_zl.ZL_MERGE<>null()
                                    ||
::                                     Jeżeli użytkownik powiązał z innym zleceniem to nie wystawiam
::                                     klucza i zapisuję parametr wyjściowy ZL_MERGE
                                       _mp.save(exec('kind_out','#b_port'),'ZL_MERGE',_args_zl.ZL_MERGE)
                                    ||
::                                     Wystawienie klucza grupującego
                                       _uidref:=ZL.uidref();
                                       _mp.grpkeyAdd(_uidref)
                                    ?}
                                 ?};
                                 ZL.cntx_pop();
                                _args_zl.RESULT.tab.next()
                             !}
                           ||
::                            Nie utworzono zlecenia bo np użytkownik zrezygnował
                              _can_continue:=0
                           ?};
                           VAR.GRUPA:=_old_grupa
                        ||
::                         Jest zlecenie dla takiego KTMa, wystawiam parametr ZL_MERGE
                           ZL.cntx_psh(); ZL.prefix();
                           {? ZL.seek(_tab.ZL)
                           || _il_px_zl:=exec('min','#math',PX_GRP.ILOSC,ZL.IL);
                              exec('add','px_zl',PX_GRP.ref(),ZL.ref(),_il_px_zl);
::                           _uidref:=ZL.uidref();
::                           _mp.grpkeyAdd(_uidref)
                              _mp.save(exec('kind_out','#b_port'),'ZL_MERGE',ZL.ref())
                           ?};
                           ZL.cntx_pop()
                        ?}
                     ?};
                     _tab.next()
                  !}
               ?};
               PX_CONN.next() & _can_continue>0
            !}
         ?};
         {? _mp.isGroup()=0 & _mp.isService()=0
         || KOMM.select()
         ?};
         _tab.ndx_drop(_ndx1);
         _tab.ndx_drop(_ndx2);
         ~~
      ?}
   ?};
   {? _key<>''
   ||
::    Generacja - wypycham pierwsze zlecenie na wyjście
      _zl_uidref:=_mp.grpkeyGet();
      {? type_of(_zl_uidref)=type_of('')
      ||
         _done:=1;
         ZL.cntx_psh();
         ZL.prefix();
         {? ZL.seek(_zl_uidref)
         ||
            do();
            _can_continue:=ZL.put();
            _mp.save(exec('kind_out','#b_port'),'ZL',ZL.ref());
            _mp.save(exec('kind_out','#b_port'),'KATEGORIA',ZL.RODZAJ);
            _mp.save(exec('kind_out','#b_port'),'GRPKEY',_key);
            _mp.grpkeyDel();
            end();
::          Jeżeli są jeszcze jakieś zlecenia to kontynuuję pętlę
            _zl_uidref:=_mp.grpkeyGet();
            {? type_of(_zl_uidref)=type_of('')
            || _mp.loop_continue()
            ?}
         ?};
         ZL.cntx_pop()
      ||
::       Zakończenie (nie powstało żadne zlecenie) - wypycham nullowe zlecenie na wyjście
         _mp.save(exec('kind_out','#b_port'),'ZL',null());
         {? _mp.pathTodo()=0
         || _done:=1
         ?}
      ?}
   || _mp.error('Brak oczekiwanego parametru %1.'@@['GRPKEY'])
   ?};
   {? _done>0 || _mp.done() ?};
   PX_GRP.cntx_pop();
   PX_CONN.cntx_pop()
?};
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Opis dla czynności generowania zleceń na podstawie planu dostaw (TTE_PZL_DZPD)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: zwraca opis Zadania
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_desc:='';
_keyRefs:=_mp.getRefs();
_in:=_mp.load(exec('kind_in','#b_port'));

:: jest rekord kluczowy to ustawiam odpowiednie PX_GRP
{? var_pres('[1]',_keyRefs)
|| _what:=exec('record','#to_string',_keyRefs[1]);
   _desc:={? _what<>'' || 'Generuj zlecenia produkcyjne na podstawie planu: %1'@@[_what] || '' ?}
::|| _desc:=exec('FindAndGet','#table',PD_K,_keyRefs[1],,"'Generuj zlecenia produkcyjne na podstawie planu dostaw %1'[PD_K.PD_N().SYM]",'')

:: jest parametr wejściowy PX_GRP to ustawiam odpowiednio
|? var_pres('PX_GRP',_in)
|| _what:=exec('record','#to_string',_in.PX_GRP);
   _desc:={? _what<>'' || 'Generuj zlecenia produkcyjne na podstawie planu: %1'@@[_what] || '' ?}
::|| _desc:=exec('FindAndGet','#table',PD_K,_in.PD_K,,"'Generuj zlecenia produkcyjne na podstawie planu dostaw  %1'[PD_K.PD_N().SYM]",'')
|| _desc:='Generuj nowe zlecenie produkcyjne'@@
?};
_desc


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Formuła ustala PARSES
::   WE: UWAGA. Do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_mp:=params_get().mp;
_context:=params_get().context;

_result:=0;

_keyRefs:=_mp.getRefs();
{? obj_len(_keyRefs)>0
|| {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];
      {? type_of(_kref)>0
      || {? ref_name(_kref)=PX_GRP.name()
         || _px_grp:=exec('FindAndGet','#table',PX_GRP,_kref,,,null());
            {? _px_grp=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               exec('deleted_in_proc','px_grp',_mp);
               return(_result)
            ?}
         ?}
      ?}
   !}
?};

{? var_pres('PX_GRP',_in)=type_of(null()) & _in.PX_GRP
|| PX_GRP.cntx_psh();
   PX_GRP.prefix();
   {? PX_GRP.seek(_in.PX_GRP)
   ||
      _oddz:='';
      PX_OBJ.cntx_psh();
      PX_CONN.cntx_psh();
      PX_CONN.index('PX_GRP');
      PX_CONN.prefix(PX_GRP.ref());
      {? PX_CONN.first()
      || {!
         |? _oddz:=exec('get_oddzial','px_obj',PX_CONN.PX_OBJ);
            PX_CONN.next() & _oddz=''
         !}
      ?};
      PX_CONN.cntx_pop();
      PX_OBJ.cntx_pop();

      {? _oddz<>''
      || __PARSES.setVal('OddzialLogProd',_oddz)
      ?};
      {? _mp.isService()
      || _args:=__PARSES.args('OkresRok');
         _args.OBSZAR:='LMG';
         _args.AR:=date()~1;
         _args.AM:=date()~2;
         __PARSES.setVal('OkresRok',_args)
      ?};
      _result:=1
   ?};
   PX_GRP.cntx_pop()
?};

:: Jeżeli uruchomienie ze startu procesów albo todo, to będzie wybór grupy, więc ok
{? _result=0 & _mp.isService()=0
|| _result:=1
|? _result=0
|| _msg:='Błędna konfiguracja procesu — brak parametru wejściowego %1 czynności %2.'@@['PX_GRP','TTE_PZL_DZPX'];
   {? _mp.isService()=0 || FUN.info(_msg) ?};
   _mp.error(_msg)
?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::   WE: _a - _mp - obiekt Menadżera procesów
::       _b - tablica z parametrami wejściowymi
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;
_in:=_b;

_can_continue:=1;
_obj:=obj_new('RESULT','PX_GRP');
_obj.RESULT:=0;
_obj.PX_GRP:=null();

_keyRefs:=_mp.getRefs();

{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];

      {? type_of(_kref)>0
      ||
         {? ref_name(_kref)=PX_GRP.name()
         || _obj.PX_GRP:=exec('FindAndGet','#table',PX_GRP,_kref,,,null());

            {? _obj.PX_GRP=null()
            ||
::             Nie znaleziono rekordu kluczowego więc robię error
               _can_continue:=0;
               exec('deleted_in_proc','px_grp',_mp)
            ?}
         ?}
      ?}
   !}
?};

{? _can_continue>0
||
:: jest parametr wejściowy PX_GRP
   {? _obj.PX_GRP=null() & var_pres('PX_GRP',_in)=type_of(null())
   || _obj.PX_GRP:=_in.PX_GRP
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};
_obj


\grupuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Zbiera PX_CONNy z jednego PX_GRPa wstępnie je grupując
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::       [_b] - tab_tmp - tabelka tymczasowa którą zasilać
::       [_c] - STRING - kategoria zlecenia:
::                         P - określ automatycznie
::                         T - zlecenie złożone
::                         N - zlecenie proste
::                         W - zlecenie proste z wieloma wyrobami
::       [_d] - ref_table - tablica grup PX_GRP
::   WY: tab_tmp - tabelka z pogrupowanymi elementami grupy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_tab:=~~;
{? var_pres('_b')>100
|| _tab:=_b
|| _tab:=exec('tab','!tte_pzl_dzpx')
?};

_kind:='P';
{? var_pres('_c')=type_of('')
|| _kind:=_c
?};
_ref_table_px:=1;
{? var_pres('_d')>100
|| _ref_table_px:=_d
|| _ref_table_px:=exec('ref_table','#table')
?};

_result:=0;
_can_continue:=1;

PX_OBJ.cntx_psh();
M.cntx_psh();
PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _ref_table_px.add(PX_GRP.ref());
   _tab.cntx_psh();
   _ndx1:=_tab.ndx_tmp(,,'ODDZ',,,'M_REF',,);
   _ndx2:=_tab.ndx_tmp(,,'ODDZ',,,'TKTL',,,'M_ATR',,,'JM_SYM',,);
   _tab.index(_ndx1);
   PX_POZ.cntx_psh();
   PX_POZ.index('TM_GRP');
   PX_POZ.prefix(PX_GRP.ref());
   _pl_rea:=0;
   {? PX_POZ.last()
   || _pl_rea:=PX_POZ.TM_END
   ?};
   _m_atr:='';
   _jm:='';
   {? PX_GRP.PX_TAG<>null()
   || _m_atr:=$PX_GRP.PX_TAG().M_ATR;
      _jm:=PX_GRP.PX_TAG().JM().KOD
   ?};

   PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |? _oddz:=exec('get_oddzial','px_obj',PX_CONN.PX_OBJ);
         {? PX_CONN.M<>null() & _oddz<>''
         ||
            _tab.prefix();
            _size:=_tab.size();

            {? _kind='W' & PX_GRP.PX_TEX().TKTL<>null()
            || _tab.index(_ndx2);
               _tab.prefix(_oddz,$PX_GRP.PX_TEX().TKTL,_m_atr,_jm)
            || _tab.index(_ndx1);
               _tab.prefix(_oddz,$PX_CONN.M)
            ?};
            {? _tab.first()
            || _ilosc:=PX_CONN.ILOSC-exec('get_ilosc_zl','px_obj',PX_CONN.PX_OBJ);
               _ilosc:=exec('max','#math',0,_ilosc);
               _tab.IL+=_ilosc;
               _tab.TM_REA:=exec('min','#math',_tab.TM_REA,PX_CONN.PX_OBJ().TM_REA);
               _tab.ENDD:=exec('tm_stamp2date','#tm_stamp',_tab.TM_REA);
               _tab.ENDT:=exec('tm_stamp2time','#tm_stamp',_tab.TM_REA);
               {? _pl_rea>0
               ||
                  _tab.TM_PLA:=exec('min','#math',_tab.TM_PLA,_pl_rea);
                  _tab.PL_DATA:=exec('tm_stamp2date','#tm_stamp',_tab.TM_PLA);
                  _tab.PL_TIME:=exec('tm_stamp2time','#tm_stamp',_tab.TM_PLA)
               ?};
               {? PX_CONN.PX_OBJ().KH<>null() & _tab.KH<>$PX_CONN.PX_OBJ().KH
               || _tab.KH:=''
               ?};
               _dk_c:=exec('get_dkc','px_obj',PX_CONN.PX_OBJ);
               {? _dk_c<>null() & _tab.DK_C<>$_dk_c
               || _tab.DK_C:=''
               ?};
               _tab.put()
            || _tab.blank();
               _tab.LP:=_size+1;
               _tab.KIND:='G';
               _tab.ODDZ:=_oddz;
               _tab.PX_GRP:=$PX_GRP.ref();
               _tab.SRC:=$PX_CONN.PX_OBJ().ZK_P;
               {? _kind='W'
               || _ktm:=exec('material4tktl','!tte_pzl_dzpx',PX_GRP.PX_TEX().TKTL,_ref_table_px);
                  M.cntx_psh(); M.prefix();
                  {? M.seek(_ktm)
                  || _tab.SYMBOL:=M.KTM;
                     _tab.M_REF:=$M.ref();
                     _tab.M_KTM:=M.KTM;
                     _tab.M_NAZ:=M.N;
                     _tab.M_ATR:=$M.M_ATR;
                     _tab.JM_SYM:=_jm
                  ?};
                  M.cntx_pop()
               || _tab.SYMBOL:=PX_CONN.M().KTM;
                  _tab.M_REF:=$PX_CONN.M;
                  _tab.M_KTM:=PX_CONN.M().KTM;
                  _tab.M_NAZ:=PX_CONN.M().N;
                  _tab.JM_SYM:=PX_CONN.M().J().KOD
               ?};
               _ilosc:=PX_CONN.ILOSC-exec('get_ilosc_zl','px_obj',PX_CONN.PX_OBJ);
               _ilosc:=exec('max','#math',0,_ilosc);
               _tab.IL:=_ilosc;

               _tab.ENDD:=PX_CONN.PX_OBJ().ENDD().DATA;
               _tab.ENDT:=PX_CONN.PX_OBJ().ENDT;
               _tab.TM_REA:=PX_CONN.PX_OBJ().TM_REA;
               _tab.KH:=$PX_CONN.PX_OBJ().KH;
               _tab.TM_PLA:=_pl_rea;
               _tab.DK_C:=$exec('get_dkc','px_obj',PX_CONN.PX_OBJ);
               {? _pl_rea>0
               || _tab.PL_DATA:=exec('tm_stamp2date','#tm_stamp',_tab.TM_PLA);
                  _tab.PL_TIME:=exec('tm_stamp2time','#tm_stamp',_tab.TM_PLA)
               ?};
               {? PX_GRP.PX_TEX().RTKTL<>''
               || _tab.TKTL:=PX_GRP.PX_TEX().RTKTL
               ?};

               {? _kind='W'
               || _tab.COMPLEX:='N'
               |? _kind='T'
               || {? exec('czy_pf','tech_mater',PX_GRP.PX_TEX().TKTL)
                  || _tab.COMPLEX:='T'
                  || _tab.COMPLEX:='N';
                     _msg:='Zmieniono kategorię zlecenia dla: %1 na zlecenie pojedyńcze. Technologia nie zawiera półfabrykatów'@[PX_GRP.SYMBOL];
                     KOMM.add(_msg,7,,1)
                  ?}
               |? _kind='N'
               || _tab.COMPLEX:='N'
               ?};
               _tab.add()
            ?}
         ?};
         PX_CONN.next()
      !}
   ?};
   {? PX_CONN.first()
   || {!
      |? _oddz:=exec('get_oddzial','px_obj',PX_CONN.PX_OBJ);
         {? PX_CONN.M<>null() & _oddz<>''
         || _tab.prefix();
            _size:=_tab.size();
            {? _kind='W' & PX_GRP.PX_TEX().TKTL<>null()
            || _tab.index(_ndx2);
               _tab.prefix(_oddz,$PX_GRP.PX_TEX().TKTL,_m_atr,_jm)
            || _tab.index(_ndx1);
               _tab.prefix(_oddz,$PX_CONN.M)
            ?};
            {? _tab.first()
            || _parent:=_tab.ref();
               _tab.blank();
               _tab.ODDZ:=_oddz;
               _tab.LP:=_size+1;
               _tab.KIND:='P';
               _tab.TREE:=_parent;
               _tab.M_REF:=$PX_CONN.M;
               _tab.M_KTM:=PX_CONN.M().KTM;
               _tab.M_NAZ:=PX_CONN.M().N;
               _tab.TKTL:=$PX_GRP.PX_TEX().TKTL;
               _tab.SRC:=$PX_CONN.PX_OBJ().ZK_P;
               _tab.SYMBOL:=PX_CONN.PX_OBJ().SYMBOL;
               {? _kind='W'
               || _tab.M_ATR:=_m_atr;
                  _tab.JM_SYM:=_jm
               ?};
               _ilosc:=PX_CONN.ILOSC-exec('get_ilosc_zl','px_obj',PX_CONN.PX_OBJ);
               _ilosc:=exec('max','#math',0,_ilosc);
               _tab.IL:=_ilosc;
               _tab.add()
            ?}
         ?};
         PX_CONN.next()
      !}
   ?};
   PX_CONN.cntx_pop();
   PX_POZ.cntx_pop();
   _tab.ndx_drop(_ndx1);
   _tab.cntx_pop();
   ~~
?};
PX_GRP.cntx_pop();
PX_OBJ.cntx_pop();
M.cntx_pop();
_tab.prefix();
::exec('select','#table',_tab,1);
_tab


\tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Zwraca tabelkę tymczasową służącą do pogrupowania
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,'TREE','TREE_REF','Drzewo',
                'SYMBOL','STRING[40]','Symbol',
                'KIND','STRING[1]','Rodzaj',
                'ODDZ','STRING[1]','Oddział',
                'COMPLEX','STRING[1]','Złożone/proste',
                'LP','REAL','Lp.',
                'M_REF','STRING[16]','Ref materiału',
                'PX_GRP','STRING[16]','Ref grupy',
                'SRC','STRING[16]','Ref źródła',
                'M_KTM','STRING[100]','Ktm',
                'M_NAZ','STRING[100]','Nazwa produktu',
                'IL','REAL','Ilość',
                'JM_SYM','STRING[20]','Jednostka miary',
                'ENDD','DATE','Termin realizacji - data',
                'ENDT','TIME','Termin realizacji - godzina',
                'PL_DATA','DATE','Planowana realizacja - data',
                'PL_TIME','TIME','Planowana realizacja - godzina',
                'TM_REA','REAL','Tm stamp terminu realizacji',
                'TM_PLA','REAL','Tm stamp planowanej realizacji',
                'ZL','STRING[16]','Ref wygenerowanego zlecenia',
                'ZL_MERGE','STRING[16]','Ref zlecenia do powiązania',
                'TKTL','STRING[16]','Ref technologii',
                'KH','STRING[16]','Ref kontrahenta',
                'DK_C','STRING[16]','Ref cechy',
                'M_ATR','STRING[16]','Zestaw atrybutów'
                );
_tab


\auto_px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Funkcja generowania jednego lub wielu zleceń na podstawie grupy w kolejce
::   WE: _a - _args - argumenty dla funkcji generujacej, wynik dzialania exec('auto_args','zl_gen')
::       _b - PX_GRP.ref - grupa w kolejce
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('auto_args','zl_gen')
?};
_px_grp:=_b;

_result:=0;
_can_continue:=1;

_mp:=params_get().mp;

PX_GRP.cntx_psh();
PX_GRP.clear();

{? PX_GRP.seek(_px_grp)
||
   _what:=exec('PX_GRP','#to_string');
:: Blokuję grupę w kolejce na czas generowania zlecenia
   _locked:=exec('lock','px_grp');
   {? _locked>0
   ||
::    Sprawdzenie produktu w zleceniach nadrzędnych
      {? _can_continue>0 & _args.ZL_NAD<>null()
      || {? exec('FindAndGet','#table',ZL,_args.ZL_NAD,,"$KTM=_b.M",0,_args)
         || _msg:='Indeks produktu jest wykorzystany w zleceniu wyższego poziomu.'@;
            {? _args.GRUPA>0
            || KOMM.add(_msg,4)
            |? _args.DIALOG>0
            || FUN.info(_msg)
            ?};
            _mp.error(_msg);
            _can_continue:=0
         || {? exec('FindAndGet','#table',ZL,_args.ZL_NAD,,
                  "exec('chk_ktm','zl_head',TREE,exec('FindAndGet','#table',M,_b.M))>0",0,_args
               )
            || _msg:='Indeks produktu jest wykorzystany w zleceniu wyższego poziomu.'@;
               {? _args.GRUPA>0
               || KOMM.add(_msg,4)
               |? _args.DIALOG>0
               || FUN.info(_msg)
               ?};
               _mp.error(_msg);
               _can_continue:=0
            ?}
         ?}
      ?};
::    Sprawdzenie terminu realizacji
      {? _can_continue>0
      ||
         {? _args.PL_DATA<date()
         || {? _args.DIALOG>0
            ||
               {? ~FUN.ask('Generowanie zlecenia\n\n'
                     'Termin realizacji jest wcześniejszy, niż data powołania zlecenia.\n'
                     'Czy wygenerować zlecenie (konieczna będzie korekta daty na zleceniu)?'@,
                  )
               || _can_continue:=0
               ?}
            |? _args.GRUPA>0
            || _can_continue:=0;
               _msg:='Termin realizacji jest wcześniejszy, niż data powołania zlecenia.'@;
               _mp.error(_msg);
               KOMM.add(_msg,2)
            ?}
         ?}
      ?};
      {? _can_continue>0
      || {? exec('sprdt','zl_head')
         || exec('auto_zl_core','zl_gen',_args)
         ?}
      ?};
::    Odblokowuje PX_GRP
      exec('unlock','px_grp')
   ?}
?};
PX_GRP.cntx_pop();
~~


\tab2args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Generuję/aktualizuję tablicę z argumentami dla funkcji generujących zlecenie na postawie
::       aktualnego rekordu kolejki PX_GRP
::   WE: [_a] - wynik działania exec('auto_args','zl_gen')
::       _b - tab_tmp
::   WY: _args - argumenty dla funkcji generującej, wynik działania exec('auto_args','zl_gen')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('auto_args','zl_gen')
?};
_tab:=_b;

_can_continue:=1;
_args.M:=_tab.M_REF;
_args.KTM:=_tab.M_KTM;
_args.ILOSC:=_tab.IL;
_args.IL_WYTW:=_tab.IL;
_args.JM_SYM:=_tab.JM_SYM;
_args.COMPLEX:=_tab.COMPLEX;
{? _tab.TKTL<>''
|| _args.TKTL:=exec('FindAndGet','#table',TKTL,_tab.TKTL,,,null())
?};
{? _tab.ZL_MERGE<>''
|| _args.ZL_MERGE:=exec('FindAndGet','#table',ZL,_tab.ZL_MERGE,,,null())
?};
{? _tab.KH<>''
|| _args.KH_REF:=_tab.KH
?};
{? _tab.DK_C<>''
|| _args.DK_C:=_tab.DK_C
?};
_args.DTR:=_tab.ENDD;
_args.PL_DATA:=_tab.ENDD;
_args.PL_TIME:=_tab.ENDT;
_args.GRP_KEY:='';
_tab.cntx_psh();
_ndx2:=_tab.ndx_tmp(,,'TREE',,);
_tab.index(_ndx2);
_tab.prefix(#_tab.ref());
_sym_conn:='';
{? _tab.first()
|| {!
   |? _sym_conn+=_tab.SYMBOL+'+';
      _tab.next()
   !}
?};
_sym_conn:=_sym_conn-1;
_tab.cntx_pop();
_tab.ndx_drop(_ndx2);
_args.OPIS:='Generowane z planu strateg.: '+_sym_conn;
_args


\action_generuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Akcja Generuj w kolejce planu
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
ZLEC.ZTP:=null();
_can_continue:=1;
_one_ver:=exec('is_one_version','px_param');
_ref:='';
_cur_tab:=cur_tab(1,1);
{? var_pres('PX_GRP',_cur_tab)>0
|| _px_grp:=_cur_tab.PX_GRP;
   {? type_of(_px_grp)=type_of(null)
   || _ref:=$_px_grp
   |? type_of(_px_grp)=type_of('')
   || _ref:=_px_grp
   ?}
?};
{? _ref=''
|| _ref:={? _one_ver || $PX_GRPS.PX_GRP || PxSelect.Pxgrp.TAB.PX_GRPI ?}
?};
_blk:='';
PX_GRP.cntx_psh();
PX_GRP.prefix();
{? PX_GRP.seek(_ref)
||
:: szukam takiego samego obiektu grupujacego ale w wersji zrodlowej
   PX_GRP.index('UID');
   _uid:='';
   _prefix_mode:=exec('poz_prefix_mode','px_grp');
   {? _prefix_mode='SOURCE'
   || _uid:=PX_GRP.UID_SRC
   || _uid:=PX_GRP.UID
   ?};
   PX_GRP.prefix(_uid);
   {? PX_GRP.first()
   || {? exec('lock','px_grp',PX_GRP.ref(),1)
      || _args:=exec('mp_run_a','#b__box');
         _args.ACT_UID:='TTE_PZL_DZPX';
         _args.UIDREF:=PX_GRP.uidref();
         _args.AKCJA:='GENERUJ';
         _args.PROC_START:='T';
         _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
         exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'PX_GRP',PX_GRP.ref());
         exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL_NAD',VAR.A_ZLNAD);
         exec('mp_run','#b__box',_args);
         exec('unlock','px_grp',_ref);
         PX_GRP.get();
         _blk:=PX_GRP.BLK
      ?}
   ?}
?};
:: Uaktualniam status blokady
PX_GRP.prefix();
{? PX_GRP.seek(_ref) & _blk<>''
|| {? PX_GRP.PX_VER().PRIMARY=0
   || PxSelect.Pxgrp.TAB.BLK:=_blk;
      PxSelect.Pxgrp.TAB.put()
   ?}
?};
PX_GRP.cntx_pop();
~~


\action_generuj_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Akcja Generuj w kolejce planu
::   WE: [_a] - uchwyt do obiektu
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
::ZLEC.ZTP:=null();
sel_nchk();
KOMM.init(250,,'Generowanie zleceń na podstawie planu'@);

_cur_tab:=cur_tab(1,1);
_sel_tab:=_cur_tab.sel_aget();
_cur_tab.cntx_psh();
_tab:=exec('tab','!tte_pzl_dzpx');
_ref_table_px:=exec('ref_table','#table');

_env_gen:=exec('env_gen','zl_gen');
_can_continue:=1;

{? _sel_tab.first()
||
   ZLEC.win_edit('ZL_GENPX');
   {? ZLEC.ZTP=null()
   || ZTP.cntx_psh();
      ZTP.prefix();
      {? ZTP.size()=1 & ZTP.first()
      || ZLEC.ZTP:=ZTP.first()
      ?};
      ZTP.cntx_pop()
   ?};
   {? ZLEC.COMPLEX=''
   || ZLEC.COMPLEX:='N'
   ?};

   ZTP.f_clear();
   _typy:=exec('typy_zlecen','zl_head','P');
   ZTP.f_set('TYP',,'ZTP.REFERENCE in (select :_a.REF from :_a)',_typy);
   obj_del(_typy);
   ZTP.win_dict('SLO');
   _env_gen.edit_ZTP:=1;
   _env_gen.edit_COMPLEX:=1;
   {? ZTP.f_size()=1 & ZTP.f_first()
   || ZLEC.ZTP:=ZTP.ref()
   ?};
   ZLEC.TKTL:=null();
   params_set('env_gen',_env_gen);

   {? ZLEC.edit("__CHK.record(ZLEC,,'ZTP')")
   || _can_continue:=1
   || _can_continue:=0
   ?};
   ZTP.f_clear();

   {? _can_continue>0
   ||
      {!
      |? _cur_tab.clear();
         {? _cur_tab.seek(_sel_tab.REF,)
         ||
            _ref:='';
            {? var_pres('PX_GRP',_cur_tab)>0
            || _px_grp:=_cur_tab.PX_GRP;
               {? type_of(_px_grp)=type_of(null)
               || _ref:=$_px_grp
               |? type_of(_px_grp)=type_of('')
               || _ref:=_px_grp
               ?}
            ?};
            {? _ref=''
            ||
               {? var_pres('_Tab')>100
               || obj_del(_Tab)
               ?};
               {? exec('is_one_version','px_param')
               || _Tab:=exec('tab','px_grps')
               || {? var_pres('_obj')>100
                  || obj_del(_obj)
                  ?};
                  _obj:=_a;
                  _obj.f_record();
                  __nr:=_obj.TAB.NR;
                  __upnode:=_obj.TAB.UPNODE;
                  _Tab:=_obj.TAB
               ?};
               _ref:=_Tab.PX_GRPI
            ?};
            {? _ref<>''
            || PX_GRP.cntx_psh(); PX_GRP.prefix();
               {? PX_GRP.seek(_ref)
               ||
::                szukam takiego samego obiektu grupujacego ale w wersji zrodlowej
                  PX_GRP.index('UID');
                  _uid:='';
                  _prefix_mode:=exec('poz_prefix_mode','px_grp');
                  {? _prefix_mode='SOURCE'
                  || _uid:=PX_GRP.UID_SRC
                  || _uid:=PX_GRP.UID
                  ?};
                  PX_GRP.prefix(_uid);
                  {? PX_GRP.first()
                  || _ref_table_px.add(PX_GRP.ref())
                  ?}
               ?};
               PX_GRP.cntx_pop()
            ?}
         ?};
         _sel_tab.next()
      !}
   ?}
?};
{? _can_continue>0
|| _rt:=_ref_table_px.tab;

   _rt.prefix();
   {? _rt.first()
   || {!
      |? PX_GRP.cntx_psh(); PX_GRP.prefix();
         {? PX_GRP.seek(_rt.SQL)
         || exec('grupuj','!tte_pzl_dzpx',,_tab,ZLEC.COMPLEX,_ref_table_px)
         ?};
         PX_GRP.cntx_pop();
         _rt.next()
      !}
   ?}
?};

{? _can_continue>0
||
   _wer:=exec('win_grupa','!tte_pzl_dzpx',_tab,ZLEC.COMPLEX);
   _tab.win_sel(_wer);
   _complex:=ZLEC.COMPLEX;

   _args_gen:=exec('auto_args','zl_gen');
   _args_gen.MERGE:=0;
   _env_gen.edit_IL:=0;
   _env_gen.edit_ZTP:=0;
   _env_gen.edit_COMPLEX:=0;

   params_set('args',_args_gen,'env_gen',_env_gen,'TAB',_tab);
   _ndx1:=_tab.ndx_tmp(,,'KIND',,);
   _tab.index(_ndx1);
   _tab.prefix('G');
   {? _tab.select()
   || {? _sel_tab.first()
      || _b_prel:=null();
         {!
         |? _cur_tab.clear();
            {? _cur_tab.seek(_sel_tab.REF,)
            || _blk:='';
               _ref:='';
               {? var_pres('PX_GRP',_cur_tab)>0
               || _px_grp:=_cur_tab.PX_GRP;
                  {? type_of(_px_grp)=type_of(null)
                  || _ref:=$_px_grp
                  |? type_of(_px_grp)=type_of('')
                  || _ref:=_px_grp
                  ?}
               ?};
               {? _ref=''
               ||
                  {? var_pres('_Tab')>100
                  || obj_del(_Tab)
                  ?};
                  {? exec('is_one_version','px_param')
                  || _Tab:=exec('tab','px_grps')
                  || {? var_pres('_obj')>100
                     || obj_del(_obj)
                     ?};
                     _obj:=_a;
                     _obj.f_record();
                     __nr:=_obj.TAB.NR;
                     __upnode:=_obj.TAB.UPNODE;
                     _Tab:=_obj.TAB
                  ?};

                  {? _Tab.PX_GRPI<>''
                  || _ref:=_Tab.PX_GRPI
                  ?}
               ?};
               {? _ref<>''
               ||
                  PX_GRP.cntx_psh(); PX_GRP.prefix();
                  {? PX_GRP.seek(_ref)
                  ||
::                   szukam takiego samego obiektu grupujacego ale w wersji zrodlowej
                     PX_GRP.index('UID');
                     _uid:='';
                     _prefix_mode:=exec('poz_prefix_mode','px_grp');
                     {? _prefix_mode='SOURCE'
                     || _uid:=PX_GRP.UID_SRC
                     || _uid:=PX_GRP.UID
                     ?};
                     PX_GRP.prefix(_uid);
                     {? PX_GRP.first()
                     || {? exec('lock','px_grp',,1)
                        || {? var_pres('_args')>100
                           || obj_del(_args)
                           ?};
                           _args:=exec('mp_run_a','#b__box');
                           _args.ACT_UID:='TTE_PZL_DZPX';
                           _args.CONTEXT:=obj_new('TAB','KIND');
                           _args.CONTEXT.TAB:=_tab;
                           _args.CONTEXT.KIND:=_complex;
                           _args.UIDREF:=PX_GRP.uidref();
                           _args.PROC_START:='T';
                           _args.GRUPA:='T';
                           _args.B_PREL:=_b_prel;
                           VAR.GRUPA:='T';
                           _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
                           exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZTP',ZLEC.ZTP);
                           exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'PX_GRP',PX_GRP.ref());
                           exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL_NAD',VAR.A_ZLNAD);
                           exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'KIND',_complex);
                           exec('mp_run','#b__box',_args);
                           _b_prel:=_args.B_PREL;
                           exec('unlock','px_grp');
                           PX_GRP.get();
                           _blk:=PX_GRP.BLK
                        ?}
                     ?}
                  ?};
                  PX_GRP.cntx_pop()
               ?};
::             Uaktualniam status blokady
               {? exec('is_one_version','px_param')=0 & _blk<>'' & var_pres('_a')>100
               || {? var_pres('_obj')>100
                  || obj_del(_obj)
                  ?};
                  _obj:=_a;
                  _obj.TAB.BLK:=_blk;
                  _obj.TAB.put()
               ?}
            ?};
            _sel_tab.next()
         !}
      ?}
   ?};
   _tab.ndx_drop(_ndx1)
?};
_cur_tab.cntx_pop();
KOMM.select();
_cur_tab.sel_adel();
0


\action_generuj_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Akcja Generuj w kolejce planu
::   WE: [_a] - uchwyt do obiektu
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
ZLEC.ZTP:=null();
VAR.GRUPA:='N';
~~


\win_grupa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Tworzy okienko selekcji dla tabelki grupującej
::   WE: _a - tab_tmp - tabelka ze zgrupowanymi rekordami
::       [_b] - STRING - kategoria zlecenia
::   WY: STRING - akronim okna
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_kind:='';
{? var_pres('_b')=type_of('')
|| _kind:=_b
?};

_wer:=_tab.mk_sel('Opcje generowania zleceń'@,,,'pxgenag',,,,,'U');
_tab.win_fld(_wer,,'M_KTM',,,25,,1,'Kod produktu'@);
_tab.win_fld(_wer,,'M_NAZ',,,25,,1,'Nazwa produktu'@);
_tab.win_fld(_wer,,'ENDD',,,10,,1,'Termin realizacji'@);
_tab.win_fld(_wer,,'IL',,,12,,1,'Ilość'@);
_tab.win_fld(_wer,ZLEC,'RED_KTL',,,15,,,'Technologia'@);
_tab.win_fld(_wer,ZLEC,'RED_WER',,,6,,1,'Wersja'@);
_tab.win_fld(_wer,ZLEC,'RODZAJ',,,5,,,'Zlecenie złożone'@,,
                                          'Zlecenie złożone - T, zlecenie proste - N'@,2,,"'T'","'N'"
);

_fb:="
   _tab:=params_get().TAB;

   VAR.A_T:=exec('FindAndGet','#table',M,_tab.M_REF);
   {? _tab.TKTL<>''
   || {? TKTL.seek(_tab.TKTL)
      || ZLEC.TKTL:=TKTL.ref();
         ZLEC.RED_KTL:=TKTL.NRK;
         ZLEC.RED_WER:=TKTL.WER
      || ZLEC.TKTL:=null();
         ZLEC.RED_KTL:='';
         ZLEC.RED_WER:=''
      ?}
   || ZLEC.TKTL:=null();
      ZLEC.RED_KTL:='';
      ZLEC.RED_WER:=''
   ?};
   ZLEC.RODZAJ:=_tab.COMPLEX;
   ZLEC.IL_2DIV:=_tab.IL;
   ZLEC.IL_ZLEC:=_tab.IL;
   ZLEC.COMPLEX:=_tab.COMPLEX;
   ZLEC.ZL_MERGE:=exec('FindAndGet','#table',ZL,_tab.ZL_MERGE,,,null());
   ~~
";

_fa:="
   ~~
";
_tab.win_act(_wer,,'Rekord',,,,_fb,_fa);

_fb:="
   params_set(params_get());
   _tab:=cur_tab(1,1);
   ZTP.f_clear();
   _typy:=exec('typy_zlecen','zl_head','P');
   ZTP.f_set('TYP',,'ZTP.REFERENCE in (select :_a.REF from :_a)',_typy);
   ZLEC.win_edit('ZL_GEN');
   _valid:=\"
      _result:='';
      {? ZLEC.RED_KTL=''
      || _result:='RED_KTL';
         FUN.info('Karta technologiczna musi być wypełniona.'@)
      ?};
      _result
   \";
   {? ZLEC.edit(_valid)
   || _tab.TKTL:=$ZLEC.TKTL;
      _tab.COMPLEX:=ZLEC.COMPLEX;
      _tab.put()
   ?};
   ZTP.f_clear();
   ~~
";
_tab.win_act(_wer,,'Formuła','Popraw'@@,,,_fb,,1,,,,'P');
_tab.win_btn(_wer,'text=%1'['Popraw'@],'menu:P');

{? _kind='W'
||
   _fb:="
      params_set(params_get());
      _tab:=cur_tab(1,1);

      _tab.cntx_psh();
      _ndx:=_tab.ndx_tmp(,,'TREE',,);
      _tab.index(_ndx);
      _tab.prefix(#_tab.ref());
      _produkty:=tab_tmp(2,
         'KTM','STRING[100]','Nazwa pola 1',
         'N','STRING[100]','Nazwa pola 1',
         'REF','STRING[16]','Nazwa pola 1'
      );
      {? _tab.first()
      || {!
         |? _produkty.prefix(_tab.M_KTM,_tab.M_NAZ,);
            {? _produkty.first()=0
            || _produkty.blank();
               _produkty.KTM:=_tab.M_KTM;
               _produkty.N:=_tab.M_NAZ;
               _produkty.REF:=_tab.M_REF;
               _produkty.add()
            ?};
            _tab.next()
         !}
      ?};
      _tab.cntx_pop();

      _produkty.prefix();
      _wer:=_produkty.mk_sel('Wybór produktu głównego dla zlecenia'@,,,'#sedffdmc',,,,,'U');
      _produkty.win_fld(_wer,,'KTM',,,50,,,'Indeks'@);
      _produkty.win_fld(_wer,,'N',,,50,,,'Nazwa'@);
      _produkty.win_act(_wer,0,'Formuła','Wybierz'@@,,,\"sel_exit()\",,1);

      _produkty.win_sel(_wer);
      {? _produkty.select()>0
      || _tab.M_KTM:=_produkty.KTM;
         _tab.M_NAZ:=_produkty.N;
         _tab.M_REF:=_produkty.REF;
         _tab.put()
      ?};
      ~~
   ";
   _tab.win_act(_wer,,'Formuła','Zmień produkt'@@,,,_fb,,,,,,'Z');
   _tab.win_btn(_wer,'text=%1'['Zmień produkt'@],'menu:Z')
?};


_fb:="
   _tab:=cur_tab(1,1);
   _result:=1;
   _tab.cntx_psh();
   {? _tab.first()
   || {!
      |? {? _tab.COMPLEX='P'
         || _tab.COMPLEX:='N';
            _tab.put()
         ?};
         {? _tab.TKTL=''
         || _result:=0;
            _msg:='Nie można kontynuować, nie wyszystkie rekordy mają uzupełnioną technologię.'@;
            FUN.emsg(_msg)
         ?};
         _tab.next() & _result>0
      !}
   ?};
   _tab.cntx_pop();
   {? _result>0
   || sel_exit()
   || 0
   ?}
";

_tab.win_act(_wer,,'Formuła','Akceptuj'@@,,,_fb,,0,,,,'A');

_tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Akceptuj'@],'menu:A');
_tab.win_sel(_wer);
_tab.fld_attr(,2);
_wer


\zlisty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Akcja Powołaj na podstawie -> planu strategicznego od strony zleceń produkcyjnych
::   WE: [_a] - tryb pracy: 1 - (domyślnie) lista zleceń, 2 - podzlecenie zlecenia złożonego
::       [_b] - ZL.ref() - zlecenie nadrzędne (wymagane dla trybu 2)
::       [_c] - STRING - który zestaw akcji dostępny: ['GENERUJ']/'WYBIERZ'
::----------------------------------------------------------------------------------------------------------------------
_tryb:=1;
{? var_pres('_a')=type_of(0)
|| _tryb:=_a
?};

_zl_nad:=null();
{? var_pres('_b')=type_of(ZL.ref())
|| _zl_nad:=_b
?};
_akcje:='GENERUJ';
{? var_pres('_c')=type_of('')
|| _akcje:=_c
?};

{? _tryb=2
|| VAR.A_ZLNAD:=_zl_nad
|| VAR.A_ZLNAD:=null()
?};

{? var_pres('_b')=type_of(null()) || _zl_nad:=_b || _zl_nad:=null() ?};


_version:=exec('get_mainversion','px_ver');

:: Definicja okien
_delete:="
   VAR_DEL.delete('PxSelect')
";
_delete();

PxSelect:=exec('pxselect','px_plan');
PxSelect.save();
PX_VAR.VIE_VER:=_version;
PX_VAR.VER_QUE:=_version;
PX_VAR.EDIT:=0;
PxSelect.VER_QUE:=_version;
PX_GRP.index('LP');
PX_GRP.prefix(_version,'Z');

exec('panel','px_conn');
::exec('actions','px_conn');
_wer:=PxSelect.Pxconn.WER;
PX_CONN.actions(_wer,'PUT',,1);

:: Okno PX_GRP
_tab:=tab_tmp(1
   ,'LP','REAL','Lp.'@
   ,'SYMBOL','STRING[100]','Symbol'@
   ,'C_ILOSC','REAL','Ilość'@
   ,'JM','STRING[10]','jm'@
   ,'T_REAL','STRING[20]','Termin realizacji'@
   ,'T_PLAN','STRING[20]','Planowana realizacja'@
   ,'T_START','STRING[20]','Planowany początek prac'@
   ,'ZNACZNIK','STRING[1]','Zwrot'@
   ,'PX_GRP','STRING[16]','Ref sql PX_GRP'
   ,'M_KTM','STRING[100]','Indeks materiałowy'@
   ,'M_NAZ','STRING[100]','Nazwa materiału'@
);

_wer:=_tab.mk_sel('Kolejka'@,,,'#pxselgen',,,,,'U');
_tab.win_fld(_wer,,'LP',,,2,0);
_tab.win_fld(_wer,,'SYMBOL',,,20);
_tab.win_fld(_wer,,'C_ILOSC',,,6,ST.DOKL);
_tab.win_fld(_wer,,'JM',,,3);
_tab.win_fld(_wer,,'T_REAL',,,-11);
_tab.win_fld(_wer,,'T_PLAN',,,-11);
_tab.win_fld(_wer,,'ZNACZNIK',,,5);

{? _akcje='GENERUJ'
||
   _fb:="
      _envq:=params_get().envq;
      _result:=exec('action_generuj','!tte_pzl_dzpx');
      _envq.reload();
      _result
   ";
   _gr1:="
      _envq:=params_get().envq;
      _result:=exec('action_generuj_gr1','!tte_pzl_dzpx');
      _envq.reload();
      _result
   ";
   _gr2:="
      exec('action_generuj_gr2','!tte_pzl_dzpx')
   ";
   _tab.win_act(_wer,0,'Formuła','Generuj zlecenia'@@,,,_fb,,1,1,_gr1,_gr2,'G');
   task_attach('TTE_PZL_DZPX')
|? _akcje='WYBIERZ'
|| _fb:="
      _tab:=cur_tab(1,1);
      PX_VAR.PX_GRP:=exec('FindAndGet','#table',PX_GRP,_tab.PX_GRP,,,null());
      sel_exit()
   ";
   _tab.win_act(_wer,0,'Formuła','Wybierz'@@,,,_fb,,1,,,,'W')
?};

_fb:="
   _tab:=cur_tab(1,1);
   PX_POZ.cntx_psh();
   PX_CUP.cntx_psh();
   PX_GRP.cntx_psh(); PX_GRP.prefix();
   {? PX_GRP.seek(_tab.PX_GRP)
   ||
      _prefix_mode:=exec('poz_prefix_mode','px_grp');
      {? _prefix_mode='SOURCE'
      || PX_GRP.index('UID');
           PX_GRP.prefix(PX_GRP.UID_SRC);
         {? PX_GRP.first()
         ||
            PX_POZ.index('TM_GRP');
            PX_POZ.prefix(PX_GRP.ref());
            PX_POZ.win_sel('WER_GRP');
            PX_POZ.hdr_sel('Pozycje planu dla grupy %1'@[PX_GRP.SYMBOL]);
            PX_POZ.select()
         ?}
      || PX_POZ.index('TM_GRP');
         PX_POZ.prefix(PX_GRP.ref());
         PX_POZ.win_sel('WER_GRP');
         PX_POZ.hdr_sel('Pozycje planu dla grupy %1'@[PX_GRP.SYMBOL]);
         PX_POZ.select()
      ?}
   ?};
   PX_CUP.cntx_pop();
   PX_GRP.cntx_pop();
   PX_POZ.cntx_pop();
   ~~
";
_tab.win_act(_wer,0,'Formuła','Pozycje'@@,,,_fb,,,,,,'P');


_fb:="
   _tab:=cur_tab(1,1);
   _result:=~~;
   PX_GRP.cntx_psh(); PX_GRP.prefix();
   {? PX_GRP.seek(_tab.PX_GRP)
   || _result:=exec('px_grp_display','px_grp')
   ?};
   PX_GRP.cntx_pop();
   _result
";
_tab.win_act(_wer,,'Wyświetl',,,,_fb);

_fb:="
   _tab:=cur_tab(1,1);
   _result:=~~;
   PX_GRP.prefix();
   {? PX_GRP.seek(_tab.PX_GRP)
   || _color:=exec('px_grp_bre','px_grp',1,PX_GRP.ref());
      _result:=Color.fnd_kol(_color)
   ?};
   _result
";
_tab.win_act(_wer,,'Rekord',,,,_fb);

_fb:="exec('px_grp_legenda','px_grp')";
_tab.win_act(_wer,,'Formuła','Legenda'@@,,,_fb,,,,,,'L');

_ff:="
   _tab:=cur_tab(1,1);
   _ref:=null();
   PX_GRP.prefix();
   {? PX_GRP.seek(_tab.PX_GRP)
   || _ref:=PX_GRP.ref()
   ?};
   {? _ref<>null()
   ||
      {? cur_afld()='SYMBOL'
      || _ok:=0;
         PX_CONN.cntx_psh();
         PX_GRP.cntx_psh();
         PX_GRP.clear();
         _ref:=PX_GRP.ref();
         PX_CONN.index('PX_GRP');
         PX_CONN.prefix(_ref);
         _ok:=PX_CONN.first();
         _wyn:=
            {? _ok
            || {? PX_GRP.PLAN_OPR='T'
               || exec('pl_plan','icon')
               |? exec('is_blocked','px_grp')>0
               || 'xwin16.png:157'
               |? PX_GRP.PROBLEMS<>exec('problem_none','px_obj')
               || 'xwin16.png:4'
               || 'xwin16.png:110'
               ?}
            || 'xwin16.png:110'
            ?};
         PX_CONN.cntx_pop();
         PX_GRP.cntx_pop();
         _wyn
      |? cur_afld()='T_PLAN'
      || _wyn:='xwin16.png:110';
         {? exec('has_point','px_point',_ref,'A',,PX_VAR.PX_SET)>0
         || _wyn:='xwin16.png:134'
         ?};
         {? exec('has_point','px_point',_ref,'RP',,PX_VAR.PX_SET)>0
         || _wyn:='xwin16.png:133'
         ?};
         _wyn
      |? cur_afld()='C_ILOSC'
      || _wyn:=
            {? PX_GRP.STATUS=exec('status_wyk1','px_grp')
            || 'xwin16.png:72'
            |? PX_GRP.STATUS=exec('status_wyk2','px_grp')
            || 'xwin16.png:38'
            || ''
            ?};
         _wyn
      || ''
      ?}
   || ''
   ?}
";
_tab.win_fml(_wer,,'SYMBOL',,'ICON_BEFORE',_ff);
_tab.win_fml(_wer,,'T_PLAN',,'ICON_BEFORE',_ff,2);
_tab.win_fml(_wer,,'C_ILOSC',,'ICON_BEFORE',_ff,2);

_ff:="
   _result:='';
   {? ~-cur_nfld()='SYMBOL'
   || PX_GRP.cntx_psh(); PX_GRP.prefix();
      {? PX_GRP.seek(cur_tab(1,1).PX_GRP)
      ||  _tab:=obj_new('CMP','KOM_ERR','KOM_WARN','KOM_INFO');
         _tab.CMP:='';

::       Analiza pol o komunikatach
         PX_GRP.cntx_psh();
         _child_kom:=exec('kom_child_chk','px_grp',PX_GRP.ref());
         _kom_err:=PX_GRP.KOM_ERR;
         _kom_warn:=PX_GRP.KOM_WARN;
         _kom_info:=PX_GRP.KOM_INFO;
         PX_GRP.cntx_pop();

::       Jesli PX_GRP nie mial swojego komunikatu to byc moze maja go jego skadniki czyli PX_CONN
         {? _kom_err='N'
         || {? _child_kom*'E'>0
            || _kom_err:='T'
            ?}
         ?};
         {? _kom_warn='N'
         || {? _child_kom*'W'>0
            || _kom_warn:='T'
            ?}
         ?};
         {? _kom_info='N'
         || {? _child_kom*'I'>0
            || _kom_info:='T'
            ?}
         ?};

         _tab.KOM_ERR:=_kom_err;
         _tab.KOM_WARN:=_kom_warn;
         _tab.KOM_INFO:=_kom_info;

         _result:=exec('txt_bd','px_grp',_tab)
      ?};
      PX_GRP.cntx_pop()
   ?};
   _result
";
_tab.fld_fml('SYMBOL','BEFORE_DISPLAY',_ff);

_ff:="exec('t_real_bd','px_grp',cur_tab(1,1))";
_tab.fld_fml('T_REAL','BEFORE_DISPLAY',_ff);

_obj:=obj_new('TAB'
              ,'WER'
              ,'PX_VER'
              ,'reload');
_obj.TAB:=_tab;
_obj.WER:=_wer;
_obj.PX_VER:=_version;
_obj.reload:="
:: Ładowanie danych
   _tab:=.TAB;

   _view:=null();
   _tab.cntx_psh();
   {? _tab.prev()
   || _view:=_tab.ref()
   ?};
   _tab.cntx_pop();

   _tab.erase();
   PX_POZ.cntx_psh();
   M.cntx_psh();
   PX_POZ.index('TM_GRP');
   PX_GRP.cntx_psh();
   PX_GRP.index('VISIBLE');
   PX_GRP.prefix(.PX_VER,'T','Z');
   {? PX_GRP.first()
   || {!
      |? {? exec('has_zl_all','px_grp')=0
         || _tab.blank();
            _tab.PX_GRP:=$PX_GRP.ref();
            _tab.LP:=PX_GRP.LP_Q;
            _tab.SYMBOL:=PX_GRP.SYMBOL;
            _tab.C_ILOSC:=PX_GRP.ILOSC;
            _tab.JM:=PX_GRP.JM().KOD;
            _tab.T_REAL:=exec('pxgrptreal','px_grp',PX_GRP.ref());
            _tab.M_KTM:=PX_GRP.M().KTM;
            _tab.M_NAZ:=PX_GRP.M().N;
            {? PX_GRP.STRSTART<>''
            || _tab.T_START:=PX_GRP.STRSTART
            || _tab.T_START:='<brak poz>'
            ?};
            {? PX_GRP.STREND<>''
            || _tab.T_PLAN:=PX_GRP.STREND
            || _tab.T_PLAN:='<brak poz>'
            ?};
            _tab.ZNACZNIK:={? PX_GRP.DIR=-1 || exec('txt_plan_bck','px_param') || exec('txt_plan_fwd','px_param') ?};
            _tab.add()
         ?};
         PX_GRP.next()
      !}
   ?};
   PX_GRP.cntx_pop();
   PX_POZ.cntx_pop();
   M.cntx_pop();
   _tab.prefix();
   {? _view<>null()
   || _tab.seek(_view)
   || _tab.first()
   ?};
   ~~
";

params_set('envq',_obj);

:: Okno grupowe
_grp:=_tab.grp_make('Kolejka: %1'@[exec('record','#to_string',_version)],,'#pxgrpview',,,,,'normal');
_before:="
";
_after_refresh:="
   params_set(params_get());
   PX_CONN.index('PX_GRP');
   PX_CONN.prefix(PX_GRP.ref());
   PX_CONN.first();

   PX_OBJ.cntx_psh();
   {? type_of(PxSelect.Pxconn)>0 & var_pres('WER',PxSelect.Pxconn)>0
   || grp_disp(PX_CONN,PxSelect.Pxconn.WER)
   ?};
   PX_OBJ.cntx_pop()
";

_tab.grp_sel(_grp,_tab,_wer,,_after_refresh,,,15,_before,,,,'maximized_with_title');

_tab.grp_splt(_grp,,'horizontal','dolny');
_fb:="
   _result:='';
   _envq:=params_get().envq;
   {? grp_empty(_envq.TAB,_envq.WER)
   || _result:='#disable'
   ?};
   _result
";
_fa:="
";
_tab.grp_sel(_grp,PX_CONN,PxSelect.Pxconn.WER,,,,,15,_fb,_fa,,,'maximized_with_title');

_tab.win_sel(_grp);
_obj.reload();
_result:=_tab.select();
PxSelect.restore();
_delete();
_result


\chk_oddział
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Sprawdza czy obiekt grupujący zawiera elementy tylko z bieżącego oddziału
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::   WY: 0 - brak zgodności
::       1 - jest zgodność
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |? _oddz:=exec('get_oddzial','px_obj',PX_CONN.PX_OBJ);
         {? _oddz<>ST.ODDZ
         || _can_continue:=0
         ?};
         PX_CONN.next() & _can_continue>0
      !}
   ?};
   PX_CONN.cntx_pop()
?};
PX_GRP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\material4tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca indeks materiałowy, podstawowy dla generowanego zlecenia na podstawie TKTL
::   WE: [_a] - TKTL.ref() lub bieżący rekord
::        _b  - ref_table - tablica grup PX_GRP
::   WY: M.ref lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TKTL.ref())
|| _ref:=_a
?};
_ref_table:=_b;

_result:=null();
_can_continue:=1;

_allowed:=tab_tmp(1,
   'M_REF','STRING[16]','Nazwa pola 2',
   'KTM','STRING[100]','Nazwa pola 1'
);

TKTL.cntx_psh();
{? _ref<>null()
|| TKTL.prefix();
   {? TKTL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| TKTLW.cntx_psh();
   TKTLW.index('TP');
   TKTLW.prefix(TKTL.ref());

   PX_GRP.cntx_psh(); PX_GRP.prefix();
   _tab:=_ref_table.tab;
   _tab.cntx_psh();
   _tab.prefix();
   {? _tab.first()
   || {!
      |? {? PX_GRP.seek(_tab.SQL)
         || PX_CONN.cntx_psh();
            PX_CONN.index('PX_GRP');
            PX_CONN.prefix(PX_GRP.ref());
            {? PX_CONN.first()
            || {!
               |? {? PX_CONN.M<>null()
                  || _allowed.prefix($PX_CONN.M);
                     {? _allowed.first()=0
                     || _allowed.blank();
                        _allowed.M_REF:=$PX_CONN.M;
                        _allowed.KTM:=PX_CONN.M().KTM;
                        _allowed.add()
                     ?}
                  ?};
                  PX_CONN.next()
               !}
            ?};
            PX_CONN.cntx_pop()
         ?};
         _tab.next()
      !}
   ?};
   _tab.cntx_pop();

   PX_GRP.cntx_pop();

:: 1. Z nagłowka
   {? TKTL.KTM<>null()
   || _allowed.prefix($TKTL.KTM);
      {? _allowed.first()
      || _result:=TKTL.KTM
      ?}
   ?};

:: 2. Z pierwszego produktu dla którego ta karta jest domyślna
   {? _result=null()
   || {? TKTLW.first()
      || {!
         |? {? TKTLW.DEFAULT='T'
            || _allowed.prefix($TKTLW.KTM);
               {? _allowed.first()
               || _result:=TKTLW.KTM
               ?}
            ?};
            TKTLW.next() & _result=null()
         !}
      ?}
   ?};

:: 3. Z pierwszego dozwolonego produktu
   {? _result=null()
   || {? TKTLW.first()
      || {!
         |? _allowed.prefix($TKTLW.KTM);
            {? _allowed.first()
            || _result:=TKTLW.KTM
            ?};
            TKTLW.next() & _result=null()
         !}
      ?}
   ?};
   TKTLW.cntx_pop()
?};
TKTL.cntx_pop();
_result


\kind_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuła na redakcję parametru KIND w procesie
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_old:=_a;

_result:='';
_names:=obj_new(3);
_names[1]:='Zlecenie pojedyncze'@;
_names[2]:='Zlecenie pojedyncze z wieloma wyrobami'@;
_names[3]:='Zlecenie z podzleceniami na półfabrykaty'@;

_vals:=obj_new(3);
_vals[1]:='N';
_vals[2]:='W';
_vals[3]:='T';

_res:=exec('edit_radiobutton','#edit',_old,'Kategoria zlecenia'@,_names,_vals,'Dane podstawowe'@);
{? type_of(_res)=type_of('')
|| _result:=_res
?};
_result


:Sign Version 2.0 jowisz:1048 2023/06/23 14:09:40 d46dd6c41e7193a9f8540997b7db76467f65b141b39211b00a7eb1e469461460962e1654ef5116256acca9f127b7368aee025ba1fa166f36aa33980199aac98ae8dd3b707c7fbc7221d7f69d193119851ff77f103a38025f088a6b32cf57563dd930b5065205f66b40f9ffd608e263f1dcabaf8e7f53e0651c6cef32cb9a870d
