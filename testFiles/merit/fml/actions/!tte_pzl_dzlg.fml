:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tte_pzl_dzlg.fml
:: Utworzony: 02.11.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły czynności TTE_PZL_DZLG - Generacja zleceń
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła główna czynności generowania zleceń podrzędnych (TTE_PZL_DZLG)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::       context - [obj_new] obiekt służący do przekazywania kontekstu wywołania czynności
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

{? type_of(_context)=type_of(~~) || _context:=obj_new('ORDERS'); _context.ORDERS:=0 ?};

::# permissions=ODDZ,LMG
::# properties=LOOP,SERVICE
::# parses=exec('parses','!tte_pzl_dzlg')
::# condition=Rejestracja zlecenia, act_uid=TTE_PZL_DZLE, auto=T, formula=_a.ZL<>~~ & _a.ZL<>null()

:: PARAMETRY WE:
::# kind=WE, symbol=ZL_NAD, type=_ZL, name=Wskazanie na zlecenie nadrzędne, required=T, keyref=T
{? var_pres('ZL_NAD',_in)<>type_of(~~) & var_pres('ZL_NAD',_in)<>type_of(null()) || return() ?};
{? var_pres('ZL_NAD',_in)=type_of(~~) || _in.ZL:=null() ?};
::# kind=WE, symbol=GRP_KEY, type=STRING, name=Klucz grupujący, required=N, keyref=N
{? var_pres('GRP_KEY',_in)<>type_of(~~) & var_pres('GRP_KEY',_in)<>type_of('') || return() ?};
{? var_pres('GRP_KEY',_in)=type_of(~~) || _in.GRP_KEY:='' ?};

:: Parametry WEW:
::# kind=WEW, symbol=GRP_KEY, type=STRING, name=Klucz grupujący, required=N, keyref=N
{? var_pres('GRP_KEY',_int)<>type_of(~~) & var_pres('GRP_KEY',_int)<>type_of('') || return() ?};
{? var_pres('GRP_KEY',_int)=type_of(~~) || _int.GRP_KEY:='' ?};

:: PARAMETRY WY:
::# kind=WY, symbol=ZL, type=_ZL, name=Wskazanie na zlecenie podrzędne, required=N
{? var_pres('ZL',_out)<>type_of(~~) & var_pres('ZL',_out)<>type_of(null()) || return() ?};
::# kind=WY, symbol=GRP_KEY, type=STRING, name=Klucz grupujący, required=N
{? var_pres('GRP_KEY',_out)<>type_of(~~) & var_pres('GRP_KEY',_out)<>type_of('') || return() ?};
::# kind=WY, symbol=MONTAZOWE, type=STRING, name=Czy zlecenie montażowe, required=N
{? var_pres('MONTAZOWE',_out)<>type_of(~~) & var_pres('MONTAZOWE',_out)<>type_of('') || return() ?};
::# kind=WY, symbol=RESULT, type=STRING, name="Wynik działania (OK, BŁĄD)", required=N

:: Ustawiam wartość domyślną argumentu LOOP żeby brama się nie zawiesiła
_out.LOOP:='N';
:: Ustawiam wartość domyślną argumentu MONTAZOWE żeby brama się nie zawiesiła
_out.MONTAZOWE:='N';
_mp.save(,_out);

:: Zlecenie nadrzędne podmieniane jest na nadrzędne do przekazanego w GRP_KEY
:: (na wypadek niepoprawnej definicji procesu)
{? _in.GRP_KEY<>''
|| ZL.cntx_psh();
   ZL.index('GRP_KEY');
   ZL.prefix(_in.GRP_KEY);
   {? ZL.first()
   || _in.ZL_NAD:=exec('get_nadzlec','zl_link',ZL.ref());
      _mp.keyRef(exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"uidref()",''))
   ?};
   ZL.cntx_pop()
?};
ZL.cntx_psh();
ZL.clear();

_clean_result:=exec('clean','!tte_pzl_dzlg',_mp,_in);
_can_continue:=_clean_result.RESULT;
_zl:=_clean_result.ZL_NAD;

:: WSTĘPNE WALIDACJE
{? _can_continue>0 & _mp.isService() & _zl=null()
|| _msg:='Błędna konfiguracja procesu — nie przekazano zlecenia.'@;
   _mp.error(_msg);
   _can_continue:=0
?};

{? _can_continue & ZL.seek(_zl)
||
   {? ZL.TYP().WP='W'
   || _msg:='Niezgodność wywołania czynności.\nDla zlecenia warsztatowego nie można generować podzleceń.'@@;
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg)

   |? ZL.RODZAJ='N'
   || _msg:='Niezgodność wywołania czynności.\nDla zlecenia niezależnego nie można generować podzleceń.'@@;
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg)

   |? ZL.RODZAJ='P' & ZL.NRNZL=0
   || _msg:='Niezgodność wywołania czynności.\nDla zlecenia prostego nie można generować podzleceń.'@@;
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg)

::   |? _in.GRP_KEY<>'' & _zl_nad<>_in.ZL_NAD
::   || _msg:=
::         'Niezgodność wywołania czynności.\n'
::         'Przekazane zlecenie nadrzędne %1 (parametr ZLNAD) nie jest takie samo\n'
::         'jak zlecenie nadrzędne względem przekazanego klucza grupującego (zlecenie %2).'
::         [exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"SYM",''),exec('FindAndGet','#table',ZL,_zl_nad,,"SYM",'')];
::      FUN.emsg(_msg);
::      _mp.error(_msg)

   |? ZL.RODZAJ='P' & ZL.TYP().TECH='T' & ZL.STAT_T='N'
   || _msg:='Nie można uruchomić czynności.\nRedagowanie technologii zlecenia nie zostało zakończone.'@;
      _result:=0;
      {? _mp.isService()
      || _out.RESULT:='BŁĄD';
         _mp.save(,_out);
         _mp.done()
      || FUN.info(_msg);
         _mp.cancel()
      ?}

   |? ZL.STAN='Z'
   || _msg:='Nie można uruchomić czynności.\nZlecenie %1 jest zamknięte.'@[ZL.SYM];
      _result:=0;
      {? _mp.isService()
      || _out.RESULT:='BŁĄD';
         _mp.save(,_out);
         _mp.done()
      || FUN.info(_msg);
         _mp.cancel()
      ?}

   || _key:=_in.GRP_KEY;
      _gen:=1;

      {? _mp.loop()=0 | _mp.akcja()='GENERUJ'
      || gen:=0;
::       Sprawdzam czy istnieje już zapamiętany klucz grupujący (np nastąpił powrót do tej instancji czynności na skutek
::       jakiejś awarii i instancja nr 1 jest uruchomiona ponownie)
         {? _int.GRP_KEY<>''
         || _key:=_int.GRP_KEY
         || _key:=exec('uid','#blank')
         ?};
         {? _key<>''
         ||
::          Zapisuję identyfikator jako parametr wewnętrzny
            _int.GRP_KEY:=_key;
            _mp.save(_int);

::          Rozpoczynam generowanie
            _grp_key_on:=_key+'1';

            {? ~KOMM.is_inited() || KOMM.init(,,'Generowanie podzleceń zlecenia %1'@[ZL.SYM]) ?};
::          Zlecenie nadrzędne z półfabrykatami - generowane jest zlecenie montażowe
            {? ZL.RODZAJ='Z'
            ||
               {? ZL.TYP().TYP='K' & ZL.KTL().ARCH<>'N'
               || _msg:='Technologia źródłowa zlecenia: %1 jest w archiwum. Zlecenie montażowe nie powstało.'@[ZL.SYM];
                  KOMM.add(_msg,'xwin16.png:2')
               |? ZL.TYP().TYP='K' & ~exec('tktl_act','tech_head',1)
               || _msg:='Technologia źródłowa zlecenia: %1 jest nieaktywna. Zlecenie montażowe nie powstało.'@[ZL.SYM];
                  KOMM.add(_msg,'xwin16.png:2')
               ||
                  _context.ORDERS:=exec('generate_assembly_order','!tte_pzl_dzlg',
                     {? _mp.isAutoRun() | _mp.isService() || 'N' || 'T' ?},_grp_key_on);
                  {? _context.ORDERS<0 || _gen:=-2 || _gen:=1 ?}
               ?}
::          Podzlecenie proste zlecenia z półfabrykatami - generowany jest kolejny poziom podzleceń
            |? ZL.RODZAJ='P' & ZL.NRNZL<>0
            || _context.ORDERS:=exec('generate_sub_order','!tte_pzl_dzlg',
                  {? _mp.isAutoRun() | _mp.isService() || 'N' || 'T' ?},_grp_key_on);
               {? _context.ORDERS<0 || _gen:=-2 || _gen:=1 ?}

            || _gen:=-1
            ?};

            {? ~_mp.isAutoRun() & ~_mp.isService() || KOMM.select() ?}
         ?}
      ?};

      {? _key<>''
      ||
         _grp_key_on:=_key+'1';
         _grp_key_off:=_key+'0';

::       Wypycham pierwsze zlecenie na wyjście
         ZL.cntx_psh();
         ZL.index('GRP_KEY');
         ZL.prefix(_grp_key_on);
         {? ZL.first()
         || ZL.cntx_psh();
            ZL.prefix();
            ZL.GRP_KEY:=_grp_key_off;
            do();
            _can_continue:=ZL.put();
            _out.ZL:=ZL.ref();
            _out.GRP_KEY:=_key;
            {? exec('is_main_podzlec','zl_link',ZL.ref())
            || _out.MONTAZOWE:='T'
            ?};
            _mp.save(,_out);
            end();
            ZL.cntx_pop();
            {? ZL.first()
            ||
::             Jeżeli są jeszcze jakieś zlecenia to kontynuuję pętlę
               _mp.loop_continue()
            ?}
         ?};
         ZL.cntx_pop();
         {? _gen<-1
         || _msg:='Nie można uruchomić generowania podzleceń dla zlecenia: %1.\n'
                  'Zlecenia podrzędne zostały już utworzone.'@@[ZL.SYM];
            {? ~_mp.isService()
            || FUN.emsg(_msg)
            ?};
            _mp.error(_msg)
         |? _gen>=0
         || {? _mp.isService()
            || {? _gen>0
               || _out.RESULT:='OK'
               || _out.RESULT:='BŁĄD'
               ?}
            || _out.RESULT:='OK'
            ?};
            _mp.save(exec('kind_out','#b_port'),'RESULT',_out.RESULT);
            _mp.done()
         ?};
         ~~
      || _mp.error('Brak oczekiwanego parametru %1.'@['GRP_KEY'])
      ?}
   ?}
?};
ZL.cntx_pop();
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opis dla czynności generowania zleceń podrzędnych (TTE_PZL_DZLG)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: zwraca opis Zadania
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_desc:='';
_keyRefs:=_mp.getRefs();

:: jest rekord kluczowy to ustawiam odpowiednie ZL
{? var_pres('[1]',_keyRefs)
|| _tmp:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"SYM",'');
   _desc:={? _tmp<>'' || 'Generuj zlecenie produkcyjne na podstawie zlecenia %1'@@[_tmp] || '' ?}
::|| _desc:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"'Generuj zlecenie produkcyjne na podstawie zlecenia %1'[SYM]",'')
|| _desc:='Generuj nowe zlecenie produkcyjne'@@
?};
_desc


\action_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Akcja 'Dołącz -> Generuj' w oknie wertowania zleceń, uruchamia czynność
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TTE_PZL_DZLG';
_args.UIDREF:=ZL.uidref();
_args.AKCJA:='GENERUJ';
_args.PROC_START:='N';
_args.CONTEXT:=obj_new('ORDERS'); _args.CONTEXT.ORDERS:=0;
_args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);

exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL_NAD',ZL.ref());

exec('mp_run','#b__box',_args);

{? _args.CONTEXT.ORDERS<0
|| FUN.info('Nie wygenerowano zleceń (były już wcześniej wygenerowane).'@)
|? _args.CONTEXT.ORDERS=0
|| FUN.info('Nie wygenerowano zleceń.'@)
|| FUN.info('Ilość wygenerowanych zleceń: %1'@[$_args.CONTEXT.ORDERS])
?};
~~


\generate_assembly_order
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Tworzy zlecenie montażowe dla zlecenia złożonego
::   WE: [_a] - STRING - 'T'/'N' - czy pokazywać dialogi (domyślnie 'T')
::       _b - STRING - klucz grupujący, którym będą ostemplowane generowane zlecenia
::       Kontekst wywołania - ustawiony rekord ZL
::   WY: 0 / 1 - czy zostało wygenerowane zlecenie / -1 - już było podzlecenie
::  OLD: \utwpodzl/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _dialog:=_a || _dialog:='T' ?};
{? var_pres('_b')=type_of('') || _grp_key:=_b || FUN.error('Parametr \'klucz grupujący\' jest wymagany.'@); return(0) ?};

{? exec('subzlec_exist','zl_link',ZL.ref()) || return(-1) ?};

ZL.cntx_psh();
_orders:=0;

{? _dialog='N' | exec('sprdt','zl_head')
|| ZL.prefix();
   ZL.NRNZL:=0;
   ZL.TKTL:=null();
   ZL.RTKTL:='';
   ZL.put();
   VAR.A_ZLNAD:=ZL.ref();
   _refnad:=ZL.ref();
   _unrzl:=ZL.UNRZL;
   _opis:=ZL.OPIS;
   _nstan:=ZL.NSTAN;
   _ktm:=ZL.KTM().KTM;
   _tree:=#ZL.ref();
   _dtr:=ZL.DTR;
   _pl_data:=ZL.PL_DATA;
   _ilp:=exec('get','#params',500205,1);
   _mg:=ZL.MG;

   ZL.RODZAJ:='P';
   ZL.TREE_TYP:='M';
   ZL.RP:='T';
   ZL.NRNZL:=_unrzl;
   ZL.OPIS:='Montaż: '+_ktm;

   ZL.LEVEL:=1;
   ZL.NSTAN:=_nstan;
   ZL.TREE:=_tree;
   ZL.DTR:=(_dtr-_ilp);
   ZL.PL_DATA:=(_pl_data-_ilp);
   ZL.SCEAN:=exec('blzl_sce','kody_kresk');
   ZL.ZLEAN:=exec('blzl2sce','kody_kresk');
   ZL.ID_KSG:=exec('zl_idksg_bl','zl_head');

   {? ZL.TREE || ZL.NODE:=exec('node','zl_head') ?};

   ZL.STAT_N:='N';
   ZL.STAT_T:='N';
   ZL.STAN:='N';

   ZL.GRP_KEY:=_grp_key;
   ZL.memo_get(,'OPIS_DOD',0);
   ZL.prefix();
   ZL.SYM:='~'+$ZL.tm_stamp();
   {? ZL.add(1)
   || _orders+=1;
      POM.TAB:='ZL';
      exec('add_grnr','numery','ZLP');
      POM.TYPDOK:=ZL.TYP().KOD_ZLP;
      ZL.NR:=0;
      ZL.NR:=exec('numer_new','numery','PACZKA');
      exec('znak','numery','ZL',1);
      ZL.memo_put(,'OPIS_DOD');
      KOMM.add('Wygenerowano podzlecenie %1'@[ZL.SYM]);

      {? ZL.TREE=0 || ZL.NODE:=exec('node','zl_head') ?};
      ZL.put();
      {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};
      exec('openmask','zl_common',ZL.ref());
      exec('zl2obj','px_obj');
      exec('add_zleczam','zl_gen',ZL.ref(),ZL.IL);
::    Przepinam partie z nadrzędnego jeżeli były
      exec('party_transfer','zl_partie',ZL.ref());
      ~~
   ?};
   _refpod:=ZL.ref();
   VAR.A_ZLEC:=ZL.ref();
   exec('add_zwar_pos','zl_common','_n',0)

?};
ZL.cntx_pop();

_orders


\generate_sub_order
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Generowanie kolejnego poziomu podzleceń - wołane z czynności generowania
::   WE: [_a] - STRING - 'T'/'N' - czy pokazywać dialogi (domyslnie 'T')
::       _b - STRING - klucz grupujący, którym będą ostemplowane generowane zlecenia
::   WY: ilość wygenerowanych zleceń (0 lub więcej) / -1 - już były podzlecenia
::  OLD: \next_gen/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _dialog:=_a || _dialog:='T' ?};
{? var_pres('_b')=type_of('') || _grp_key:=_b || FUN.error('Parametr \'klucz grupujący\' jest wymagany.'@); return() ?};

ZL.cntx_psh(); TMAT.cntx_psh();
_var:=VAR.A_ZLEC;
VAR.A_ZLEC:=ZL.ref();
_orders:=exec('levelpod','!tte_pzl_dzlg',VAR.A_ZLEC,_dialog,_grp_key);
VAR.A_ZLEC:=_var;
ZL.cntx_pop(); TMAT.cntx_pop();
_orders


\levelpod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Formuła generująca kolejny poziom zlecenia.
::   WE: _a - ZL.ref() - zlecenie, do którego generować podzlecenia
::       [_b] - STRING - 'T'/'N' - czy pokazywać dialogi (domyslnie 'T')
::       _c - STRING - klucz grupujący, którym będą ostemplowane generowane zlecenia
::   WY: ilość wygenerowanych zleceń
::  OLD: \levelpod/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
{? var_pres('_b')=type_of('') || _dialog:=_b || _dialog:='T' ?};
{? var_pres('_c')=type_of('') || _grp_key:=_c || FUN.error('Parametr \'klucz grupujący\' jest wymagany.'@); return() ?};

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
||
:: czy własna technologia
   _tech:=ZL.TYP().TECH;

   _orders:=0;

   {? _tech='T'
   || _ktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"ref()",null())
   || _ktl:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"ref()",null())
   ?};

   exec('tktl_cntx_psh','tech_common');
   _msk:=(8+ref_name(_ktl))+3;
   exec('tktl_use','tech_common',_msk);

   exec('stop_tpar','tech_param');
   tpar:=obj_new(@.CLASS.TPAr);
   tpar.TABLE:=TPAR;
   tpar.INDEX:='NN';
   tpar.PREFIX:=_ktl;
   tpar.KTM:=ZL.KTM;
   tpar.loadp();

   TMAT.index('NNL');
   TMAT.prefix(_ktl);

   {? TMAT.first()
   || {!
      |? ZL.cntx_psh();
         ZL.index('TMAT_SRC');
         ZL.prefix(ZL.UNRZL,TMAT.ref());
         {? ~ZL.first()
         || {? TMAT.NROP().EXIST<>''
            || _exist:=tpar.calc(TMAT.NROP().EXIST)
            || _exist:=1
            ?};
            {? _exist
            || {? TMAT.EXIST<>''
               || _exist:=tpar.calc(TMAT.EXIST)
               || _exist:=1
               ?}
            ?};
            {? _exist
            || _new_order:=exec('gen_zl4tmat','zl_gen',_zl,TMAT.ref(),_dialog,_grp_key,1);
               {? _new_order<>null() || _orders+=1 ?}
            ?}
         ?};
         ZL.cntx_pop();
         TMAT.next()
      !}
   ?};

   exec('stop_tpar','tech_param');
   exec('tktl_cntx_pop','tech_common')
?};
ZL.cntx_pop();
_orders


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::   WE: [_a] - _mp - obiekt Menadżera procesów
::       [_b] - tablica z parametrami wejściowymi
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _mp:=_a
|| _mp:=params_get().mp
?};
{? var_pres('_b')>100
|| _in:=_b
|| _in:=params_get().in
?};

_can_continue:=1;
_obj:=obj_new('RESULT','ZL_NAD');
_obj.RESULT:=0;
_obj.ZL_NAD:=null();

_keyRefs:=_mp.getRefs();

{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];

      {? type_of(_kref)>0
      ||
         {? ref_name(_kref)=ZL.name()
         || _obj.ZL_NAD:=exec('FindAndGet','#table',ZL,_kref,,,null());

            {? _obj.ZL_NAD=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZL,_obj.ZL_NAD,,"ZL.STAN",'')='Z'
            ||
::            Zlecenie zostało zamknięte, więc robie error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp,,0)
            ?}
         ?}
      ?}
   !}
?};

{? _can_continue>0
||
:: jest parametr wejściowy ZL
   {? _obj.ZL_NAD=null() & var_pres('ZL_NAD',_in)=type_of(null())
   || _obj.ZL_NAD:=_in.ZL_NAD
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};

_obj


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Formuła ustalająca PARSES
::   WE:
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
params_exec('zl_parses','zl_common')

:Sign Version 2.0 jowisz:1045 2023/10/25 11:20:40 49e423e68fe96645e5ffecdd4ed8d1d79eb41172587c7f9bcfb31f36e0559b898b648084bc1f4280617c8c5e6db473da9516bdc721701057fc983a12531fc2891b4f8e0a23e4c0aabf2f8d74629b89f00ea113c099720193a45abc3d92b490808345554ca5eff3019b3cb4548be2a96899a92fd3d8206f1d9fdc4d8cb6466140
