:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tte_wyk_dgro.fml
:: Utworzony: 16.05.2016
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły czynności TTE_WYK_DGRO - Rozliczenie odpadów
::                                             (Generowanie rozliczenia odpadów zlecenia)
::            UWAGA: w przypadku modyfikacji uwzględniać też czynności: TTE_WYK_DGRW, TTE_WYK_DGZW.
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Główna formuła czynności generowania rozliczenia odpadów zlecenia (TTE_WYK_DGRO)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

::# permissions=ODDZ,LMG
::# parses=exec('parses','!tte_wyk_dgro')
::# properties=SERVICE,LOOP
::# condition=Rejestracja dokumentu przyjęcia, act_uid=LMG_MAG_DAPZ, auto=T, formula=_a.ND<>~~ & _a.ND<>null()

:: PARAMETRY WE:
::# kind=WE, symbol=ZL, type=_ZL, name=Zlecenie, required=N, keyref=T
::# kind=WE, symbol=ND, type=_ND, name=Dokument raportujący, required=N, keyref=N
::# kind=WE, symbol=TYPYDOK, type=_TYPYDOK, name=Typ dokumentu przychodowego, required=N, keyref=N, fml_val="exec('typ_dok','!tte_wyk_dgro')", fml_exp="exec('typydok_export','magdok_nag',_a)"
::# kind=WE, symbol=GEN_DOK, type=STRING, name=Generacja dokumentów, required=N
::# kind=WE, symbol=GROP, type=_GROP, name=Grupa operacji, required=N, keyref=T
{? var_pres('ZL',_in)<>type_of(~~) & var_pres('ZL',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRO','ZL']);
   return()
|? _in.ZL=~~
|| _in.ZL:=null()
?};
{? var_pres('ND',_in)<>type_of(~~) & var_pres('ND',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRO','ND']);
   return()
|? _in.ND=~~
|| {? _mp.akcja()='GENERUJ'
   || _in.ND:=_context.ND
   || _in.ND:=null()
   ?}
?};
{? var_pres('TYPYDOK',_in)<>type_of(~~) & var_pres('TYPYDOK',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRO','TYPYDOK']);
   return()
|? _in.TYPYDOK=~~
|| _in.TYPYDOK:=null()
?};
{? var_pres('GEN_DOK',_in)<>type_of(~~) & var_pres('GEN_DOK',_in)<>type_of('')
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRO','GEN_DOK']);
   return()
|? _in.GEN_DOK=~~
|| _in.GEN_DOK:=''
?};
{? var_pres('GROP',_in)<>type_of(~~) & var_pres('GROP',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRO','GROP']);
   return()
|? _in.GROP=~~
|| _in.GROP:=null()
?};

:: PARAMETRY WEW:
::# kind=WEW, symbol=ND, type=_ND, name=Dokument przychodowy, required=N
{? var_pres('ND',_int)<>type_of(~~) & var_pres('ND',_int)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wewnętrznego %2).'@['TTE_WYK_DGRO','ND']);
   return()
|? _int.ND=~~
|| _int.ND:=null()
?};

:: PARAMETRY WY:
::# kind=WY, symbol=ZL, type=_ZL, name=Zlecenie, required=N
::# kind=WY, symbol=ND, type=_ND, name=Dokument przychodowy, required=N
::# kind=WY, symbol=GEN_DOK, type=STRING, name=Generacja dokumentów, required=N
::# kind=WY, symbol=RESULT, type=STRING, name="Wynik czynności (OK, BŁĄD)", required=N

:: Ustawiam wartość domyślną argumentu LOOP żeby brama się nie zawiesiła
_mp.save(exec('kind_out','#b_port'),'LOOP','N');

:: Czy komunikaty walidacji na ekran
_display:={? _mp.isService() || 0 || 1 ?};

:: WSTĘPNE WALIDACJE
_clean_result:=params_exec('clean','!tte_wyk_dgro',_mp,_in);
_can_continue:=_clean_result.RESULT;
_zl:=_clean_result.ZL;
{? _can_continue=0
|| return()
?};

:: Zlecenie musi być produkcyjne
{? _in.ZL<>null() & exec('FindAndGet','#table',ZL,_in.ZL,,"TYP().WP='W'",1)
|| _msg:='Błędna konfiguracja procesu — zlecenie nie może być warsztatowe.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};
:: Musi być conajmniej jeden parametr przekazany (chyba, że jest już coś wygenerowane, czyli _int.ND<>null())
:: (chyba, że uruchomienie jako czynność startowa z pulpitu)
{? _in.ND=null() & _in.ZL=null() & _in.GROP=null() & _in.GEN_DOK='' & _int.ND=null() & ~_mp.pathProc()
|| _msg:='Błędna konfiguracja procesu — brak parametru wejściowego (musi być określony %1, %2 albo %3).'@@
      ['ND','GROP','GEN_DOK'];
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};
:: Walidacja typu dokumentu
{? _in.TYPYDOK
|| _in_typ:=exec('FindAndGet','#table',TYPYDOK,_in.TYPYDOK,,"T",'');
   {? (' '+exec('get','#params',500705,2))*(' '+_in_typ+' ')=0
   || _msg:='Błędna konfiguracja procesu — przekazany typ dokumentu %1 nie jest wskazany w parametrze %2.'@@[_in_typ,'500705'];
      {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
      _mp.error(_msg);
      return()
   ?}
?};
:: Walidacja dokumentu
_nd_zl:=exec('FindAndGet','#table',ND,_in.ND,,"ZL",null());
{? _in.ND
|| _in_typ:=exec('FindAndGet','#table',ND,_in.ND,,"TYP",null());
   {? _nd_zl=null()
   || _msg:='Błędna konfiguracja procesu — przekazany dokument nie jest powiązany ze zleceniem.'@@;
      {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
      _mp.error(_msg);
      return()
   ?}
?};
:: Zgodność dokumentu ze zleceniem
{? _in.ZL<>null() & _in.ND<>null() & _in.ZL<>_nd_zl
|| _msg:='Błędna konfiguracja procesu — przekazany dokument dotyczy innego zlecenia niż przekazane.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
|? _in.ZL=null()
|| _in.ZL:=_nd_zl
?};
:: Czynność w trybie usługi musi dotyczyć konkretnego dokumentu raportującego
{? _mp.isService() & ~_in.ND & ~_in.GROP &_in.GEN_DOK=''
|| _msg:='Błędna konfiguracja procesu — nie przekazano dokumentu.'@@;
   _mp.error(_msg);
   return()
?};

_mp.keyRef(exec('FindAndGet','#table',ZL,_in.ZL,,"uidref()",''));

_zl_sym:=exec('FindAndGet','#table',ZL,_in.ZL,,"SYM",'');

:: Przekazany parametr _int.ND, czyli powstały już dokumenty raportujące, ale czynność się nie zakończyła
:: (np. zamknięcie programu "krzyzykiem")
{? _mp.loop()=0 & _int.ND
|| _gen_dok:=exec('FindAndGet','#table',ND,_int.ND,,"GRP_KEY",'');
:: Zapisanie parametru wyjściowego ND, wykluczenie kolejnej realizacji z pętli, zakończenie czynności
   {? _gen_dok<>''
   ||
      ND.cntx_psh();
      ND.prefix();
      _grp_key:=_gen_dok-1;
      _grp_key_on:=_grp_key+'1';
      _grp_key_off:=_grp_key+'0';
      {? _grp_key<>''
      || ND.index('GRP_KEY');
         ND.prefix(_grp_key_on);
         {? ND.first()
         || ND.cntx_psh();
            ND.prefix();
            ND.GRP_KEY:=_grp_key_off;
            do();
            ND.put();
            _mp.save(exec('kind_out','#b_port'),'ND',ND.ref());
            _mp.save(exec('kind_out','#b_port'),'GEN_DOK',_gen_dok);
            _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
            end();
            ND.cntx_pop();
::          kontynuacja pętli
            {? ND.first()
            || _mp.loop_continue()
            ?}
         ?}
      ?};
      ND.cntx_pop();
      _mp.done()
   ?}

:: Przekazany tylko parametr _in.ZL, wejscie z ToDo, czyli wyświetlenie panela do rozliczania
|? _in.ZL & ~_in.ND & ~_in.GROP & _mp.pathTodo()
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_in.ZL)
   || __ENV_GEN:=exec('env_gen','zl_limit','ODP');
      {? ZL.STAN<>'O'
      || FUN.emsg('Zlecenie do rozliczenia musi być otwarte.'@)
      || KOMM.init(,,'Rozliczenie odpadów/koproduktów'@);
         exec('find_nd','zl_nlimit');
         exec('select_gen','zl_limit')
      ?};
      VAR_DEL.delete('__ENV_GEN')
   ?};
   ZL.cntx_pop()

:: Przekazany tylko parametr _in.GROP, wejscie z ToDo, czyli wyświetlenie panela do rozliczania
|? _in.GROP & ~_in.ZL & ~_in.ND  & _mp.pathTodo()
|| GROP.cntx_psh();
   GROP.prefix();
   {? GROP.seek(_in.GROP)
   || __ENV_GEN:=exec('env_gen','zl_limit','ODP_GROP');
      {? GROP.AKC<>'T' | GROP.STATUS<>'O'
      || FUN.emsg('Grupa operacji do rozliczenia musi być zaakceptowana i otwarta.'@)
      || KOMM.init(,,'Rozliczenie odpadów/koproduktów'@);
         exec('find_zlgd','zl_grop');
         exec('select_gen','zl_limit')
      ?};
      VAR_DEL.delete('__ENV_GEN')
   ?};
   GROP.cntx_pop()

:: Przekazany parametr _in.ND, czyli generowanie dokumentów rozliczających do dokumentu raportującego
:: Przekazany parametr _in.GROP, czyli generowanie dokumentów rozliczających do grupy operacji
:: Kolejny obrót pętli generatora, czyli wypychanie wygenerowanych dokumentów
|? _in.ND | _in.GROP | _in.ZL | _mp.loop()>0
||
:: Wyzwalacz, który po dodaniu/aktualizacji/usunięciu nagłówka dokumentu rozliczającego
:: dodaje/usuwa/aktualizuje parametr wewnętrzny _int.ND (aktualizacja nie dotyczy dokumentu źródłowego)
   _nd_uid:=exec('FindAndGet','#table',ND,_in.ND,,"uidref()",'');
   _mp.trigRef('ND',,1,,exec('kind_internal','#b_port'),'ND',,$('ND.uidref()<>\''+_nd_uid+'\''));

   _continue:=0;
   _gen_dok:='';
   _typydok:={? var_pres('TYPYDOK',_in)=type_of(null()) || _in.TYPYDOK || null() ?};

:: pierwsze wywołanie dla dokumentu raportującego
   {? _mp.loop()=0 & _in.ND
   ||
      ND.cntx_psh();
      _jest:=ND.seek(_in.ND);
      {? ~_jest || ND.prefix(); _jest:=ND.seek(_in.ND) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono dokumentu raportującego.')
      |? _jest & ND.STAT_REJ<>'T'
      || _msg:='Dokument raportujący %1 nie został zaakceptowany'@[ND.SYM];
         {? _mp.isGroup() || KOMM.add(_msg) || FUN.info(_msg) ?};
         _continue:=-1
      |? _jest & exec('rozliczone','zl_limit',ND.ref(),'T')
      || _msg:='Do dokumentu raportującego %1 zostały już wystawione dokumenty rozliczające.'@[ND.SYM];
         {? _mp.isGroup() || KOMM.add(_msg) || FUN.info(_msg) ?};
         _continue:=-2
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}

         |? _mp.isAutoRun()
            | _mp.isService()
            | _mp.pathTodo()
         ||
            KOMM.init(250,,'Generowanie rozliczenia odpadów/koproduktów'@);

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            || _in.TYPYDOK:=exec('typ_dok','!tte_wyk_dgro')
            ?};

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            || _continue:=-1
            ||
               do();
               DK.cntx_psh();
               _tm_stamp:=exec('utwdok','zl_nlimit',_in.TYPYDOK,'ODP');
               {? _tm_stamp='' || undo() ?};
               DK.cntx_pop();
               end();

               {? _tm_stamp='y'
               || _continue:=-3
               || _internal:=_mp.load(exec('kind_internal','#b_port'));
                  _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
                  {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
               ?}
            ?};

            {? _mp.isAutoRun() || {? _continue<>1 || KOMM.select() ?}
            |? _mp.pathTodo() || KOMM.select()
            ?}

         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRO/ND'])
         ?}
      ?};
      ND.cntx_pop()

:: pierwsze wywołanie dla grupy
   |? _mp.loop()=0 & _in.GROP
   ||
      GROP.cntx_psh();
      _jest:=GROP.seek(_in.GROP);
      {? ~_jest || GROP.prefix(); _jest:=GROP.seek(_in.GROP) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono grupy operacji.'@@)
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}
         |? 0
::          Tryb automatyczny/serwisowy nieobsługiwany
::            _mp.isAutoRun()
::            | _mp.isService()
::            | _mp.pathTodo()
         ||
            KOMM.init(250,,'Generowanie rozliczenia  odpadów/koproduktów'@);

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            || _in.TYPYDOK:=exec('typ_dok','!tte_wyk_dgro')
            |?  ~_in.TYPYDOK &  (_mp.isService() | _mp.isAutoRun())
            || _in.TYPYDOK:=exec('Get_TYPYDOK','magdok_wspolne','ODP');
               {? _in.TYPYDOK=null()
               || _msg:='Brak określonego domyślnego typu dokumentu rejestracji odpadów ze zlecenia (parametry %1, %2).'
                           ' Dokument rozliczenia odpadów nie został utworzony.'@['500705','500716'];
                  KOMM.add(_msg,7,,1)
               ?}
            ?};

            {? ~_in.TYPYDOK
            || _continue:=-1
            ||
               do();
               _tm_stamp:='';
               GROP.cntx_psh();
               GROP.prefix();
               {? GROP.seek(_in.GROP)
               || __ENV_GEN:=exec('env_gen','zl_limit','ODP_GROP');
                  {? GROP.STATUS<>'O'
                  || _msg:='Grupa operacji do rozliczenia musi być otwarta.'@;
                     KOMM.add(_msg,7,,1)
                  |? GROP.AKC<>'T'
                  || _msg:='Grupa operacji do rozliczenia musi być zaakceptowana.'@;
                     KOMM.add(_msg,7,,1)
                  || params_set('env_gen',__ENV_GEN);
                     _grupa:=VAR.A_GROP;
                     VAR.A_GROP:=GROP.ref();
                     exec('find_zlgd','zl_grop');
                     _tm_stamp:=exec('gen_dok','zl_nlimit',_in.TYPYDOK);
                     VAR.A_GROP:=_grupa
                  ?};
                  VAR_DEL.delete('__ENV_GEN')
               ?};
               GROP.cntx_pop();
               {? _tm_stamp='' || undo() ?};
               end();
               {? _tm_stamp='y'
               || _continue:=-3
               || _internal:=_mp.load(exec('kind_internal','#b_port'));
                  _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
                  {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
               ?}
            ?}

         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRO/GROP'])
         ?}
      ?};
      GROP.cntx_pop()

:: pierwsze wywołanie dla zlecenia
   |? _mp.loop()=0 & _in.ZL
   ||
      ZL.cntx_psh();
      _jest:=ZL.seek(_in.ZL);
      {? ~_jest || ZL.prefix(); _jest:=ZL.seek(_in.ZL) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono zlecenia.'@@)
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}
         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRO/ZL'])
         ?}
      ?};
      ZL.cntx_pop()
:: wywołanie w pętli
   || _continue:=_in.GEN_DOK<>'';
      {? _continue || _gen_dok:=_in.GEN_DOK ?}
   ?};

:: Wycofano się z wystawiania dokumentów
   {? _continue=-1
   || {? _mp.isService()
      || _mp.save(exec('kind_out','#b_port'),'RESULT','BŁĄD');
         _mp.done()
      || _mp.cancel()
      ?}

:: Dokumenty rozliczające już wcześniej wystawione
   |? _continue=-2
   || {? _mp.isService()
      || _mp.save(exec('kind_out','#b_port'),'RESULT','BŁĄD');
         _mp.done()
      || _mp.done()
      ?}

:: Nie potrzeba generować dokumentów (brak odpadów w definicji zlecenia)
   |? _continue=-3
   || {? _mp.isService()
      || _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
         _mp.done()
      || _mp.done()
      ?}

:: Zapisanie parametru wyjściowego ND, wykluczenie kolejnej realizacji z pętli, zakończenie czynności
   |? _continue=1 & _gen_dok<>''
   ||
      ND.cntx_psh();
      ND.prefix();
      _grp_key:=_gen_dok-1;
      _grp_key_on:=_grp_key+'1';
      _grp_key_off:=_grp_key+'0';
      {? _grp_key<>''
      || ND.index('GRP_KEY');
         ND.prefix(_grp_key_on);
         {? ND.first()
         || ND.cntx_psh();
            ND.prefix();
            ND.GRP_KEY:=_grp_key_off;
            do();
            ND.put();
            _mp.save(exec('kind_out','#b_port'),'ND',ND.ref());
            _mp.save(exec('kind_out','#b_port'),'GEN_DOK',_gen_dok);
            _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
            end();
            ND.cntx_pop();
::          kontynuacja pętli
            {? ND.first()
            || _mp.loop_continue()
            ?}
         ?}
      ?};
      ND.cntx_pop();
      _mp.done()

   || _mp.error('Brak oczekiwanego parametru %1.'@@['GEN_DOK'])
   ?}

:: Uruchomienie ze startu procesów
|? _mp.pathProc()
|| _choice:=FUN.choice('Rozliczenie odpadów do:'@,,'Zlecenia'@,'Grupy operacji'@);
   {? _choice=1
   || ZL.cntx_psh();
      ZL.clear();
      _join:='join ZTP left join ZL as ZLNAD using(ZL.NRNZL,ZLNAD.UNRZL)';
      _where:=
         'ZL.STAN=''O'' and '
         'ZTP.WP=''P'' and '
         'ZL.RODZAJ=''P'' and '
         '(ZL.LEVEL=0 or ZL.LEVEL=1) and '
         '(ZL.NRNZL=0 or ZL.NR=1 or ZLNAD.RODZAJ=''N'') and '
         'ZL.ILDOK>0';
      ZL.f_set('SYM',_join,_where);
      exec('icons_slo_sl','zl_head');
      ZL.win_sel('SLO_SL');
      ZL.actions('SLO_SL','XY','W');
      {? ZL.select()
      || exec('action_ro_generate','!tte_wyk_dgro')
      ?};
      ZL.cntx_pop()
   |? _choice=2
   || GROP.cntx_psh();
      GROP.clear();
      _join:='';
      _where:=
         'GROP.STATUS=''O'' and '
         'GROP.AKC=''T'' '
      ;
      GROP.f_set('KOD',_join,_where);
      GROP.win_sel('SLO');
      {? GROP.select()
      || exec('action_ro_gropgen','!tte_wyk_dgro')
      ?};
      GROP.cntx_pop()
   ?}
|| _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRO'])
?};
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opis dla czynności generowania rozliczenia odpadów (TTE_WYK_DGRO)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: zwraca opis Zadania
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_keyRefs:=_mp.getRefs();
_in:=_mp.load(exec('kind_in','#b_port'));
_int:=_mp.load(exec('kind_internal','#b_port'));

_desc:='';
_zl:=null();
_nd:=null();
_nd_int:=null();
_grop:=null();


:: sprawdzam czy jest rekord kluczowy, jak jest to ustawiam odpowiedniego ZL albo GROP
{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];
      {? type_of(_kref)>0
      ||
         {? ref_name(_kref)=ZL.name()
         || _zl:=exec('FindAndGet','#table',ZL,_kref,,,null())
         |? ref_name(_kref)=GROP.name()
         || _grop:=exec('FindAndGet','#table',GROP,_kref,,,null())
         ?}
      ?}
   !}
?};

:: jest parametr wejściowy to ustawiam odpowiedniego ZL
{? _zl=null() & var_pres('ZL',_in)=type_of(null())
|| _zl:=_in.ZL
?};

:: jest parametr wejściowy GROP
{? _grop=null() & var_pres('GROP',_in)=type_of(null())
|| _grop:=_in.GROP
?};

:: jest parametr wejściowy to ustawiam odpowiedniego ND
{? var_pres('ND',_in)=type_of(null())
|| _nd:=_in.ND
?};

:: jest parametr wewnętrzny to ustawiam odpowiedniego ND
{? var_pres('ND',_int)=type_of(null())
|| _nd_int:=_int.ND
?};

_desc:='';
{? _nd_int<>null()
|| {? _grop<>null()
   || _desc:='Zakończ rozliczenie odpadów/koproduktów do grupy operacji %1'@@
             [exec('record','#to_string',_grop)]
   |? _zl<>null() & _nd<>null()
   || _desc:='Zakończ rozliczenie odpadów/koproduktów do dokumentu %1 (zlecenie %2)'@@
             [exec('record','#to_string',_nd),exec('record','#to_string',_zl)]
   |? _zl<>null() & _nd=null()
   || _desc:='Zakończ rozliczenie odpadów/koproduktów do zlecenia %1'@@
             [exec('record','#to_string',_zl)]
   |? _zl=null() & _nd<>null()
   || _desc:='Zakończ rozliczenie odpadów/koproduktów do dokumentu %1 (zlecenie %2)'@@
             [exec('record','#to_string',_nd),
              exec('record','#to_string',exec('FindAndGet','#table',ND,_nd,,"ZL",null()))
             ]
   || _desc:='Zakończ rozliczenie odpadów/koproduktów'@@
   ?}
|| {? _grop<>null()
   || _desc:='Wygeneruj rozliczenie odpadów/koproduktów do grupy operacji %1'@@
             [exec('record','#to_string',_grop)]
   |? _zl<>null() & _nd<>null()
   || _desc:='Wygeneruj rozliczenie odpadów/koproduktów do dokumentu %1 (zlecenie %2)'@@
             [exec('record','#to_string',_nd),exec('record','#to_string',_zl)]
   |? _zl<>null() & _nd=null()
   || _desc:='Wygeneruj rozliczenie odpadów/koproduktów do zlecenia %1'@@
             [exec('record','#to_string',_zl)]
   |? _zl=null() & _nd<>null()
   || _desc:='Wygeneruj rozliczenie odpadów/koproduktów do dokumentu %1 (zlecenie %2)'@@
             [exec('record','#to_string',_nd),
              exec('record','#to_string',exec('FindAndGet','#table',ND,_nd,,"ZL",null()))
             ]
   || _desc:='Wygeneruj rozliczenie odpadów/koproduktów'@@
   ?}
?};
_desc


\action_ro_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyświetla panel rozliczania odpadów dla zleceń
::----------------------------------------------------------------------------------------------------------------------
{? ZL.sel_size()=0
|| _f500705:=exec('get','#params',500705,2);
   {? _f500705=''
   || FUN.emsg('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500705']);
      return()
   ?};
   VAR_DEL.delete('__ENV_GEN');
   __ENV_GEN:=exec('env_gen','zl_limit','ODP')
?};
{? ZL.STAN<>'O'
|| {? ZL.sel_size()=0 || FUN.emsg('Zlecenie do rozliczenia musi być otwarte.'@) ?}
|| {? ZL.sel_size()=0
   || KOMM.init(,,'Rozliczenie odpadów/koproduktów'@)
   ?};
   exec('find_nd','zl_nlimit');
   {? ZL.sel_size()=0
   || exec('select_gen','zl_limit');
      VAR_DEL.delete('__ENV_GEN')
   ?}
?};
~~


\action_ro_generate_group_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed akcją grupową - obsługa panela rozliczania odpadów dla zlecenia
::----------------------------------------------------------------------------------------------------------------------
_f500705:=exec('get','#params',500705,2);
{? _f500705=''
|| FUN.emsg('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500705']);
   0
|| KOMM.init(,,'Rozliczenie odpadów/koproduktów'@);
   VAR_DEL.delete('__ENV_GEN');
   __ENV_GEN:=exec('env_gen','zl_limit','ODP');
   1
?}


\action_ro_generate_group_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Po akcji grupowej - obsługa panela rozliczania odpadów dla zlecenia
::----------------------------------------------------------------------------------------------------------------------
exec('select_gen','zl_limit');
VAR_DEL.delete('__ENV_GEN');
~~


\action_ro_gropgen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wyświetla panel rozliczania odpadów dla grup operacji
::----------------------------------------------------------------------------------------------------------------------
{? GROP.sel_size()=0
|| _f500705:=exec('get','#params',500705,2);
   {? _f500705=''
   || FUN.emsg('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500705']);
      return()
   ?};
   VAR_DEL.delete('__ENV_GEN');
   __ENV_GEN:=exec('env_gen','zl_limit','ODP_GROP')
?};
{? GROP.AKC<>'T' | GROP.STATUS<>'O'
|| {? GROP.sel_size()=0 || FUN.emsg('Zlecenie do rozliczenia musi być otwarte.'@) ?}
|| {? GROP.sel_size()=0
   || KOMM.init(,,'Rozliczenie odpadów/koproduktów'@)
   ?};
   exec('find_zlgd','zl_grop');
   {? GROP.sel_size()=0
   || exec('select_gen','zl_limit');
      VAR_DEL.delete('__ENV_GEN')
   ?}
?};
~~


\action_ro_gropgen_group_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Przed akcją grupową - obsługa panela rozliczania odpadów dla grup operacji
::----------------------------------------------------------------------------------------------------------------------
_f500705:=exec('get','#params',500705,2);
{? _f500705=''
|| FUN.emsg('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500705']);
   0
|| KOMM.init(,,'Rozliczenie odpadów/koproduktów'@);
   VAR_DEL.delete('__ENV_GEN');
   __ENV_GEN:=exec('env_gen','zl_limit','ODP_GROP');
   1
?}


\action_ro_gropgen_group_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Po akcji grupowej - obsługa panela rozliczania odpadów dla grup operacji
::----------------------------------------------------------------------------------------------------------------------
exec('select_gen','zl_limit');
VAR_DEL.delete('__ENV_GEN');
~~


\typ_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Selekcja typów dokumentów magazynowych (dla parametru wejściowego czynności oraz wyboru typu w czynności)
::----------------------------------------------------------------------------------------------------------------------
_TypDok:=exec('get','#params',500705,2);
{? _TypDok<>''
|| _Typdok:=gsub(form(_TypDok),' ','\',\'');
   _TypDok:='\''+_Typdok+'\'';
   _warunek:='"TYPYDOK".T in ('+_TypDok+') '
|| _warunek:='0=1'
?};
exec('typ_dok','lmg',_warunek,,,0,0,
   'Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500705'],,,,-1
)


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła ustala PARSES
::   WE: UWAGA. Do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;

_result:=0;

:: Jeżeli jest dokument, to oddział i okres wg niego
{? var_pres('ND',_in)=type_of(null()) & _in.ND
|| ND.cntx_psh();
   ND.use(ref_name(_in.ND));
   ND.prefix();
   {? ND.seek(_in.ND)
   || __PARSES.setVal('OddzialLogProd',ND.ODDZ);
      _args:=__PARSES.args('OkresRok');
      _args.OBSZAR:='LMG';
      _args.AR:=ND.AR;
      _args.AM:=ND.AM;
      __PARSES.setVal('OkresRok',_args);
      _result:=1
   ?};
   ND.cntx_pop()

:: Jeżeli jest zlecenie, to oddział wg niego, reszta dziedziczona
|? var_pres('ZL',_in)=type_of(null()) & _in.ZL
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_in.ZL)
   || __PARSES.setVal('OddzialLogProd',ZL.ODDZ);
      _result:=1
   ?};
   ZL.cntx_pop()
:: Jeżeli jest grupa, to oddział wg niej, reszta dziedziczona
|? var_pres('GROP',_in)=type_of(null()) & _in.GROP
|| GROP.cntx_psh();
   GROP.prefix();
   {? GROP.seek(_in.GROP)
   || __PARSES.setVal('OddzialLogProd',GROP.ODDZ);
      _result:=1
   ?};
   GROP.cntx_pop()

:: Nic nie ustawiamy, ale zwracamy 1, w formule przy braku parametrów wejściowych zostanie zgłoszony błąd
|| _result:=1
?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::   WE: [_a] - _mp - obiekt Menadżera procesów
::       [_b] - tablica z parametrami wejściowymi
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _mp:=_a
|| _mp:=params_get().mp
?};
{? var_pres('_b')>100
|| _in:=_b
|| _in:=params_get().in
?};
_can_continue:=1;
_obj:=obj_new('RESULT','ZL','GROP');
_obj.RESULT:=0;
_obj.ZL:=null();
_obj.GROP:=null();

_keyRefs:=_mp.getRefs();

{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];

      {? type_of(_kref)>0
      ||
         {? ref_name(_kref)=ZL.name()
         || _obj.ZL:=exec('FindAndGet','#table',ZL,_kref,,,null());

            {? _obj.ZL=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp)
            ?}
         |? ref_name(_kref)=GROP.name()
         || _obj.GROP:=exec('FindAndGet','#table',GROP,_kref,,,null());

            {? _obj.GROP=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego ze grupą, więc robię error
               _can_continue:=0;
               exec('grop_deleted_in_proc','zl_common',_mp)
            ?}
         ?}
      ?}
   !}
?};

{? _can_continue>0
||
:: jest parametr wejściowy ZL
   {? _obj.ZL=null() & var_pres('ZL',_in)=type_of(null())
   || _obj.ZL:=_in.ZL
   ?};
:: jest parametr wejściowy ZL
   {? _obj.GROP=null() & var_pres('GROP',_in)=type_of(null())
   || _obj.GROP:=_in.GROP
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};

_obj

:Sign Version 2.0 jowisz:1048 2023/06/23 14:09:40 17af6f498c8db14aa132554ea7661ae87e2dd72ad0e124eeac8431173515ac401a633f80362aa939ed392e8a9bf2a62d75086e25c33b8626bb0daee143c497baaaf369c715d1238b143b500f31a21e39c43281931bf4652446e4d0af960d5ddb5fe40adcc66846b73317f075978da4a67402f930c02922a9a0e893583ff9ca50
