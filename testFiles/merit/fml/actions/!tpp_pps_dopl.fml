:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tpp_pps_dopl.fml
:: Utworzony: 06.06.2016
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły czynności TPP_PPS_DOPL - Planowanie obiektu
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła główna czynności TPP_PPS_DOPL
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

::# permissions=ODDZ

::# properties=SERVICE
::# access=exec('access','!tpp_pps_dopl')
::# parses=exec('parses','!tpp_pps_dopl')

:: PARAMETRY WE:
::# kind=WE, symbol=ZL, type=_ZL, name=Wskazanie na zlecenie, required=N, keyref=T
{? var_pres('ZL',_in)<>type_of(~~) & var_pres('ZL',_in)<>type_of(null())
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['ZL','TPP_PPS_DOPL'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};
::# kind=WE, symbol=ZK_N, type=_ZK_N, name=Zamówienie sprzedaży, required=N, keyref=T
{? var_pres('ZK_N',_in)<>type_of(~~) & var_pres('ZK_N',_in)<>type_of(null())
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['ZK_N','TPP_PPS_DOPL'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};
::# kind=WE, symbol=ZK_P, type=_ZK_P, name=Pozycja zamówienia, required=N, keyref=T
{? var_pres('ZK_P',_in)<>type_of(~~) & var_pres('ZK_P',_in)<>type_of(null())
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['ZK_P','TPP_PPS_DOPL'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};
::# kind=WE, symbol=PX_GRP, type=_PX_GRP, name=Element kolejki, required=N, keyref=N
{? var_pres('PX_GRP',_in)<>type_of(~~) & var_pres('PX_GRP',_in)<>type_of(null())
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['PX_GRP','TPP_PPS_DOPL'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};

::# kind=WE, symbol=GROP, type=_GROP, name=Grupa operacji, required=N, keyref=T
{? var_pres('GROP',_in)<>type_of(~~) & var_pres('GROP',_in)<>type_of(null())
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['GROP','TPP_PPS_DOPL'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};

::# kind=WE, symbol=POS, type=NUMBER, name=Pozycja w kolejce, required=N, keyref=N
{? var_pres('POS',_in)<>type_of(~~) & var_pres('POS',_in)<>type_of(0)
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['POS','TPP_PPS_DOPL'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};
{? _in.POS=~~ || _in.POS:=-1 ?};

::# kind=WE, symbol=PX_TAG, type=_PX_TAG, name=Grupa obiektów, required=N, keyref=T
{? var_pres('PX_TAG',_in)<>type_of(~~) & var_pres('PX_TAG',_in)<>type_of(null())
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['PX_TAG','TPP_PPS_DOPL'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};


:: PARAMETRY WY:
::# kind=WY, symbol=RESULT, type=STRING, name=Rezultat działania, required=N

PX_TAG.cntx_psh();
PX_TAG.prefix();
ZL.cntx_psh();
ZL.clear();
ZK_N.cntx_psh();
ZK_N.clear();
ZK_P.cntx_psh();
GROP.cntx_psh();
GROP.prefix();
ZK_P.clear();

PX_OBJ.cntx_psh();
PX_OBJ.clear();

_result:=0;

_zl:=null();
_zk_n:=null();
_zk_p:=null();
_clean_result:=exec('clean','!tpp_pps_dopl',_mp,_in);
_can_continue:=_clean_result.RESULT;
_zl:=_clean_result.ZL;
_zk_n:=_clean_result.ZK_N;
_zk_p:=_clean_result.ZK_P;
_grop:=_clean_result.GROP;
_px_tag:=_clean_result.PX_TAG;
_pos_in_queue:=_in.POS;

_what:='';
{? _can_continue>0 & _zl<>null()
|| _can_continue:=ZL.seek(_zl)
?};
{? _can_continue>0
|| {? _zk_n<>null()
   ||
      ZK_N.use(ref_name(_zk_n));
      ZK_N.clear();
      _can_continue:=ZK_N.seek(_zk_n);

      {? _can_continue>0
      || ZK_P.use(5+ZK_P.name()+(ref_name(_zk_n)+3));
         ZK_P.index('NAG')
      ?}
   |? _zk_p<>null()
   || ZK_P.use(ref_name(_zk_p));
      ZK_P.clear();
      _can_continue:=ZK_P.seek(_zk_p);

      {? _can_continue>0
      || ZK_N.use(5+ZK_N.name()+(ref_name(_zk_p)+3))
      ?}
   |? _grop<>null()
   || _can_continue:=GROP.seek(_grop)
   |? _px_tag<>null()
   || _can_continue:=PX_TAG.seek(_px_tag)
   ?}
?};
{? _can_continue>0
||
   _mainver:=exec('get_mainversion','px_ver');
   _planned:=0;
   _res_plan:=0;
   _dialog:=1;
   _edit:=1;
   _replan:=1;
   _il_zam:=0;
   _drop_dest:=null();
   {? _in.PX_GRP<>null()
   || _drop_dest:=_in.PX_GRP
   ?};
   _win_refresh:=0;
   _ctrl:=1;
   _pathtodo:=1;
   _komm_show:=0;

   _ver:=exec('get_mainversion','px_ver');

   {? type_of(_context)>100 & var_pres('ZK_P',_context)>0
   || {? _context.ZK_P<>null()
      || _zk_p:=_context.ZK_P
      ?}
   ?};

   {? type_of(_context)>100 & var_pres('DEST',_context)>0
   || {? _context.DEST<>null()
      || _drop_dest:=_context.DEST
      ?}
   ?};
   _ver_que:=null();
   {? var_pres('_context')>100 & var_pres('VER_QUE',_context)>0
   || _ver_que:=_context.VER_QUE
   ?};

   {? _mp.akcja()='DO_KOLEJKI'
   || _win_refresh:=1;
      _replan:=0;
      _pathtodo:=0;
      _ver:=PX_VAR.VER_QUE
   || PX_VAR.VER_QUE:=_ver
   ?};

   {? _pathtodo>0 | _dialog=2
   || _komm_show:=1
   ?};

   {? _mp.akcja()='PLANUJ_GROP'
   || _komm_show:=0
   ?};

   {? _ver_que=null()
   || _ver_que:=_ver
   ?};

   {? _komm_show>0
   || KOMM.init(250,,'Planowanie obiektu')
   ?};

   {? _mp.isAutoRun()
   || _dialog:=0;
      _edit:=0
   ?};
   {? _mp.isService()
   || _dialog:=3;
      _edit:=0
   ?};
   {? _mp.isGroup()
   || _win_refresh:=0;
      _dialog:=2;
      _edit:=0;
      _ctrl:=0
   ?};

   {? _pos_in_queue>-1
   || _replan:=0
   ?};

   {? exec('lock','px_ver',_ver,_dialog)
   ||
      {? _zl<>null()
      ||
::       ZLECENIE
         _what:=exec('record','#to_string',_zl);
::       Sekcja sprawdzania
         {? ZL.IL<>0 & exec('zl_planned','px_obj',_zl,_ver)=ZL.IL
         || _planned:=1
         ?};
         _can_continue:=exec('que_tab_chk_zl','!tpp_pps_dopl',,_dialog,_mp,_out,_mp.isGroup(),_ver);
         {? _can_continue>0
         ||
            {? _planned=0
            ||
::             Zlecenie nie było jeszcze planowane
               {? var_pres('KOMM2')<100
               || exec('JCQ_decl','#message');
                  KOMM2:=obj_new(@.CLASS.JCQ)
               ?};

::             Sprawdzam czy zlecenie powstało na podstawie zamówienia które jest w planie
               KOMM2.init(250,,'Umieszczanie zlecenia w planie strategicznym.'@);
               _transform:=0;
               ZLZAM.cntx_psh();
               ZLZAM.index('ZLZM');
               ZLZAM.prefix(_zl);
               {? ZLZAM.first()
               || {!
                  |?
                     {? (5+ZLZAM.ZAMPOZ)=(5+ZK_P.name())
                     || ZK_P.use(8+ZLZAM.ZAMPOZ);
                        ZK_P.clear();
                        {? ZK_P.seek(ZLZAM.ZAMPOZ,8+ZLZAM.ZAMPOZ)
                        || _zkp_obj:=exec('get_zkp_object','px_obj',ZK_P.ref());
                           _il_zam+=ZK_P.ILP-ZK_P.ILRB;
                           PX_CONN.cntx_psh();
                           PX_CONN.index('VER');
                           PX_CONN.prefix(_mainver,_zkp_obj);
                           {? PX_CONN.first()
                           || _transform:=1;
                              KOMM2.sect_beg('Powiązane zamówienia w kolejce planu ze zleceniem: %1'@[_what]);
                              {!
                              |? KOMM2.add('Pozycja kolejki: %1. %2 ilość: %3'@[$PX_CONN.PX_GRP().LP_Q,PX_CONN.PX_GRP().SYMBOL,$PX_CONN.ILOSC],7,,1);
                                 PX_CONN.next()
                              !};
                              KOMM2.sect_end()
                           ?};
                           PX_CONN.cntx_pop()
                        ?}
                     ?};
                     ZLZAM.next()
                  !}
               ?};

               {? _transform>0
               ||
                  _ask:=1;
                  _what:=exec('record','#to_string',ZL.ref());
                  _msg:='Zamówienie na podstawie którego powołano zlecenie: %1\n'
                        'zostało zaplanowane w planie strategicznym. Plan zlecenia spowoduje korektę planu zamówienia.\n\n'
                        'Czy kontynuować?'@[_what];

                  {? _dialog=1
                  || {!
                     |? _choice:=FUN.choice(_msg,,'Szczegóły'@,'Tak'@,,,'Nie'@);

                        {? _choice=1
                        || KOMM2.select()
                        |? _choice=2
                        || _ask:=1
                        || _ask:=0
                        ?};
                        _choice=1
                     !}
                  ?};
                  {? _can_continue>0 & _ask>0 & ZLZAM.first()
                  || {? var_pres('_context')>100 & var_pres('TRANSFORMED',_context)>0
                     || _context.TRANSFORMED:=1
                     ?};
                     {!
                     |?
                        {? (5+ZLZAM.ZAMPOZ)=(5+ZK_P.name())
                        || ZK_P.use(8+ZLZAM.ZAMPOZ);
                           ZK_P.clear();
                           {? ZK_P.seek(ZLZAM.ZAMPOZ,8+ZLZAM.ZAMPOZ)
                           || _zkp_obj:=exec('get_zkp_object','px_obj',ZK_P.ref());
::                            Przekształcam plan zamówienia w plan zlecenia
                              _can_continue:=exec('transform','!tpp_pps_dopl',_zkp_obj,_mainver,ZLZAM.ref());
                              {? _can_continue>0
                              || _res_plan:=1
                              ?};

                              {? _ver_que<>null()
                              || exec('transform','!tpp_pps_dopl',_zkp_obj,_ver_que,ZLZAM.ref())
                              ?};
                              ~~
                           ?}
                        ?};
                        ZLZAM.next()
                     !};

::                   Sprawdzam czy cała ilość zlecenia została w kolejce. Mogło coś zostać
::                   bo zlecenie się składa z zamówienia i ilości powołanej ręcznie
::                   Pozostałą ilość zlecenia trzeba dokleić do pierwszej znalezionej grupy w kolejce
                     _zl_obj:=exec('get_zl_object','px_obj',_zl);
                     _que_il:=exec('get_ilosc_que','px_obj',_ver_que,_zl_obj);
                     _diff:=ZL.IL-_que_il;
                     {? _diff>0
                     || _grp_new:=exec('get_first_grp','px_obj',_ver_que,_zl_obj);
                        {? _grp_new<>null()
                        || _px_conn:=exec('get_first_conn','px_obj',_grp_new,PX_OBJ.ref());
::                         Szukam konkretnego PX_CONNa w której obiekt już jest i zwiększam mu ilosc
                           PX_CONN.cntx_psh(); PX_CONN.prefix();
                           {? PX_CONN.seek(_px_conn)
                           || PX_CONN.ILOSC+=_diff;
                              {? PX_CONN.put()>0
                              || exec('prenumber','px_grp',_mainver);
                                 _argsfast:=exec('fast_replan_a','px_logix');
                                 _argsfast.PX_GRP:=_grp_new;

                                 _can_replan:=exec('queue_update_core','px_logix',_argsfast.PX_GRP);
                                 {? _can_replan>0
                                 || _can_replan:=exec('queue_check_one','px_logix',_argsfast.PX_GRP)
                                 ?};

                                 {? _can_replan>0
                                 || _can_continue:=exec('grp_fast_replan','px_logix',_argsfast)
                                 ?}
                              ?}
                           ?};
                           PX_CONN.cntx_pop()
                        ?}
                     ?}
                  ?}
               ||
::                Planujemy na świeżo zlecenie
::                Dodajemy do kolejki
                  _to_que:=exec('que_tab4zl','!tpp_pps_dopl',ZL.ref(),_dialog,_mp,_out,_mp.isGroup(),_ver,,0);
                  _can_continue:=_to_que.RESULT;
                  {? _can_continue>0
                  ||
                     _add_result:=exec('add_to_queue','!tpp_pps_dopl',_to_que.TAB
                                                                        ,_edit
                                                                        ,_win_refresh
                                                                        ,_ctrl
                                                                        ,_drop_dest
                                                                        ,_mp.isGroup()
                                                                        ,_pathtodo
                                                                        ,_ver
                                                                        ,_dialog
                                                                        ,'Z'
                                                                        ,_pos_in_queue);
                     {? _add_result=0
                     || _can_continue:=0;
                        {? _dialog<>1
                        || _mp.error('Nie udało się zaplanować zlecenia: %1'@[_what])
                        ?}
                     ?}
                  ?};

                  {? _can_continue>0
                  ||
::                   Planuje dodany obiekt
                     _px_obj:=exec('get_zl_object','px_obj',_zl);
                     {? _replan>0
                     || _res_plan:=exec('replan_obj','!tpp_pps_dopl',_px_obj)
                     || _res_plan:=1
                     ?}
                  ?}
               ?};
               ZLZAM.cntx_pop();
               ~~
            ||
::             Zlecenie jest już zaplanowane, przeplanowuje je
               _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
               {? _px_obj<>null()
               || {? _replan>0
                  || _res_plan:=exec('replan_obj','!tpp_pps_dopl',_px_obj)
                  || _res_plan:=1
                  ?}
               ?}
            ?}
         ?}
      |? _zk_n<>null() | _zk_p<>null()
      ||
::       ZAMÓWIENIE SPRZEDAŻY

::       Sekcja sprawdzania
         _stan:='';
         _what:='';
         {? _zk_p<>null()
         || _what:=exec('record','#to_string',_zk_p);
            _stan:=exec('FindAndGet','#table',ZK_P,_zk_p,,"N().STAN",'')
         |? _zk_n<>null()
         || _what:=exec('record','#to_string',_zk_n);
            _stan:=exec('FindAndGet','#table',ZK_N,_zk_n,,"STAN",'')
         ?};

         {? _stan='ZRE'
         ||
            _can_continue:=0;
            _msg:='Zamówienie: %1 zostało już zrealizowane.\n'
                  'Nie można dodawać do Planu strategicznego.'@[_what];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg)
         ?};

         {? _can_continue>0
         ||
            {? _zk_p<>null()
            || _to_que:=exec('que_tab4zkp','!tpp_pps_dopl',_zk_p,_dialog,_mp,_out,_mp.isGroup(),_ver)
            |? _zk_n<>null()
            || _to_que:=exec('que_tab4zkn','!tpp_pps_dopl',_zk_n,_dialog,_mp,_out,_mp.isGroup(),_ver)
            ?}
         ?};

         {? _can_continue>0
         || _can_continue:=_to_que.RESULT
         ?};

         {? _can_continue>0
         ||
::          Dodajemy do kolejki
            _add_result:=exec('add_to_queue','!tpp_pps_dopl',_to_que.TAB
                                                ,_edit
                                                ,_win_refresh
                                                ,_ctrl
                                                ,_drop_dest
                                                ,_mp.isGroup()
                                                ,_pathtodo
                                                ,_ver
                                                ,_dialog
                                                ,'Z'
                                                ,_pos_in_queue);
            {? _add_result=0
            || _can_continue:=0;
               {? _dialog<>1
               || _mp.error('Nie udało się zaplanować żadnej pozycji zamówienia: %1'@[_what])
               ?}
            ?}
         ?};

::       Przeplanowywuje te które zostały dodane do kolejki
         {? _replan>0 & _can_continue>0
         || _to_que.TAB.clear();
            {? _to_que.TAB.first()
            || {!
               |? _px_obj:=exec('FindAndGet','#table',PX_OBJ,_to_que.TAB.SQL,,,null());
                  {? exec('replan_obj','!tpp_pps_dopl',_px_obj)=0
                  || _can_continue:=0
                  ?};
                  _to_que.TAB.next()
               !}
            ?}
         ?};
::       Kończę planować zamówienie dopiero kiedy wszystkie jego ZK_Py które są produktami albo półfabrykatami są zaplanowane
         {? _can_continue>0
         ||
            ZK_P.index('NAG');
            _res_plan:=1;
            ZK_P.prefix(_zk_n);
            {? ZK_P.first()
            || {!
               |?
                  {? 'PW'*ZK_P.M().R & M.RODZ='T'
                  ||
                     _il_zam:=ZK_P.ILP-ZK_P.ILRB;
                     {? exec('zkp_planned','px_obj',ZK_P.ref(),_mainver)<_il_zam
                     || _res_plan:=0;
                        _can_continue:=0
                     ?}
                  ?};
                  ZK_P.next() & _can_continue>0
               !}
            ?}
         ?}
      |? _grop<>null()
      ||
::       GRUPA OPERACJI
         _what:=exec('GROP','#to_string');

::       Sekcja sprawdzania

         {? GROP.DIR=0 & _dialog=0 & _mp.isGroup()=0
         || _can_continue:=0;
            _msg:='Nie można zaplanować grupy operacji: %1 w trybie bezdialogowym, ponieważ w grupie nie określono zwrotu planowania.'@[_what];
            _mp.error(_msg)
         ?};
         {? GROP.PL_DATA=date(0,0,0) & _dialog=0 & _mp.isGroup()=0
         || _can_continue:=0;
            _msg:='Nie można zaplanować grupy operacji: %1 w trybie bezdialogowym, ponieważ w grupie nie określono wewnętrznego terminu realizacji.'@[_what];
            _mp.error(_msg)
         ?};
         {? exec('is_one_version','px_param')=0
         || _can_continue:=0;
            _msg:='Nie można planować grup operacji, jeżeli plan strategiczny pracuje na wielu wersjach (parametr: %1)'@['500365'];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg)
         ?};

::       Sprawdzam czy grupa jest już w całości kolejce planu
         {? _can_continue>0 & GROP.IL<>0 & exec('grop_planned','px_obj',_grop,_ver)=GROP.IL
         || _planned:=1;

            {? _planned=1 & _dialog>0
            ||
::             Jeżeli wszystko już w kolejce to komunikat
               _can_continue:=0;
               _msg:='Nie można zaplanować obiektu: %1, ponieważ cała ilość znajduje się już w kolejce planu.'@[_what];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_ver;
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _mp.error(_msg)
            ?}
         ?};
         {? _can_continue>0 & GROP.ILW>0
         || _can_continue:=0;
            _msg:='Grupa operacji: %1 posiada już zarejestrowane wykonania.\n'
                  'Nie można dodawać do Planu strategicznego.'@[_what];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg)
         ?};
         {? _can_continue>0 & GROP.STATUS='Z'
         || _can_continue:=0;
            _msg:='Nie można zaplanować grupy operacji: %1 ponieważ jest zamknięta.'@[_what];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg)
         ?};
         {? _can_continue>0 & GROP.AKC<>'T'
         || _can_continue:=0;
            _msg:='Nie można zaplanować grupy operacji: %1 ponieważ nie jest zaakceptowane.'@[_what];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg)
         ?};
         {? _can_continue>0
         ||
            {? _planned=0
            ||
               _predivision_tab:=~~;
               _px_obj:=exec('get_grop_object','px_obj',GROP.ref());
               {? _mp.isService()
               || _predivision_tab:=exec('predivision_tab','px_grop');
                  GROPS.cntx_psh();
                  GROPS.index('DEFAULT');
                  GROPS.prefix(GROP.ref(),'T');
                  {? GROPS.first()
                  || _can_continue:=exec('predivision_grops2tab','px_grop',_predivision_tab,1);
                     ~~
                  ?};
                  GROPS.cntx_pop()
               |? _mp.isGroup()>0
               || _predivision_tab:=exec('predivision_tab','px_grop');
                  {? PX_VAR.PL_RESGG<>null()
                  || GROPS.cntx_psh();
                     GROPS.index('GROPRES');
                     GROPS.prefix(GROP.ref(),PX_VAR.PL_RESGG);
                     {? GROPS.first()
                     || _can_continue:=exec('predivision_grops2tab','px_grop',_predivision_tab,1)
                     ?};
                     GROPS.cntx_pop()
                  ?}
               || _ref_table:=exec('ref_table','#table');
                  _ref_table.add(_px_obj);
                  _predivision_tab:=exec('predivision','px_grop',_ref_table.tab);
                  {? type_of(_predivision_tab)=0
                  || _can_continue:=0
                  ?}
               ?};
               {? _can_continue>0
               ||
::                Dodajemy do kolejki - grupy operacji zawsze idą grupowo, żeby dialogi się nie pojawiały
                  _to_que:=exec('que_tab4grop','!tpp_pps_dopl',GROP.ref(),_ver,_predivision_tab);
                  _can_continue:=_to_que.RESULT
               ?};
               {? _can_continue>0
               ||
                  _add_result:=exec('add_to_queue','!tpp_pps_dopl',_to_que.TAB
                                                                     ,_edit
                                                                     ,_win_refresh
                                                                     ,_ctrl
                                                                     ,_drop_dest
                                                                     ,1
                                                                     ,_pathtodo
                                                                     ,_ver
                                                                     ,_dialog
                                                                     ,'G'
                                                                     ,_pos_in_queue
                                                                     ,null()
                                                                     ,GROP.ref());
                  {? _add_result=0
                  || _can_continue:=0;
                     {? _dialog<>1
                     || _mp.error('Nie udało się zaplanować grupy operacji: %1'@[_what])
                     ?}
                  ?}
               ?};
               exec('prenumber','px_grp',_ver);

               {? _can_continue>0
               ||
::                Planuje dodany obiekt
                  _px_obj:=exec('get_grop_object','px_obj',GROP.ref());
                  {? _replan>0
                  || _res_plan:=exec('replan_obj','!tpp_pps_dopl',_px_obj)
                  || _res_plan:=1
                  ?}
               ?}
            ?}
         ?}
      |? _px_tag<>null()
      ||
::       GRUPA OBIEKTÓW
         _what:=exec('PX_TAG','#to_string');

::       Sekcja sprawdzania
         {? PX_TAG.TKTL=null()
         || _can_continue:=0;
            _msg:='Grupa obiektów: %1 nie posiada przypisanej technologii źródłowej.'@[_what];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg)
         ?};

         PX_OBJ.cntx_psh();
         PX_OBJ.index('PX_TAG');
         PX_OBJ.prefix(_px_tag);
         {? PX_OBJ.first()
         || _il_plan:=exec('get_ilosc_que','px_tag',_ver,_px_tag);
            _to_plan:=PX_TAG.ILOSC-_il_plan;

            {? _to_plan<=0
            || _msg:='Grupa obiektów: %1 jest w całości zaplanowana.'@[_what];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_ver;
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _mp.error(_msg)
            ?}
         || _can_continue:=0;
            _msg:='Grupa obiektów: %1 jest pusta, nie zawiera żadnych obiektów.'@[_what];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg)
         ?};

         PX_OBJ.cntx_pop();


         {? _can_continue>0
         ||
            {? _planned=0
            ||
::             Dodajemy do kolejki
               _to_que:=exec('que_tab4tag','!tpp_pps_dopl',_px_tag,_dialog,_mp,_out,_mp.isGroup(),_ver);
               _can_continue:=_to_que.RESULT;
               {? _can_continue>0
               ||
                  _add_result:=exec('add_to_queue','!tpp_pps_dopl',_to_que.TAB
                                                                     ,_edit
                                                                     ,_win_refresh
                                                                     ,_ctrl
                                                                     ,_drop_dest
                                                                     ,_mp.isGroup()
                                                                     ,_pathtodo
                                                                     ,_ver
                                                                     ,_dialog
                                                                     ,'Z'
                                                                     ,_pos_in_queue
                                                                     ,_px_tag);
                  {? _add_result=0
                  || _can_continue:=0;
                     {? _dialog<>1
                     || _mp.error('Nie udało się zaplanować grupy operacji: %1'@[_what])
                     ?}
                  ?}
               ?};

               {? _can_continue>0
               ||
::                Planuje dodany obiekt
                  {? _replan>0
                  || _res_plan:=exec('replan_tag','!tpp_pps_dopl',_px_tag)
                  || _res_plan:=1
                  ?}
               ?}
            ?}
         ?};
         ~~
      || _out.RESULT:='BŁĄD'
      ?};
      {? _can_continue>0
      || _out.RESULT:='OK'
      || _out.RESULT:='BŁĄD'
      ?};

::    Obsługa na done
      {? _mp.isService()
      || _mp.done()
      || {? _res_plan>0
         || _mp.done()
         ?}
      ?};
      _mp.save(,_out);

      {? _komm_show>0
      || KOMM.select()
      ?}
   ?};
   exec('unlock','px_ver',_ver);
   ~~
|| _msg:='Błąd konfiguracji czynności TPP_PPS_DOPL - Planowanie obiektu - nie przekazano obiektu do zaplanowania'@;
   _mp.error(_msg)
?};

ZK_P.cntx_pop();
ZK_N.cntx_pop();
ZL.cntx_pop();
PX_OBJ.cntx_pop();
GROP.cntx_pop();
PX_TAG.cntx_pop();
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła na opis TODO czynności TTP_PPS_DOPL
::   WY: STRING - opis zadania
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_desc:='';
_keyRefs:=_mp.getRefs();
_in:=_mp.load(exec('kind_in','#b_port'));
_zk_n:=null();
_zk_p:=null();
_zl:=null();
_grop:=null();
_px_tag:=null();

_sym_zkn:='';
_sym_zkp:='';
_sym_zl:='';
_sym_grop:='';
_sym_tag:='';

:: jest rekord kluczowy ZK_N, to ustawiam odpowiedniego ZK_N
{? var_pres('[1]',_keyRefs)>0 & 5+ref_name(_keyRefs[1])=5+ZK_N.name()
|| _zk_n:=exec('FindAndGet','#table',ZK_N,_keyRefs[1],,,null())
:: jest parametr wejściowy ZK_N
|? var_pres('ZK_N',_in)>0
|| _zk_n:=exec('FindAndGet','#table',ZK_N,_in.ZK_N,,,null())
?};

:: jest rekord kluczowy ZK_P, to ustawiam odpowiedniego ZK_P
{? var_pres('[1]',_keyRefs)>0 & 5+ref_name(_keyRefs[1])=5+ZK_P.name()
|| _zk_p:=exec('FindAndGet','#table',ZK_P,_keyRefs[1],,,null())
:: jest parametr wejściowy ZK_P
|? var_pres('ZK_P',_in)>0
|| _zk_p:=exec('FindAndGet','#table',ZK_P,_in.ZK_P,,,null())
?};

{? _zk_p<>null()
|| _zk_n:=exec('FindAndGet','#table',ZK_P,_zk_p,,"N",null());
   _sym_zkp:=exec('record','#to_string',_zk_p)
?};

{? _zk_n<>null()
|| _sym_zkn:=exec('record','#to_string',_zk_n)
?};

:: jest rekord kluczowy ZL, to ustawiam odpowiednie ZL
{? var_pres('[1]',_keyRefs)>0 & ref_name(_keyRefs[1])=ZL.name()
|| _zl:=exec('FindAndGet','#table',ZL,_keyRefs[1],,,null())
:: jest parametr wejściowy ZL
|? var_pres('ZL',_in)>0
|| _zl:=exec('FindAndGet','#table',ZL,_in.ZL,,,null())
?};
{? _zl<>null()
|| _sym_zl:=exec('record','#to_string',_zl)
?};

:: jest rekord kluczowy GROP, to ustawiam odpowiednie GROP
{? var_pres('[1]',_keyRefs)>0 & ref_name(_keyRefs[1])=GROP.name()
|| _grop:=exec('FindAndGet','#table',GROP,_keyRefs[1],,,null())
:: jest parametr wejściowy GROP
|? var_pres('GROP',_in)>0
|| _grop:=exec('FindAndGet','#table',GROP,_in.GROP,,,null())
?};
{? _grop<>null()
|| _sym_grop:=exec('record','#to_string',_grop)
?};

:: jest rekord kluczowy PX_TAG, to ustawiam odpowiednie PX_TAG
{? var_pres('[1]',_keyRefs)>0 & ref_name(_keyRefs[1])=PX_TAG.name()
|| _px_tag:=exec('FindAndGet','#table',PX_TAG,_keyRefs[1],,,null())
:: jest parametr wejściowy PX_TAG
|? var_pres('PX_TAG',_in)>0
|| _px_tag:=exec('FindAndGet','#table',PX_TAG,_in.PX_TAG,,,null())
?};
{? _px_tag<>null()
|| _sym_tag:=exec('record','#to_string',_px_tag)
?};

{? _sym_zkp<>''
|| _desc:='Zaplanuj %1'@@[-(1+_sym_zkp)+(1-_sym_zkp)]
|? _sym_zkn<>''
|| _desc:='Zaplanuj zamówienie: %1'@@[_sym_zkn]
|? _sym_zl<>''
|| _desc:='Zaplanuj zlecenie %1'@@[_sym_zl]
|? _sym_grop<>''
|| _desc:='Zaplanuj grupę operacji: %1'@@[_sym_grop]
|? _sym_tag<>''
|| _desc:='Zaplanuj grupę obiektów: %1'@@[_sym_tag]
?};
_desc


\access
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła ograniczajaca uprawnienia do czynności TTP_PPS_DOPL w przypadku pracy na zestawach
::       Sprawdza czy dany użytkownik może zacząć planować dany obiekt tzn czy ma uprawnienia do zestawu
::       startowego danego obiektu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_user:=params_get().user;
_mp:=params_get().mp;

_result:=1;
_can_continue:=1;

{? exec('is_px_set','px_param')>0
||
   _zk_n:=null();
   _zl:=null();
   _keyRefs:=_mp.getRefs();
:: jest rekord kluczowy ZK_N, to ustawiam odpowiedniego ZK_N
   {? var_pres('[1]',_keyRefs)>0 & 5+ref_name(_keyRefs[1])=5+ZK_N.name()
   || _zk_n:=exec('FindAndGet','#table',ZK_N,_keyRefs[1],,,null())
:: jest parametr wejściowy ZK_N
   |? var_pres('ZK_N',_in)>0
   || _zk_n:=exec('FindAndGet','#table',ZK_N,_in.ZK_N,,,null())
   ?};

:: jest rekord kluczowy ZL, to ustawiam odpowiednie ZL
   {? var_pres('[1]',_keyRefs)>0 & ref_name(_keyRefs[1])=ZL.name()
   || _zl:=exec('FindAndGet','#table',ZL,_keyRefs[1],,,null())
:: jest parametr wejściowy ZL
   |? var_pres('ZL',_in)>0
   || _zl:=exec('FindAndGet','#table',ZL,_in.ZL,,,null())
   ?};

   PX_SETU.cntx_psh();
   PX_SETU.index('PX_SET');
   {? _zk_n<>null()
   ||
      ZK_P.cntx_psh();
      ZK_P.use(5+ZK_P.name()+(ref_name(_zk_n)+3));
      ZK_P.index('NAG');
      ZK_P.prefix(_zk_n);
      {? ZK_P.first()
      || {!
         |?
            _can_continue:=exec('zkp2obj','px_obj');
            {? _can_continue>0
            || _result:=0;
               _px_obj:=exec('get_zkp_object','px_obj',ZK_P.ref());
               {? _px_obj<>null()
               || _px_set:=exec('FindAndGet','#table',PX_OBJ,_px_obj,,"PX_SET",null());

                  {? _px_set<>null()
                  ||
::                   Sprawdzam czy użytkownik ma uprawnienie do zestawu chociaż jednej pozycji
                     PX_SETU.prefix(_px_set,_user);
                     {? PX_SETU.size()>0
                     || _result:=1;
                        _can_continue:=0
                     ?}
                  || _result:=1
                  ?}
               ?}
            ?};
            ZK_P.next() & _can_continue>0
         !}
      ?};
      ZK_P.cntx_pop();
      ~~
   |? _zl<>null()
   ||
      ZL.cntx_psh(); ZL.prefix();
      {? ZL.seek(_zl)
      || _can_continue:=exec('zl2obj','px_obj');
         {? _can_continue>0
         || _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
            {? _px_obj<>null()
            || _result:=0;
               _px_set:=exec('FindAndGet','#table',PX_OBJ,_px_obj,,"PX_SET",null());
               {? _px_set<>null()
               ||
::                Sprawdzam czy użytkownik ma uprawnienie do zestawu tego zlecenia
                  PX_SETU.prefix(_px_set,_user);
                  {? PX_SETU.size()>0
                  || _result:=1
                  ?}
               || _result:=1
               ?}
            ?}
         ?}
      ?};
      ZL.cntx_pop();
      ~~
   ?};
   PX_SETU.cntx_pop();
   ~~
?};
_result


\replan_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przeplanowuje wszystkie grupy w kolejce zawierające dany obiekt
::   WE: _a - PX_OBJ.ref() - obiekt do przeplanowania
::   WY: 0 - nie udało się przeplanować
::       1 - udało się ale są błędy
::       2 - udało się ale są ostrzeżenia
::       10 - wszystko ok
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_px_obj:=_a;

_result:=0;

_can_continue:=1;

_mainver:=exec('get_mainversion','px_ver');
PX_CONN.cntx_psh();
PX_CONN.index('VER');
PX_CONN.prefix(_mainver,_px_obj);
{? PX_CONN.first()
||
   {!
   |? _result:=exec('replan_grp','!tpp_pps_dopl',PX_CONN.PX_GRP);
      PX_CONN.next()
   !}
?};
PX_CONN.cntx_pop();
_result


\replan_tag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Przeplanowuje wszystkie grupy w kolejce powiązane z danym PX_TAG
::   WE: _a - PX_OBJ.ref() - obiekt do przeplanowania
::   WY: 0 - nie udało się przeplanować
::       1 - udało się ale są błędy
::       2 - udało się ale są ostrzeżenia
::       10 - wszystko ok
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_px_tag:=_a;

_result:=0;

_can_continue:=1;

_mainver:=exec('get_mainversion','px_ver');
PX_GRP.cntx_psh();
PX_GRP.index('PX_TAG');
PX_GRP.prefix(_px_tag,_mainver);
{? PX_GRP.first()
|| {!
   |? _result:=exec('replan_grp','!tpp_pps_dopl',PX_GRP.ref());
      PX_GRP.next()
   !}
?};
PX_GRP.cntx_pop();
_result


\replan_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Przeplanowuje PX_GRP w kolejce planu
::   WE: _a - PX_GRP.ref()
::   WY: 0 - nie udało się przeplanować
::       1 - udało się ale są błędy
::       2 - udało się ale są ostrzeżenia
::       10 - wszystko ok
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh(); PX_GRP.prefix();
{? PX_GRP.seek(_px_grp)
|| _mainver:=exec('get_mainversion','px_ver');
   _args:=exec('fast_replan_a','px_logix');
   exec('mod_stamp','px_ver',_mainver);
   _args.PX_GRP:=_px_grp;
   _args.MOD_START:=1;
   _args.TM_ZERO:=PX_GRP.tm_stamp();
   _args.CLEAN:=1;
   _args.MOD_QUEUE:=1;
   _args.RENUMERATE:=1;
   _args.SUR_UPD:=1;

   _can_replan:=exec('queue_update_core','px_logix',PX_GRP.ref());
   {? _can_replan>0
   || _can_replan:=exec('queue_check_one','px_logix',PX_GRP.ref())
   ?};

   {? _can_replan>0
   || _can_continue:=exec('grp_fast_replan','px_logix',_args)
   ?};

   {? _can_continue>0
   ||
      _result:=10;

::    Sprawdzam czy są błędy
      {? _result=10 & PX_GRP.KOM_ERR='T'
      || _result:=1
      ?};
::    Sprawdzam czy są ostrzeżenia
      {? _result=10 & PX_GRP.KOM_WARN='T'
      || _result:=2
      ?}
   ?}
?};
PX_GRP.cntx_pop();
_result


\add_to_queue
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Dodaje obiekt do kolejki
::   WE: [_a] - tab_tmp - lista obiektów które umieścić w kolejce
::       [_b] - INTEGER - 0/[1] - czy wyświetlać okno edycyjne, czy dodawać wg domyślnych wartości
::       [_c] - INTEGER - [0]/1 - czy odświeżać okno kolejki
::       [_d] - INTEGER - 0/[1] - czy sprawdzać poprawność dodawania
::       [_e] - .ref()  - element na który są upuszczane rekordy
::       [_f] - INTEGER - [0]/1 - czy akcja grupowa czy pojedyncza
::       [_g] - INTEGER - 0/[1] - 1 - wywołanie z listy TODO (procesu), 0 - wywołanie z obszaru roboczego
::       [_h] - PX_VER.ref - wersja do której dodawać, jeśli nie podane to wersja główna
::       [_i] - INTEGER - tryb dialogów:   0 - brak,
::                                         1 - komunikaty na ekran
::                                         2 - komunikaty do KOMMa,
::                                         3 - komunikaty do PX_KOMM i do _mp.error
::       [_j] - STRING - rodzaj kolejki do której dodawać: 'Z' - normalna, 'G' - grupy operacji
::       [_k] - INTEGER - pozycja w kolejce na której umieścić obiekty
::       [_l] - PX_TAG.ref - grupa obiektów
::       [_m] - GROP.ref - grupa operacji
::   WY: 0 - żaden element nie dodany do kolejki
::       1 - nie wszystkie elementy dodane do kolejki
::       2 - wszystkie elementy dodane do kolejki
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_to_que:=_a;

_edit:=1;
{? var_pres('_b')=type_of(0)
|| _edit:=_b
?};

_refresh:=0;
{? var_pres('_c')=type_of(0)
|| _refresh:=_c
?};

_ctrl:=1;
{? var_pres('_d')=type_of(0)
|| _ctrl:=_d
?};

_drop_dest:=null();
{? var_pres('_e')=type_of(null())
|| _drop_dest:=_e
?};

_grupa:=0;
{? var_pres('_f')=type_of(0)
|| _grupa:=_f
?};

_pathtodo:=1;
{? var_pres('_g')=type_of(0)
|| _pathtodo:=_g
?};

_ver:=exec('get_mainversion','px_ver');
{? var_pres('_h')=type_of(PX_VER.ref())
|| _ver:=_h
?};
_dialog:=1;
{? var_pres('_i')=type_of(0)
|| _dialog:=_i
?};
_kind:='Z';
{? var_pres('_j')=type_of('')
|| _kind:=_j
?};
_pos_in_queue:=-1;
{? var_pres('_k')=type_of(0)
|| _pos_in_queue:=_k
?};
_px_tag:=null();
{? var_pres('_l')=type_of(PX_TAG.ref())
|| _px_tag:=_l
?};
_grop:=null();
{? var_pres('_m')=type_of(GROP.ref())
|| _grop:=_m
?};

_result:=0;

exec('trigger_on','px_grp');

_elements_to_que:=exec('to_que_tab','!tpp_pps_dopl');

_to_que.cntx_psh();
_to_que.clear();
{? _to_que.first()
|| {!
   |? _elements_to_que.blank();
      {? _to_que.ILOSC>0
      || _elements_to_que.blank();
         _elements_to_que.REF:=_to_que.REF;
         _elements_to_que.CRC:=_to_que.CRC;
         _elements_to_que.POS:=_to_que.POS;
         _elements_to_que.SQL:=_to_que.SQL;
         _elements_to_que.PLANNED:=_to_que.PLANNED;
         _elements_to_que.QUEUED:=_to_que.QUEUED;
         _elements_to_que.ILOSC:=_to_que.ILOSC;
         _elements_to_que.GROPS:=_to_que.GROPS;
         _elements_to_que.add()
      ?};
      _to_que.next()
   !}
?};

{? _elements_to_que.size()>1
|| _grupa:=1
?};

_dest_lpq:=0;
{? _pos_in_queue>-1
||
:: Przed stwierdzeniem gdzie wrzucić muszę naprawić kolejność w kolejce
   exec('prenumber','px_grp',_ver);
   PX_GRP.cntx_psh();

   {? _pos_in_queue=0
   ||
      {? exec('is_whatif','px_ver')>0
      || PX_GRP.index('PLAN_S');
         PX_GRP.prefix(_ver,'N','N','N',_kind)
      || PX_GRP.index('PLAN');
         PX_GRP.prefix(_ver,'N','N',_kind)
      ?};
      {? PX_GRP.first()
      || _dest_lpq:=PX_GRP.LP_Q
      ?}
   |? _pos_in_queue>0
   ||
      {? exec('is_whatif','px_ver')>0
      || PX_GRP.index('PLAN_S');
         PX_GRP.prefix(_ver,'N','N','N',_kind,_pos_in_queue)
      || PX_GRP.index('PLAN');
         PX_GRP.prefix(_ver,'N','N',_kind,_pos_in_queue)
      ?};
      {? PX_GRP.first()
      || _dest_lpq:=PX_GRP.LP_Q
      ?}
   ?};
   PX_GRP.cntx_pop()
?};

:: Jądro dodawania do kolejki
exec('to_queue','px_grp',_elements_to_que
                        ,_drop_dest
                        ,_refresh
                        ,_ver
                        ,_edit
                        ,_ctrl
                        ,_grupa
                        ,_pathtodo
                        ,_dialog
                        ,_px_tag
                        ,_grop);

:: Sprawdzam czy się dodało do kolejki
{? _to_que.first()
|| _result:=0;
   _w_kolejce:=0;
   {!
   |? _px_obj:=exec('FindAndGet','#table',PX_OBJ,_to_que.SQL,,,null());

      {? _px_obj<>null()
      ||
         PX_CONN.cntx_psh();
         PX_CONN.index('VER');
         PX_CONN.prefix(_ver,_px_obj);
         {? PX_CONN.first()
         || _w_kolejce+=1;
            _to_que.QUEUED:=1;
            _to_que.PX_GRP:=$PX_CONN.PX_GRP;
            _to_que.LP_Q:=PX_CONN.PX_GRP().LP_Q;
            _to_que.put()
         ?};
         PX_CONN.cntx_pop();
         ~~
      ?};
      _to_que.next()
   !};

   {? _pos_in_queue>-1
   ||
::    Przenumerowanie elementów kolejki tak żeby nowe elementy trafiły w przekazane
::    parametrem miejsce
      _to_que.cntx_psh();
      {? _to_que.last()
      || PX_GRP.cntx_psh(); PX_GRP.prefix();
         _frac:=0.001;
         _it:=0;
         {!
         |? {? _to_que.PX_GRP<>''
            || _it+=1;
               {? PX_GRP.seek(_to_que.PX_GRP)
               || PX_GRP.LP_Q:=_dest_lpq-(_it*_frac);
                  PX_GRP.put()
               ?}
            ?};
            _to_que.prev()
         !};
         PX_GRP.cntx_pop()
      ?};
      exec('prenumber','px_grp',_ver);
      _to_que.cntx_pop()
   ?};
   {? _w_kolejce=_to_que.size()
   || _result:=2
   |? _w_kolejce>0
   || _result:=1
   ?}
?};
_to_que.cntx_pop();
exec('trigger_off','px_grp');
_result


\que_tab4zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę z obiektami do kolejki dodając do niej przekazane zlecenie
::   WE: _a - ZL.ref() - zlecenie
::       _b - INTEGER - 0/1 - czy wyświetlać dialogi
::       _c - obj_new() - obiekt Menadżera Procesów
::       _d - obj_new() - parametry wyjściowe
::       _e - INTEGER - 0/1 - czy akcja grupowa
::       [_f] - PX_VER.ref() - wersja planu, jeżeli nie podane to wersja główna
::       [_g] - tab_tmp - tabelka do której dodawać, wynik exec('to_que_tab','!tpp_pps_dopl')
::       [_h] - INTEGER - 0/1 - czy sprawdzać czy można dodać do kolejki
::   WY: tab_tmp
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_dialog:=_b;
_mp:=_c;
_out:=_d;
_grupa:=_e;

_ver:=exec('get_mainversion','px_ver');
{? var_pres('_f')=type_of(PX_VER.ref())
|| _ver:=_f
?};
{? var_pres('_g')>100
|| _to_que:=_g
|| _to_que:=exec('to_que_tab','!tpp_pps_dopl')
?};
_check:=1;
{? var_pres('_h')=type_of(0)
|| _check:=_h
?};

_result:=obj_new('RESULT','TAB');
_result.RESULT:=0;

PX_OBJ.cntx_psh();
PX_OBJ.clear();
ZL.cntx_psh();
ZL.clear();
_can_continue:=1;

{? ZL.seek(_zl)
|| exec('zl2obj','px_obj');
   _planned:=exec('zl_planned','px_obj',ZL.ref(),_ver);

   _can_continue:=1;
   {? _check>0
   || _can_continue:=exec('que_tab_chk_zl','!tpp_pps_dopl',,_dialog,_mp,_out,_grupa,_ver)
   ?};
   {? _can_continue>0
   || _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
      {? PX_OBJ.seek(_px_obj)
      || _to_que.REF:=#PX_OBJ.ref();
         _to_que.CRC:=PX_OBJ.crc();
         _to_que.SQL:=$PX_OBJ.ref();
         _to_que.POS:=1;
         _to_que.ILOSC:=ZL.IL;
         _to_que.PLANNED:=_planned;
         _to_que.add()
      ?}
   ?}
?};
ZL.cntx_pop();
PX_OBJ.cntx_pop();
{? _can_continue>0
|| _result.RESULT:=1
?};
_result.TAB:=_to_que;
_result


\que_tab4zkn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę z obiektami do kolejki dodając do niej przekazane zamówienie
::   WE: _a - ZK_N.ref - zamówienie sprzedaży
::       _b - INTEGER - 0/1 - czy wyświetlać dialogi
::       _c - obj_new() - obiekt Menadżera Procesów
::       _d - obj_new() - parametry wyjściowe
::       _e - INTEGER - 0/1 - czy akcja grupowa
::       [_f] - PX_VER.ref() - wersja planu, jeżeli nie podane to wersja główna
::   WY: obj_new
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_zk_n:=_a;
_dialog:=_b;
_mp:=_c;
_out:=_d;
_grupa:=_e;

_result:=obj_new('RESULT','TAB');
_result.RESULT:=0;

PX_OBJ.cntx_psh();
PX_OBJ.clear();
ZK_P.cntx_psh();
ZK_P.index('NAG');
ZK_N.cntx_psh();
ZK_N.clear();

_ver:=exec('get_mainversion','px_ver');
{? var_pres('_f')=type_of(PX_VER.ref())
|| _ver:=_f
?};
_can_continue:=1;

_to_que:=exec('to_que_tab','!tpp_pps_dopl');

{? ZK_N.seek(_zk_n)
||
   ZK_P.prefix(ZK_N.ref());
   {? ZK_P.first()
   || {!
      |?
         _planned:=exec('zkp_planned','px_obj',ZK_P.ref(),_ver);
::       Sekcja sprawdzania
         _can_continue:=exec('que_tab_chk_zkp','!tpp_pps_dopl',,_dialog,_mp,_out,_grupa);
         {? _can_continue>0
         ||
            exec('zkp2obj','px_obj');
            _px_obj:=exec('get_zkp_object','px_obj',ZK_P.ref());
            {? PX_OBJ.seek(_px_obj)
            ||
               {? exec('can_plan','px_obj',PX_OBJ.ref(),_dialog,,,,,,_ver)>0
               ||
                  _to_que.REF:=#PX_OBJ.ref();
                  _to_que.CRC:=PX_OBJ.crc();
                  _to_que.SQL:=$PX_OBJ.ref();
                  _to_que.POS:=1;
                  _to_que.PLANNED:=_planned;
                  _to_que.ILOSC:=ZK_P.ILP-ZK_P.ILRB;
                  _to_que.add()
               || _can_continue:=0
               ?}
            ?}
         ?};
         ZK_P.next() & _can_continue>0
      !}
   ?}
|| _can_continue:=0
?};

{? _can_continue>0
|| _out.RESULT:='OK'
|| _out.RESULT:='BŁĄD'
?};

ZK_N.cntx_pop();
ZK_P.cntx_pop();
PX_OBJ.cntx_pop();

{? _can_continue>0
|| _result.RESULT:=1
?};
_result.TAB:=_to_que;
_result


\que_tab4zkp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę z obiektami do kolejki dodając do niej przekazaną pozycję zamówienia
::   WE: _a - ZK_P.ref - zamówienie sprzedaży
::       _b - INTEGER - 0/1 - czy wyświetlać dialogi
::       _c - obj_new() - obiekt Menadżera Procesów
::       _d - obj_new() - parametry wyjściowe
::       _e - INTEGER - 0/1 - czy akcja grupowa
::       [_f] - PX_VER.ref() - wersja planu, jeżeli nie podane to wersja główna
::       [_g] - tab_tmp - tabelka do której dodawać, wynik exec('to_que_tab','!tpp_pps_dopl')
::   WY: tab_tmp
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_zk_p:=_a;
_dialog:=_b;
_mp:=_c;
_out:=_d;
_grupa:=_e;

_ver:=exec('get_mainversion','px_ver');
{? var_pres('_f')=type_of(PX_VER.ref())
|| _ver:=_f
?};
{? var_pres('_g')>100
|| _to_que:=_g
|| _to_que:=exec('to_que_tab','!tpp_pps_dopl')
?};

_result:=obj_new('RESULT','TAB');
_result.RESULT:=0;

M.cntx_psh();
PX_OBJ.cntx_psh();
PX_OBJ.clear();
ZK_P.cntx_psh();
ZK_P.use(ref_name(_zk_p));
ZK_P.clear();

ZK_N.cntx_psh();
ZK_N.clear();

_can_continue:=1;

{? ZK_P.seek(_zk_p)
||
:: Sekcja sprawdzania
   _planned:=exec('zkp_planned','px_obj',ZK_P.ref(),_ver);
   _can_continue:=exec('que_tab_chk_zkp','!tpp_pps_dopl',,_dialog,_mp,_out,_grupa,_ver);
   {? _can_continue>0
   ||
      exec('zkp2obj','px_obj');
      _px_obj:=exec('get_zkp_object','px_obj',ZK_P.ref());
      {? PX_OBJ.seek(_px_obj)
      || _to_que.REF:=#PX_OBJ.ref();
         _to_que.CRC:=PX_OBJ.crc();
         _to_que.SQL:=$PX_OBJ.ref();
         _to_que.POS:=1;
         _to_que.PLANNED:=_planned;
         _to_que.ILOSC:=ZK_P.ILP-ZK_P.ILRB;
         _to_que.add()
      ?}
   ?}
?};

{? _can_continue>0
|| _out.RESULT:='OK'
|| _out.RESULT:='BŁĄD'
?};

ZK_N.cntx_pop();
ZK_P.cntx_pop();
PX_OBJ.cntx_pop();
M.cntx_pop();
{? _can_continue>0
|| _result.RESULT:=1
?};
_result.TAB:=_to_que;
_result


\que_tab4grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Tworzy tabelkę z obiektami do kolejki dodając do niej przekazaną grupę operacji
::   WE: _a - GROP.ref() - grupa operacji
::       [_b] - PX_VER.ref() - wersja planu, jeżeli nie podane to wersja główna
::       [_c] - tab_tmp - tabelka z rozpiska jak rozpisać grupę operacji w kolejce planu
::   WY: tab_tmp
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

_ver:=exec('get_mainversion','px_ver');
{? var_pres('_b')=type_of(PX_VER.ref())
|| _ver:=_b
?};

_predivision_tab:=~~;
{? var_pres('_c')>100
|| _predivision_tab:=_c
?};

_result:=obj_new('RESULT','TAB');
_result.RESULT:=0;

PX_OBJ.cntx_psh();
PX_OBJ.clear();
GROP.cntx_psh();
GROP.clear();
_can_continue:=1;

_to_que:=exec('to_que_tab','!tpp_pps_dopl');

{? GROP.seek(_grop)
|| exec('grop2obj','px_obj');
   _planned:=exec('grop_planned','px_obj',GROP.ref(),_ver);
   _px_obj:=exec('get_grop_object','px_obj',GROP.ref());
   {? PX_OBJ.seek(_px_obj)
   ||
      {? var_pres('_predivision_tab')>100
      || {? _predivision_tab.first()
         || {!
            |?
               {? _predivision_tab.IL_PLAN>0
               ||
                  _to_que.blank();
                  _to_que.REF:=#PX_OBJ.ref();
                  _to_que.CRC:=PX_OBJ.crc();
                  _to_que.SQL:=$PX_OBJ.ref();
                  _to_que.POS:=1;
                  _to_que.ILOSC:=_predivision_tab.IL_PLAN;
                  _to_que.PLANNED:=_planned;
                  _to_que.GROPS:=_predivision_tab.GROPS;
                  _to_que.add()
               ?};
               _predivision_tab.next()
            !}
         ?}
      ||
         _to_que.REF:=#PX_OBJ.ref();
         _to_que.CRC:=PX_OBJ.crc();
         _to_que.SQL:=$PX_OBJ.ref();
         _to_que.POS:=1;
         _to_que.ILOSC:=GROP.IL-exec('get_ilosc_que','px_obj',_ver,_px_obj)-GROP.ILW;
         _to_que.ILOSC:=exec('max','#math',_to_que.ILOSC,0);
         _to_que.PLANNED:=_planned;
         _to_que.add()
      ?}
   ?}
?};
GROP.cntx_pop();
PX_OBJ.cntx_pop();
{? _can_continue>0
|| _result.RESULT:=1
?};
_result.TAB:=_to_que;
_result


\to_que_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę z obiektami do kolejki
::   WE:
::   WY:
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_to_que:=tab_tmp(1,
   'REF','INTEGER','#PX_OBJ.ref()',
   'CRC','INTEGER','PX_OBJ.crc()',
   'POS','INTEGER','Pozycja',
   'SQL','STRING[16]','Ref SQL PX_OBJ',
   'PLANNED','REAL','Ile zaplanowane',
   'ILOSC','REAL','Ilość na obiekcie',
   'QUEUED','INTEGER','Czy dodane do kolejki',
   'PX_GRP','STRING[16]','Ref SQL PX_GRP do którego dodano obiekt',
   'LP_Q','REAL','Pozycja w kolejce',
   'GROPS','STRING[16]','Zasób dla grupy operacji'
   );
_to_que


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła ustala PARSES
::   WE: UWAGA. Do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;

_result:=0;

:: Jeżeli jest zamówienie, to oddział, rok, miesiąc wg niego, reszta dziedziczona
{? var_pres('ZK_N',_in)=type_of(null()) & _in.ZK_N
|| ZK_N.cntx_psh();
   ZK_N.use(ref_name(_in.ZK_N));
   ZK_N.prefix();
   {? ZK_N.seek(_in.ZK_N)
   || __PARSES.setVal('OddzialLogProd',ZK_N.ODDZ);
      _args:=__PARSES.args('OkresRok');
      _args.OBSZAR:='LSP';
      _args.AR:=ZK_N.R;
      _args.AM:=ZK_N.M;
      __PARSES.setVal('OkresRok',_args);
      _result:=1
   ?};
   ZK_N.cntx_pop()

:: Jeżeli jest zlecenie, to oddział wg niego, reszta dziedziczona
|? var_pres('ZL',_in)=type_of(null()) & _in.ZL
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_in.ZL)
   || __PARSES.setVal('OddzialLogProd',ZL.ODDZ);
      _args:=__PARSES.args('OkresRok');
      _args.OBSZAR:='LSP';
      _args.AR:=ZL.OD~1;
      _args.AM:=ZL.OD~2;
      __PARSES.setVal('OkresRok',_args);
      _result:=1
   ?};
   ZL.cntx_pop()

:: Nic nie ustawiamy, ale zwracamy 1, w formule przy braku parametrów wejściowych zostanie zgłoszony błąd
|| _result:=1
?};
_result


\transform
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przekształca w kolejce planu zamówienia w zlecenie
::   WE: _a - PX_OBJ.ref() - obiekt dotyczący zamówienia
::       _b - PX_VER.ref() - wersja planu
::       _c - ZLZAM.ref()
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_zkp_obj:=_a;
_px_ver:=_b;
_zlzam:=_c;

_result:=0;
_can_continue:=1;

PX_CONN.cntx_psh();
PX_CONN.index('VER');
PX_CONN.prefix(_px_ver,_zkp_obj);
_il_processed:=0;
_il_left:=ZL.IL;
{? PX_CONN.first()
|| {!
   |?
      {? _il_left>0
      || _can_continue:=exec('zlzam2plan','px_tie',_zlzam,PX_CONN.ref(),_px_ver)
      ?};

      {? _can_continue>0
      || _il_left-=PX_CONN.ILOSC
      ?};
      PX_CONN.next() & _can_continue>0 & _il_left>0
   !}
?};
PX_CONN.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::   WE: [_a] - _mp - obiekt Menadżera procesów
::       [_b] - tablica z parametrami wejściowymi
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _mp:=_a
|| _mp:=params_get().mp
?};
{? var_pres('_b')>100
|| _in:=_b
|| _in:=params_get().in
?};

_can_continue:=1;
_obj:=obj_new('RESULT','ZL','ZK_N','ZK_P','GROP','PX_TAG');
_obj.RESULT:=0;
_obj.ZL:=null();
_obj.ZK_N:=null();
_obj.ZK_P:=null();
_obj.GROP:=null();
_obj.PX_TAG:=null();

_keyRefs:=_mp.getRefs();
_has_key:=0;
{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];

      {? type_of(_kref)>0
      || _has_key:=1;
         {? ref_name(_kref)=ZL.name()
         || _obj.ZL:=exec('FindAndGet','#table',ZL,_kref,,,null());

            {? _obj.ZL=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZL,_obj.ZL,,"ZL.STAN",'')='Z'
            ||
::            Zlecenie zostało zamknięte, więc robie error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp,,0)
            ?}
         |? ref_name(_kref)=GROP.name()
         || _obj.GROP:=exec('FindAndGet','#table',GROP,_kref,,,null());

            {? _obj.GROP=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego z grupą operacji, więc robię error
               _can_continue:=0;
               exec('grop_deleted_in_proc','zl_grop',_mp)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',GROP,_obj.GROP,,"GROP.STATUS",'')='Z'
            ||
::             Grupa została zamknięta, więc robie error
               _can_continue:=0;
               exec('grop_deleted_in_proc','zl_grop',_mp,,0)
            ?}
         |? ref_name(_kref)=PX_TAG.name()
         || _obj.PX_TAG:=exec('FindAndGet','#table',PX_TAG,_kref,,,null());

            {? _obj.PX_TAG=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego z grupą obiektów, więc robię error
               _can_continue:=0;
               _msg:='Grupa obiektów nie zostaa odnaleziona, prawdopodobnie została usunięty.'@@;
               {? _mp.isService()=0 & _mp.CLEANER=0
               || {? _mp.isGroup()
                  || KOMM.add(_msg,2,,1)
                  || FUN.emsg(_msg)
                  ?}
               ?};
               _mp.error(_msg)
            ?}
         |? (5+ref_name(_kref))=(5+ZK_N.name())
         || _obj.ZK_N:=exec('FindAndGet','#table',ZK_N,_kref,,,null());

            {? _obj.ZK_N=null()
            || _can_continue:=0;
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _msg:='Zamówienie nie zostało odnalezione, prawdopodobnie zostało usunięte.'@;
               {? _mp.isService()=0 & _mp.CLEANER=0
               || FUN.emsg(_msg)
               ?};
               _mp.error(_msg)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZK_N,_obj.ZK_N,,"(name()+2)<>'__'",0)
            ||
::             Zamówienie przeniesione do archiwum, robię error
               _can_continue:=0;
               exec('zam_deleted_in_proc','zamowienia',_mp,,,1)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZK_N,_obj.ZK_N,,"STAT_REJ='A'",0)
            ||
::             Zamówienie anulowane, robię error
               _can_continue:=0;
               exec('zam_deleted_in_proc','zamowienia',_mp,,,2)
            ?}
         |? (5+ref_name(_kref))=(5+ZK_P.name())
         || _obj.ZK_P:=exec('FindAndGet','#table',ZK_P,_kref,,,null());

            {? _obj.ZK_P=null()
            || _can_continue:=0;
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _msg:='Pozycja zamówienia nie została odnaleziona, prawdopodobnie została usunięta.'@;
               {? _mp.isService()=0 & _mp.CLEANER=0
               || FUN.emsg(_msg)
               ?};
               _mp.error(_msg)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZK_P,_obj.ZK_P,,"(name()+2)<>'__'",0)
            ||
::             Zamówienie przeniesione do archiwum, robię error
               _can_continue:=0;
               exec('zam_deleted_in_proc','zamowienia',_mp,,,1)
            |? ~_mp.isMicro()
            || _zk_n:=exec('FindAndGet','#table',ZK_P,_obj.ZK_P,,"N",null);
               {? exec('FindAndGet','#table',ZK_N,_zk_n,,"STAT_REJ='A'",0)
               ||
::                Zamówienie anulowane, robię error
                  _can_continue:=0;
                  exec('zam_deleted_in_proc','zamowienia',_mp,,,2)
               ?}
            ?}
         ?}
      ?}
   !}
?};
{? _has_key=0
|| {? var_pres('ZL',_in)=0 &
      var_pres('ZK_N',_in)=0 &
      var_pres('ZK_P',_in)=0 &
      var_pres('GROP',_in)=0 &
      var_pres('PX_TAG',_in)=0
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: jest parametr wejściowy ZL
   {? _obj.ZL=null() & var_pres('ZL',_in)=type_of(null())
   || _obj.ZL:=_in.ZL
   ?};
:: jest parametr wejściowy ZK_N
   {? _obj.ZK_N=null() & var_pres('ZK_N',_in)=type_of(null())
   || _obj.ZK_N:=_in.ZK_N
   ?};
:: jest parametr wejściowy ZK_P
   {? _obj.ZK_P=null() & var_pres('ZK_P',_in)=type_of(null())
   || _obj.ZK_P:=_in.ZK_P
   ?};
:: jest parametr wejściowy GROP
   {? _obj.GROP=null() & var_pres('GROP',_in)=type_of(null())
   || _obj.GROP:=_in.GROP
   ?};
:: jest parametr wejściowy PX_TAG
   {? _obj.PX_TAG=null() & var_pres('PX_TAG',_in)=type_of(null())
   || _obj.PX_TAG:=_in.PX_TAG
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};

_obj


\que_tab4tag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Tworzy tabelkę z obiektami do kolejki dodając do niej przekazaną grupę obiektów
::   WE: _a - PX_TAG.ref - grupa obiektów
::       _b - INTEGER - 0/1 - czy wyświetlać dialogi
::       _c - obj_new() - obiekt Menadżera Procesów
::       _d - obj_new() - parametry wyjściowe
::       _e - INTEGER - 0/1 - czy akcja grupowa
::       [_f] - PX_VER.ref() - wersja planu, jeżeli nie podane to wersja główna
::   WY: obj_new
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_px_tag:=_a;
_dialog:=_b;
_mp:=_c;
_out:=_d;
_grupa:=_e;

_result:=obj_new('RESULT','TAB');
_result.RESULT:=0;

PX_TAG.cntx_psh();
PX_TAG.clear();

_ver:=exec('get_mainversion','px_ver');
{? var_pres('_f')=type_of(PX_VER.ref())
|| _ver:=_f
?};
_can_continue:=1;

_to_que:=exec('to_que_tab','!tpp_pps_dopl');

{? PX_TAG.seek(_px_tag)
||
   PX_OBJ.cntx_psh();
   PX_OBJ.index('PX_TAG');
   PX_OBJ.prefix(_px_tag);
   {? PX_OBJ.first()
   || {!
      |? _to_plan:=PX_OBJ.IL-exec('get_ilosc_que','px_obj',_ver,PX_OBJ.ref());
         {? _to_plan>0
         ||
            {? PX_OBJ.ZK_P<>null()
            ||
               ZK_P.use(ref_name(PX_OBJ.ZK_P));
               ZK_P.clear();
               _can_continue:=ZK_P.seek(PX_OBJ.ZK_P);

               {? _can_continue>0
               || ZK_N.use(5+ZK_N.name()+(ref_name(PX_OBJ.ZK_P)+3))
               ?};
               {? _can_continue>0
               ||
                  {? var_pres('_res')>100
                  || obj_del(_res)
                  ?};
                  _res:=exec('que_tab4zkp','!tpp_pps_dopl',PX_OBJ.ZK_P,_dialog,_mp,_out,_grupa,_ver,_to_que);
                  _can_continue:=_res.RESULT
               ?}
            |? PX_OBJ.ZL<>null()
            || {? var_pres('_res')>100
               || obj_del(_res)
               ?};
               _res:=exec('que_tab4zl','!tpp_pps_dopl',PX_OBJ.ZL,_dialog,_mp,_out,_grupa,_ver,_to_que,1);
               _can_continue:=_res.RESULT
            ?}
         ?};
         PX_OBJ.next() & _can_continue>0
      !}
   ?};
   PX_OBJ.cntx_pop();
   ~~
|| _can_continue:=0
?};

{? _can_continue>0
|| _out.RESULT:='OK'
|| _out.RESULT:='BŁĄD'
?};

PX_TAG.cntx_pop();

{? _can_continue>0
|| _result.RESULT:=1
?};
_result.TAB:=_to_que;
_result


\que_tab_chk_zkp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy można dodać do kolejki ZK_P
::   WE: [_a] - ZK_P lub bieżący rekord
::       _b - INTEGER - 0/1 - czy wyświetlać dialogi
::       _c - obj_new() - obiekt Menadżera Procesów
::       _d - obj_new() - parametry wyjściowe
::       _e - INTEGER - 0/1 - czy akcja grupowa
::       [_f] - PX_VER.ref() - wersja planu, jeżeli nie podane to wersja główna
::   WY: 0 - nie można
::       1 - można
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZK_P.ref())
|| _ref:=_a
?};
_dialog:=_b;
_mp:=_c;
_out:=_d;
_grupa:=_e;
_ver:=exec('get_mainversion','px_ver');
{? var_pres('_f')=type_of(PX_VER.ref())
|| _ver:=_f
?};

_result:=0;
_can_continue:=1;

ZK_P.cntx_psh();
{? _ref<>null()
|| ZK_P.prefix();
   {? ZK_P.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _planned:=exec('zkp_planned','px_obj',ZK_P.ref(),_ver);
   _what:=exec('ZK_P','#to_string');
   _dir:=ZK_P.PL_DIR;
   _pl_data:=ZK_P.PL_DATA;

   {? _grupa=0 & _dialog=0 & _dir=0
   ||
      _can_continue:=0;
      _msg:='Nie można zaplanować obiektu: %1 w trybie bezdialogowym, ponieważ na zamówieniu nie określono zwrotu planowania.'@[_what];
      _mp.error(_msg)
   ?};

   {? _grupa=0 & _dialog=0 & _pl_data=date(0,0,0)
   || _can_continue:=0;
      _msg:='Nie można zaplanować obiektu: %1 w trybie bezdialogowym, ponieważ na zamówieniu nie określono wewnętrznego teminu realizacji.'@[_what];
      _mp.error(_msg)
   ?};

   {? _can_continue>0
   ||
      {? 'PW'*ZK_P.M().R & M.RODZ='T'
      || _can_continue:=1
      || _can_continue:=0;
         _msg:='Nie można zaplanować obiektu: %1, ponieważ jego indeks materiałowy nie jest wyrobem gotowym lub półfabrykatem.'@[_what];
         _mp.error(_msg);
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || KOMM.add(_msg,2,,1)
         |? _dialog=3
         || {? var_pres('_komm_args')>100
            || obj_del(_komm_args)
            ?};
            _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_ver;
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);
            ~~
         ?}
      ?}
   ?};

   {? _can_continue>0
   ||
      {? ZK_P.N().A='Z'
      || _can_continue:=0;
         _msg:='Nie można zaplanować obiektu: %1, ponieważ znajduje się w archiwum.'@[_what];
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || KOMM.add(_msg,2,,1)
         |? _dialog=3
         || {? var_pres('_komm_args')>100
            || obj_del(_komm_args)
            ?};
            _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_ver;
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);
            ~~
         ?};
         _mp.error(_msg)
      ?}
   ?};

   _px_obj:=null();
   {? _can_continue>0
   || {? (ZK_P.ILP-ZK_P.ILRB)=0 | (ZK_P.ILP)=0
      ||
::       Jeżeli wszystko zarezerwowane to komunikat
         _can_continue:=0;
         _msg:='Nie można zaplanować obiektu: %1, ponieważ cała ilość została zrealizowana lub zarezerwowana.'@[_what];
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || KOMM.add(_msg,2,,1)
         |? _dialog=3
         || {? var_pres('_komm_args')>100
            || obj_del(_komm_args)
            ?};
            _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_ver;
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);
            ~~
         ?};
         _mp.error(_msg)
      ?}
   ?};

   {? _can_continue>0 & _mp.akcja()='DO_KOLEJKI'
   || {? _planned>=ZK_P.ILP-ZK_P.ILRB
      ||
::       Jeżeli wszystko już w kolejce to komunikat
         _can_continue:=0;
         _msg:='Nie można zaplanować obiektu: %1, ponieważ cała ilość znajduje się już w kolejce.'@[_what];
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || KOMM.add(_msg,2,,1)
         |? _dialog=3
         || _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_ver;
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);
            ~~
         ?};
         _mp.error(_msg)
      ?}
   ?}
?};
ZK_P.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\que_tab_chk_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy można dodać do kolejki ZL
::   WE: [_a] - ZL.ref lub bieżący rekord
::       _b - INTEGER - 0/1 - czy wyświetlać dialogi
::       _c - obj_new() - obiekt Menadżera Procesów
::       _d - obj_new() - parametry wyjściowe
::       _e - INTEGER - 0/1 - czy akcja grupowa
::       [_f] - PX_VER.ref() - wersja planu, jeżeli nie podane to wersja główna
::   WY: 0 - nie można
::       1 - można
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_dialog:=_b;
_mp:=_c;
_out:=_d;
_grupa:=_e;
_ver:=exec('get_mainversion','px_ver');
{? var_pres('_f')=type_of(PX_VER.ref())
|| _ver:=_f
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _what:=exec('ZL','#to_string');
   {? ZL.PL_DIR=0 & _dialog=0 & _mp.isGroup()=0
   || _can_continue:=0;
      _msg:='Nie można zaplanować zlecenia: %1 w trybie bezdialogowym, ponieważ na zleceniu nie określono zwrotu planowania.'@[_what];
      _mp.error(_msg)
   ?};
   {? ZL.PL_DATA=date(0,0,0) & _dialog=0 & _mp.isGroup()=0
   || _can_continue:=0;
      _msg:='Nie można zaplanować zlecenia: %1 w trybie bezdialogowym, ponieważ na zleceniu nie określono wewnętrznego teminu realizacji.'@[_what];
      _mp.error(_msg)
   ?};

   {? ZL.ILDOK>0 | ZL.ILWYK>0 | ZL.HWYK>0
   || _can_continue:=0;
      _msg:='Zlecenie: %1 posiada już zarejestrowane wykonania.\n'
            'Nie można dodawać do Planu strategicznego.'@[_what];
      {? _dialog=1
      || FUN.emsg(_msg)
      |? _dialog=2
      || KOMM.add(_msg,2,,1)
      |? _dialog=3
      || _komm_args:=exec('add_komm_a','px_komm');
         _komm_args.PX_VER:=_ver;
         _komm_args.TYP:=exec('type_error','px_komm');
         _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
         _komm_args.MESSAGE:=_msg;
         exec('add_komm','px_komm',_komm_args);
         ~~
      ?};
      _mp.error(_msg)
   ?};

   {? ZL.STAN='Z'
   || _can_continue:=0;
      _msg:='Nie można zaplanować zlecenia: %1 ponieważ jest zamknięte.'@[_what];
      {? _dialog=1
      || FUN.emsg(_msg)
      |? _dialog=2
      || KOMM.add(_msg,2,,1)
      |? _dialog=3
      || _komm_args:=exec('add_komm_a','px_komm');
         _komm_args.PX_VER:=_ver;
         _komm_args.TYP:=exec('type_error','px_komm');
         _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
         _komm_args.MESSAGE:=_msg;
         exec('add_komm','px_komm',_komm_args);
         ~~
      ?};
      _mp.error(_msg)
   ?};
   _top:=exec('top_level','zl_link',ZL.ref());
   _rodz_tex:=exec('FindAndGet','#table',ZL,_top,,"RODZ_TEX",'');
   _what_top:=exec('record','#to_string',_top);
   {? _top<>null() & exec('is_podzlec','zl_link',ZL.ref())>0 & _rodz_tex='Z'
   || _can_continue:=0;
      _msg:='Nie można zaplanować podzlecenia: %1 ponieważ zlecenie nadrzędne posiada przepis zintegrowany. Należy zaplanować zlecenie nadrzędne: %2'@[_what,_what_top];
      {? _dialog=1
      || FUN.emsg(_msg)
      |? _dialog=2
      || KOMM.add(_msg,2,,1)
      |? _dialog=3
      || _komm_args:=exec('add_komm_a','px_komm');
         _komm_args.PX_VER:=_ver;
         _komm_args.TYP:=exec('type_error','px_komm');
         _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
         _komm_args.MESSAGE:=_msg;
         exec('add_komm','px_komm',_komm_args);
         ~~
      ?};
      _mp.error(_msg)
   ?};
   {? ZL.RODZAJ='P' & ZL.NRNZL<>0 & ZL.RODZ_TEX='P'
   ||
::    Dla składnika zlecenia złożonego, sprawdzam czy to zlecenie złożone powstało na podstawie
::    zamówienia sprzedaży które jest w planie. Jeżeli tak, to zgłaszam error, ponieważ nie będzie się
::    dało przekształcić planu zamówienia w plan zlecenia (podrzędnego)
      {? exec('zl_from_zam_planned','px_tie',ZL.ref())>0
      ||
         _can_continue:=0;
         _msg:='Nie można zaplanować podzlecenia: %1 ponieważ zlecenie nadrzędne powstało w oparciu o zamówienie, które jest w planie. '
               'Należy zaplanować zlecenie nadrzędne: %2'@[_what,_what_top];
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || KOMM.add(_msg,2,,1)
         |? _dialog=3
         || _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_ver;
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);
            ~~
         ?};
         _mp.error(_msg)
      ?};
      ~~
   ?};
   {? ZL.RODZAJ='N' & exec('subsubzlec_exist','zl_link',ZL.ref())=0
   ||
::    Nie można wrzucić do planu zlecenia niezależnego bez podzleceń (bo tak naprawdę to planują się te podzlecenia)
      _can_continue:=0;
      _msg:='Nie można zaplanować zlecenia: %1 ponieważ jest to zlecenie niezależne, bez podzleceń.'@[_what];
      {? _dialog=1
      || FUN.emsg(_msg)
      |? _dialog=2
      || KOMM.add(_msg,2,,1)
      |? _dialog=3
      || _komm_args:=exec('add_komm_a','px_komm');
         _komm_args.PX_VER:=_ver;
         _komm_args.TYP:=exec('type_error','px_komm');
         _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
         _komm_args.MESSAGE:=_msg;
         exec('add_komm','px_komm',_komm_args);
         ~~
      ?};
      _mp.error(_msg)
   ?};

:: Sprawdzam czy zlecenie jest już w całości kolejce planu
   {? ZL.IL<>0 & exec('zl_planned','px_obj',ZL.ref(),_ver)=ZL.IL
   || {? _mp.akcja()='DO_KOLEJKI'
      ||
::       Jeżeli wszystko już w kolejce to komunikat
         _can_continue:=0;
         _msg:='Nie można zaplanować obiektu: %1, ponieważ cała ilość znajduje się już w kolejce.'@[_what];
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || KOMM.add(_msg,2,,1)
         |? _dialog=3
         || _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_ver;
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);
            ~~
         ?};
         _mp.error(_msg)
      ?}
   ?}
?};
ZL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:09:38 def18b42f4f3a2599206684e24970c12f7100f65067968f8bb22cdeda7c6e8032c47ffcaf208899b041fd1829577061f79264d2ec2102f8a5579d8a6c8e7fc787f0ccb56c57d5dd36cc51b7a35b10860497725d412486507fce550ed7a87f3d2e4e6cb2704901ef7c28c6c6e1e0695c96081c55424f9f2d7a4e1859a58594eab
