:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tte_wyk_dgrw.fml
:: Utworzony: 01.04.2016
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły czynności TTE_WYK_DGRW - Rozliczenie surowców nielimit.
::                                             (Generowanie rozliczenia dla surowców nielimitowanych)
::            UWAGA: w przypadku modyfikacji uwzględniać też czynności: TTE_WYK_DGRO, TTE_WYK_DGZW.
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Główna formuła czynności generowania rozliczenia dla surowców nielimitowanych (TTE_WYK_DGRW)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

::# permissions=ODDZ,LMG
::# parses=exec('parses','!tte_wyk_dgrw')
::# properties=SERVICE,LOOP
::# condition=Rejestracja dokumentu wydania, act_uid=LMG_MAG_DWYD, auto=T, formula=_a.ND<>~~ & _a.ND<>null()

:: PARAMETRY WE:
::# kind=WE, symbol=ZL, type=_ZL, name=Zlecenie, required=N, keyref=T
::# kind=WE, symbol=ZGP, type=_ZGP, name=Pozycja przewodnika zlecenia, required=N, keyref=T
::# kind=WE, symbol=ILOSC, type=NUMBER, name=Ilość produktu, required=N, keyref=N
::# kind=WE, symbol=ND, type=_ND, name=Dokument raportujący, required=N, keyref=T
::# kind=WE, symbol=TYPYDOK, type=_TYPYDOK, name=Typ dokumentu rozchodowego, required=N, keyref=N, fml_val="exec('typ_dok','!tte_wyk_dgrw')", fml_exp="exec('typydok_export','magdok_nag',_a)"
::# kind=WE, symbol=GEN_DOK, type=STRING, name=Generacja dokumentów, required=N
::# kind=WE, symbol=TYPROZ, type=NUMBER, name=Sposób rozliczenia surowców, required=N
::# kind=WE, symbol=GROP, type=_GROP, name=Grupa operacji, required=N, keyref=T
{? var_pres('ZL',_in)<>type_of(~~) & var_pres('ZL',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','ZL']);
   return()
|? _in.ZL=~~
|| _in.ZL:=null()
?};
{? var_pres('ZGP',_in)<>type_of(~~) & var_pres('ZGP',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','ZGP']);
   return()
|? _in.ZGP=~~
|| _in.ZGP:=null()
?};
{? var_pres('ILOSC',_in)<>type_of(~~) & var_pres('ILOSC',_in)<>type_of(0)
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','ILOSC']);
   return()
|? _in.ILOSC=~~
|| _in.ILOSC:=0
?};
{? var_pres('ND',_in)<>type_of(~~) & var_pres('ND',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','ND']);
   return()
|? _in.ND=~~
|| {? _mp.akcja()='GENERUJ'
   || _in.ND:=_context.ND
   || _in.ND:=null()
   ?}
?};
{? var_pres('TYPYDOK',_in)<>type_of(~~) & var_pres('TYPYDOK',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','TYPYDOK']);
   return()
|? _in.TYPYDOK=~~
|| _in.TYPYDOK:=null()
?};
{? var_pres('GEN_DOK',_in)<>type_of(~~) & var_pres('GEN_DOK',_in)<>type_of('')
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejsciowego %2).'@['TTE_WYK_DGRW','GEN_DOK']);
   return()
|? _in.GEN_DOK=~~
|| _in.GEN_DOK:=''
?};
{? var_pres('TYPROZ',_in)<>type_of(~~) & var_pres('TYPROZ',_in)<>type_of(0)
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','TYPROZ']);
   return()
|? _in.TYPROZ=~~
|| _in.TYPROZ:=0
?};
{? var_pres('GROP',_in)<>type_of(~~) & var_pres('GROP',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','GROP']);
   return()
|? _in.GROP=~~
|| _in.GROP:=null()
?};

:: PARAMETRY WEW:
::# kind=WEW, symbol=ND, type=_ND, name=Dokument rozchodowy, required=N
{? var_pres('ND',_int)<>type_of(~~) & var_pres('ND',_int)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wewnętrznego %2).'@['TTE_WYK_DGRW','ND']);
   return()
|? _int.ND=~~
|| _int.ND:=null()
?};

:: PARAMETRY WY:
::# kind=WY, symbol=ZL, type=_ZL, name=Zlecenie, required=N
::# kind=WY, symbol=ND, type=_ND, name=Dokument rozchodowy, required=N
::# kind=WY, symbol=GEN_DOK, type=STRING, name=Generacja dokumentów, required=N
::# kind=WY, symbol=RESULT, type=STRING, name="Wynik czynności (OK, BŁĄD)", required=N

:: Ustawiam wartość domyślną argumentu LOOP żeby brama się nie zawiesiła
_mp.save(exec('kind_out','#b_port'),'LOOP','N');

:: Czy komunikaty walidacji na ekran
_display:={? _mp.isService() || 0 || 1 ?};

:: WSTĘPNE WALIDACJE
_clean_result:=params_exec('clean','!tte_wyk_dgrw',_mp,_in);
_can_continue:=_clean_result.RESULT;
_zl:=_clean_result.ZL;
{? _can_continue=0
|| return()
?};

:: Zlecenie musi być produkcyjne
{? _in.ZL<>null() & exec('FindAndGet','#table',ZL,_in.ZL,,"TYP().WP='W'",1)
|| _msg:='Błędna konfiguracja procesu — zlecenie nie może być warsztatowe.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};
:: Musi być conajmniej jeden parametr przekazany (chyba, że jest już coś wygenerowane, czyli _int.ND<>null())
:: (chyba, że uruchomienie jako czynność startowa z pulpitu)
{? _in.ND=null() & _in.ZGP=null() & _in.ZL=null() & _in.GROP=null() & _in.GEN_DOK='' & _int.ND=null() & ~_mp.pathProc()
|| _msg:='Błędna konfiguracja procesu — brak parametru wejściowego (musi być określony %1, %2, %3 albo %4).'@@
         ['ND','ZGP','GROP','GEN_DOK'];
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};
:: Nie może być jednocześnie pozycja przewodnika i dokument
{? _in.ND<>null() & _in.ZGP<>null()
|| _msg:='Błędna konfiguracja procesu — nie może być przekazany jednocześnie dokument raportujący i pozycja przewodnika.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};
:: Nie może być jednocześnie grupa operacji i dokument
{? _in.ND<>null() & _in.GROP<>null()
|| _msg:='Błędna konfiguracja procesu — nie może być przekazany jednocześnie dokument raportujący i grupa operacji.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};

:: Walidacja typu dokumentu
{? _in.TYPYDOK
|| _in_typ:=exec('FindAndGet','#table',TYPYDOK,_in.TYPYDOK,,"T",'');
   {? (' '+exec('get','#params',500707,2))*(' '+_in_typ+' ')=0
   || _msg:='Błędna konfiguracja procesu — przekazany typ dokumentu %1 nie jest wskazany w parametrze %2.'@@
            [_in_typ,'500707'];
      {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
      _mp.error(_msg);
      return()
   ?}
?};
:: Walidacja dokumentu
_nd_zl:=exec('FindAndGet','#table',ND,_in.ND,,"ZL",null());
{? _in.ND
|| {? _nd_zl=null()
   || _msg:='Błędna konfiguracja procesu — przekazany dokument nie jest powiązany ze zleceniem.'@@;
      {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
      _mp.error(_msg);
      return()
   ?}
?};
:: Zgodność dokumentu ze zleceniem
{? _in.ZL<>null() & _in.ND<>null() & _in.ZL<>_nd_zl
|| _msg:='Błędna konfiguracja procesu — przekazany dokument dotyczy innego zlecenia niż przekazane.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
|? _in.ZL=null()
|| _in.ZL:=_nd_zl
?};
:: Zgodność pozycji przewodnika ze zleceniem
_zgp_zl:=exec('FindAndGet','#table',ZGP,_in.ZGP,,"ZL",null());
{? _in.ZL<>null() & _in.ZGP<>null() & _in.ZL<>_zgp_zl
|| _msg:='Błędna konfiguracja procesu — przekazana pozycja przewodnika dotyczy innego zlecenia niż przekazane.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
|? _in.ZL=null()
|| _in.ZL:=_zgp_zl
?};
:: Czynność w trybie usługi musi dotyczyć konkretnego dokumentu raportującego albo przewodnika
{? _mp.isService() & ~_in.ND & ~_in.ZGP & _in.GEN_DOK=''
|| _msg:='Błędna konfiguracja procesu — nie przekazano dokumentu ani przewodnika.'@@;
   _mp.error(_msg);
   return()
?};

_mp.keyRef(exec('FindAndGet','#table',ZL,_in.ZL,,"uidref()",''));

_zl_sym:=exec('FindAndGet','#table',ZL,_in.ZL,,"SYM",'');

:: Przekazany parametr _int.ND, czyli powstały już dokumenty raportujące, ale czynność się nie zakończyła
:: (np. zamknięcie programu "krzyzykiem")
{? _mp.loop()=0 & _int.ND
|| _gen_dok:=exec('FindAndGet','#table',ND,_int.ND,,"GRP_KEY",'');
:: Zapisanie parametru wyjściowego ND, wykluczenie kolejnej realizacji z pętli, zakończenie czynności
   {? _gen_dok<>''
   ||
      ND.cntx_psh();
      ND.prefix();
      _grp_key:=_gen_dok-1;
      _grp_key_on:=_grp_key+'1';
      _grp_key_off:=_grp_key+'0';
      {? _grp_key<>''
      || ND.index('GRP_KEY');
         ND.prefix(_grp_key_on);
         {? ND.first()
         || ND.cntx_psh();
            ND.prefix();
            ND.GRP_KEY:=_grp_key_off;
            do();
            ND.put();
            _mp.save(exec('kind_out','#b_port'),'ND',ND.ref());
            _mp.save(exec('kind_out','#b_port'),'GEN_DOK',_gen_dok);
            _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
            end();
            ND.cntx_pop();
::          kontynuacja pętli
            {? ND.first()
            || _mp.loop_continue()
            ?}
         ?}
      ?};
      ND.cntx_pop();
      _mp.done()
   ?}

:: Przekazany tylko parametr _in.ZL, wejście z ToDo, czyli wyświetlenie panela do rozliczania
|? _in.ZL & ~_in.ND & ~_in.ZGP & ~_in.GROP & _mp.pathTodo()
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_in.ZL)
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI');
      {? ZL.STAN<>'O'
      || FUN.emsg('Zlecenie do rozliczenia musi być otwarte.'@)
      || KOMM.init(,,'Rozliczenie surowców'@);
         exec('find_nd','zl_nlimit');
         exec('select_gen','zl_limit')
      ?};
      VAR_DEL.delete('__ENV_GEN')
   ?};
   ZL.cntx_pop()

:: Przekazany tylko parametr _in.GROP, wejście z ToDo, czyli wyświetlenie panela do rozliczania
|? ~_in.ZL & ~_in.ND & ~_in.ZGP & _in.GROP & _mp.pathTodo()
|| GROP.cntx_psh();
   GROP.prefix();
   {? GROP.seek(_in.GROP)
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI_GROP');
      {? GROP.AKC<>'T' | GROP.STATUS<>'O'
      || FUN.emsg('Grupa operacji do rozliczenia musi być zaakceptowana i otwarta.'@)
      || KOMM.init(,,'Rozliczenie surowców'@);
         exec('find_zlgd','zl_grop');
         exec('select_gen_zlgd','zl_limit')
      ?};
      VAR_DEL.delete('__ENV_GEN')
   ?};
   GROP.cntx_pop()

:: Przekazany parametr _in.ND, czyli generowanie dokumentów rozliczających do dokumentu raportującego
:: Przekazany parametr _in.ZGP, czyli generowanie dokumentów rozliczających do pozycji przewodnika
:: Przekazany parametr _in.GROP, czyli generowanie dokumentów rozliczających do grupy operacji
:: Kolejny obrót pętli generatora, czyli wypychanie wygenerowanych dokumentów
|? _in.ND | _in.ZGP | _in.GROP | _in.ZL | _mp.loop()>0
||
:: Wyzwalacz, który po dodaniu/aktualizacji/usunięciu nagłówka dokumentu rozliczającego
:: dodaje/usuwa/aktualizuje parametr wewnętrzny _int.ND (aktualizacja nie dotyczy dokumentu źródłowego)
   _nd_uid:=exec('FindAndGet','#table',ND,_in.ND,,"uidref()",'');
   _mp.trigRef('ND',,1,,exec('kind_internal','#b_port'),'ND',,$('ND.uidref()<>\''+_nd_uid+'\''));

   _continue:=0;
   _gen_dok:='';
   _typydok:={? var_pres('TYPYDOK',_in)=type_of(null()) || _in.TYPYDOK || null() ?};

:: pierwsze wywołanie dla dokumentu raportującego
   {? _mp.loop()=0 & _in.ND
   ||
      ND.cntx_psh();
      _jest:=ND.seek(_in.ND);
      {? ~_jest || ND.prefix(); _jest:=ND.seek(_in.ND) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono dokumentu raportującego.')
      |? _jest & ND.STAT_REJ<>'T'
      || _msg:='Dokument raportujący %1 nie został zaakceptowany'@[ND.SYM];
         {? _mp.isGroup() || KOMM.add(_msg) || FUN.info(_msg) ?};
         _continue:=-1
      |? _jest & exec('rozliczone','zl_limit',ND.ref(),'N')
      || _msg:='Do dokumentu raportującego %1 zostały już wystawione dokumenty rozliczające.'@[ND.SYM];
         {? _mp.isGroup() || KOMM.add(_msg) || FUN.info(_msg) ?};
         _continue:=-2
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}

         |? _mp.isAutoRun()
            | _mp.isService()
            | _mp.pathTodo()
         ||
            KOMM.init(250,,'Generowanie rozliczenia surowców'@);

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            ||
::              Jeżeli jest typ domyślny lub tylko 1 typ dokumentu RW to go pobiera, w innym przypadku wyświetla listę
               _in.TYPYDOK:=exec('Get_TYPYDOK','magdok_wspolne','NLI');
               {? _in.TYPYDOK=null
               || _in.TYPYDOK:=exec('typ_dok','!tte_wyk_dgrw')
               ?}
            ?};

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            || _continue:=-1
            ||
               do();
               DK.cntx_psh();
               _tm_stamp:=exec('utwdok','zl_nlimit',_in.TYPYDOK,'NLI',_in.TYPROZ);
               {? _tm_stamp='' || undo() ?};
               DK.cntx_pop();
               end();

               {? _tm_stamp='y'
               || _continue:=-3
               || _internal:=_mp.load(exec('kind_internal','#b_port'));
                  _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
                  {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
               ?}
            ?};

            {? _mp.isAutoRun() || {? _continue<>1 || KOMM.select() ?}
            |? _mp.pathTodo() || KOMM.select()
            ?}

         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW/ND'])
         ?}
      ?};
      ND.cntx_pop()

:: pierwsze wywołanie dla pozycji przewodnika
   |? _mp.loop()=0 & _in.ZGP
   ||
      ZGP.cntx_psh();
      _jest:=ZGP.seek(_in.ZGP);
      {? ~_jest || ZGP.prefix(); _jest:=ZGP.seek(_in.ZGP) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono pozycji przewodnika.'@@)
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}
         |? _mp.isAutoRun()
            | _mp.isService()
            | _mp.pathTodo()
         ||
            KOMM.init(250,,'Generowanie rozliczenia surowców'@);

::            {? _in.ILOSC=0
::            ||
::             Czynność się kończy mimo braku ilości - żaden dokument nie jest generowany
::               KOMM.add('Nie podano ilości. Dokumenty nie zostały utworzone.'@,4,,1);
::               _mp.done()
::            ||
            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            ||
::             Jeżeli jest typ domyślny lub tylko 1 typ dokumentu RW to go pobiera, w innym przypadku wyświetla listę
               _in.TYPYDOK:=exec('Get_TYPYDOK','magdok_wspolne','NLI');
               {? _in.TYPYDOK=null
               || _in.TYPYDOK:=exec('typ_dok','!tte_wyk_dgrw')
               ?}
            ?};

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            || _continue:=-1
            ||
               _ZLIM:='';
               _ok:=1;
               {? ~_mp.isAutoRun() & ~_mp.isService()
               || _ZLIM:=exec('kart_lim','zl_limit',9,ZGP.ZL,'N',,ZGP.ref(),,'T');
                  {? _in.TYPROZ
                  || _ndx:=_ZLIM.ndx_tmp(,,'ROZ',,);
                     _ZLIM.index(_ndx);
                     _ZLIM.prefix('T')
                  || _ZLIM.prefix()
                  ?};
                  {? _ZLIM.size()>0
                  ||
                     _form:="
                        _tab:=cur_tab(1,1);
                        _res:=_tab.MAG;
                        MG.cntx_psh();
                        MG.win_sel('SLO');
                        MG.index('MAG');
                        MG.prefix();
                        {? MG.first()
                        ||
                           {? MG.select(,,10)
                           ||
                              _tab.MAG_REF:=#MG.ref;
                              _res:=_tab.MAG:=MG.SYM;
                              _tab.put()
                           ?}
                        ||
                           FUN.info('Nie odnaleziono żadnych magazynów.'@)
                        ?};
                        MG.cntx_pop();
                        _res
                     ";

                     _bf:=_ZLIM.fld_fml('MAG','F3',_form);
                     _wer:=exec('__ZLIM_wer','!tte_wyk_dgrw',_ZLIM);
                     _ZLIM.win_sel(_wer);
                     {? ~_ZLIM.select()
                     || _ok:=0;
                        _continue:=-1
                     ?};
                     _ZLIM.fld_fml('MAG','F3',_bf)
                  ?}
               ?};
               {? _ok
               ||
                  do();
                  DK.cntx_psh();
                  _tm_stamp:='';
                  _tm_stamp:=exec('utwdok_zgp','!tte_wyk_dgrw',_in.TYPYDOK,ZGP.ref(),_in.ILOSC,_in.TYPROZ,_ZLIM);
                  {? _tm_stamp='' || undo() ?};
                  DK.cntx_pop();
                  end();

                  {? _tm_stamp='y'
                  || _continue:=-3
                  || _internal:=_mp.load(exec('kind_internal','#b_port'));
                     _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
                     {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
                  ?};
::            ?};

                  {? _mp.pathTodo() | _mp.isAutoRun() & _continue<>1 || KOMM.select() ?};
::                Czynność zawsze się kończy, bez względu na ilość/jakość wygenerowanych dokumentów
                  _mp.done()
               ?}
            ?}

         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW/ZGP'])
         ?}
      ?};
      ZGP.cntx_pop()

:: pierwsze wywołanie dla grupy operacji
   |? _mp.loop()=0 & _in.GROP
   ||
      GROP.cntx_psh();
      _jest:=GROP.seek(_in.GROP);
      {? ~_jest || GROP.prefix(); _jest:=GROP.seek(_in.GROP) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono grupy operacji.'@@)
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}
         |? 0
::            _mp.isAutoRun()
::            | _mp.isService()
::            | _mp.pathTodo()
         ||
            KOMM.init(250,,'Generowanie rozliczenia surowców'@);

::            {? _in.ILOSC=0
::            ||
::             Czynność się kończy mimo braku ilości - żaden dokument nie jest generowany
::               KOMM.add('Nie podano ilości. Dokumenty nie zostały utworzone.'@,4,,1);
::               _mp.done()
::            ||
            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            ||
::             Jeżeli jest typ domyślny lub tylko 1 typ dokumentu RW to go pobiera, w innym przypadku wyświetla listę
               _in.TYPYDOK:=exec('Get_TYPYDOK','magdok_wspolne','NLI');
               {? _in.TYPYDOK=null
               || _in.TYPYDOK:=exec('typ_dok','!tte_wyk_dgrw')
               ?}
            ?};

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            || _continue:=-1
            ||
               _ZLIM:='';
               _ok:=1;
               {? ~_mp.isAutoRun() & ~_mp.isService()
               || _ZLIM:=exec('kart_lim','zl_limit',9,,'N',,null(),,'T',,GROP.ref());
                  {? _in.TYPROZ
                  || _ndx:=_ZLIM.ndx_tmp(,,'ROZ',,);
                     _ZLIM.index(_ndx);
                     _ZLIM.prefix('T')
                  || _ZLIM.prefix()
                  ?};
                  {? _ZLIM.size()>0
                  ||
                     _form:="
                        _tab:=cur_tab(1,1);
                        _res:=_tab.MAG;
                        MG.cntx_psh();
                        MG.win_sel('SLO');
                        MG.index('MAG');
                        MG.prefix();
                        {? MG.first()
                        ||
                           {? MG.select(,,10)
                           ||
                              _tab.MAG_REF:=#MG.ref;
                              _res:=_tab.MAG:=MG.SYM;
                              _tab.put()
                           ?}
                        ||
                           FUN.info('Nie odnaleziono żadnych magazynów.'@)
                        ?};
                        MG.cntx_pop();
                        _res
                     ";

                     _bf:=_ZLIM.fld_fml('MAG','F3',_form);
                     _wer:=exec('__ZLIM_wer','!tte_wyk_dgrw',_ZLIM);
                     _ZLIM.win_sel(_wer);
                     {? ~_ZLIM.select()
                     || _ok:=0;
                        _continue:=-1
                     ?};
                     _ZLIM.fld_fml('MAG','F3',_bf)
                  ?}
               ?};
               {? _ok
               ||
                  do();
                  DK.cntx_psh();
                  _tm_stamp:='';
                  _tm_stamp:=exec('utwdok_zgp','!tte_wyk_dgrw',_in.TYPYDOK,ZGP.ref(),_in.ILOSC,_in.TYPROZ,_ZLIM);
                  {? _tm_stamp='' || undo() ?};
                  DK.cntx_pop();
                  end();

                  {? _tm_stamp='y'
                  || _continue:=-3
                  || _internal:=_mp.load(exec('kind_internal','#b_port'));
                     _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
                     {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
                  ?};
::            ?};

                  {? _mp.pathTodo() | _mp.isAutoRun() & _continue<>1 || KOMM.select() ?};
::                Czynność zawsze się kończy, bez względu na ilość/jakość wygenerowanych dokumentów
                  _mp.done()
               ?}
            ?}

         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW/GROP'])
         ?}
      ?};
      GROP.cntx_pop()

:: pierwsze wywołanie dla zlecenia
   |? _mp.loop()=0 & _in.ZL
   ||
      ZL.cntx_psh();
      _jest:=ZL.seek(_in.ZL);
      {? ~_jest || ZL.prefix(); _jest:=ZL.seek(_in.ZL) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono zlecenia.'@@)
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}
         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW/ZL'])
         ?}
      ?};
      ZL.cntx_pop()

:: wywołanie w pętli
   || _continue:=_in.GEN_DOK<>'';
      {? _continue || _gen_dok:=_in.GEN_DOK ?}
   ?};

:: Wycofano się z wystawiania dokumentów
   {? _continue=-1
   || {? _mp.isService()
      || _mp.save(exec('kind_out','#b_port'),'RESULT','BŁĄD');
         _mp.done()
      || _mp.cancel()
      ?}

:: Dokumenty rozliczające już wcześniej wystawione
   |? _continue=-2
   || {? _mp.isService()
      || _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
         _mp.done()
      || _mp.done()
      ?}

:: Nie potrzeba generować dokumentów (brak surowców nielimitowanych w definicji zlecenia / grupy operacji)
   |? _continue=-3
   || {? _mp.isService()
      || _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
         _mp.done()
      || _mp.done()
      ?}

:: Zapisanie parametru wyjściowego ND, wykluczenie kolejnej realizacji z pętli, zakończenie czynności
   |? _continue=1 & _gen_dok<>''
   ||
      ND.cntx_psh();
      ND.prefix();
      _grp_key:=_gen_dok-1;
      _grp_key_on:=_grp_key+'1';
      _grp_key_off:=_grp_key+'0';
      {? _grp_key<>''
      || ND.index('GRP_KEY');
         ND.prefix(_grp_key_on);
         {? ND.first()
         || ND.cntx_psh();
            ND.prefix();
            ND.GRP_KEY:=_grp_key_off;
            do();
            ND.put();
            _mp.save(exec('kind_out','#b_port'),'ND',ND.ref());
            _mp.save(exec('kind_out','#b_port'),'GEN_DOK',_gen_dok);
            _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
            end();
            ND.cntx_pop();
::          kontynuacja pętli
            {? ND.first()
            || _mp.loop_continue()
            ?}
         ?}
      ?};
      ND.cntx_pop();
      _mp.done()

   || _mp.error('Brak oczekiwanego parametru %1.'@@['GEN_DOK'])
   ?}

:: Uruchomienie ze startu procesów - tylko dla zleceń
|? _mp.pathProc()
|| ZL.cntx_psh();
   ZL.clear();
   _join:='join ZTP left join ZL as ZLNAD using(ZL.NRNZL,ZLNAD.UNRZL)';
   _where:=
      'ZL.STAN=''O'' and '
      'ZTP.WP=''P'' and '
      'ZL.RODZAJ=''P'' and '
      '(ZL.LEVEL=0 or ZL.LEVEL=1) and '
      '(ZL.NRNZL=0 or ZL.NR=1 or ZLNAD.RODZAJ=''N'') and '
      'ZL.ILDOK>0';
   ZL.f_set('SYM',_join,_where);
   exec('icons_slo_sl','zl_head');
   ZL.win_sel('SLO_SL');
   ZL.actions('SLO_SL','XY','W');
   {? ZL.select()
   || exec('action_rw_generate','!tte_wyk_dgrw')
   ?};
   ZL.cntx_pop()

|| _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW'])
?};
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opis dla czynności generowania rozliczenia surowców nielimitowanych (TTE_WYK_DGRW)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: zwraca opis Zadania
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_keyRefs:=_mp.getRefs();
_in:=_mp.load(exec('kind_in','#b_port'));
_int:=_mp.load(exec('kind_internal','#b_port'));

_desc:='';
_zl:=null();
_nd:=null();
_nd_int:=null();
_zgp:={? var_pres('ZGP',_in)=type_of(null()) || _in.ZGP || null() ?};
_grop:=null();

:: sprawdzam czy jest rekord kluczowy, jak jest to ustawiam odpowiedniego ZL albo GROP
{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];
      {? type_of(_kref)>0
      ||
         {? ref_name(_kref)=ZL.name()
         || _zl:=exec('FindAndGet','#table',ZL,_kref,,,null())
         |? ref_name(_kref)=GROP.name()
         || _grop:=exec('FindAndGet','#table',GROP,_kref,,,null())
         ?}
      ?}
   !}
?};

:: jest parametr wejściowy ZL
{? _zl=null() & var_pres('ZL',_in)=type_of(null())
|| _zl:=_in.ZL
?};

:: jest parametr wejściowy GROP
{? _grop=null() & var_pres('GROP',_in)=type_of(null())
|| _grop:=_in.GROP
?};

:: jest parametr wejściowy to ustawiam odpowiedniego ND
{? var_pres('ND',_in)=type_of(null())
|| _nd:=_in.ND
?};

:: jest parametr wewnętrzny to ustawiam odpowiedniego ND
{? var_pres('ND',_int)=type_of(null())
|| _nd_int:=_int.ND
?};

_desc:='';
{? _nd_int<>null()
|| {? _zgp<>null()
   || _desc:='Zakończ rozliczenie surowców do pozycji przewodnika %1'@@
             [exec('record','#to_string',_zgp)]
   |? _grop<>null()
   || _desc:='Zakończ rozliczenie surowców do grupy operacji %1'@@
             [exec('record','#to_string',_grop)]
   |? _zl<>null() & _nd<>null()
   || _desc:='Zakończ rozliczenie surowców do dokumentu %1 (zlecenie %2)'@@
             [exec('record','#to_string',_nd),exec('record','#to_string',_zl)]
   |? _zl<>null() & _nd=null()
   || _desc:='Zakończ rozliczenie surowców do zlecenia %1'@@
             [exec('record','#to_string',_zl)]
   |? _zl=null() & _nd<>null()
   || _zl_nd:=exec('FindAndGet','#table',ND,_nd,,"ZL",null());
      _desc:='Zakończ rozliczenie surowców do dokumentu %1 (zlecenie %2)'@@
             [exec('record','#to_string',_nd),
              exec('record','#to_string',_zl_nd)
             ]
   || _desc:='Zakończ rozliczenie surowców'@@
   ?}
|| {? _zgp<>null()
   || _desc:='Wygeneruj rozliczenie surowców do pozycji przewodnika %1'@@
             [exec('record','#to_string',_zgp)]
   |? _grop<>null()
   || _desc:='Wygeneruj rozliczenie surowców do grupy operacji %1'@@
             [exec('record','#to_string',_grop)]
   |? _zl<>null() & _nd<>null()
   || _desc:='Wygeneruj rozliczenie surowców do dokumentu %1 (zlecenie %2)'@@
             [exec('record','#to_string',_nd),exec('record','#to_string',_zl)]
   |? _zl<>null() & _nd=null()
   || _desc:='Wygeneruj rozliczenie surowców do zlecenia %1'@@
             [exec('record','#to_string',_zl)]
   |? _zl=null() & _nd<>null()
   || exec('FindAndGet','#table',ND,_nd,,"ZL",null());
      _desc:='Wygeneruj rozliczenie surowców do dokumentu %1 (zlecenie %2)'@@
             [exec('record','#to_string',_nd),
              exec('record','#to_string',_zl_nd)
             ]
   || _desc:='Wygeneruj rozliczenie surowców'@@
   ?}
?};
_desc


\action_rw_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyświetla panel rozliczania surowców nielimitowanych dla zleceń
::   WE: _a - STRING - Kontekst wywołania:
::                 [0] - rozliczane dla RP
::                  1  - rozliczane dla rejestracji wykonań
::      [_b] - czy tylko uzupełnić tabelę (bez powoływania środowiska i wyświetlania wyniku): 1 - tak, [0] - nie
::----------------------------------------------------------------------------------------------------------------------
_typ:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_fill_only:={? var_pres('_b')=type_of(0) || _b || 0 ?};
{? ~_fill_only & ZL.sel_size()=0
|| _f500707:=exec('get','#params',500707,2);
   {? _f500707=''
   || FUN.emsg('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500707']);
      return()
   ?};
   VAR_DEL.delete('__ENV_GEN');
   {? _typ=0
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI')
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI_ZLGD')
   ?}
?};
{? ZL.STAN<>'O'
|| {? ~_fill_only || {? ZL.sel_size()=0 || FUN.emsg('Zlecenie do rozliczenia musi być otwarte.'@) ?} ?}
|| {? ~_fill_only
   || {? ZL.sel_size()=0
      || KOMM.init(,,'Rozliczenie surowców'@)
      ?}
   ?};
   {? _typ=0
   || exec('find_nd','zl_nlimit')
   || exec('find_zlgd','zl_wyk')
   ?};
   {? ~_fill_only & ZL.sel_size()=0
   || {? _typ=0
      || exec('select_gen','zl_limit')
      || exec('select_gen_zlgd','zl_limit')
      ?};
      VAR_DEL.delete('__ENV_GEN')
   ?}
?};
~~


\action_rw_generate_group_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed akcją grupową - obsługa panela rozliczania surowców nielimitowanych
::   WE: _a - STRING - Kontekst wywołania:
::                 [0] - rozliczane dla RP
::                  1  - rozliczane dla rejestracji wykonań
::----------------------------------------------------------------------------------------------------------------------
_typ:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_f500707:=exec('get','#params',500707,2);
{? _f500707=''
|| FUN.emsg('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500707']);
   0
|| KOMM.init(,,'Rozliczenie surowców'@);
   VAR_DEL.delete('__ENV_GEN');
   {? _typ=0
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI')
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI_ZLGD')
   ?};
   1
?}


\action_rw_generate_group_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Po akcji grupowej - obsługa panela rozliczania surowców nielimitowanych
::   WE: _a - STRING - Kontekst wywołania:
::                      [0] - rozliczane dla RP
::                       1  - rozliczane dla rejestracji wykonań
::----------------------------------------------------------------------------------------------------------------------
_typ:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? _typ=0
|| exec('select_gen','zl_limit')
|| exec('select_gen_zlgd','zl_limit')
?};
VAR_DEL.delete('__ENV_GEN');
~~


\typ_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Selekcja typów dokumentów magazynowych (dla parametru wejściowego czynności oraz wyboru typu w czynności)
::----------------------------------------------------------------------------------------------------------------------
_TypDok:=exec('get','#params',500707,2);
{? _TypDok<>''
|| _Typdok:=gsub(form(_TypDok),' ','\',\'');
   _TypDok:='\''+_Typdok+'\'';
   _warunek:='"TYPYDOK".T in ('+_TypDok+') '
|| _warunek:='0=1'
?};
exec('typ_dok','lmg',_warunek,,,0,0,
   'Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500707'],,,,-1
)


\utwdok_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Tworzy dokumenty rozchodowe dla surowców nielimitowanych zlecenia.
::       Powstaje tyle dokumentów ile jest różnych magazynów zdefiniowanych na nielimitach.
::       Dotyczy automatycznego generowania dokumentów rozchodowych w czynności TTE_WYK_DGRW.
::       Formuła działa w kontekście pozycji przewodnika zlecenia
::       UWAGA: Formuła na podstawie utwdok/zl_limit.fml (w razie poprawek modyfikować obie)
::   WE: _a - TYPYDOK.ref() - jeżeli nie określony, to wg pametrów 500707 i 500708
::       _b - ZGP.ref()
::       _c - Ilość produktu
::       [_d] - NUMBER - Czy uwzględniać tylko surowce oznaczone jako "rozliczane z operacją":
::            1 - tak, [0] - nie (uwzględniać wszystkie surowce)
::       [_e] - tabela ze zmodyfikowaną rozpiską surowców, wynik formuły exec('kart_lim','zl_nlimit')
::   WY: STRING[15] - tm_stamp którym zostały osteplowane utworzone dokumenty rozliczające
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null()) & _a<>null()
|| _typydok:=_a
|| _typydok:=exec('Get_TYPYDOK','magdok_wspolne','NLI')
?};

{? _typydok=null()
|| _msg:='Brak możliwości określenia typu dokumentu rozchodowego na zlecenie (parametry %1, %2). '
         'Dokument rozchodujący surowce nielimitowane nie został utworzony.'@['500707','500708'];
   KOMM.add(_msg,7,,1);
   return('')
?};

_mrdok:=exec('FindAndGet','#table',TYPYDOK,_typydok,,"T",'');

_zgp:=_b;
_ilosc:=_c;
_typ:={? var_pres('_d')=type_of(0) || _d || 0 ?};

_result:='';
_ok:=1;
_first:=1;
_lim:=0;
_ref:=-1;

_mags:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'REF','STRING[16]','Sql ref magazynu',
   'SYM','STRING[10]','Symbol magazynu',
   'NAZ','STRING[60]','Nazwa magazynu',
   'TYP','STRING[8]' ,'Typ magazynu',
   'SL','STRING[1]','Czy magazyn z lokalizacjmi'
);

:: Tabele przechowująca ilość zarazerwowaną dla konkretnych dostaw
:: Wykorzystywna w przypadku rozliczania nielimitów z przypisaną dostawą
{? var_pres('_tab_rez')>100 || obj_del(_tab_rez) ?};
_tab_rez:=exec('tab_rez_create','zl_nlimit');
_ndx1:=_tab_rez.index('?');
_ndx2:=_tab_rez.ndx_tmp(,,'TYP',,,'ZLREF',,,'MREF',,,'ZLIM',,,'REF',,);
_ndx3:=_tab_rez.ndx_tmp(,,'SCEAN',,,'TYP',,1);
_ndx4:=_tab_rez.ndx_tmp(,,'SRDK',,,'TYP',,1);

:: Tabela przechowująca refy pozycji dokumentów utworzonych na podstawie dedykowanych rezerwacji do nielimitów
{? var_pres('_dk_rez')>100 || obj_del(_dk_rez) ?};
_dk_rez:=tab_tmp(1,
   'REF','STRING[16]','Ref pozycji $DK.ref()'
);
_kodmsk:='';

_can_continue:=1;
_tm_stamp:=tm_stamp();
_ilosc_nd:=0;

REZ.cntx_psh();
_rez_mask:=(REZ.name()-2)+'__';
{? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
REZ.clear();
ZGP.cntx_psh();
ZGP.prefix();
{? ZGP.seek(_zgp)
|| _zl:=ZGP.ZL;
   _wyd:=ZGP.PFAZ().WYD;
   _data:=date();
   _dalej:=1;
   {? _zl<>null()
   || ZL.cntx_psh();
      ZLIM.cntx_psh();
      VAR.cntx_psh();
      VAR.A_ZLEC:=_zl;
      exec('openmask','zl_common',VAR.A_ZLEC);
      exec('s_nlim','zl_common');

::    Surowce nielimitowane do ZGP, jeżeli jest rozpiska wypełniona przez użytkownika to przypisuje ją
      _ZLIM:={? var_pres('_e')>100
             || _e
             || exec('kart_lim','zl_limit',9,VAR.A_ZLEC,'N',,ZGP.ref(),,'T')
             ?};
      {? _typ
      || _ndx:=_ZLIM.ndx_tmp(,,'ROZ',,);
         _ZLIM.index(_ndx);
         _ZLIM.prefix('T')
      || _ZLIM.prefix()
      ?};

::    1. Zbieram liste magazynów - to mi określi ile nagłówków dokumentów należy utworzyć
      MG.cntx_psh(); MG.clear();
      M.cntx_psh();
      _mags.clear();
      _deleted:=1;
      {? _mags.first()
      || {!
         |? _deleted:=_mags.del(,1);
            _mags.first() & _deleted>0
         !}
      ?};

      {? _ZLIM.first()
      || {!
         |?
::          Podczytuję ZLIMa
            ZLIM.prefix();
            {? ZLIM.seek(_ZLIM.REF)
            || _mg:=exec('FindAndGet','#table',MG,_ZLIM.MAG_REF,'mag_s',"ref()",null);
               {? _mg<>null & MG.seek(_mg)
               ||
::                Podczytuję magazyn
::                  ZLIM.MG();

::                Sprawdzam czy jest dostępny stan magazynowy dla podanej pozycji
                  _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
                  _stan:=0;

                  {? ZLIM.ROZ='T'
                  ||
::                   Jeżeli jest rozpiska wygenerowana po rejestracji operacji to wyciągam z niej dane
                     {? _ZLIM.IL<>0
                     || {? var_pres('_sctab')>100 || obj_del(_sctab) ?};
                        {? _ZLIM.RSC<>''
                        || {? _ZLIM.KODPAL<>''
                           || _sctab:=exec('sc_tmp_scean','magazyn_stan',null(),,,,_ZLIM.RSC)
                           || _sctab:=exec('sc_tmp_scean','magazyn_stan',null(),_ZLIM.SCEAN)
                           ?};
                           _sctab.prefix()
                        || _sctab:=~~
                        ?};
                        _zgp:=exec('FindAndGet','#table','ZGP',_ZLIM.ZGP_REF,'zguidep',,null());
                        _zl:=exec('FindAndGet','#table','ZL',_ZLIM.ZL_REF,'zlec_akt',,null());
                        _ktm:=exec('FindAndGet','#table','M',_ZLIM.M_REF,'material',,null());
                        _stan+=exec('rej_mat_chk_stan','zl_common',_zgp,_ZLIM.REF,$_mg,$_zl,_ZLIM.RSC,_ZLIM.EANL
                                                             ,'ZGP','N',1,_sctab,_tab_rez,,,_ZLIM.KODPAL);
                        _il:={? _dokl>0
                             || (_ZLIM.IL)$ _dokl
                             || ceil(_ZLIM.IL)
                             ?}
                     ||
::                       Surowiec rozliczany z operacją a nie ma rozpisanej ilości, nie generuje dokumentu
                        _can_continue:=0
                     ?}
                  || {? ZLIM.DK_C<>null()
                     || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,MG.ref(),,,_data,-2,,,,ZLIM.DK_C)
                     || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,MG.ref(),,,_data,-2)
                     ?};
                     _stan+=BEER.SD;
                     {? _ZLIM.CZY_REZ>0
                     || _stan+=exec('zlim_il_rez','zl_nlimit',_ZLIM.REF)
                     ?};
                     _il:={? _dokl>0
                          || ((ZLIM.LIL*_ilosc)/VAR.A_ZLEC().IL)$ _dokl
                          || ceil(((ZLIM.LIL*_ilosc)/VAR.A_ZLEC().IL))
                          ?}
                  ?};
                  {? _can_continue & _stan<_il
                  || _str:='';
                     {? _ZLIM.KODPAL<>''
                     || _str:='kodzie palety: %1'@[_ZLIM.KODPAL]
                     || _str:='kodzie dostawy: %1'@[_ZLIM.SCEAN]
                     ?};
                     {? ZLIM.DK_C<>null()
                     || {? _ZLIM.SCEAN='' & _ZLIM.KODPAL=''
                        || _msg:='Brak surowca: %1 w magazynie: %2 o wymaganych wartościach atrybutów. '
                                 'Dokumenty %3 nie zostały utworzone.'@
                                 [ZLIM.KTM().KTM,MG.SYM,form(_mrdok)]
                        |? _ZLIM.EANL=''
                        || _msg:='Brak surowca: %1 w magazynie: %2 o %3 '
                                 'o wymaganych wartościach atrybutów. Dokumenty %4 nie zostały utworzone.'@
                                 [ZLIM.KTM().KTM,MG.SYM,_str,form(_mrdok)]
                        || _msg:='Brak surowca: %1 w magazynie: %2 w lokalizacji: %3 %4 '
                                 'o wymaganych wartościach atrybutów. Dokumenty %5 nie zostały utworzone.'@
                                 [ZLIM.KTM().KTM,MG.SYM,_str
                                 ,exec('FindAndGet','#table','EANL',_ZLIM.EANL,,"EANL.KOD",''),form(_mrdok)]
                        ?}
                     || {? _ZLIM.SCEAN='' & _ZLIM.KODPAL=''
                        || _msg:='Brak surowca: %1 w magazynie: %2. '
                                 'Dokumenty %3 nie zostały utworzone.'@
                                 [ZLIM.KTM().KTM,MG.SYM,form(_mrdok)]
                        |? _ZLIM.EANL=''
                        || _msg:='Brak surowca: %1 w magazynie: %2 o %3. '
                                 'Dokumenty %4 nie zostały utworzone.'@
                                 [ZLIM.KTM().KTM,MG.SYM,_str,form(_mrdok)]
                        || _msg:='Brak surowca: %1 w magazynie: %2 w lokalizacji: %3 o %4. '
                                 'Dokumenty %5 nie zostały utworzone.'@
                                 [ZLIM.KTM().KTM,MG.SYM,_str
                                 ,exec('FindAndGet','#table','EANL',_ZLIM.EANL,,"EANL.KOD",''),form(_mrdok)]
                        ?}
                     ?};
                     KOMM.add(_msg,4,,1);
                     _can_continue:=0
                  ?};

                  {? _can_continue>0
                  ||
                     _mags.cntx_psh();
                     _mags.prefix($MG.ref());
                     {? _mags.size()=0
                     ||
                        _mags.blank();
                        _mags.REF:=$MG.ref();
                        _mags.SYM:=MG.SYM;
                        _mags.NAZ:=MG.NAZ;
                        _mags.TYP:=MG.TYP;
                        _mags.SL:=MG.SL;
                        _mags.add()
                     ?};
                     _mags.cntx_pop()
                  ?}
               ||
                  KOMM.add('Nie przypisano magazynu do surowca %1. Dokumenty %2 nie zostały utworzone.'@
                           [ZLIM.KTM().KTM,form(_mrdok)],4,,1);
                  _can_continue:=0
               ?}
            ?};
            _ZLIM.next()
         !}
      || KOMM.add(
            'Do pozycji przewodnika nie zdefiniowano surowców nielimitowanych lub wystawiono już dokumenty rozliczające.'
            'Dokumenty nie zostały utworzone.'@,4,,1
         );
         _can_continue:=0;
         _result:='y'
      ?};
::       Pętla po magazynach - sprawdzenie dostępności typów dokumentów
         MG.clear();
         {? _mags.first()
         || {!
            |? {? MG.seek(_mags.REF,)
               || _magtab:=obj_new(1); _magtab[1]:=MG.ref();
                  _typydok_sym:=exec('FindAndGet','#table',TYPYDOK,_typydok,,"T",'');
                  _typy_ok:=exec('typ_dok','lmg','"TYPYDOK".T=\''+_typydok_sym+'\'',,,1,_magtab,,,0);
                  {? _typy_ok=''
                  || _msg:='Brak dostępu do dokumentu: %1 na magazynie: %2.'@[_typydok_sym,MG.SYM];
                     KOMM.add(_msg,4,,1);
                     _can_continue:=0
                  ?};
                  obj_del(_magtab)
               ?};
               _mags.next()
            !}
         ?};

::    2. W pętli po magazynach tworzę nagłówki dokumentów, a do nich pozycje na podstawie nielimitów
      {? _can_continue>0
      ||
         {? _mags.first()
         ||
            _ndx:=_ZLIM.ndx_tmp(,,'MAG_REF',,,'ROZ',,);
            _ZLIM.index(_ndx);
            {!
            |? _mg:=exec('FindAndGet','#table',MG,_mags.REF,,,null());

::             TWORZĘ NAGŁÓWEK DOKUMENTU MAGAZYNOWEGO (zawsze bez wykorzystywania wolnych numerów)
               _time:=exec('spr_dttm','magazyn_inw',_mg,_data,1);
               {? (*_time)>(*time(23,59,0)) || _time:=time(0,0,0) ?};
               _nd:=exec('addnag','magdok_nag',_mg,ST.AR,ST.AM,_typydok,'N',,_data,,,,,,,_zl,,,,,0,_time);
               {? _nd<>null()
               ||
::                ostemplowanie nagłówka GRP_KEY - jedna paczka dokumentów w ramach czynności TTE_WYK_DGRW
                  ND.cntx_psh();
                  ND.prefix();
                  {? ND.seek(_nd) || ND.GRP_KEY:=_tm_stamp+'1'; _kodmsk:=ND.name()+3; ND.put() ?};
                  ND.cntx_pop();
                  {? _typ
                  || _ZLIM.prefix(#_mg,'T')
                  || _ZLIM.prefix(#_mg)
                  ?};
                  {? _ZLIM.first()
                  || {!
                     |? {? ZLIM.seek(_ZLIM.REF)
                        || _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
                           {? ZLIM.ROZ='T'
                           ||
::                            Surowiec rozliczany z operacją, pobieram dane z rozpiski
                              {? _ZLIM.IL<>0
                              || _il:={? _dokl>0
                                      || (_ZLIM.IL)$ _dokl
                                      || ceil(_ZLIM.IL)
                                      ?}
                              || _il:=0
                              ?}
                           || _il:={? _dokl>0
                                   || ((ZLIM.LIL*_ilosc)/VAR.A_ZLEC().IL)$ _dokl
                                   || ceil(((ZLIM.LIL*_ilosc)/VAR.A_ZLEC().IL))
                                   ?}
                           ?};
                           _zgp:=exec('FindAndGet','#table',ZGP,_ZLIM.ZGP_REF,,"ZGP.ref",null);
                           _dorozp:=_il;
::                         Suma zarezerwowanej ilości na rozpiskach
                           _sum_rezr:=0;
                           _sum_rezd:=0;
::                         Ilość dodatkową, która należy rozliczyć
                           _il_add_d:=0;
::                           _il_add_f:=0;
::                         Jeżeli zapis powstał na podstawie rozpiski rozliczeń nielimitów to na początku
::                         tworzone pozycje dokumentów na ich podstawie, w drugiej kolejności brane pod uwagę są
::                         dedykowane rezerwacje do nielimitów (zlecenia ze stanów mag.)
                           {? ZLIM.ROZ='T' & (_ZLIM.SCEAN<>'' | _ZLIM.KODPAL<>'')
                           || {? _ZLIM.KODPAL<>''
                              || _tab_rez.index(_ndx4);
                                 _tab_rez.prefix(_ZLIM.RSC)
                              || _tab_rez.index(_ndx3);
                                 _tab_rez.prefix(_ZLIM.SCEAN)
                              ?};
                              {? _tab_rez.first()
                              || {!
                                 |?
                                    {? _tab_rez.TYP='R'
                                    || _sum_rezr+=exec('rej_mat_il_rez','zl_common',_zgp,$ZLIM.ref(),_mg
                                          ,_tab_rez.SRDK,,'ZGP',,_ZLIM.KODPAL)
                                    || _sum_rezd+=exec('sc_il_rez','zl_nlimit',_tab_rez.SRDK,$ZLIM.ref())
                                    ?};
                                    _tab_rez.next()
                                 !}
                              ?};
                              _il_add:=_dorozp-_sum_rezr;
                              {? _il_add<0 || _il_add:=0 ?};
                              {? _il_add>0
                              || _il_add_d:={? _il_add>_sum_rezd || _sum_rezd || _il_add ?}
::                                 _il_add_f:=_il_add-_il_add_d;
::                                 {? _il_add_f<0 || _il_add_f:=0 ?}
                              ?};
                              _czy_rez:=2
::                         Jeżeli istnieją rezerwacje dedykowane do nielimitów (do konkretnych dostaw),
::                         to na początku tworzone pozycje dokumentów na podstawie zarezerwowanych wcześniej dostaw
                           |? _ZLIM.CZY_REZ>0
                           || _tab_rez.index(_ndx2);
                              _tab_rez.prefix('D',$_zl,$ZLIM.KTM,$ZLIM.ref());
                              _czy_rez:=1
::                         Brak dodatkowych rozpisek/rezerwacji, rozliczanie FIFO
                           || _czy_rez:=0
                           ?};
                           _first:=1;
                           {!
                           |?
                              _scean:=_ZLIM.SCEAN;
                              _kodpal:=_ZLIM.KODPAL;
                              {? _czy_rez>0
                              || {? _first>0
                                 || _loop:=_tab_rez.first();
                                    _first:=0
                                 || _loop:=_tab_rez.next()
                                 ?}
                              || _loop:=0
                              ?};
                              {? _loop>0
                              || {? _czy_rez=2
                                 || {? _tab_rez.TYP='D'
                                    || _scean:='';
                                       _kodpal:=''
                                    ?};
                                    _sta_d:=exec('sc_il_rez','zl_nlimit',_tab_rez.SRDK,$ZLIM.ref());
                                    _sta_r:=exec('rej_mat_il_rez','zl_common',_zgp,$ZLIM.ref(),_mg
                                             ,_tab_rez.SRDK,,'ZGP',,_kodpal);
                                    _ilr:={? _tab_rez.TYP='R' || _sta_r || _sta_d ?};
                                    {? _tab_rez.TYP='R' & _il_add_d>0 & _sta_d>0
                                    || _ilr:=_ilr+{? _il_add_d>_sta_d || _sta_d || _il_add_d ?}
                                    ?};
::                                    {? _il_add_f>0
::                                    || _sta_f:=exec('FindAndGet','#table',SC,_tab_rez.REF,,
::                                          "exec('obl_stsc','magazyn_stan')",0);
::                                       _ilr:=_ilr+{? _il_add_f>_sta_f || _sta_f || _il_add_f ?}
::                                    ?};
                                    _il:={? _dorozp>_ilr || _ilr || _dorozp ?};
                                    _sc:=_tab_rez.REF
                                 || _ilr:=exec('sc_il_rez','zl_nlimit',_tab_rez.SRDK,$ZLIM.ref());
                                    _il:={? _dorozp>_ilr || _ilr || _dorozp ?};
                                    _sc:=_tab_rez.REF
                                 ?}
                              || _il:=_dorozp;
                                 _sc:=''
                              ?};
                              {? _il>0
                              ||
::                               TWORZĘ POZYCJĘ DOKUMENTU MAGAZYNOWEGO
                                 {? var_pres('_res_dk')>100
                                 || obj_del(_res_dk)
                                 ?};
                                 _res_dk:=exec('adddk4zl','magdok_prod'
                                                  ,_zl
                                                  ,{? _wyd<>null() || _wyd || ZLIM.WYD ?}
                                                  ,_il
                                                  ,ZLIM.KTM
                                                  ,_nd
                                                  ,_mg
                                                  ,
                                                  ,ZLIM.DK_C
                                                  ,ZLIM.ref()
                                                  ,_tm_stamp
                                                  ,exec('FindAndGet','#table',ZGP,_ZLIM.ZGP_REF,,"ZGP.NRPRZ",null)
                                                  ,exec('FindAndGet','#table',ZPARN,_ZLIM.ZPARN,,"ZPARN.ref",null)
                                                  ,_zgp
                                                  ,_tab_rez
                                                  ,_ZLIM.EANL
                                                  ,_scean
                                                  ,{? _scean<>'' | _kodpal<>'' || 'Z' || '' ?}
                                                  ,
                                                  ,_sc
                                                  ,_dk_rez
                                                  ,$_zgp
                                                  ,
                                                  ,
                                                  ,_ZLIM.KODPAL
                                              );
                                 _can_continue:=_res_dk.RESULT;

                                 {? _can_continue>0
                                 || _dorozp-=_il;
::                                  Aktualizacja dodatkowych ilości do rozpisania
                                    {? _loop>0 & _czy_rez=2
                                    || _ilosc:=_il;
                                       {? _tab_rez.TYP='R'
                                       || _sta_r:=exec('rej_mat_il_rez','zl_common',_zgp,$ZLIM.ref(),_mg
                                                   ,_tab_rez.SRDK,,'ZGP',,_kodpal);
                                          _diff:=_tab_rez.ILR-_sta_r;
                                          _tab_rez.ILR:=_sta_r;
                                          _tab_rez.put();
                                          _ilosc-=_diff
                                       ?};
                                       {? _ilosc>0 & _il_add_d>0
                                       || _ild:={? _ilosc>_sta_d || _sta_d || _ilosc ?};
                                          _ilosc-=_ild;
                                          _il_add_d-=_ild
                                       ?}
::                                       {? _ilosc>0 & _il_add_f>0
::                                       || _ilf:={? _ilosc>_sta_f || _sta_f || _ilosc ?};
::                                          _ilosc-=_ilf;
::                                          _il_add_f-=_ilf
::                                       ?}
                                    ?}
                                 ?}
                              ?};
                              _loop>0 & _dorozp>0
                           !};
                           {? _can_continue=0
                           || _msg:='Nie udało się utworzenie pozycji dokumentu magazynowego dla surowca: %1'@
                                    [ZLIM.KTM().KTM];
                              KOMM.add(_msg,2,,1)
                           ?}
                        ?};
                        _ZLIM.next() & _can_continue>0
                     !}
                  ?}
               || _can_continue:=0
               ?};

               {? _can_continue>0
               || _nd_sym:=exec('FindAndGet','#table',ND,_nd,,"SYM",'');
                  _msg:='Utworzono dokument o symbolu: %1 na magazynie: %2'@[_nd_sym,_mags.SYM];
                  KOMM.add(_msg,7,,1);
::                Rozpisanie dokumentu wg lokalizacji (uzupełnienie)
                  {? _mags.SL='T'
                  || ND.cntx_psh(); ND.clear();
                     {? ND.seek(_nd)
                     || exec('rozpdk_l','magdok_poz',,ND.MAG,,,ND.DLAKH,,,,,0)
                     ?};
                     ND.cntx_pop()
                  ?};
                  _ilosc_nd+=1
               || _msg:='Nie udało się utworzyć dokumentu: %1 na magazynie: %2'@[form(_mrdok),_mags.SYM];
                  KOMM.add(_msg,2,,1);
                  {? _nd<>null()
                  ||
::                   Jeśli nagłówek powstał to go usuwam
                     ND.cntx_psh(); ND.clear();
                     {? ND.seek(_nd)
                     || exec('n_usun','magdok_nag',0,0,,,,,,_dk_rez)
                     ?};
                     ND.cntx_pop();
                     ~~
                  ?}
               ?};
               _mags.next() & _can_continue>0
            !}
         ?}
      ?};
      M.cntx_pop();
      MG.cntx_pop();
      VAR.cntx_pop();
      ZL.cntx_pop();
      ZLIM.cntx_pop()
   ?};
:: Czyszczę rezerwacje (rozpiskę surowców) dla pozycji przewodnika
   {? _can_continue>0
   || exec('del4ZLGD','zl_limit',1,,_kodmsk)
   ?}
?};
ZGP.cntx_pop();
REZ.cntx_pop();
{? _can_continue>0
|| _result:=_tm_stamp
?};
_result


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła ustala PARSES
::   WE: UWAGA. Do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_context:=params_get().context;

_result:=0;

:: Jeżeli jest dokument, to oddział i okres wg niego
_nd:={? var_pres('ND',_in)=type_of(null()) & _in.ND
     || _in.ND
     |? var_pres('_context')>0 & var_pres('ND',_context)=type_of(null()) & _context.ND
     || _context.ND
     || null()
     ?};
{? _nd<>null()
|| ND.cntx_psh();
   ND.use(ref_name(_nd));
   ND.prefix();
   {? ND.seek(_nd)
   || __PARSES.setVal('OddzialLogProd',ND.ODDZ);
      _args:=__PARSES.args('OkresRok');
      _args.OBSZAR:='LMG';
      _args.AR:=ND.AR;
      _args.AM:=ND.AM;
      __PARSES.setVal('OkresRok',_args);
      _result:=1
   ?};
   ND.cntx_pop()

:: Jeżeli jest zlecenie, to oddział wg niego, reszta dziedziczona
|? var_pres('ZL',_in)=type_of(null()) & _in.ZL
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_in.ZL)
   || __PARSES.setVal('OddzialLogProd',ZL.ODDZ);
      _args:=__PARSES.args('OkresRok');
      _args.OBSZAR:='LMG';
      _args.AR:=date()~1;
      _args.AM:=date()~2;
      __PARSES.setVal('OkresRok',_args);
      _result:=1
   ?};
   ZL.cntx_pop()

:: Nic nie ustawiamy, ale zwracamy 1, w formule przy braku parametrów wejściowych zostanie zgłoszony błąd
|| _result:=1
?};

_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::   WE: [_a] - _mp - obiekt Menadżera procesów
::       [_b] - tablica z parametrami wejściowymi
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _mp:=_a
|| _mp:=params_get().mp
?};
{? var_pres('_b')>100
|| _in:=_b
|| _in:=params_get().in
?};
_can_continue:=1;
_obj:=obj_new('RESULT','ZL');
_obj.RESULT:=0;
_obj.ZL:=null();

_keyRefs:=_mp.getRefs();

{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];

      {? type_of(_kref)>0
      ||
         {? ref_name(_kref)=ZL.name()
         || _obj.ZL:=exec('FindAndGet','#table',ZL,_kref,,,null());

            {? _obj.ZL=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp)
            ?}
         ?}
      ?}
   !}
?};

{? _can_continue>0
||
:: jest parametr wejściowy ZL
   {? _obj.ZL=null() & var_pres('ZL',_in)=type_of(null())
   || _obj.ZL:=_in.ZL
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};

_obj


\__ZLIM_wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Tworzy okienko wertowania do obiektu __ZLIM. Okno umożliwia korekcję nielimitów przed utworzeniem dokumentu RW.
::   WE: _a - wynik formuły exec('kart_lim','zl_limit')
::   WY: Utworzone okno
::----------------------------------------------------------------------------------------------------------------------
_wer:='';
_tab:={? var_pres('_a')>100 || _a || return(_wer) ?};

_wer:=_tab.mk_sel('Lista surowców do rozliczenia'@,,,'zlim_ls');
_tab.win_fld(_wer,,'KTM',,,18,,1,'Kod materiału'@);
_tab.win_fld(_wer,,'N',,,30,,1,'Nazwa materiału'@);
_tab.win_fld(_wer,,'PARSYM',,,,,1,'Partia'@);
_tab.win_fld(_wer,,'IL',,,,ST.DOKL,0,'Ilość'@);
_tab.win_fld(_wer,,'J',,,,,1,'jm'@);
_tab.win_fld(_wer,,'MAG',,,,,0,'Magazyn'@);
_tab.win_fld(_wer,,'SD',,,,ST.DOKL,1,'Stan dostępny'@);
_tab.fld_fml('MAG','BEFORE_EDIT',"{? cur_tab(1,1).SCEAN<>'' || 0 || 1 ?}");
_tab.win_act(_wer,,'Popraw','Popraw'@);

_tab.win_act(_wer,,'Usuń','Usuń'@);

_formula_b:="
   _tab:=cur_tab(1,1);
   _ktm:=exec('FindAndGet','#table',M,_tab.M_REF,,\"M.ref()\",null);
   _mg:=exec('FindAndGet','#table',MG,_tab.MAG_REF,,\"MG.ref()\",null);
   _zgp:=exec('FindAndGet','#table','ZGP',_tab.ZGP_REF,'zguidep',,null());
   _zl:=exec('FindAndGet','#table','ZL',_tab.ZL_REF,'zlec_akt',,null());
   _stan:=0;
   {? _tab.REJ_MAT<>'T'
   || _dk_c:=exec('FindAndGet','#table','ZLIM',_tab.REF,,\"ZLIM.DK_C\",null());
      {? _dk_c<>null()
      || exec('obl_stan','magazyn_stan',_ktm,1,_mg,,,date(),-2,,,,_dk_c)
      || exec('obl_stan','magazyn_stan',_ktm,1,_mg,,,date(),-2)
      ?};
      _stan+=BEER.SD
   || {? var_pres('_sctab')>100 || obj_del(_sctab) ?};
      {? _tab.RSC<>''
      || {? _tab.KODPAL<>''
         || _sctab:=exec('sc_tmp_scean','magazyn_stan',null(),,,,_tab.RSC)
         || _sctab:=exec('sc_tmp_scean','magazyn_stan',null(),_tab.SCEAN)
         ?};
         _sctab.prefix()
      || _sctab:=~~
      ?};
      _stan+=exec('rej_mat_chk_stan','zl_common',_zgp,_tab.REF,$_mg,$_zl,_tab.RSC,_tab.EANL,'ZGP','N',1,_sctab)
   ?};
   _tab.SD:=_stan;
   _tab.put();
   ~~
";
_formula_a:="
   _tab:=cur_tab(1,1);
   {?_tab.IL<0
   || FUN.emsg('Ilość musi być większa od 0.'@);
      0
   |? _tab.MAG=''
   || FUN.emsg('Magazyn musi zostać określony.'@);
      0
   |? exec('FindInSet','#table','MG','MAGAZYNY', _tab.MAG,,\"MG.ref()\",1,,null)=null
   || FUN.emsg('Nie odnaleziono magazynu o wskazanym symbolu.'@);

      0
   || 1
   ?}

";
_tab.win_act(_wer,,'Rekord',,,,_formula_b,_formula_a);
   _valid:="
   _tab:=cur_tab(1,1);
   _result:=1;
   _msg:='';
   {? _tab.first()
   || {!
      |?
         {? _tab.MAG=''
         || _result:=0;
            _msg:='Do materiału %1 nie przypisano magazynu.'@[_tab.N]
         |? exec('FindAndGet','#table',MG,_tab.MAG_REF,,\"MG.ref()\",null)=null
         || _result:=0;
            _msg:='Do materiału %1 przypisano nieprawidłowy magazyn.'@[_tab.N]
         |? _tab.IL>_tab.SD
         || _result:=0;
            _msg:=('W magazynie %1 nie ma wystarczającej ilości surowca: %2. \n'
                   'Należy wskazać inny magazyn lub zmniejszyć ilość rozliczanego surowca.'@[_tab.MAG,_tab.N])
         ?};
         _result & _tab.next()
      !}
   ?};
   {? _result
   || sel_exit()
   || FUN.emsg(_msg)
   ?}

";
_tab.win_act(_wer,,'Formuła','Akceptuj'@,,,_valid);

_wer


\action_rw_gropgen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Wyświetla panel rozliczania surowców nielimitowanych dla grup operacji
::   WE: _a - STRING - Kontekst wywołania (parametr do wykorzystania w przyszłości)
::      [_b] - czy tylko uzupełnić tabelę (bez powoływania środowiska i wyświetlania wyniku): 1 - tak, [0] - nie
::----------------------------------------------------------------------------------------------------------------------
_typ:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_fill_only:={? var_pres('_b')=type_of(0) || _b || 0 ?};
{? ~_fill_only & GROP.sel_size()=0
|| _f500707:=exec('get','#params',500707,2);
   {? _f500707=''
   || KOMM.info('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500707'],GROP.sel_size()=0);
      return()
   ?};
   VAR_DEL.delete('__ENV_GEN');
   {? _typ=0
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI_GROP')
   ?}
?};
{? GROP.AKC<>'T' | GROP.STATUS<>'O'
|| {? ~_fill_only
   || {? GROP.sel_size()=0
      || KOMM.info('Grupa operacji do rozliczenia musi być zaakceptowana i otwarta.'@,GROP.sel_size()=0)
      ?}
   ?}
|| {? ~_fill_only
   || {? GROP.sel_size()=0
      || KOMM.init(,,'Rozliczenie surowców'@)
      ?}
   ?};
   {? _typ=0
   || exec('find_zlgd','zl_grop')
   ?};
   {? ~_fill_only & GROP.sel_size()=0
   || {? _typ=0
      || exec('select_gen_zlgd','zl_limit')
      ?};
      VAR_DEL.delete('__ENV_GEN')
   ?}
?};
~~


\action_rw_gropgen_group_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Przed akcją grupową - obsługa panela rozliczania surowców nielimitowanych dla grup operacji
::   WE: _a - STRING - Kontekst wywołania (parametr do wykorzystania w przyszłości)
::----------------------------------------------------------------------------------------------------------------------
_typ:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_f500707:=exec('get','#params',500707,2);
{? _f500707=''
|| FUN.emsg('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500707']);
   0
|| KOMM.init(,,'Rozliczenie surowców'@);
   VAR_DEL.delete('__ENV_GEN');
   {? _typ=0
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI_GROP')
   ?};
   1
?}


\action_rw_gropgen_group_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Po akcji grupowej - obsługa panela rozliczania surowców nielimitowanych dla grup operacji
::   WE: _a - STRING - Kontekst wywołania (parametr do wykorzystania w przyszłości)
::----------------------------------------------------------------------------------------------------------------------
_typ:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? _typ=0
|| exec('select_gen_zlgd','zl_limit')
?};
VAR_DEL.delete('__ENV_GEN');
~~

:Sign Version 2.0 jowisz:1045 2024/02/14 12:59:46 aeaf362b4ae627ba8459c5cc05fd0ba3fa67c42c5811c147ce76084acafb860788a548db043698e3179b92f510b02cc60c2c394a59d05e831456352a4486d8100413954eb16968080048085cf064d729cc6e4a48655c86d3b43f2f88e46317031bdd9390fda677b95c445ad8c2fdd6a2d47f050380b098ae2e75b7d708c3a900
