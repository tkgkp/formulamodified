:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tte_wyk_dgrp.fml
:: Utworzony: 04.03.2016
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły czynności TTE_WYK_DGRP - Generowanie raportu produkcji
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Główna formuła czynności generowania raportu produkcji (TTE_WYK_DGRP)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

::# permissions=ODDZ,LMG
::# parses=exec('parses','!tte_wyk_dgrp')
::# properties=SERVICE,LOOP
::# condition=Ponowne generowanie raportu produkcji, act_uid=TTE_WYK_DGRP, auto=N, formula=exec('jest_do_wykonania','%gate',_a.ZL)
::# condition=Rejestracja dokumentu przyjęć, act_uid=LMG_MAG_DAPZ, auto=T, formula=_a.ND<>~~ & _a.ND<>null()

:: PARAMETRY WE:
::# kind=WE, symbol=ZL, type=_ZL, name=Wskazanie na zlecenie, required=N, keyref=T
{? var_pres('ZL',_in)<>type_of(~~) & var_pres('ZL',_in)<>type_of(null())
|| return()
|? _in.ZL=~~
|| _in.ZL:=null()
?};
::# kind=WE, symbol=TYPYDOK, type=_TYPYDOK, name=Wskazanie na typ dokumentu, required=N, keyref=N, fml_val="exec('typ_dok','!tte_wyk_dgrp',-1)", fml_exp="exec('typydok_export','magdok_nag',_a)"
{? var_pres('TYPYDOK',_in)<>type_of(~~) & var_pres('TYPYDOK',_in)<>type_of(null())
|| return()
|? _in.TYPYDOK=~~
|| _in.TYPYDOK:=null()
?};
::# kind=WE, symbol=WARIANT, type=STRING, name=Wariant działania czynności, required=N, fml_val="exec('wariant','!tte_wyk_dgrp')"
{? var_pres('WARIANT',_in)<>type_of(~~) & var_pres('WARIANT',_in)<>type_of('')
|| return()
|? _in.WARIANT=~~
|| _in.WARIANT:='A'
?};

:: PARAMETRY WY:
::# kind=WY, symbol=ZL, type=_ZL, name=Wskazanie na zlecenie, required=N
{? var_pres('ZL',_out)<>type_of(~~) & var_pres('ZL',_out)<>type_of(null()) || return() ?};
::# kind=WY, symbol=ND, type=_ND, name=Dokument magazynowy, required=N
{? var_pres('ND',_out)<>type_of(~~) & var_pres('ND',_out)<>type_of(null()) || return() ?};

_key:=_out.GRPKEY:=_mp.grpkey(_out.GRPKEY,_in.GRPKEY);
_dok_count:=0;
_nd_uidref:='';
{? _key<>''
||
:: Odszukanie istniejącego dokumentu, a tak naprawdę decyzja czy generować, czy tylko wystawiać
:: na wyjście
   _exist:=_mp.grpkeyGet();
   {? type_of(_exist)=type_of('')
   || _nd_uidref:=_exist
   ?}
?};
_clean_result:=params_exec('clean','!tte_wyk_dgrp',{? _nd_uidref<>'' || 0 || 1 ?});
_can_continue:=_clean_result.RESULT;

:: Ustawiam wartość domyślną argumentu LOOP żeby brama się nie zawiesiła
_mp.save(exec('kind_out','#b_port'),'LOOP','N');

_done:=0;
:: Czy komunikaty walidacji na ekran
_display:={? _mp.isService() || 0 || 1 ?};

{? _nd_uidref=''
||
   {? _can_continue>0
   ||
::    Uruchomienie jako czynność startowa w procesie - wybór zlecenia
      {? _mp.pathProc() & _in.ZL=null()
      || _tmp:=exec('sel_zl_and_typdok','!tte_wyk_dgrp',_in.TYPYDOK);
         {? _tmp.ZL=null() | _tmp.TYPYDOK=null()
         || _mp.cancel();
            return()
         || _in.ZL:=_tmp.ZL;
            _in.TYPYDOK:=_tmp.TYPYDOK
         ?}
      ?};

::    WSTĘPNE WALIDACJE
      {? _in.ZL=null()
      || _msg:='Błędna konfiguracja procesu — nie przekazano zlecenia.'@;
         {? _display || FUN.emsg(_msg) ?};
         _mp.error(_msg);
         return()
      ?};
      {? date()<date(ST.AR,ST.AM,1)
      || _msg:='Nie można utworzyć dokumentu — wybrany okres nie może być późniejszy niż bieżąca data.'@;
         {? _display || FUN.emsg(_msg) ?};
         _mp.cancel();
         return()
      ?};
      _zl_sym:=exec('FindAndGet','#table',ZL,_in.ZL,,"SYM",'');
      _dtod:=exec('FindAndGet','#table',ZL,_in.ZL,,"OD",date());
      _dtok:=date(ST.AR,ST.AM,0);
      {? _dtod>_dtok
      || _msg:='Zlecenie %1 powołane jest z datą późniejszą (%2)\nniż wybrany okres (%3).'@[_zl_sym,$_dtod,form(_dtok,,8)];
         {? _display || FUN.emsg(_msg) ?};
         _mp.cancel();
         return()
      ?};
      {? exec('FindAndGet','#table',ZL,_in.ZL,,"KTM",null())=null()
      || _msg:='Nie można utworzyć dokumentu dla zlecenia %1 nie powiązanego z produktem.'@[_zl_sym];
         {? _display || FUN.emsg(_msg) ?};
         return()
      ?};
      _rp:=exec('FindAndGet','#table',ZL,_in.ZL,,"RP",'N');
      {? _rp<>'T'
      || _msg:=
            'Nie można utworzyć dokumentu raportującego produkcję na zleceniu %1,\n'
            'na którym nie powstaje produkt lub półprodukt raportowany na magazyn.'@[_zl_sym];
         {? _display || FUN.emsg(_msg) ?};
         _mp.error(_msg);
         return()
      ?};
::    Sprawdzenie uprawnień do typu dokumentu
::    (jak wiele wyrobów to pomijam, tam walidacja w oknie rozpisywania na wyroby)
      {? _in.TYPYDOK<>null() & ~exec('zl_czy_wyr','zl_wyr',_in.ZL)
      || _mg:=exec('zl_mg','zl_common',_in.ZL);
         {? ~exec('chk_mg4typ','magdok_wspolne',_mg,_in.TYPYDOK)
         || _mg_sym:=exec('FindAndGet','#table',MG,_mg,,"SYM",'');
            _typydok_sym:=exec('FindAndGet','#table',TYPYDOK,_in.TYPYDOK,,"T",'');
            _msg:='Brak dostępu do dokumentu: %1 na magazynie: %2.'@[_typydok_sym,_mg_sym];
            {? _display || FUN.emsg(_msg) ?};
            _mp.error(_msg);
            return()
         ?}
      ?};

      _args_gendok:=exec('gendok_args','!tte_wyk_dgrp');
      _args_gendok.ZL:=_in.ZL;
      _args_gendok.TYPYDOK:=_in.TYPYDOK;
      _args_gendok.DISPLAY:=_display;

      ZL_WYR.cntx_psh();
      ZL_WYR.index('ZL');
      ZL_WYR.prefix(_args_gendok.ZL);
      {? ZL_WYR.first()
      || _args_gendok.MULTIWYR:=1
      ?};
      ZL_WYR.cntx_pop();

      {? _in.WARIANT='M' | _in.WARIANT='A' & exec('zl_bez_oper','zl_common',_in.ZL)
      || _args_gendok.WARIANT:='M'
      |? _in.WARIANT='W' | _in.WARIANT='A' & ~exec('zl_bez_oper','zl_common',_in.ZL)
      || _args_gendok.WARIANT:='W'
      ?};

      {? _mp.isService() & _in.ZL<>null()
      ||
::       Uruchomienie jako usługa do wcześniej zarejestrowanej robocizny albo do zlecenia
::       (wybór wg wariantu wywołania czynności albo automatycznie)
         {? _in.WARIANT='M' | _in.WARIANT='A' & exec('zl_bez_oper','zl_common',_in.ZL)
         || _res:=exec('gendok_mag','!tte_wyk_dgrp',_args_gendok)
         |? _in.WARIANT='W' | _in.WARIANT='A' & ~exec('zl_bez_oper','zl_common',_in.ZL)
         || _res:=exec('gendok_zl','!tte_wyk_dgrp',_args_gendok)
         || _res:=exec('result_gendok','magdok_wspolne');
            _res.TXT:='Błąd konfiguracji czynności — nie można ustalić wariantu działania.'@@
         ?}
      |? _mp.isAutoRun() & _in.ZL<>null()
      ||
::       Uruchomienie automatyczne do wcześniej zarejestrowanej robocizny albo zlecenia
::       (wybór wg wariantu wywołania czynności albo automatycznie)
         {? _in.WARIANT='M' | _in.WARIANT='A' & exec('zl_bez_oper','zl_common',_in.ZL)
         || _res:=exec('gendok_mag','!tte_wyk_dgrp',_args_gendok)
         |? _in.WARIANT='W' | _in.WARIANT='A' & ~exec('zl_bez_oper','zl_common',_in.ZL)
         || _res:=exec('gendok_zl','!tte_wyk_dgrp',_args_gendok)
         || _res:=exec('result_gendok','magdok_wspolne');
            _res.TXT:='Błąd konfiguracji czynności — nie można ustalić wariantu działania.'@@
         ?}
      |? _mp.pathTodo() & _in.ZL<>null()
      ||
::       Uruchomienie z ToDo do wcześniej zarejestrowanej robocizny albo zlecenia
::       (wybór wg wariantu wywołania czynności albo automatycznie)
         {? _in.WARIANT='M' | _in.WARIANT='A' & exec('zl_bez_oper','zl_common',_in.ZL)
         || _res:=exec('gendok_mag','!tte_wyk_dgrp',_args_gendok)
         |? _in.WARIANT='W' | _in.WARIANT='A' & ~exec('zl_bez_oper','zl_common',_in.ZL)
         || _res:=exec('gendok_zl','!tte_wyk_dgrp',_args_gendok)
         || _res:=exec('result_gendok','magdok_wspolne');
            _res.TXT:='Błąd konfiguracji czynności — nie można ustalić wariantu działania.'@@
         ?}
      |? (_mp.akcja()='ZL_GENERUJ' | _mp.pathProc()) & _in.ZL<>null()
      ||
::       Generowanie do zlecenia bez powiązania z rejestracją robocizny albo w powiązaniu (wybór operatora gdy dostępna)
::       Uruchomienie jako czynność startowa w procesie - faktyczna akcja
         _args_gendok.SPR_ROB:=1;
         _res:=exec('gendok_mag','!tte_wyk_dgrp',_args_gendok)
      |? _mp.akcja()='ZGP_GENERUJ' & _in.ZL<>null()
      ||
::       Generowanie do pozycji przewodnika
         _args_gendok.ZGP:=_context.ZGP;
         _res:=exec('gendok_zgp','!tte_wyk_dgrp',_args_gendok)
      |? _mp.akcja()='ZPARN_GENERUJ' & _in.ZL<>null()
      ||
::       Generowanie do utworzonych partii
         {? _args_gendok.DISPLAY>0
         || _args_gendok.DISPLAY:=2
         ?};
         _args_gendok.TAB_PART:=_context.TAB_PART;

         _res:=exec('gendok_zparn','!tte_wyk_dgrp',_args_gendok)
      || _mp.error('Nieobsługiwana ścieżka wywołania czynności.'@@)
      ?}
   ?};
   {? var_pres('_res')>100
   || _tab:=_res.TAB_DOK;
      _tab.index(_res.NDX_DOK_TYP);
      _tab.prefix(_res.TYP_ND);
      {? _tab.first()
      || {!
         |?
            {? _tab.ND<>''
            || _dok_count+=1;
::             Wystawienie klucza grupującego
               _uidref:=exec('FindAndGet','#table',ND,_tab.ND,,"ND.uidref()",'');
               {? _uidref<>''
               || _mp.grpkeyAdd(_uidref)
               ?}
            ?};
            _tab.next()
         !}
      ?};
      _first:=_mp.grpkeyGet();
      {? type_of(_first)=type_of('')
      || _nd_uidref:=_first
      ?};

      {? _display>0 & _dok_count>1
      || exec('show_after_info_multi','!tte_wyk_dgrp',_in.ZL,_res,_dok_count)
      ?}
   ?}
?};
{? _key<>''
||
:: Wypycham pierwszy dokument na wyjście
   {? _nd_uidref<>''
   ||
      _done:=1;
      ND.cntx_psh();
      ND.prefix();
      {? ND.seek(_nd_uidref)
      ||
         {? _display>0 & _dok_count=1
         || exec('show_after_info','!tte_wyk_dgrp',ND.ref())
         ?};

         do();
         _mp.save(exec('kind_out','#b_port'),'ZL',_in.ZL);
         _mp.save(exec('kind_out','#b_port'),'ND',ND.ref());
         _mp.save(exec('kind_out','#b_port'),'GRPKEY',_key);
         _mp.grpkeyDel();
         end();
::       Jeżeli są jeszcze jakieś dokumenty to kontynuuję pętlę
         _nd_uidref:=_mp.grpkeyGet();
         {? type_of(_nd_uidref)=type_of('')
         || _mp.loop_continue()
         ?}
      ?};
      ND.cntx_pop()
   ||
::    Zakończenie (nie powstał żadnen dokument) - wypycham null na wyjście
      _mp.save(exec('kind_out','#b_port'),'ND',null());
      {? _mp.pathTodo()=0
      || _done:=1
      ?}
   ?}
|| _mp.error('Brak oczekiwanego parametru %1.'@@['GRPKEY'])
?};
{? _done>0
|| _mp.done()
|? _dok_count=0 & var_pres('_res')>100
||
   {? _res.RESULT=0
   ||
::    Błąd
      _mp.error(_res.TXT)
   |? _res.RESULT=(-1)
   ||
::    Dokument nie powstał, np. rezygnacja z podania ilości
      {? _mp.isService()
      || _mp.error(_res.TXT)
      || _mp.cancel()
      ?}
   |? _res.RESULT=1
   ||
::    Dokument nie powstał, ale należy iść dalej, np. już wcześniej wszystko zaraportowane
      _out.ZL:=_in.ZL;
      _out.ND:=null();
      _mp.save(,_out);
      _done:=1
   ?}
?};

{? _can_continue>0 & _dok_count>0
||
:: Jeżeli kończę i dokument powstał, to uruchamiam cleanery samego siebie, żeby wysprzątać
:: zdublowane instancje na todo
   _zl_uid:=exec('FindAndGet','#table',ZL,_in.ZL,,"ZL.uidref()",'');
   {? _zl_uid<>''
   || {! _it:=1..10
      |? _run_cleaner:=0;
         {? exec('record_keyrefed','#b__box',_zl_uid,'TTE_WYK_DGRP')
         || _run_cleaner:=1
         ?};
         {? _run_cleaner>0
         || exec('clean_record','#b__box',_zl_uid,_display)
         ?};
         _run_cleaner>0
      !}
   ?}
?};
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opis dla czynności generowania raportu produkcji (TTE_WYK_DGRP)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: zwraca opis Zadania
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_desc:='';
_keyRefs:=_mp.getRefs();
_in:=_mp.load(exec('kind_in','#b_port'));

:: jest rekord kluczowy to ustawiam odpowiedniego ZL
{? var_pres('[1]',_keyRefs)
|| _tmp:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"SYM",'');
   _desc:={? _tmp<>'' || 'Wygeneruj dokument raportujący do zlecenia %1'@@[_tmp] || '' ?}
::|| _desc:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"'Wygeneruj dokument raportujący do zlecenia '+SYM",'')

:: jest parametr wejściowy to ustawiam odpowiedniego ZL
|? var_pres('ZL',_in)
||
   _tmp:=exec('FindAndGet','#table',ZL,_in.ZL,,"SYM",'');
   _desc:={? _tmp<>'' || 'Wygeneruj dokument raportujący do zlecenia %1'@@[_tmp] || '' ?}
::   _desc:=exec('FindAndGet','#table',ZL,_in.ZL,,"'Wygeneruj dokument raportujący do zlecenia '+SYM",'')
?};
_desc


\action_zl_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Generowanie dokumentu raportującego - akcja z menu okna wertowania zleceń (tabela ZL)
::       Umożliwia wygenerowanie dokumentu raportującego na dowolną ilość do zlecenia
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TTE_WYK_DGRP';
_args.UIDREF:=ZL.uidref();
_args.AKCJA:='ZL_GENERUJ';
_args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
_args.PROC_START:='T';
_args.CONTEXT:=obj_new('ZLGD','TAB_PART','ZGP');
_args.CONTEXT.ZLGD:=null();
_args.CONTEXT.ZGP:=null();
_args.CONTEXT.TAB_PART:=exec('ref_table','#table');

exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',ZL.ref());

exec('mp_run','#b__box',_args)


\action_zparn_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Generowanie dokumentu raportującego - akcja z menu okna wertowania partii (tabela ZPARN)
::       Umożliwia wygenerowanie dokumentu raportującego do zaznaczonych partii
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TTE_WYK_DGRP';
_args.UIDREF:=ZL.uidref();
_args.AKCJA:='ZPARN_GENERUJ';
_args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
_args.PROC_START:='T';
_args.CONTEXT:=obj_new('ZLGD','TAB_PART','ZGP');
_args.CONTEXT.ZLGD:=null();
_args.CONTEXT.ZGP:=null();
_args.CONTEXT.TAB_PART:=exec('ref_table','#table');

_grp_act:=ZPARN.sel_size();
_sel:=ZPARN.sel_aget();


ZPARN.cntx_psh();
ZPARN.prefix();
{? _grp_act>0
|| {? _sel.first()
   || {!
      |? {? ZPARN.seek(_sel.REF,)
         || _args.CONTEXT.TAB_PART.add(ZPARN.ref())
         ?};
         _sel.next()
      !}
   ?}
|| _args.CONTEXT.TAB_PART.add(ZPARN.ref())
?};
ZPARN.cntx_pop();
ZPARN.sel_adel();

exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',ZL.ref());

exec('mp_run','#b__box',_args)


\action_prodrej_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Generowanie dokumentu raportującego - akcja z menu okna wertowania PROD_REJ
::       Umożliwia wygenerowanie dokumentu raportującego do pozycji przewodnika
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;

{? PROD_REJ.ZGP=null()
|| _msg:='Akcja dotyczy wyłącznie wykonań powiązanych z przewodnikiem zlecenia'@;
   FUN.emsg(_msg);
   _can_continue:=0
?};

{? _can_continue>0
||
   _args:=exec('mp_run_a','#b__box');
   _args.ACT_UID:='TTE_WYK_DGRP';
   _args.UIDREF:=ZL.uidref();
   _args.AKCJA:='ZGP_GENERUJ';
   _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
   _args.PROC_START:='T';
   _args.CONTEXT:=obj_new('ZLGD','TAB_PART','ZGP');
   _args.CONTEXT.ZLGD:=null();
   _args.CONTEXT.ZGP:=PROD_REJ.ZGP;
   _args.CONTEXT.TAB_PART:=exec('ref_table','#table');
   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',ZL.ref());

   exec('mp_run','#b__box',_args)
?};
~~


\action_zgp_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Generowanie dokumentu raportującego - akcja z menu okna wertowania PROD_REJ
::       Umożliwia wygenerowanie dokumentu raportującego do pozycji przewodnika
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;

{? _can_continue>0
||
   _args:=exec('mp_run_a','#b__box');
   _args.ACT_UID:='TTE_WYK_DGRP';
   _args.UIDREF:=ZL.uidref();
   _args.AKCJA:='ZGP_GENERUJ';
   _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
   _args.PROC_START:='T';
   _args.CONTEXT:=obj_new('ZLGD','TAB_PART','ZGP');
   _args.CONTEXT.ZLGD:=null();
   _args.CONTEXT.ZGP:=ZGP.ref();
   _args.CONTEXT.TAB_PART:=exec('ref_table','#table');
   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',ZL.ref());

   exec('mp_run','#b__box',_args)
?};
~~


\gendok_mag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [12.10]
:: OPIS: Generowanie dokumentu raportującego produkcję dla zlecenia - nie powiązanego z rejestracją robocizny
::   WE: _a - obj_new() - tablica argumentów wszystkich funkcji gendok_, wynik działania exec('gendok_args','!tte_wyk_dgrp')
::   WY: obj_new() - wynik działania exec('gendok_struktura_env','!tte_wyk_dgrp')
::  OLD: \gen_rp/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_info:=1;
_display:=_args.DISPLAY;
{? _args.ZL<>null()
|| _zl:=_args.ZL
|| _zl:=ZL.ref()
?};
{? _args.TYPYDOK=null()
|| {? exec('is_usluga_zl','zl_uslugi',_zl)
   || _args.TYPYDOK:=exec('get_typydok','zl_uslugi')
   || _a_zlec:=VAR.A_ZLEC;
      VAR.A_ZLEC:=_zl;
      _args.TYPYDOK:=exec('typ_dok','!tte_wyk_dgrp',0,,"exec('typ_dok_valid','!tte_wyk_dgrp',VAR.A_ZLEC)");
      {? _args.TYPYDOK=null()
      || _info:=0
      ?};
      VAR.A_ZLEC:=_a_zlec
   ?}
?};

{? _args.ZPARN<>null()
|| _args.ZGH:=exec('FindAndGet','#table',ZPARN,_args.ZPARN,,"ZGH",null())
?};

_res:=exec('gendok_struktura_env','!tte_wyk_dgrp');

:: Brak typu dokumentu - uniemożliwia kontynuację procesu
{? _args.TYPYDOK=null()
|| _res.RESULT:=-1;
   _res.TXT:='Nie ustalono typu dokumentu magazynowego.';
   {? _info>0
   || {? _args.DISPLAY=1
      || FUN.emsg(_res.TXT)
      |? _args.DISPLAY=2
      || KOMM.add(_res.TXT,2,,1)
      ?}
   ?};
   return(_res)
?};
:: Sprawdzenie uprawnień do typu dokumentu (jak wiele wyrobów to pomijam, tam walidacja w oknie rozpisywania na wyroby)
{? _args.TYPYDOK<>null() & _zl<>null() & ~exec('zl_czy_wyr','zl_wyr',_zl)
|| _mg:=exec('zl_mg','zl_common',_zl);
   {? ~exec('chk_mg4typ','magdok_wspolne',_mg,_args.TYPYDOK)
   || _res.RESULT:=-1;
      _mg_sym:=exec('FindAndGet','#table',MG,_mg,,"SYM",'');
      _typydok_sym:=exec('FindAndGet','#table',TYPYDOK,_args.TYPYDOK,,"T",'');
      _res.TXT:='Brak dostępu do dokumentu: %1 na magazynie: %2.'@[_typydok_sym,_mg_sym];
      {? _args.DISPLAY=1
      || FUN.emsg(_res.TXT)
      |? _args.DISPLAY=2
      || KOMM.add(_res.TXT,2,,1)
      ?};
      return(_res)
   ?}
?};
_can_continue:=1;

:: Sprawdza, czy są zapisy niezbilansowane "robocizny"
_do_rob:=0;
{? _args.SPR_ROB
|| ZLGD.cntx_psh();
   _names:=ZLGD.names();
   {? _names.first()
   || {!
      |? ZLGD.use(_names.NAME);
         ZLGD.index('ZLECENIE');
         ZLGD.prefix(_zl);
::       Znalezienie pierwszej niezbilansowanej pozycji robocizny
         {? ZLGD.first()
         || {!
            |? _ilegen:=exec('ilegen','magdok_prod').ilegen;
               {? _ilegen>0
               || _do_rob:=1;
                  _can_continue:=0
               ?};
               _can_continue=1 & ZLGD.next()
            !}
         ?};
         _can_continue=1 & _names.next()
      !}
   ?};
   ZLGD.cntx_pop()
?};

:: Pytanie, czy generować do robocizny, czy luzem
_choice:=2;
{? _do_rob>0
|| _choice:=FUN.choice(
      'W systemie są zapisy robocizny, do których nie ma wygenerowanych dokumentów.\n'
      'Należy wskazać sposób generowania dokumentów:'@,,
      'W powiązaniu z &robocizną'@,'&Bez powązań z robocizną'@)
|? _do_rob=0 & _args.WARIANT='W'
|| _msg:='Generacja działa w oparciu o robociznę, zlecenie nie ma robocizny '
         'pozwalającej na raportowanie produktu.'@;

   FUN.emsg(_msg);
   _choice:=0
?};

{? _choice=0
|| _res.RESULT:=-1;
   return(_res)
|? _choice=1
|| _args.WARIANT:='W';
   obj_del(_res);
   _res:=exec('gendok_zl','!tte_wyk_dgrp',_args);
   return(_res)
?};

{? _args.WARIANT='W' & _choice=2
||
:: Jeżeli był wariant wg robocizny ale tej robocizny nie ma, albo użytkownik świadomie
:: wybrał opcję bez robocizny to zmieniam wariant na magazynowy
   _args.WARIANT:='M'
?};

_can_continue:=1;
ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
||
   _args.ZL:=ZL.ref();

   {? _args.DISPLAY=1
   ||
      _edit_res:=exec('edit','!tte_wyk_dgrp',_args);

      {? _edit_res.RESULT>0
      ||
         _args.ZGH:=exec('FindAndGet','#table',ZGH,_edit_res.TAB.ZGH_REF);
         {? _edit_res.TAB.PART_REF<>''
         || _args.ZPARN:=exec('FindAndGet','#table',ZPARN,_edit_res.TAB.PART_REF)
         ?};
         _args.ILOSC:=_edit_res.TAB.ILOSC;
         _args.DATA:=_edit_res.TAB.DT;
         _args.ILP:=_edit_res.TAB.ILP;
         _args.TPAL:=_edit_res.TAB.TPAL;
         _args.ZGP:=exec('first_with_dok','zl_guide',_args.ZL,_args.ZGH);
         {? _args.ZGP=null()
         || _args.ZGP:=exec('last_zgp','zl_guide',_args.ZL,_args.ZGH)
         ?};
         _args.TW:=_edit_res.TAB.TW;

         {? _args.MULTIWYR>0 & _args.WARIANT='M'
         || _args.TAB_WYR:=exec('env_show_tab','zl_wyr',_args.ZGP,_args.ZPARN,_args.TYPYDOK);
            {? type_of(_args.TAB_WYR)=type_of(~~)
            || _can_continue:=0;
               _res.RESULT:=(-1)
            ?}
         ?};

         {? _can_continue>0
         || _res_local:=exec('gendok_core','!tte_wyk_dgrp',_args);
            obj_del(_res);
            _res:=_res_local
         ?}
      || _res.RESULT:=(-1)
      ?}
   ||
      {? _args.ILOSC=0
      ||
         _il:={? ZL.IL>ZL.ILDOK || ZL.IL-ZL.ILDOK || 0 ?};
         _ild:=exec('wylild','!tte_wyk_dgrp');
         _ilosc:=_il-_ild;
         {? _args.ZPARN<>null()
         ||
::          Jeżeli partia podana, to ilość na dokumencie obliczam w oparciu o nią
            _zparn_left:=exec('ilosc_left','zl_partie',_args.ZPARN,'M');
            _ilosc:=exec('min','#math',_ilosc,_zparn_left)
         ?};
         _args.ILOSC:=_ilosc
      ?};
      {? _args.ZGH=null()
      || _args.ZGP:=exec('first_not_completed','zl_guide',_args.ZL,_args.WARIANT);
         _args.ZGH:=exec('FindAndGet','#table',ZGP,_args.ZGP,,"NRPRZ",null())
      ?};
      obj_del(_res);
      _res:=exec('gendok_core','!tte_wyk_dgrp',_args)
   ?}
?};
ZL.cntx_pop();
_res


\wylild
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [12.10]
:: OPIS: Wylicza ilość na dokumentach niezatwierdzonych.
::  OLD: \wylild/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_main_podzlec:={? VAR.A_ZLEC().RP<>'T'
               || exec('main_podzlec','zl_link',VAR.A_ZLEC)
               || VAR.A_ZLEC
               ?};
_result:=0;

_args_dkil:=exec('ilosc_dk_a','zl_common');
_args_dkil.ZL:=_main_podzlec;
_args_dkil.RP:=1;
_args_dkil.AKC:=2;

:: Zbieramy ilości z niezaakceptowanych dokumentów RP
_result+=exec('get_ilosc_dk','zl_common',_args_dkil);

:: Zbieramy ilości z niezaakceptowanych dokumentów ZP
_args_dkil.RESULT:=0;
_args_dkil.RP:=0;
_args_dkil.ZP:=1;
_result-=exec('get_ilosc_dk','zl_common',_args_dkil);
_result


\gendok_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Generuje raport produkcji do zlecenia w powiązaniu z ostatnio zarejestrowaną robocizną
::   WE: _a - obj_new() - tablica argumentów wszystkich funkcji gendok_, wynik działania exec('gendok_args','!tte_wyk_dgrp')
::   WY: obj_new() - wynik działania exec('gendok_struktura_env','!tte_wyk_dgrp')
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_res:=~~;
_can_continue:=1;

_party:=exec('zlec_party','zl_common',_args.ZL);
ZGP.cntx_psh();
ZPARN.cntx_psh();
ZPARN.index('ZGH');

{? var_pres('TAB_PART',_args)=0
|| _args.TAB_PART:=exec('ref_table','#table')
?};
_part_size:=0;
{? _party>0
||
   ZPARN.cntx_psh();
   ZPARN.index('ZL2');
   ZPARN.prefix(_args.ZL);
   {? ZPARN.first()
   || {!
      |? _ilegen:=exec('get_ilosc_zlgd','zl_partie',ZPARN.ref(),,1);

         {? _ilegen>0
         || _args.TAB_PART.add(ZPARN.ref());
            _part_size+=1
         ?};
         ZPARN.next()
      !}
   ?};
   _tab:=_args.TAB_PART.tab;
   _tab.prefix();
   {? _tab.size()>0
   ||
      {? _tab.size()>1
      || _args.DISPLAY:=2
      ?};
      _res:=exec('gendok_zparn','!tte_wyk_dgrp',_args)
   ?};
   ZPARN.cntx_pop();
   ~~
?};

{? _part_size=0
||
   ZGP.index('ZLEC');
   ZGP.prefix(_args.ZL);
   {? ZGP.first()
   ||
      {!
      |?
         _ilegen:=exec('ilegen','magdok_prod',null(),'ZGP').ilegen;
         {? _ilegen>0
         ||
            _args.ZGP:=ZGP.ref();
            _res:=exec('gendok_zgp','!tte_wyk_dgrp',_args);
            _can_continue:=0
         ?};
         ZGP.next() & _can_continue>0
      !}
   ?}
?};
ZPARN.cntx_pop();
ZGP.cntx_pop();
:: Brak zapisów do raportowania - proces będzie kontynuowany
{? type_of(_res)=type_of(~~)
||
   _res:=exec('gendok_struktura_env','!tte_wyk_dgrp');
   _res.TXT:='Brak zapisów robocizny aby utworzyć dokument.';
   {? _args.DISPLAY=1
   || FUN.info(_res.TXT)
   |? _args.DISPLAY=2
   || KOMM.add(_res.TXT,2,,1)
   ?}
?};
_res


\gendok_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Generowanie dokumentów do konkretnego ZGPa
::   WE: _a - obj_new() - tablica argumentów wszystkich funkcji gendok_, wynik działania exec('gendok_args','!tte_wyk_dgrp')
::   WY: obj_new() - wynik działania exec('gendok_struktura_env','!tte_wyk_dgrp')
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_res:=exec('gendok_struktura_env','!tte_wyk_dgrp');
_can_continue:=1;

ZL.cntx_psh();
ZGH.cntx_psh();
ZGP.cntx_psh();
ZGP.prefix();

VAR_DEL.delete('ATR_GRAY');
exec('gray_init','mat_atr');

{? ZGP.seek(_args.ZGP)
||
   _what:=exec('ZGP','#to_string');
:: Ustawienie kontekstu
   ZGP.NRPRZ();
   ZGH.ZLEC();

   {? ZL.RP='T'
   || _prod_zl:=ZGP.ZL
   || _prod_zl:=exec('main_podzlec','zl_link',ZGP.ZL)
   ?};

:: SEKCJA SPRAWDZANIA

:: Sprawdzam czy zlecenie jest zleceniem partiowanym
   _party:=exec('zlec_party','zl_common',_prod_zl);

   {? ZGP.DOK=null()
   || _res.TXT:='Generowanie dokumentu raportującego niemożliwe. Operacja: %1 nie ma przypisanego typu dokumentu magazynowego.'@[_what];
      {? _args.DISPLAY=1
      || FUN.info(_res.TXT)
      |? _args.DISPLAY=2
      || KOMM.add(_res.TXT)
      ?};
      _can_continue:=0
   ?};

   {? ZGP.ZL().RP<>'T'
   ||
      _res.TXT:='Generowanie dokumentu raportującego niemożliwe. Zlecenie: %1 nie jest zleceniem na którym powstają dokumenty.'@[exec('ZL','#to_string')];
      {? _args.DISPLAY=1
      || FUN.info(_res.TXT)
      |? _args.DISPLAY=2
      || KOMM.add(_res.TXT)
      ?};
      _can_continue:=0
   ?};

   _args.ZGH:=ZGP.NRPRZ;
   _args.TYPYDOK:=ZGP.DOK;

   _ile_part:=0;
   _tab_partie:=exec('ref_table','#table');

   _rule:="
      _tab_partie:=_b;
      ZLGD.cntx_psh();
      ZLGD.index('S2');
      ZLGD.prefix(ZGP.ref());
      {? ZLGD.first()
      || {!
         |? _zlgd_left:=ZLGD.IL-ZLGD.ILGEN;
            {? ZLGD.ZGP().DOK<>null() & _zlgd_left>0 & ZLGD.ZPARN<>null()
            || _tab_partie.add(ZLGD.ZPARN)
            ?};
            ZLGD.next()
         !}
      ?};
      ZLGD.cntx_pop()
   ";
   exec('for_each_mask','#table',ZLGD,_rule,,,_tab_partie);

   _tab_partie.tab.prefix();

:: Przypisanie partii do _args
   {? _party>0 & _args.ZPARN=null() & ZGP.ZL=_prod_zl
   ||
      ZPARN.cntx_psh();
      ZPARN.index('ZGH');
      ZPARN.prefix(ZGH.ref());
      {? ZPARN.first() & ZPARN.size()=1
      ||
::       Jeżeli partia nie przekazana, ale przewodnik ma tylko jedną to ją automatycznie biorę
         _args.ZPARN:=ZPARN.ref()
      ?};
      ZPARN.cntx_pop()
   ?};
   {? _args.WARIANT='W' & _party>0 & _args.ZPARN=null()
   || {? _tab_partie.tab.size()=1 & _tab_partie.tab.first()
      || _args.ZPARN:=exec('FindAndGet','#table',ZPARN,_tab_partie.tab.SQL,,,null())
      ?}
   ?};

   {? _can_continue>0
   ||

      {? _args.WARIANT='W'
      ||
::       Wariant robocizny
         _rob_ready:=0;
::       Obliczenie ilości i wyznaczenie typów dokumentów
         _obj:=exec('ilegen','magdok_prod',,'ZGP');
         _ilosc:=_obj.ilegen;
         _typ_tab:=_obj.typ_tab;
         {? _typ_tab.first()
         || {? _typ_tab.TYP=#_args.TYPYDOK | _args.TYPYDOK=null()
            || _args.ILOSC:=_typ_tab.ILE;
               _rob_ready:=1
            || _res.TXT:=
                  'Nie można wygenerować dokumentu:\n'
                  '- typ dokumentu wskazany w procesie: %1\n'
                  '- typ dokumentu przypisany do operacji: %2'@
                  [exec('FindAndGet','#table',TYPYDOK,_args.TYPYDOK,,"T",''),
                   exec('FindAndGet','#table',TYPYDOK,_typ_tab.TYP,,"T",'')];
               {? _args.DISPLAY=1
               || FUN.info(_res.TXT)
               |? _args.DISPLAY=2
               || KOMM.add(_res.TXT)
               ?}
            ?}
         ?};
         {? _rob_ready=0
         || _can_continue:=0;
            _msg:='Generacja działa w oparciu o robociznę, pozycja przewodnika nie ma robocizny '
                  'pozwalającej na raportowanie produktu.'@;
            _res.TXT:=_msg;
            {? _args.DISPLAY=1
            || FUN.emsg(_msg)
            |? _args.DISPLAY=2
            || KOMM.add(_msg,2,,1)
            ?}
         ?};
::
::         {? _can_continue>0 & _args.DISPLAY=1 & _tab_partie.tab.size()<=1
::         ||
::::          Okienko edycyjne
::            _edit_res:=exec('edit','!tte_wyk_dgrp',_args,0);
::
::            {? _edit_res.RESULT>0
::            ||
::               _args.ZGH:=exec('FindAndGet','#table',ZGH,_edit_res.TAB.ZGH_REF);
::               {? _edit_res.TAB.PART_REF<>''
::               || _args.ZPARN:=exec('FindAndGet','#table',ZPARN,_edit_res.TAB.PART_REF)
::               ?};
::               _args.ILOSC:=_edit_res.TAB.ILOSC;
::               _args.DATA:=_edit_res.TAB.DT;
::               ~~
::            || _can_continue:=0
::            ?}
::         ?};

         {? _can_continue>0
         ||
::          Kontrola ilości - w wariancie 'W' nie może przekroczyć ilości na robociznie
            _left:=0;
            {? _args.ZPARN<>null()
            || _left:=exec('ilosc_left','zl_partie',_args.ZPARN,_args.WARIANT)
            ||
               _left:=exec('ilegen','magdok_prod',null(),'ZGP').ilegen;
               _left:=exec('max','#math',0,_left)
            ?};

            {? _args.ILOSC>_left
            || _can_continue:=0;
               _res.TXT:='Ilość na dokumencie (%1) nie może przekraczać ilości dozwolonej (%2).'@[$_args.ILOSC,$_left];
               {? _args.DISPLAY=1
               || FUN.info(_res.TXT)
               |? _args.DISPLAY=2
               || KOMM.add(_res.TXT)
               ?}
            ?}
         ?}

      |? _args.WARIANT='M'
      ||
::       Wariant magazynowy
         {? _args.DISPLAY=1
         ||
::          Okienko edycyjne
            _edit_res:=exec('edit','!tte_wyk_dgrp',_args,0);

            {? _edit_res.RESULT>0
            ||
               _args.ZGH:=exec('FindAndGet','#table',ZGH,_edit_res.TAB.ZGH_REF);
               {? _edit_res.TAB.PART_REF<>''
               || _args.ZPARN:=exec('FindAndGet','#table',ZPARN,_edit_res.TAB.PART_REF)
               ?};
               _args.ILOSC:=_edit_res.TAB.ILOSC;
               _args.DATA:=_edit_res.TAB.DT;
               _args.TW:=_edit_res.TAB.TW;
               ~~
            || _can_continue:=0
            ?}
         || _args.ILOSC:=exec('ilosc_left','zl_guide',_args.ZGP,_args.WARIANT)
         ?}
      ?};

      {? _can_continue>0 & _args.ZPARN<>null()
      ||
         _zparn_left:=exec('ilosc_left','zl_partie',_args.ZPARN,_args.WARIANT);
         _args.ILOSC:=exec('min','#math',_args.ILOSC,_zparn_left);
         {? _zparn_left=0
         || _can_continue:=0;
            _zparn_sym:=exec('FindAndGet','#table',ZPARN,_args.ZPARN,,"SYM",0);
            _res.TXT:='Utworzono już dokumenty raportujące produkcję na całą ilość partii %1.'@[_zparn_sym];
            {? _args.DISPLAY=1
            || FUN.emsg(_res.TXT)
            |? _args.DISPLAY=2
            || KOMM.add(_res.TXT,2,,1)
            ?}
         ?}
      ?}
   ?};

:: Start generowania raportu
   {? _can_continue>0
   ||
      VAR.A_DOK:=ZGP.DOK;
      _args.ZL:=ZGP.ZL;
      _args.M:=ZGP.ZL().KTM;
      {? _can_continue>0
      ||
         _args.TYPYDOK:=VAR.A_DOK;

         _jm:=exec('FindAndGet','#table',M,_args.M,,"J().KOD",'');
         _typ_naz:=exec('FindAndGet','#table',TYPYDOK,_args.TYPYDOK,,"NAZ",'');

         _sigle_dok:=1;

         {? _args.WARIANT='W' & _tab_partie.tab.size()>1
         || _sigle_dok:=0
         ?};

         {? _sigle_dok>0
         ||
::          Jedna pozycja dokumentu

::          Ostrzeżenie o zbyt dużej ilości
::            _args_il:=exec('ilosc_dk_a','zl_common');
::            _args_il.ZGH:=ZGP.NRPRZ;
::            _args_il.ZL:=ZGP.ZL;
::            _ilrap:=(_args_il.RP:=1; exec('get_ilosc_dk','zl_common',_args_il))
::                    -(_args_il.RP:=0; _args_il.ZP:=1; exec('get_ilosc_dk','zl_common',_args_il));
::            _ilnprz:=ZGH.ILNPRZ;
::            {? _ilrap+_args.ILOSC>_ilnprz
::            || _msg:='Łączna ilość do wygenerowania (%1) i wcześniej zaraportowana (%2)\n'
::                           'nie powinna być większa niż na przewodniku (%3).'@
::                           [$_args.ILOSC,$_ilrap,$_ilnprz];
::               {? _args.DISPLAY=1
::               || FUN.info(_msg)
::               |? _args.DISPLAY=2
::               || KOMM.add(_msg,2,,1)
::               ?}
::            ?};

::          Generowanie dokumentu
            _locked:=null;
            {? _args.DISPLAY=1
            || {? exec('blk_lock','#table','ZGH',ZGP.NRPRZ,,,'Przewodnik %1 jest redagowany'@[exec('record','#to_string',ZLGD.ZGH)])>0
               || _locked:=ZGP.NRPRZ
               || _can_continue:=0
               ?}
            ?};

            {? _can_continue>0
            || {? var_pres('_res_local')>100
               || obj_del(_res_local)
               ?};
               _res_local:=exec('gendok_core','!tte_wyk_dgrp',_args);
               obj_del(_res);
               _res:=_res_local
            ?};

            {? _locked<>null()
            || exec('blk_unlock','#table','ZGH',_locked)
            ?};

::          Jeżeli dokument raportujący produkcję powstał, to aktualizacja ilości na zleceniu
            _tab_dok:=_res.TAB_DOK;
            VAR.A_DOK:=_args.TYPYDOK;
            _tab_dok.index(_res.NDX_DOK_ZGP);
            _tab_dok.prefix($ZGP.ref(),_res.TYP_DK);
            _ilosc:=0;
            {? _tab_dok.first()
            || {!
               |? {? _tab_dok.DK<>''
                  || exec('robocizna_dk_add','magdok_prod',_tab_dok.DK,ZGP.ref());
::                     _ilosc:=_tab_dok.ILOSC;
::                     _nd:=exec('FindAndGet','#table',DK,_tab_dok.DK,,"N",null);
::                     exec('nawzlgd','zl_wyk',_ilosc,_nd,'ZGP');
                     ~~
                  ?};
                  _tab_dok.next()
               !}
            ?};
            ~~
         ||
::          Wiele pozycji dokumentu
            ATR_GRAY.types:='P,';
            _tab:=_tab_partie.tab;
            _args.DISPLAY:=2;
            _zparn_first:=null();
            {? _tab.first()
            || _zparn_first:=exec('FindAndGet','#table',ZPARN,_tab.SQL,,,null())
            ?};
            {? _can_continue>0
            ||
               ZL.KTM().M_ATR();
               _buf_matr:=exec('buffer','mat_atr');
               _buf_matr.get_matr();

               DK_C.cntx_psh();
               {? ZL.DK_C<>null()
               || ZL.DK_C();
                  _buf_matr.get_dkc()
               ?};
               DK_C.cntx_pop();

               {? _args.DISPLAY>0 & _buf_matr.count()>0 & _buf_matr.all_set()=0 & ZL.MG().TYP*'DOST'>0
               || _dk_c:=exec('edit_cecha','!tte_wyk_dgrp',_args,,_zparn_first);
                  {? _dk_c=null()
                  || _can_continue:=0
                  ?}
               ?}
            ?};

            {? _can_continue>0 & _tab.first()
            ||
               _args.TAB_PART:=_tab_partie;
               _args.TYPYDOK:=ZGP.DOK;
::             Generowanie dokumentów
               _res_local:=exec('gendok_core','!tte_wyk_dgrp',_args);
               obj_del(_res);
               _res:=_res_local;

::             Jeżeli dokument raportujący produkcję powstał, to aktualizacja ilości na zleceniu
               _tab_dok:=_res.TAB_DOK;
               VAR.A_DOK:=_args.TYPYDOK;
               _tab_dok.index(_res.NDX_DOK_ZGP);
               _tab_dok.prefix($ZGP.ref(),_res.TYP_DK);
               _ilosc:=0;
               {? _tab_dok.first()
               || {!
                  |? {? _tab_dok.DK<>''
                     ||
                        exec('robocizna_dk_add','magdok_prod',_tab_dok.DK,ZGP.ref());

::                        _ilosc:=_tab_dok.ILOSC;
::                        _nd:=exec('FindAndGet','#table',DK,_tab_dok.DK,,"N",null);
::                        exec('nawzlgd','zl_wyk',_ilosc,_nd,'ZGP');
                        ~~
                     ?};
                     _tab_dok.next()
                  !}
               ?}
            ?}
         ?}
      ?};
      ~~
   ||
::    Nie ma potrzeby generowania dokumentów
      _res.RESULT:=1
   ?}
?};
VAR_DEL.delete('ATR_GRAY');
ZL.cntx_pop();
ZGP.cntx_pop();
ZGH.cntx_pop();
_res


\gendok_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: generuje automatycznie dokument raportujący na magazynie (funkcja najniższego poziomu)
::   WE: _a - obj_new() - tablica argumentów wszystkich funkcji gendok_, wynik działania exec('gendok_args','!tte_wyk_dgrp')
::   WY: obj_new() - wynik działania exec('gendok_struktura_env','!tte_wyk_dgrp')
::  OLD: \utwrap/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_zl:=_args.ZL;

_mag:=exec('zl_mg','zl_common',_zl);
_wyd:=exec('zl_wyd','zl_common',_zl);

_env_strukt:=exec('gendok_struktura_env','!tte_wyk_dgrp');

_ilosc:=_args.ILOSC;
_data:=_args.DATA;
_typydok:=_args.TYPYDOK;
_zparn:=_args.ZPARN;
_zgh:=_args.ZGH;
{? _zgh=null() & _args.ZGP<>null()
|| _zgh:=exec('FindAndGet','#table',ZGP,_args.ZGP,,"NRPRZ",null())
?};
_nd:=_args.ND;
_dk_c:=_args.DK_C;
_display:=_args.DISPLAY;
_ilp:=_args.ILP;
_tpal:=_args.TPAL;
_twrp:=_args.TW;

_ok:=0;
_can_continue:=1;
_result:=exec('result_gendok','magdok_wspolne');

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
||
   _args.M:=ZL.KTM;
:: Wstępne ustalenie daty dokumentu
   {? _args.DATA=date(0,0,0)
   || _args.DATA:={? date()>date(ST.AR,ST.AM,0)
                  || date(ST.AR,ST.AM,0)
                  |? date()<date(ST.AR,ST.AM,1)
                  || date(ST.AR,ST.AM,1)
                  || date()
                  ?}
   ?};

   _what:='';
   {? _args.ZPARN<>null()
   || _what:=exec('record','#to_string',_args.ZPARN)
   |? _args.ZGH<>null()
   || _what:=exec('record','#to_string',_args.ZGH)
   |? _args.ZL<>null()
   || _what:=exec('record','#to_string',_args.ZL)
   ?};

:: SEKCJA SPRAWDZANIA
   {? ZL.STAN<>'O'
   || _can_continue:=0;
      _msg:='Zlecenie: %1 nie jest otwarte, generowanie raportów produkcji niemożliwe.'@[ZL.SYM];
      _result.TXT:=_msg;
      {? _args.DISPLAY=1
      || FUN.emsg(_result.TXT)
      |? _args.DISPLAY=2
      || KOMM.add(_result.TXT,2,,1)
      ?}
   ?};

   _otwarty:=exec('czy_z_ok','okresy',1,0,ST.AR,ST.AM,_mag);
   {? ~_otwarty
   || _can_continue:=0;
      _mag_sym:=exec('FindAndGet','#table',MG,_mag,,"SYM",'');
      _msg:='Nie udało się utworzyć dokumentu raportującego.\n\n'
            'Okres %1/%2 w magazynie %3 jest zamknięty.'@[$ST.AR,$ST.AM,_mag_sym];
      {? _display=1
      || FUN.emsg(_msg)
      |? _display=2
      || KOMM.add(_msg,2,,1)
      ?}
   ?};

   {? _can_continue>0 & _zgh<>null()
   || _can_continue:=exec('blk_lock','#table','ZGH',_zgh,,,'Przewodnik %1 jest redagowany'@[exec('record','#to_string',_zgh)],,_display-1)
   ?};

   {? exec('is_usluga_zl','zl_uslugi')
   || {? _typydok<>exec('get_typydok','zl_uslugi')
      || _usl_typ:=exec('get_typydok_sym','zl_uslugi');
         _result.TXT:='Zlecenia na usługi mogą być raportowane wyłącznie dokumentami typu: %1'@[_usl_typ];
         {? _args.DISPLAY=1
         || FUN.emsg(_result.TXT)
         |? _args.DISPLAY=2
         || KOMM.add(_result.TXT,2,,1)
         ?};
         _can_continue:=0
      ?}
   ?};
   {? ZL.RP<>'T'
   || _result.TXT:=
         'Nie można utworzyć dokumentu raportującego produkcję na zleceniu %1,\n'
         'na którym nie powstaje produkt lub półprodukt raportowany na magazyn'@[ZL.SYM];
      {? _args.DISPLAY=1
      || FUN.emsg(_result.TXT)
      |? _args.DISPLAY=2
      || KOMM.add(_result.TXT,2,,1)
      ?};
      _can_continue:=0
   ?};

   {? _args.M=null()
   || _result.TXT:='Nie można utworzyć dokumentu dla zlecenia %1 nie powiązanego z produktem.'@[ZL.SYM];
      {? _args.DISPLAY=1
      || FUN.emsg(_result.TXT)
      |? _args.DISPLAY=2
      || KOMM.add(_result.TXT,2,,1)
      ?};
      _can_continue:=0
   ?};

   _time:=exec('spr_dttm','magazyn_inw',ZL.MG,_args.DATA,1);
   {? (*_time)>(*time(23,59,0))
   || _time:=time(0,0,0)
   ?};

   {? _args.DATA<ZL.OD
   || _result.RESULT:=(-1);
      _result.TXT:='Zlecenie %1 powołane jest z datą późniejszą niż data dokumentu.'@[ZL.SYM];
      {? _args.DISPLAY=1
      || FUN.emsg(_result.TXT)
      |? _args.DISPLAY=2
      || KOMM.add(_result.TXT,2,,1)
      ?};
      _can_continue:=0
   ?};

   {? ~exec('spr_datn','magdok_wspolne',ZL.MG,_args.DATA,_typydok,_args.DISPLAY,,0
       ,'Niemożliwe utworzenie dokumentu raportującego produkcję.'@,,_time)
   || _result.RESULT:=(-1);
      _result.TXT:='Niemożliwe utworzenie dokumentu raportującego produkcję.'@;
      {? _args.DISPLAY=1
      || FUN.emsg(_result.TXT)
      |? _args.DISPLAY=2
      || KOMM.add(_result.TXT,2,,1)
      ?};
      _can_continue:=0
   ?};

:: SEKCJA GENEROWANIA
   {? _can_continue>0
   ||
      _part_ok:=1;
      ZPARN.cntx_psh(); ZPARN.clear();
      M.cntx_psh();
::    Sprawdzam czy zlecenie ma cechę lub jest partiowane
      _party:=exec('zlec_party','zl_common',ZL.ref());

      exec('gendok_struktura','!tte_wyk_dgrp',_args,_env_strukt);
::      _can_continue:=_env_strukt.select();

      {? _can_continue>0
      ||
         ND.cntx_psh(); DK.cntx_psh();
         ND.use('nagdo'+ST.ODDZ+($(ST.AR)+2));
         DK.use('dokma'+ST.ODDZ+($(ST.AR)+2));

         _tab:=_env_strukt.TAB_DOK;
         _tab.index(_env_strukt.NDX_DOK_TYP);
         _tab.prefix(_env_strukt.TYP_ND,);

         {? _can_continue>0
         ||
::          Sekcja sprawdzania
            {? _tab.first()
            ||
               {!
               |?
                  _tab.cntx_psh();
                  _par:=_tab.UID;
                  _del_poz:=0;
                  _mag:=exec('FindAndGet','#table',MG,_tab.MG,,,_mag);
                  _typydok:=exec('FindAndGet','#table',TYPYDOK,_tab.TYPYDOK,,,_typydok);
                  {? _mag=null()
                  || _msg:='Nie udało się utworzyć dokumentu raportującego.\n\nNie określono magazynu dla zlecenia.'@;
                     {? _display=1
                     || FUN.emsg(_msg)
                     |? _display=2
                     || KOMM.add(_msg,2,,1)
                     ?};
                     _del_poz:=1
::                Sprawdzenie uprawnień do typu dokumentu na magazynach
                  |? ~exec('chk_mg4typ','magdok_wspolne',_mag,_typydok)
                  || _mg_sym:=exec('FindAndGet','#table',MG,_mag,,"SYM",'');
                     _typydok_sym:=exec('FindAndGet','#table',TYPYDOK,_typydok,,"T",'');
                     _msg:='Brak dostępu do dokumentu: %1 na magazynie: %2.'@[_typydok_sym,_mg_sym];
                     {? _display=1
                     || FUN.emsg(_msg)
                     |? _display=2
                     || KOMM.add(_msg,2,,1)
                     ?};
                     _del_poz:=1
                  ?};

                  _tab.index(_env_strukt.NDX_DOK_PAR);
                  _tab.prefix(_par);

                  {? _tab.first()
                  || {!
                     |? _next:=0;
                        _ref_nxt:=null();
                        _tab.cntx_psh();
                        {? _tab.next()
                        || _ref_nxt:=_tab.ref()
                        ?};
                        _tab.cntx_pop();
                        {? _del_poz>0
                        ||
::                         Błąd w nagłówku, usuwanie pozycji
                           _can_continue:=_tab.del(,1)
                        ||
                           _ilosc:=_tab.ILOSC;
                           {? _ilosc<=0
                           || _result.RESULT:=1;
                              _result.TXT:='Utworzono już dokumenty raportujące produkcję na całą dostępną ilość dla:  %1.'@[_what];
                              {? _args.DISPLAY=1
                              || FUN.emsg(_result.TXT)
                              |? _args.DISPLAY=2
                              || KOMM.add(_result.TXT,2,,1)
                              ?};
                              _can_continue:=_tab.del(,1)
                           ?};

                           _zgh:=exec('FindAndGet','#table',ZGH,_tab.ZGH,,,_zgh);
                           {? _zgh=null()
                           || _can_continue:=0;
                              _msg:='Nie ustalono przewodnika, generowanie raportów produkcji niemożliwe.'@;
                              _result.TXT:=_msg;
                              {? _args.DISPLAY=1
                              || FUN.emsg(_result.TXT)
                              |? _args.DISPLAY=2
                              || KOMM.add(_result.TXT,2,,1)
                              ?};
                              _can_continue:=_tab.del(,1)
                           ?};

                           {? _can_continue>0
                           ||
                              _zparn:=exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,,_zparn);
                              _zgp:=exec('FindAndGet','#table',ZGP,_tab.ZGP,,,_args.ZGP);
                              {? _can_continue>0 & exec('get','#params',500712,type_of(''))='T' & _args.DISPLAY=1 & _args.WARIANT='W'
                              || _left:=exec('ilosc_left','!tte_wyk_dgrp',_args.WARIANT,_zgp,_zparn);
                                 ZGP.cntx_psh(); ZGP.prefix();
                                 {? ZGP.seek(_zgp)
                                 || _what:=exec('ZGP','#to_string');
                                    {? _tab.ILOSC>_left
                                    || _msg:='Ilość raportowana: %1 jest większa niż pozostała do zaraportowania: %2 na przewodniku: %3\n\n'
                                             'Czy na pewno wystawić dokument?'@[$_tab.ILOSC,$_left,_what];
                                       _can_continue:=FUN.ask(_msg)
                                    |? _tab.ILOSC+ZGP.ILGEN>ZGP.ILOSC
                                    || _msg:='Przewodnik: %1 po zaraportowaniu ilości: %2 będzie miał na dokumentach: %3\n\n'
                                             'Czy na pewno wystawić dokument?'@[_what,$_tab.ILOSC,$(_tab.ILOSC+ZGP.ILGEN)];
                                       _can_continue:=FUN.ask(_msg)
                                    ?}
                                 ?};
                                 ZGP.cntx_pop()
                              ?}
                           ?}
                        ?};

                        {? _ref_nxt<>null()
                        || _next:=_tab.seek(_ref_nxt)
                        ?};
                        _next>0 & _can_continue>0
                     !}
                  ?};
                  _tab.cntx_pop();
                  _tab.next()
               !}
            ?};
::          Usuwam puste nagłówki, bez pozycji
            _tab.index(_env_strukt.NDX_DOK_TYP);
            _tab.prefix(_env_strukt.TYP_ND,);
            {? _can_continue>0 & _tab.first()
            || {!
               |? _next:=0;
                  _ref_nxt:=null();
                  _tab.cntx_psh();
                  {? _tab.next()
                  || _ref_nxt:=_tab.ref()
                  ?};
                  _tab.cntx_pop();

                  _del:=0;
                  _tab.cntx_psh();
                  _par:=_tab.UID;
                  _tab.index(_env_strukt.NDX_DOK_PAR);
                  _tab.prefix(_par);
                  {? _tab.first()=0
                  || _del:=1
                  ?};
                  _tab.cntx_pop();

                  {? _del>0
                  || _can_continue:=_tab.del(,1)
                  ?};

                  {? _ref_nxt<>null()
                  || _next:=_tab.seek(_ref_nxt)
                  ?};
                  _next>0 & _can_continue>0
               !}
            ?}
         ?};

         _buf_matr:=exec('buffer','mat_atr');
         {? _can_continue>0 & _tab.first()
         || {!
            |?
               _zl:=exec('FindAndGet','#table',ZL,_tab.ZL,,,_zl);
               _mag:=exec('FindAndGet','#table',MG,_tab.MG,,,_mag);
               _wyd:=exec('zl_wyd','zl_common',_zl);
               _typydok:=exec('FindAndGet','#table',TYPYDOK,_tab.TYPYDOK,,,_typydok);
::             Tworzenie nagłowka dokumentu
               _wolne_nr:=_args.DISPLAY;
               {? _wolne_nr=2
               || _wolne_nr:=0
               ?};
               _time:=exec('spr_dttm','magazyn_inw',_mag,_data,1);
               {? (*_time)>(*time(23,59,0)) || _time:=time(0,0,0) ?};
               _nd:=exec('addnag','magdok_nag',_mag,ST.AR,ST.AM,_typydok,'N',,_data,,,,,,,_zl,_wyd,,,,_wolne_nr,_time);

               {? _nd<>null()
               || _tab.ND:=$_nd;
                  _can_continue:=_tab.put();

                  _tab.cntx_psh();
                  _par:=_tab.UID;
                  _tab.index(_env_strukt.NDX_DOK_PAR);
                  _tab.prefix(_par);
                  {? _can_continue>0 & _tab.first()
                  || {!
                     |?
                        ZL.clear();
                        {? ZL.seek(_zl)
                        ||
::                         Tworzenie pozycji dokumentu
                           _ilosc:=_tab.ILOSC;
                           {? _ilosc>0
                           ||
                              _material:=exec('FindAndGet','#table',M,_tab.M,,,_args.M);
                              _zgh:=exec('FindAndGet','#table',ZGH,_tab.ZGH,,,_zgh);
                              _zparn:=exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,,_zparn);
                              _zgp:=exec('FindAndGet','#table',ZGP,_tab.ZGP,,,_args.ZGP);
                              {? var_pres('_res_dk')>100
                              || obj_del(_res_dk)
                              ?};

                              {? _party>0
                              ||
::                               Jeśli zlecenie ma partie to najpierw wyświetlam słownik partii
                                 _part_ok:=0;
                                 _select:=0;
                                 {!
                                 |? _jm:=ZL.KTM().J().KOD;
                                    _repeat:=0;

                                    {? _zparn=null()
                                    ||
::                                     Partia nie podana - probuję ją ustalić automatycznie (pierwsza nie wykonana w całości)
                                       _zparn:=exec('first_not_completed','zl_partie',ZL.ref(),_zgh,_args.WARIANT)
                                    ?};
                                    {? _zparn=null()
                                    ||
::                                     Partia w arg nie podana, więc o nią pytam bo automat nie ustalił
                                       _select:=exec('select_zgh','zl_partie',_zgh,1);
                                       {? _select>0
                                       || _zparn:=ZPARN.ref()
                                       ?}
                                    ||
::                                     Partia w arg podana, więc się na niej ustawiam
                                       {? ZPARN.seek(_zparn)
                                       || _select:=1
                                       ?}
                                    ?};

                                    {? _select>0
                                    ||
::                                     Sprawdzam czy wybrana partia ma jeszcze dostępną ilość do rozliczenia
                                       _part_rp:=exec('get_ilosc_rp','zl_partie',ZPARN.ref());
                                       _left:=exec('ilosc_left','zl_partie',,_args.WARIANT);
                                       {? _ilosc>_left
                                       ||
                                          {? exec('can_over_rap','zl_partie')
                                          ||
::                                           Nadwykonania dla partii
                                             {? _display=1
                                             || ~~
                                             |? _display=2
                                             || _msg:='Utworzono nadwykonanie na partii: %1. Ilość na partii: %2 %4, ilość raportowana: %3 %4'@[ZPARN.SYM,$ZPARN.IL,$_ilosc,_jm];
                                                KOMM.add(_msg,1,,1)
                                             ?}
                                          ||
::                                           Brak nadwykonań dla partii
                                             {? _display=1
                                             ||
                                                _msg:=
                                                   'Ilość na dokumencie przekracza dozwoloną ilość dla partii. \n\n'
                                                   'Ilość na tworzonym dok.: %1 %6. \n'
                                                   'Ilość na partii: %2 %6. \n'
                                                   'Ilość poprzednio zaraportowana dla partii: %3 %6. \n'
                                                   'Dla partii: %4 pozostało do zaraportowania: %5 %6.'@
                                                   [$_ilosc,$ZPARN.IL,$_part_rp,ZPARN.SYM,$_left,_jm]
                                             |? _display=2
                                             || _msg:='Ilość na dokumencie przekracza dozwoloną ilość dla partii: %1'@[ZPARN.SYM]
                                             ?};
                                             _choice:=0;
                                             {? _display=1
                                             || _choice:=FUN.choice(_msg,,'Wybierz inną partię'@,'Zmień ilość raportowaną'@)
                                             |? _display=2
                                             || KOMM.add(_msg,2,,1)
                                             ?};
                                             {? _choice=1
                                             ||
::                                              Powtarzamy wybór partii
                                                _repeat:=1;
                                                _zparn:=null()
                                             |? _choice=2
                                             ||
::                                              Edytujemy ilość na dokumencie RP
                                                undefine();
                                                define('H1',~~,'Ilość na dokumencie'@);
                                                define('ILOSC',_left,'Podaj ilość [%1]'@[_jm],,,8,ZL.KTM().DOKL);
                                                def_btn('text=%1'['Zapisz'@],'key:F2');
                                                def_btn('text=%1'['Anuluj'@],'key:Esc');
                                                _validate:="_result:='';
                                                            _part_rp:=exec('get_ilosc_rp','zl_partie',ZPARN.ref());
                                                            _left:=ZPARN.IL-_part_rp;
                                                            {? DEFINE.ILOSC<=0
                                                            || FUN.emsg('Ilość do na dokumencie musi być wieksza od zera.'@);
                                                               _result:='ILOSC'
                                                            ?};
                                                            {? DEFINE.ILOSC>ZL.IL
                                                            || FUN.emsg('Ilość na dokumencie nie może być większa od ilości zlecenia.'@);
                                                               _result:='ILOSC'
                                                            ?};
                                                            {? DEFINE.ILOSC>_left
                                                            ||
                                                               _msg:=
                                                                  'Ilość na dokumencie nie może być większa od ilości pozostałej do '
                                                                  'zaraportowania.\nDla partii: %1 pozostało do zaraportowania: %2'@
                                                                  [ZPARN.SYM,$_left];
                                                               FUN.emsg(_msg);
                                                               _result:='ILOSC'
                                                            ?};
                                                            _result";
                                                _can_continue:=def_edit(_validate,'Zmiana ilości na dokumencie raportującym'@);
                                                {? _can_continue>0
                                                || _ilosc:=DEFINE.ILOSC
                                                ?};
                                                undefine()
                                             |? _choice=0
                                             || _select:=0;
                                                _can_continue:=0
                                             ?}
                                          ?}
                                       ?}
                                    ?};
                                    _repeat>0 & _select>0 & _can_continue>0
                                 !};

                                 {? _select>0
                                 || ATR.ZPARN_DK:=ZPARN.ref()
                                 || ATR.ZPARN_DK:=null();
                                    _can_continue:=0
                                 ?}
                              ?};

                              {? _can_continue>0
                              ||
::                               Tworzenie lub kopiowanie cechy
                                 {? _zparn<>null()
                                 || _dk_p:=exec('FindAndGet','#table',ZPARN,_zparn,,"DK_C",null());
                                    {? _dk_p=null() & _dk_c=null()
                                    ||
::                                     Tworzę nową cechę tylko jeżeli cecha na wejście nie przekazana i jest jeden atrybut - partia
                                       _dk_c:=exec('dkc_create','zl_partie',_zparn)
                                    ||
::                                     Kopiuję przekazaną na wejściu cechę podmieniając jej partię
                                       _dk_c:=exec('dkc_copy','zl_partie',{? _dk_p<>null() || _dk_p || _dk_c ?},_zparn)

                                    ?}
                                 ||
::                                  Zlecenie bez partii
                                    {? _dk_c=null() & ZL.DK_C<>null()
                                    ||
::                                     Przypisuję cechę ze zlecenia tylko jeżeli cecha na wejściu nie przekazana
                                       _dk_c:=ZL.DK_C
                                    ?}
                                 ?};
::                               Edycja cechy
                                 ZL.KTM().M_ATR();
                                 _buf_matr.get_matr();

                                 DK_C.cntx_psh();
                                 {? ZL.DK_C<>null()
                                 || ZL.DK_C();
                                    _buf_matr.get_dkc()
                                 ?};
                                 DK_C.cntx_pop();

                                 {? _dk_c<>null()
                                 || DK_C.cntx_psh(); DK_C.prefix();
                                    {? DK_C.seek(_dk_c)
                                    || _buf_matr.get_dkc()
                                    ?};
                                    DK_C.cntx_pop()
                                 ?};
                                 {? _args.DISPLAY=1 & _buf_matr.count()>0 & _buf_matr.all_set()=0 & ZL.MG().TYP*'DOST'>0
                                 || _args.DK_C:=_dk_c;
                                    _dk_c:=exec('edit_cecha','!tte_wyk_dgrp',_args,,_zparn);
                                    {? _dk_c<>null()
                                    || {? _party>0
                                       || _zparn:=ATR.ZPARN_DK
                                       ?}
                                    || _can_continue:=0
                                    ?}
                                 ?}
                              ?};

                              {? _can_continue>0
                              ||
                                 _res_dk:=exec('adddk4zl','magdok_prod',_zl
                                                                     ,_wyd
                                                                     ,_ilosc
                                                                     ,_material
                                                                     ,_nd
                                                                     ,_mag
                                                                     ,
                                                                     ,
                                                                     ,
                                                                     ,
                                                                     ,_zgh
                                                                     ,_zparn
                                                                     ,_zgp
                                                                     ,
                                                                     ,
                                                                     ,
                                                                     ,
                                                                     ,_twrp);
                                 {? _res_dk.RESULT>0
                                 ||
                                    _tab.DK:=$_res_dk.DK;
                                    _can_continue:=_tab.put();

                                    {? _party>0 | exec('is_atrybut','zl_common')
                                    ||
                                       DK_C.cntx_psh();
                                       DK.cntx_psh();
                                       DK.prefix();
                                       {? DK.seek(_res_dk.DK)
                                       ||
::                                        Jeśli udało się stworzyć cechę lub przekazano ją argumentem to stempluje nia dokument
                                          {? _dk_c<>null()
                                          || DK.PARTIA:=_zparn;
                                             DK.DK_C:=_dk_c;
                                             {? DK.M().IDMOB='P' & DK.PARTIA<>null() & DK.PARTIA().SCEAN<>''
                                             || DK.SCEAN:=DK.PARTIA().SCEAN
                                             |? DK.M().IDMOB='D' & DK.M().IDZP & DK.PARTIA<>null() & DK.PARTIA().ZPEAN<>''
                                             || DK.SCEAN:=DK.PARTIA().ZPEAN;
                                                _tw:=exec('twSCEANZP','magdok_wspolne',DK.SCEAN,DK.PRDK,DK.M);
                                                {? _tw<>date(1,1,1) || DK.TW:=EANX.TW:=_tw ?}
                                             ?};
                                             {? DK.DK_C<>null() | DK.PARTIA<>null()
                                             || {? DK.put() & DK.PARTIA<>null()
                                                ||
::                                                 Podział partii - jeżeli dopuszczalny
                                                   ZPARN.cntx_psh(); ZPARN.prefix();
                                                   {? ZPARN.seek(_zparn)
                                                   || {? ZPARN.IL>exec('get_ilosc_rp','zl_partie',ZPARN.ref())
                                                      ||
::                                                       Nie dzielę partii która jest już w całości wykonana
                                                         exec('split','zl_partie',DK.PARTIA,DK.IL)
                                                      ?}
                                                   ?};
                                                   ZPARN.cntx_pop()
                                                ?}
                                             ?};
                                             _result.DK_C:=DK.DK_C;
                                             ~~
                                          ?}
                                       ?};
                                       DK_C.cntx_pop();
                                       DK.cntx_pop()
                                    ?};
::                                  zapis o wymiarach o ile istnieją
                                    {? _res_dk.RESULT>0
                                    || DK.cntx_psh();
                                       DK.prefix();
                                       {? DK.seek(_res_dk.DK) & DK.PLUS='T' & DK.N().MAG().SL='T'
                                       || _pal:=tab_tmp(1,'REF','STRING[16]','','IL','REAL','');
::                                        generowanie palet dla magazynu paletowego
                                          {? DK.N().MAG().PAL='T'
                                          ||
::                                           ustawiamy parametry generacji
                                             _dokl_m:=exec('jaka_dok_m','jm',DK.M);
                                             _stmag:=ST.MAG;
                                             ST.MAG:=DK.N().MAG;
                                             EANX.TYPPAL:=exec('FindInSet','#table','TPAL','TYP',_tpal,_tpal);
                                             EANX.KOPIA:='B';
                                             EANX.MPAL:=DK.M;
                                             EANX.ALLPAL:=DK.IL;
                                             EANX.ILMPAL:=DK.IL/_ilp $ _dokl_m;
                                             EANX.CMPAL:=DK.C;
                                             EANX.TWMPAL:=DK.TW;
                                             EANX.ILPAL:={? (EANX.ILMPAL*_ilp)>=EANX.ALLPAL || _ilp || _ilp+1 ?};
                                             EANX.DOPAS:='T';
                                             EANX.DK_C:=DK.DK_C;
                                             exec('autoapal','magdok_palety',,_pal);
                                             ST.MAG:=_stmag
                                          ?};
                                          {? _tab.EANL<>''
                                          || _eanl:=exec('FindAndGet','#table',EANL,_tab.EANL,,,null())
                                          || _eanl:=DK.ZL().EANL
                                          ?};
                                          {? _eanl=null() || _eanl:=DK.N().MAG().EANL ?};
                                          _tw:={? DK.TW<>date(0,0,0)
                                               || DK.TW
                                               |? _tab.TW<>date(0,0,0)
                                               || _tab.TW
                                               || DK.PARTIA().TW
                                               ?};
                                          {? _tw<>date(0,0,0) | _eanl<>null()
                                          || _pal.clear();
                                             {? ~_pal.first()
                                             || exec('add2dk_l','magdok_wspolne',DK.ref(),null(),_eanl,null()
                                                 ,_tw,date(0,0,0),DK.IL,ND.MAG,DK.M,,,null())
                                             || {!
                                                |? _rpal:=exec('FindAndGet','#table',PAL,_pal.REF,,,null());
                                                   exec('add2dk_l','magdok_wspolne',DK.ref(),null(),_eanl,null()
                                                    ,_tw,date(0,0,0),_pal.IL,ND.MAG,DK.M,,,_rpal);
                                                   _pal.next()
                                                !}
                                             ?}
                                          ?};
                                          obj_del(_pal)
                                       ?};
                                       DK.cntx_pop()
                                    ?}
                                 || _can_continue:=0
                                 ?}
                              ?}
                           ?};
                           ND.cntx_psh();
                           {? ND.clear; ND.seek(_nd)
                           || exec('dk_sum','magdok_wspolne',ND.ref())
                           ?};
                           ND.cntx_pop()
                        ?};
                        _tab.next() & _can_continue>0
                     !}
                  ?};
                  _tab.cntx_pop();
                  ~~
               || _msg:='Nie udało się utworzyć nagłówka dokumentu raportującego.'@;
                  {? _display=1
                  || FUN.emsg(_msg)
                  |? _display=2
                  || KOMM.add(_msg,2,,1)
                  ?}
               ?};

               {? _can_continue<=0
               ||
::                Coś się wykrzaczyło, usuwam dokument
                  ND.clear();
                  {? ND.seek(_nd)
                  || {? do_state()<2 & ~Plugin.run('BEFORE_DELTAB_001',ND.ref()) & do_state() || undo() ?};
                     numer:=ND.NR;
                     oldnumer:=1;
                     exec('nr_old','numery');
                     ND.del()
                  ?};
                  _result.ND:=null()
               ?};

               _tab.next() & _can_continue>0
            !}
         ?};
         ND.cntx_pop(); DK.cntx_pop()
      || _msg:='Nie udało się utworzyć dokumentu raportującego.'@;
         {? _display=1
         || FUN.emsg(_msg)
         |? _display=2
         || KOMM.add(_msg,2,,1)
         ?}
      ?};
      {? _can_continue<=0
      || _env_strukt.RESULT:=0
      ?};

      M.cntx_pop();
      ZPARN.cntx_pop();
      ~~
   ?}
?};
ZL.cntx_pop();

{? _zgh<>null()
|| exec('blk_unlock','#table','ZGH',_zgh)
?};
_env_strukt


\typ_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Selekcja typów dokumentów magazynowych (dla parametru wejściowego czynności oraz wyboru typu w czynności)
::   WE: _a - parametr _j formuły exec('typ_dok','lmg'):
::          1-założyć tylko ograniczenie 0-nie(domyślnie), -1-tak jak 0, dodatkowo wyświetla okienko dla jednego rekordu
::       [_b] - STRING - typ dokumentu, jesli nie podany to domyślny
::       [_c] - parametr _c formuły exec('typ_dok','lmg'): formuła na akcje "WYBIERZ"
::----------------------------------------------------------------------------------------------------------------------
_TypDok:=exec('get','#params',500701,2);
{? var_pres('_b')=type_of('') & _b<>''
|| _TypDok:=_b
?};
_form:="";
{? var_pres('_c')=type_of("") & _c<>""
|| _form:=_c
?};
{? _TypDok<>''
|| _Typdok:=gsub(form(_TypDok),' ','\',\'');
   _TypDok:='\''+_Typdok+'\'';
   _warunek:='"TYPYDOK".T in ('+_TypDok+') '
|| _warunek:='0=1'
?};
exec('typ_dok','lmg',_warunek,,_form,0,0,
   'Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500701'],,,,_a
)


\sel_zl_and_typdok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wybiera zlecenie i typ dokumentu raportującego
::   WE: _a - TYPYDOK.ref()
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh(); ZL.clear();
TYPYDOK.cntx_psh();

_join:='join ZTP left join ZL as ZLNAD using(ZL.NRNZL,ZLNAD.UNRZL)';
_where:=
   'ZL.STAN=''O'' and '
   'ZTP.WP=''P'' and '
   'ZL.RODZAJ=''P'' and '
   'ZL.RP=''T'' '
   ;
ZL.f_set('SYM',_join,_where);

_res:=obj_new('ZL','TYPYDOK');
_res.ZL:=null();
_res.TYPYDOK:=null();
{? _a<>null()
|| _res.TYPYDOK:=_a
|| TYPYDOK.f_set(,,'"TYPYDOK".P=\'T\' and "TYPYDOK".WYR=\'T\'');
   {? TYPYDOK.f_size()=1
   || {? TYPYDOK.f_first() || _res.TYPYDOK:=TYPYDOK.ref() ?}
   ?};
   TYPYDOK.f_clear()
?};

_tab:=tab_tmp(1,'ZL','STRING[20]','Zlecenie','TYPYDOK','STRING[8]','Typ dokumentu');
_f3:="
   ZL.index('SYM');
   ZL.f_find(fld());
   exec('icons_slo_sl','zl_head');
   ZL.win_sel('SLO_SL');
   ZL.actions('SLO_SL','XY','W');
   {? ZL.select(,1,5)
   || ZL.SYM
   || ~~
   ?}
";
_tab.fld_fml('ZL','F3',_f3);
_f3:="
   _zl:=cur_tab(1,1).ZL;
   _typdok:='';
   {? _zl<>''
   || ZL.cntx_psh();
      ZL.index('SYM');
      ZL.prefix(_zl,);
      {? ZL.first()
      || {? ZL.KTM().RODZ='U'
         || _typdok:=exec('get_typydok_sym','zl_uslugi')
         ?}
      ?};
      ZL.cntx_pop()
   ?};
   _ref:=exec('typ_dok','!tte_wyk_dgrp',-1,_typdok);
   {? _ref<>null()
   || exec('FindAndGet','#table',TYPYDOK,_ref,,\"T\",'')
   || ~~
   ?}
";
_tab.fld_fml('TYPYDOK','F3',_f3);
_tab.TYPYDOK:=exec('FindAndGet','#table',TYPYDOK,_res.TYPYDOK,,"T",'');
_red:=_tab.mk_edit('Generowanie dokumentu %1'@[_tab.TYPYDOK],,'sel_zl_and_typy');
_tab.win_efld(_red,,'ZL',,,20,,,'Zlecenie'@,,,,'F3_button=1');
_tab.win_efld(_red,,'TYPYDOK',,,20,,,'Typ dokumentu'@,,,,'F3_button=1');
_tab.efld_opt(_red,'mark=1',,'ZL');
{? _a=null()
|| _tab.efld_opt(_red,'mark=1',,'TYPYDOK')
|| _tab.efld_opt(_red,'enable=0',,'TYPYDOK')
?};
exec('ok_esc','#window',_tab,_red,1);
_tab.win_edit(_red);
_chk:="
   _tab:=cur_tab(1,1);
   _typ_dok:=exec('get','#params',500701,2);
   _result:='';
   ZL.index('SYM');
   ZL.prefix(_tab.ZL,);
   TYPYDOK.index('TYP');
   TYPYDOK.prefix(_tab.TYPYDOK,);
   {? _tab.ZL=''
   || FUN.info('Należy wypełnić pole \'\'Zlecenie\'\'.'@);
      _result:='ZL'
   |? ~ZL.first()
   || FUN.info('Należy podać prawidłowy symbol zlecenia.'@);
      _result:='ZL'
   |? _tab.TYPYDOK=''
   || FUN.info('Należy wypełnić pole \'\'Typ dokumentu\'\'.'@);
      _result:='TYPYDOK'
   |? ~TYPYDOK.first()
   || FUN.info('Należy podać prawidłowy typ dokumentu.'@);
      _result:='TYPYDOK'
   |? TYPYDOK.first() & (_typ_dok*(TYPYDOK.T+' ')=0)
   || {? ZL.KTM().RODZ='U'
      || _usl_dok:=exec('get_typydok_sym','zl_uslugi');
         {? _usl_dok<>_tab.TYPYDOK
         || _result:='TYPYDOK';
            _msg:='Zlecenie na usługi musi być raportowane dokumentem: %1'@[_usl_dok];
            FUN.info(_msg)
         ?}
      || FUN.info('Należy podać prawidłowy typ dokumentu (%1).'@[_typ_dok-1]);
         _result:='TYPYDOK'
      ?}
   ?};
   ZL.prefix();
   _result
";
{? _tab.edit(_chk)
|| ZL.index('SYM');
   ZL.prefix(_tab.ZL,);
   {? ZL.first()
   || _res.ZL:=ZL.ref()
   ?};
   TYPYDOK.index('TYP');
   TYPYDOK.prefix(_tab.TYPYDOK,);
   {? TYPYDOK.first()
   || _res.TYPYDOK:=TYPYDOK.ref()
   ?}
?};

ZL.cntx_pop();
TYPYDOK.cntx_pop();
_res


\wariant
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wybór wariantu działania czynności (ustawienie wartości parametru wejściowego czynności)
::----------------------------------------------------------------------------------------------------------------------
_choice:=FUN.choice('Wybór wariantu czynności:'@,,
   'Według rejestracji &wykonań'@,
   'Według dokumentów &magazynowych'@,
   'Au&tomatycznie'@
);
_result:={? _choice=1 || 'W' |? _choice=2 || 'M' |? _choice=3 || 'A' || ~~ ?};
_result


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła ustala PARSES
::   WE: UWAGA. Do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_mp:=params_get().mp;
_context:=params_get().context;

_result:=0;

_keyRefs:=_mp.getRefs();
{? obj_len(_keyRefs)>0
|| {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];
      {? type_of(_kref)>0
      || {? ref_name(_kref)=ZL.name()
         || _zl:=exec('FindAndGet','#table',ZL,_kref,,,null());
            {? _zl=null()
            ||
::             W tym miejscu zwracam 1, wyświetlenie komunikatu oraz dalsza obsługa w cleanerze czynności
               return(1)
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
::               exec('zl_deleted_in_proc','zl_common',_mp);
::               return(_result)
            ?}
         ?}
      ?}
   !}
?};

{? var_pres('ZL',_in)=type_of(null()) & _in.ZL
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_in.ZL)
   || __PARSES.setVal('OddzialLogProd',ZL.ODDZ);
      {? _mp.isService()
      || _args:=__PARSES.args('OkresRok');
         _args.OBSZAR:='LMG';
         _args.AR:=date()~1;
         _args.AM:=date()~2;
         __PARSES.setVal('OkresRok',_args)
      ?};
      _result:=1
   ?};
   ZL.cntx_pop()

|? var_pres('_context')<>type_of(~~) & var_pres('ZLGD',_context) & _context.ZLGD
|| ZLGD.cntx_psh();
   ZLGD.use(ref_name(_context.ZLGD));
   ZLGD.prefix();
   {? ZLGD.seek(_context.ZLGD)
   || __PARSES.setVal('OddzialLogProd',ZLGD.ZL().ODDZ);
      _args:=__PARSES.args('OkresRok');
      _args.OBSZAR:='LMG';
      _args.AR:=ZLGD.DT~1;
      _args.AM:=ZLGD.DT~2;
      __PARSES.setVal('OkresRok',_args);
      _result:=1
   ?};
   ZLGD.cntx_pop()

?};

:: Jeżeli uruchomienie ze startu procesów, to będzie wybór zlecenia, więc ok
{? _result=0 & _mp.pathProc()
|| _result:=1
|? _result=0
|| _msg:='Błędna konfiguracja procesu — brak parametru wejściowego %1 czynności %2.'@@['ZL','TTE_WYG_DGRP'];
   {? _mp.isService()=0 || FUN.info(_msg) ?};
   _mp.error(_msg)
?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WE: [_a] - INTEGER - 0/[1] - czy sprawdzać robociznę
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_chk_rob:=1;
{? var_pres('_a')=type_of(0)
|| _chk_rob:=_a
?};

_mp:=params_get().mp;
_in:=params_get().in;
_out:=params_get().out;

_can_continue:=1;
_obj:=obj_new('RESULT');
_obj.RESULT:=0;

{? _in.WARIANT=~~ | _in.WARIANT=''
|| _in.WARIANT:='A'
?};

_keyRefs:=_mp.getRefs();

{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];

      {? type_of(_kref)>0
      ||
         {? ref_name(_kref)=ZL.name()
         || _zl:=exec('FindAndGet','#table',ZL,_kref,,,null());

            {? _zl=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZL,_zl,,"ZL.STAN",'')='Z'
            ||
::             Zlecenie zostało zamknięte, więc robie done
               _can_continue:=0;
               _out.ZL:=_in.ZL;
               _out.ND:=null();
               _mp.save(,_out);
               exec('zl_deleted_in_proc','zl_common',_mp,0,0)
::            ||
::             Sprawdzenie stanu zlecenia, jeżeli jest już zamknięte, to done()
::               _display:={? _mp.isService() | _mp.CLEANER || 0 || 1 ?};
::               {? exec('FindAndGet','#table',ZL,_zl,,"STAN='Z'",0)
::               || _can_continue:=0;
::                  {? _display || FUN.info('Zlecenie jest już zamknięte.'@) ?};
::                  _out.ZL:=_in.ZL;
::                  _out.ND:=null();
::                  _mp.save(,_out);
::                  _mp.done()
::               ?}
            ?}
         ?}
      ?}
   !}
?};
{? _can_continue>0 & _in.ZL<>null() & _chk_rob>0
||
   {? _in.WARIANT='W' | (_in.WARIANT='A' & ~exec('zl_bez_oper','zl_common',_in.ZL))
   ||
::    Wariant z robocizną sprawdza czy jest jakaś niezbilansowana robocizna
      _args:=obj_new('ILOSC','ZL');
      _args.ZL:=_in.ZL;
      _args.ILOSC:=0;

      _rule:="
         _args:=_b;
         ZLGD.cntx_psh();
         _result:=1;
         ZLGD.index('ZLECENIE');
         ZLGD.prefix(_args.ZL);
         {? ZLGD.first()
         || {!
            |? _zlgd_left:=ZLGD.IL-ZLGD.ILGEN;
               {? ZLGD.ZGP().DOK<>null() & _zlgd_left>0
               || _args.ILOSC+=_zlgd_left;
                  {? _args.ILOSC>0
                  || _result:=0
                  ?}
               ?};
               ZLGD.next() & _result>0
            !}
         ?};
         ZLGD.cntx_pop();
         _result
      ";
      exec('for_each_mask','#table',ZLGD,_rule,,,_args,1);

      {? _args.ILOSC=0
      || _can_continue:=0;
         _display:={? _mp.isService() | _mp.CLEANER || 0 || 1 ?};
         _msg:='Brak zapisów robocizny aby utworzyć dokument dla zlecenia: %1.'@[exec('record','#to_string',_in.ZL)];
         {? _display
         || FUN.emsg(_msg)
         ?};
         _mp.error(_msg)
      ?}
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};

_obj


\show_after_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Wyświetla info o wygenerowanym dokumencie
::   WE: _a - ND.ref - ref wygenerowanego dokumentu
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_nd:=_a;

ND.cntx_psh();
DK.cntx_psh();
ND.use('nagdo'+ST.ODDZ+($(ST.AR)+2));
DK.use('dokma'+ST.ODDZ+($(ST.AR)+2));

ND.prefix();

{? ND.seek(_nd)
|| _old_var:=VAR.A_ZLEC;
   VAR.A_ZLEC:=ND.ZL;
   _choice:=FUN.choice('Wygenerowano dokument o symbolu %1 na magazynie %2.'@[ND.SYM,ND.MAG().SYM],,'Szczegóły'@,,,,'Zamknij'@);
   {? _choice=1
   || exec('pozrap','magdok_prod',1,0,0,ND.ref())
   ?};
   VAR.A_ZLEC:=_old_var
?};
DK.cntx_pop();
ND.cntx_pop();
~~


\show_after_info_multi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Wyświetla info o wygenerowanym dokumencie
::   WE: _a - ZL.ref()
::       _b - obj_new() - wynik działania exec('gendok_struktura_env','!tte_wyk_dgrp')
::       _c - INTEGER - liczba wygenerowanych dokumentów
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_env:=_b;
_dok_count:=_c;

_tab:=_env.TAB_DOK;
_tab.cntx_psh();
_tab.index(_env.NDX_DOK_ND);

ND.cntx_psh();
DK.cntx_psh();
ND.use('nagdo'+ST.ODDZ+($(ST.AR)+2));
DK.use('dokma'+ST.ODDZ+($(ST.AR)+2));
_old_var:=VAR.A_ZLEC;
VAR.A_ZLEC:=_zl;
_choice:=FUN.choice('Wygenerowanych dokumentów magazynowych: %1'@[$_dok_count],,'Szczegóły'@,,,,'Zamknij'@);
{? _choice=1
|| exec('pozrap','magdok_prod',1,0,0,_tab)
?};
VAR.A_ZLEC:=_old_var;
DK.cntx_pop();
ND.cntx_pop();
_tab.cntx_pop();
~~


\gendok_zparn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Generuje dokument RP z wieloma pozycjami dot partii
::   WE: _a - obj_new() - tablica argumentów wszystkich funkcji gendok_, wynik działania exec('gendok_args','!tte_wyk_dgrp')
::   WY: obj_new() - wynik działania exec('gendok_struktura_env','!tte_wyk_dgrp')
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_tab_part:=_args.TAB_PART.tab;
_res:=exec('gendok_struktura_env','!tte_wyk_dgrp');

M.cntx_psh();
M_ATR.cntx_psh();
ZLGD.cntx_psh();
ZLGD.index('ZPARN');
ZPARN.cntx_psh();
ZPARN.prefix();
_tab_part.cntx_psh();
_tab_part.prefix();

VAR_DEL.delete('ATR_GRAY');
exec('gray_init','mat_atr');
{? _tab_part.size()>1
|| ATR_GRAY.types:='P,'
?};

_can_continue:=1;

{? _tab_part.first()
||
   _zparn_first:=exec('FindAndGet','#table',ZPARN,_tab_part.SQL,,,null());
   {? _args.DISPLAY>0
   || KOMM.init(250,,'Generowanie raportów produkcji do partii'@)
   ?};
   ZL.cntx_psh(); ZL.prefix();
   {? ZL.seek(_args.ZL)
   ||

::    SEKCJA SPRAWDZANIA
      {? _can_continue>0
      || _tab_part.cntx_psh();

         {? _args.WARIANT='W'
         || _rob_ready:=0;
            {? _tab_part.first()
            || {!
               |? {? ZPARN.seek(_tab_part.SQL)
                  ||
                     {? exec('get_ilosc_zlgd','zl_partie',ZPARN.ref(),_args.ZGP,1,exec('zl_czy_wyr','zl_wyr'))>0
                     || _rob_ready:=1
                     ?}
                  ?};
                  _tab_part.next() & _rob_ready=0
               !}
            ?};

            {? _rob_ready=0
            || _can_continue:=0;
               _msg:='Generacja działa w oparciu o robociznę, żadna z zaznaczonych partii nie ma robocizny '
                     'pozwalającej na raportowanie produktu.'@;
               _res.TXT:=_msg;
               {? _args.DISPLAY>0
               || KOMM.add(_msg,2,,1)
               ?}
            ?}

         |? _args.WARIANT='M'
         ||
            _mag_ready:=0;
            {? _tab_part.first()
            || {!
               |? {? ZPARN.seek(_tab_part.SQL)
                  ||
                     _zparn_rp:=exec('get_ilosc_rp','zl_partie',ZPARN.ref());
                     _zparn_left:=exec('ilosc_left','zl_partie',,_args.WARIANT);
                     _zparn_left:=exec('max','#math',0,_zparn_left);
                     {? _zparn_left>0
                     || _mag_ready:=1
                     ?}
                  ?};
                  _tab_part.next() & _mag_ready=0
               !}
            ?};
            {? _mag_ready=0
            || _can_continue:=0;
               _msg:='Żadna z zaznaczonych partii nie ma ilości pozwalającej na raportowanie do magazynu'@;
               _res.TXT:=_msg;
               {? _args.DISPLAY>0
               || KOMM.add(_msg,2,,1)
               ?}
            ?}
         ?};
         _tab_part.cntx_pop()
      ?};

::    Edycja cechy
      ZL.KTM().M_ATR();
      _buf_matr:=exec('buffer','mat_atr');
      _buf_matr.get_matr();

      DK_C.cntx_psh();
      {? ZL.DK_C<>null()
      || ZL.DK_C();
         _buf_matr.get_dkc()
      ?};
      DK_C.cntx_pop();

      {? _can_continue>0
      || {? _args.DISPLAY>0 & _buf_matr.count()>0 & _buf_matr.all_set()=0 & ZL.MG().TYP*'DOST'>0
         || _dk_c:=exec('edit_cecha','!tte_wyk_dgrp',_args,,_zparn_first);
            {? _dk_c=null()
            || _can_continue:=0
            ?}
         ?}
      ?}
   ?};
   {? _can_continue>0 & _args.WARIANT='M' & _tab_part.size()=1 & _args.DISPLAY>0
   ||
::    Okienko ręcznej edycji
      ZPARN.prefix();
      {? ZPARN.seek(_tab_part.SQL)
      || _args.ZL:=ZPARN.ZL;
         _args.ZPARN:=ZPARN.ref();
         _edit_res:=exec('edit','!tte_wyk_dgrp',_args,0);
         {? _edit_res.RESULT>0
         ||
            _args.ZGH:=exec('FindAndGet','#table',ZGH,_edit_res.TAB.ZGH_REF);
            {? _edit_res.TAB.PART_REF<>''
            || _args.ZPARN:=exec('FindAndGet','#table',ZPARN,_edit_res.TAB.PART_REF)
            ?};
            _args.ILOSC:=_edit_res.TAB.ILOSC;
            _args.DATA:=_edit_res.TAB.DT;
            _args.TW:=_edit_res.TAB.TW;
            ~~
         || _can_continue:=0
         ?}
      ?}
   ?};
   ZL.cntx_pop();

:: SEKCJA GENEROWANIA
   ZPARN.prefix();

   {? _can_continue>0 & _tab_part.first()
   ||
      obj_del(_res);
      _res:=exec('gendok_core','!tte_wyk_dgrp',_args);
      _tab_dok:=_res.TAB_DOK;
      {? _args.WARIANT='W'
      || {? _tab_part.first()
         || {!
            |? _zparn:=exec('FindAndGet','#table',ZPARN,_tab_part.SQL,,,null());
               {? _zparn<>null()
               ||
::                Jeżeli dokument raportujący produkcję powstał, to aktualizacja ilości na zleceniu
                  VAR.A_DOK:=_args.TYPYDOK;
                  _tab_dok.index(_res.NDX_DOK_ZPARN);
                  _tab_dok.prefix($_args.ZPARN,_res.TYP_DK);
                  _ilosc:=0;
                  {? _tab_dok.first()
                  || {!
                     |? {? _tab_dok.DK<>''
                        || exec('robocizna_dk_add','magdok_prod',_tab_dok.DK,,_zparn)
                        ?};
                        _tab_dok.next()
                     !}
                  ?}

               ?};
               _tab_part.next()
            !}
         ?}
      ?};
      ~~
   ?};
   {? _args.DISPLAY>0
   || KOMM.select()
   ?}
?};
_tab_part.cntx_pop();
ZPARN.cntx_pop();
ZLGD.cntx_pop();
M.cntx_pop();
M_ATR.cntx_pop();

:: Odszarzam pola w oknie, jeśli je wcześniej zaszarzyłem
{? ATR_GRAY.types<>''
|| ATR_GRAY.types:='';
   exec('set_efld_opt','mat_atr',ATR.MJS,DK_C,'RED_ATR')
?};

VAR_DEL.delete('ATR_GRAY');
_res


\gendok_args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Argumenty dla wszystkich funkcji gendok_
::   WY: obj_new()
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------

_result:=obj_new(
:: Zlecenie
   'ZL'
:: Materiał
   ,'M'
:: Ilosc
   ,'ILOSC'
:: Typ dokumentu
   ,'TYPYDOK'
:: Data dokumentu
   ,'DATA'
:: Przewodnik
   ,'ZGH'
:: Partia do której przypisać dokument
   ,'ZPARN'
:: Istniejący nagłówek dokumentu do któego dołączyć pozycję
   ,'ND'
:: Cecha którą przypisać pozycji dokumentu, jeżeli podana również partia to tworzona jest
:: kopia przekazanej cechy, z właściwą partią
   ,'DK_C'
:: 0/[1]/2 - komunikaty: brak, na ekran, do KOMMa
   ,'DISPLAY'
:: czy umożliwić generowanie dokumentu do robocizny (1), nie [0]
   ,'SPR_ROB'
:: zapis robocizny który powiązać z dokumentem
   ,'ZLGD'
:: pozycja przewodnika
   ,'ZGP'
:: Tablica zaznaczonych partii
   ,'TAB_PART'
:: Wariant uruchomienia czynności
   ,'WARIANT'
:: Ilość palet - dotyczy magazynu z obsługą palet
   ,'ILP'
:: Typ palety - dotyczy magazynu z obsługą palet
   ,'TPAL'
:: Czy zlecenie ma wiele wyrobów?
   ,'MULTIWYR'
:: Rozpiska na wiele wyrobów
   ,'TAB_WYR'
:: Termin ważności
   ,'TW'
);
_result.ZL:=null();
_result.M:=null();
_result.ILOSC:=0;
_result.TYPYDOK:=null();
_result.DATA:={? date()>date(ST.AR,ST.AM,0)
               || date(ST.AR,ST.AM,0)
               |? date()<date(ST.AR,ST.AM,1)
               || date(ST.AR,ST.AM,1)
               || date()
               ?};
_result.ZGH:=null();
_result.ZGP:=null();
_result.ZPARN:=null();
_result.ND:=null();
_result.DK_C:=null();
_result.DISPLAY:=1;
_result.SPR_ROB:=0;
_result.ZLGD:=null();
_result.TAB_PART:=~~;
_result.WARIANT:='';
_result.ILP:=1;
_result.TPAL:='EUR';
_result.MULTIWYR:=0;
_result.TAB_WYR:=~~;
_result.TW:=date(0,0,0);
_result


\edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Okienko edycyjne przed generowaniem dokumentu RP
::   WE: _a - obj_new() - tablica argumentów wszystkich funkcji gendok_, wynik działania exec('gendok_args','!tte_wyk_dgrp')
::       [_b] - INTEGER - 0/[1] - czy umożliwiać redakcje pola Przewodnik
::       [_c] - INTEGER - 0/[1] - czy umożliwiać redakcje pola Partia
::       [_d] - INTEGER - 0/[1] - czy na zleceniu wiele wyrobów
::   WY: obj_new
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
params_set('args_gendok',_args);
_mod_zgh:=1;
{? var_pres('_b')=type_of(0)
|| _mod_zgh:=_b
?};
_mod_part:=1;
{? var_pres('_c')=type_of(0)
|| _mod_part:=_c
?};

_multiwyr:=0;
{? _args.WARIANT='M'
|| _multiwyr:=_args.MULTIWYR
?};

_can_continue:=1;

_result:=obj_new('RESULT','TAB');
_result.RESULT:=0;

_tab:=tab_tmp(,
      'TYPYDOK','STRING[8]','Typ dokumentu'@,
      'ZGH','STRING[30]','Przewodnik'@,
      'ZGH_REF','STRING[16]','$ZGH.ref()',
      'PART','STRING[30]','Partia'@,
      'PART_REF','STRING[16]','$ZPARN.ref()',
      'ILOSC','REAL','Ilość'@,
      'DT','DATE','Data'@,
      'ILP','INTEGER','Liczba palet'@,
      'TPAL','STRING[20]','Typ palety'@,
      'TW','DATE','Termin ważności'@
   );
_tab.blank();
_result.TAB:=_tab;

ZGH.cntx_psh();
ZGP.cntx_psh();
ZPARN.cntx_psh();
ZL.cntx_psh(); ZL.prefix();
{? ZL.seek(_args.ZL)
||
   _mag:=exec('zl_mg','zl_common',_args.ZL);
   _pal:={? _mag<>null() || exec('FindAndGet','#table',MG,_mag,,"PAL='T'",0) || 0 ?};
   _party:=exec('zlec_party','zl_common',ZL.ref());
:: Określenie kontekstu - przewodnik
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   _zgh_size:=ZGH.size();

:: Wstępne określenie ilości
   {? _args.ZGP=null()
   || _args.ZGP:=exec('first_not_completed','zl_guide',ZL.ref(),_args.WARIANT)
   ?};
   ZGP.prefix();
   {? _args.ZGP<>null & ZGP.seek(_args.ZGP)
   || _args.ZGH:=ZGP.NRPRZ;
      _tab.ZGH_REF:=$_args.ZGH;
      _tab.ZGH:=ZGP.NRPRZ().NRPRZ;
      _tab.ILOSC:=exec('ilosc_left','zl_guide',,_args.WARIANT);
      ~~
   ?};

:: Jeżeli tylko jeden przewodnik i coś jeszcze zostało do wykonania na nim
:: to blokuję pole z przewodnikiem do redakcji
   {? _tab.ILOSC>0 & _zgh_size<=1
   || _mod_zgh:=0
   ?};

:: Określenie kontekstu - partia
   ZPARN.cntx_psh();
   {? _party>0
   || {? _args.ZGH<>null()
      || ZPARN.index('ZGH');
         ZPARN.prefix(_args.ZGH)
      || ZPARN.index('ZL2');
         ZPARN.prefix(ZL.ref())
      ?};
      _zparn_size:=ZPARN.size();

      {? _args.ZPARN<>null()
      ||
::       Jeśli partia podana to blokuję partię do redakcji
         _mod_part:=0
      ?};

      {? _args.ZPARN=null() & _args.ZGH<>null()
      ||
::       Wyznaczam pierwszą partię
         _args.ZPARN:=exec('first_not_completed','zl_partie',ZL.ref(),_args.ZGH,_args.WARIANT)
      ?};
      {? _args.ZPARN<>null()
      || _zparn_left:=exec('ilosc_left','zl_partie',_args.ZPARN,_args.WARIANT);
         _args.ILOSC:=_zparn_left;
         _tab.ILOSC:=_zparn_left;
         ZPARN.prefix();
         {? ZPARN.seek(_args.ZPARN)
         || _tab.PART_REF:=$ZPARN.ref();
            _tab.PART:=ZPARN.SYM;
            _args.TW:=ZPARN.TW;
            _tab.TW:=ZPARN.TW
         ?}
      ?};

::    Jeżeli tylko jedna partia i coś jeszcze zostało do wykonania to blokuję partię
      {? _tab.ILOSC>0 & _zparn_size<=1
      || _mod_part:=0
      ?}
   || _mod_part:=0
   ?};
   ZPARN.cntx_pop();

:: Określenie kontekstu - typ dokumentu
   {? _args.TYPYDOK=null()
   || {? exec('is_usluga_zl','zl_uslugi',_args.ZL)
      || _args.TYPYDOK:=exec('get_typydok','zl_uslugi')
      || _args.TYPYDOK:=exec('typ_dok','!tte_wyk_dgrp',0,,"exec('typ_dok_valid','!tte_wyk_dgrp',ZL.ref())")
      ?}
   ?};

::   _formula:="exec('itsPositive','#field',1,,fld())";
::   _tab.fld_fml('ILOSC','AFTER_EDIT',_formula);
   _formula:="'in_prec='+$ZL.KTM().DOKL";
   _tab.fld_fml('ILOSC','EDIT_FORMAT',_formula);
   _red:=_tab.mk_edit('Dokument raportujący produkcję'@,,'dokrapprod');
   _tab.win_esep(_red,'Dane podstawowe'@);
   _typ_sym:=exec('FindAndGet','#table',TYPYDOK,_args.TYPYDOK,,"T",'');
   _tab.TYPYDOK:=_typ_sym;
   _tab.win_efld(_red,,'TYPYDOK',,,30,,1,'Typ dokumentu'@,,,,'F3_button=1');


:: Obsługa pola przewodnik
   _tab.win_efld(_red,,'ZGH',,,30,,~_mod_zgh,'Przewodnik'@,,,,'F3_button=1');
   _tab.efld_opt(_red,'mark=%1'[$_mod_zgh],,'ZGH');

   _formula:="
      _tab:=cur_tab(1,1);
      _args_gendok:=params_get().args_gendok;
      _wer:=ZGH.mk_sel('Wybierz przewodnik'@,'P',0,'naglowkiprzew',,,10,,'U');
      ZGH.win_fld(_wer,,'NRPRZ');
      ZGH.win_fld(_wer,,'ILNPRZ',,,,,,'Ilość'@);
      ZGH.win_fld(_wer,VAR1,'ILWYK',,,,,,'Wykonano'@);
      ZGH.win_act(_wer,,'Formuła','Wybierz'@@,,,,\"sel_exit()\",1);
      _before:=\"
         _args:=exec('ilosc_dk_a','zl_common');
         _args.ZGH:=ZGH.ref();
         _args.RP:=1;
         exec('ilosc_dk','zl_common',_args);
         _zgh_rp:=_args.RESULT;
         VAR1.ILWYK:=_zgh_rp;
         ~~
      \";
      ZGH.win_act(_wer,,'Rekord',,,,_before);
      ZGH.win_sel(_wer);
      ZGH.prefix(ZL.ref());
      {? ZGH.select()
      || _tab.ZGH_REF:=$ZGH.ref();
         _tab.ZGH:=ZGH.NRPRZ;
         _args_gendok.ZGH:=ZGH.ref()
      ?};
      _tab.ZGH
   ";
   _tab.fld_fml('ZGH','F3',_formula);
   _formula:="
      _tab:=cur_tab(1,1);
      _args_gendok:=params_get().args_gendok;
      _result:=1;

      {? fld()<>''
      ||
         ZGH.prefix(ZL.ref(),fld(),);
         {? ZGH.first()
         || _tab.ZGH_REF:=$ZGH.ref();
            _args:=exec('ilosc_dk_a','zl_common');
            _args.ZGH:=ZGH.ref();
            _args.ZL:=ZL.ref();
            _args_gendok.ZGH:=ZGH.ref();
            _tab.ILOSC:=
               ZGH.ILNPRZ
               -(_args.RP:=1; exec('get_ilosc_dk','zl_common',_args))
               +(_args.RP:=0; _args.ZP:=1; exec('get_ilosc_dk','zl_common',_args));
            {? _tab.ILOSC<0 || _tab.ILOSC:=0 ?};

            ZPARN.cntx_psh();
            ZPARN.index('ZGH');
            ZPARN.prefix(ZGH.ref());
            _zparn_size:=ZPARN.size();
            {? ZPARN.first()>0
            || _args_gendok.ZPARN:=exec('first_not_completed','zl_partie',ZL.ref(),ZGH.ref(),_args_gendok.WARIANT);
               {? _args_gendok.ZPARN<>null()
               || ZPARN.prefix();
                  {? ZPARN.seek(_args_gendok.ZPARN)
                  || _tab.PART_REF:=$ZPARN.ref();
                     _tab.PART:=ZPARN.SYM;
                     _tab.ILOSC:=exec('ilosc_left','zl_partie',,_args_gendok.WARIANT)
                  ?}
               || _tab.PART_REF:='';
                  _tab.PART:=''
               ?}
            ?};
            ZPARN.cntx_pop()

         || FUN.info('Brak przewodnika o symbolu %1.'@[fld()]);
            _result:=0
         ?}
      || _tab.PART:='';
         _tab.PART_REF:='';
         _tab.ILOSC:=0
      ?};
      _result
   ";
   _tab.fld_fml('ZGH','AFTER_EDIT',_formula);

   {? _party>0
   ||
::    Obsługa pola z partią

      _tab.win_efld(_red,,'PART',,,30,,,'Partia'@,,,,'F3_button=1');
      _tab.efld_opt(_red,'mark=%1'[$_mod_part],,'PART');

      _formula:="
         _tab:=cur_tab(1,1);
         _args_gendok:=params_get().args_gendok;

         _view:=null();
         {? fld()<>''
         ||
            ZPARN.cntx_psh();
            ZPARN.index('ZL2');
            ZPARN.prefix(ZL.ref(),fld(),fld());
            {? ZPARN.first()
            || _view:=ZPARN.ref()
            ?};
            ZPARN.cntx_pop()
         ?};

         {? _args_gendok.ZGH<>null()
         || _select:=exec('select_zgh','zl_partie',_args_gendok.ZGH,1,0,,_view)
         || _select:=exec('select_zl','zl_partie',_args_gendok.ZL,1,0,,_view)
         ?};
         {? _select>0
         || _args_gendok.ZPARN:=ZPARN.ref();
            _tab.PART:=ZPARN.SYM;
            _tab.PART_REF:=$ZPARN.ref()
         ?};
         _tab.PART
      ";
      _tab.fld_fml('PART','F3',_formula);
      _formula:="
         _tab:=cur_tab(1,1);
         _args_gendok:=params_get().args_gendok;
         _result:=1;
         ZPARN.cntx_psh();
         ZPARN.index('ZL2');
         {? fld()<>''
         || ZPARN.prefix(ZL.ref(),fld(),fld());
            {? ZPARN.first()
            || _tab.PART_REF:=$ZPARN.ref();
               _args_gendok.ZPARN:=ZPARN.ref();
               _tab.ILOSC:=exec('ilosc_left','zl_partie',,_args_gendok.WARIANT)
            || FUN.info('Brak partii o symbolu %1.'@[fld()]);
               _result:=0
            ?}
         || _tab.ILOSC:=0
         ?};
         ZPARN.cntx_pop();
         _result
      ";
      _tab.fld_fml('PART','AFTER_EDIT',_formula);


      _formula:="
         _tab:=cur_tab(1,1);
         _args_gendok:=params_get().args_gendok;

         ZPARN.cntx_psh();
         {? _args_gendok.ZGH<>null()
         || ZPARN.index('ZGH');
            ZPARN.prefix(_args_gendok.ZGH)
         || ZPARN.index('ZL2');
            ZPARN.prefix(ZL.ref())
         ?};
         _zparn_size:=ZPARN.size();
         ZPARN.cntx_pop();

         _mod_part:=1;
::         {? _tab.ILOSC>0 & _zparn_size<=1
::         || _mod_part:=0
::         ?};
         _tab.efld_opt(cur_win(1,1),'mark=%1'[$_mod_part],,'PART');
         _mod_part
      ";
      _tab.fld_fml('PART','BEFORE_EDIT',_formula);
      ~~
   ?};

   {? _args.MULTIWYR=0
   || _tab.win_efld(_red,,'ILOSC',,,20,ZL.KTM().DOKL,,'Ilość'@);
      _tab.efld_opt(_red,'mark=1',,'ILOSC')
   ?};

   _tab.DT:=_args.DATA;
   _tab.win_efld(_red,,'DT',,,,,,'Data'@);
   _tab.efld_opt(_red,'mark=1',,'DT');
   _formula:="
      _tab:=cur_tab(1,1);
      _args_gendok:=params_get().args_gendok;
      _result:=1;

      {? fld()<>date(0,0,0)
      || _tw_mt:={? ZL.KTM().TWD>0 || _tab.DT+ZL.KTM().TWD || date(0,0,0) ?};
         {? _tw_mt<>date(0,0,0) & _tw_mt<>_tab.TW
          & FUN.ask('Dla wyrobu %1 podano liczbę dni na termin ważności.\n\n'
                    'Czy zmienić termin ważności wg daty przyjęcia wyrobu?'@[ZL.KTM().KTM])
         || _tab.TW:=_tw_mt;
            _args_gendok.TW:=_tw_mt
         ?}
      || FUN.info('Wymagana data przyjęcia wyrobu.'@);
         _result:=0
      ?};
      _result
   ";
   _tab.fld_fml('DT','AFTER_EDIT',_formula);
   _tab.TW:=_args.TW;
   _tab.win_efld(_red,,'TW',,,,,,'Termin ważności'@);
   _tab.efld_opt(_red,'mark=0',,'TW');

:: magazyn paletowy
   {? _pal
   || _tab.ILP:=1;
      _tab.win_efld(_red,,'ILP',,,20,0,,'Ilość palet'@);
      _tab.efld_opt(_red,'mark=1',,'ILP');
      _formula:="
         _result:=1;
         _tab:=cur_tab(1,1);
         {? _tab.ILP<=0
         || FUN.info('Ilość palet musi być większa od zera.'@);
            _tab.ILP:=1;
            _result:=0
         ?};
         _result
      ";
      _tab.fld_fml('ILP','AFTER_EDIT',_formula);

      _tab.TPAL:=exec('FindAndGet','#table',MG,_mag,,"{? TPAL<>null() || TPAL().TYP || 'EUR' ?}",'EUR');
      _tab.win_efld(_red,,'TPAL',,,,,,'Typ palety'@);
      _tab.efld_opt(_red,'mark=1',,'TPAL');
      _formula:="
         _tab:=cur_tab(1,1);
         _win:=TPAL.win_sel('?');
         _akc:=TPAL.actions('SEL','DPU:D');
         TPAL.win_sel('SEL');
         TPAL.index('TYP');
         TPAL.prefix();
         TPAL.find_key(_tab.TPAL,);
         {? TPAL.select() || _tab.TPAL:=TPAL.TYP ?};
         TPAL.win_sel(_win);
         TPAL.actions('SEL',_akc);
         _tab.TPAL
      ";
      _tab.fld_fml('TPAL','F3',_formula);
      _formula:="
         _result:=1;
         _tab:=cur_tab(1,1);
         {? _tab.TPAL=''
         || FUN.info('Należy podać typ palety.'@);
            _tab.TPAL:='EUR';
            _result:=0
         || TPAL.index('TYP');
            TPAL.prefix(_tab.TPAL,);
            {? ~TPAL.first()
            || TPAL.prefix(_tab.TPAL);
               {? TPAL.first()
               || _tab.TPAL:=TPAL.TYP
               || FUN.info('Nieprawidłowy typ palety.'@);
                  _tab.TPAL:='EUR';
                  _result:=0
               ?}
            ?}
         ?};
         _result
      ";
      _tab.fld_fml('TPAL','AFTER_EDIT',_formula)
   ?};

   _tab.win_ebtn(_red,'text=%1'['Zapisz'@],'key:F2');
   _tab.win_ebtn(_red,'text=%1'['Anuluj'@],'key:Esc');
   _tab.win_edit(_red);

   _blk_zl:=null();

   {? _args.ZL<>null()
   || {? exec('blk_lock','#table','ZL',_args.ZL,,,'Zlecenie %1 jest redagowane'@[exec('record','#to_string',_args.ZL)])>0
      || _blk_zl:=_args.ZL
      || _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   || _tw_mt:={? ZL.KTM().TWD>0 || _tab.DT+ZL.KTM().TWD || date(0,0,0) ?};
      {? _tw_mt<>date(0,0,0) & _tw_mt<>_tab.TW
       & FUN.ask('Dla wyrobu %1 podano liczbę dni na termin ważności.\n\n'
                 'Czy zmienić termin ważności wg daty przyjęcia wyrobu?'@[ZL.KTM().KTM])
      || _tab.TW:=_tw_mt;
         _args.TW:=_tw_mt
      ?};
      {? _tab.edit("params_exec('valid','!tte_wyk_dgrp')")
      || _result.RESULT:=1
      ?}
   ?};

   {? _blk_zl<>null()
   || exec('blk_unlock','#table','ZL',_blk_zl)
   ?}
?};
{? _multiwyr>0
|| _tab.ILOSC:=0
?};
ZL.cntx_pop();
ZPARN.cntx_pop();
ZGH.cntx_pop();
ZGP.cntx_pop();
_result


\valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Walidacja okienka generowania RP
::   WY: STRING - '' lub akronim pola do którego wrócić
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
_args_gendok:=params_get().args_gendok;

_party:=exec('zlec_party','zl_common',ZL.ref());
{? _args_gendok.MULTIWYR>0
||
   {? _party>0
   || _chk:=__CHK.record(_tab,,'ZGH','PART','DT')
   || _chk:=__CHK.record(_tab,,'ZGH','DT')
   ?}
||
   {? _party>0
   || _chk:=__CHK.record(_tab,,'ZGH','PART','ILOSC','DT')
   || _chk:=__CHK.record(_tab,,'ZGH','ILOSC','DT')
   ?}
?};

{? _chk='' & _tab.DT<ZL.OD
|| FUN.info('Zlecenie %1 powołane jest z datą późniejszą niż data dokumentu.'@[ZL.SYM]);
   _chk:='DT'
?};
{? _chk='' & _tab.DT<date(ST.AR,ST.AM,1) | _tab.DT>date(ST.AR,ST.AM,0)
|| FUN.info('Data dokumentu musi być zgodna z wybranym okresem.'@);
   _chk:='DT'
?};
{? _chk=''
|| {? _args_gendok.MULTIWYR=0
   || {? exec('itsPositive','#field',1,,_tab.ILOSC)<=0
      || _chk:='ILOSC'
      ?}
   ?}
?};

{? _chk='' & _args_gendok.WARIANT='W'
|| _msg:='Niepoprawny kontekst działania - okno edycji dostępne tylko dla wariantu magazynowego'@;
   FUN.emsg(_msg);
   _chk:='ILOSC'
?};

{? _chk=''
||
   _left:=0;
   _allowed:=0;
   _ilrap:=0;

   _zparn_il:=0;
   _left:=exec('ilosc_left','!tte_wyk_dgrp',_args_gendok.WARIANT,_args_gendok.ZGP,_args_gendok.ZPARN);
   {? _tab.PART<>''
   || _zparn_il:=exec('FindAndGet','#table',ZPARN,_args_gendok.ZPARN,,"IL",0);
      _allowed:=_zparn_il;
      _ilrap:=exec('get_ilosc_rp','zl_partie',_args_gendok.ZPARN);
      ~~
   ||
      _allowed:=exec('FindAndGet','#table',ZGH,_tab.ZGH_REF,,"ILNPRZ",0);
      _args_rp:=exec('ilosc_dk_a','zl_common');
      _args_rp.ZGH:=exec('FindAndGet','#table',ZGH,_tab.ZGH_REF,,"ref()",0);
      _args_rp.ZL:=exec('FindAndGet','#table',ZGH,_tab.ZGH_REF,,"ZLEC",0);

      _args_rp.RP:=1;
      _ilosc_rp:=exec('get_ilosc_dk','zl_common',_args_rp);
      _args_rp.RP:=0;
      _args_rp.ZP:=1;
      _ilosc_zp:=exec('get_ilosc_dk','zl_common',_args_rp);
      _ilrap:=_ilosc_rp-_ilosc_zp;
      ~~
   ?};
   {? _tab.ILOSC>_left & exec('get','#params',500712,type_of(''))='T'
   || _msg:='Łączna ilość wpisana (%1) i zaraportowana (%2) nie powinna być większa niż dozwolona (%3).'@[$_tab.ILOSC,$_ilrap,$_allowed];
      {? _args_gendok.WARIANT='M'
      ||
         {? FUN.ask(_msg+
                '\n\n'+'Czy na pewno wystawić dokument?'@
            )
         || 1
         || _chk:='ILOSC'
         ?}
      |? _args_gendok.WARIANT='W'
      || FUN.emsg(_msg);
         _chk:='ILOSC'
      ?}
   ?};

   {? _chk='' & _args_gendok.WARIANT='W' & _zparn_il>0
   || {? _tab.ILOSC>_zparn_il
      || _msg:='Ilość wpisana (%1) przekracza ilość na partii (%2)'@[$_tab.ILOSC,$_zparn_il];
         {? FUN.ask(_msg+
                '\n\n'+'Czy na pewno wystawić dokument?'@
            )
         || 1
         || _chk:='ILOSC'
         ?}
      ?}
   ?}
?};
_chk


\edit_cecha
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Wyświetlenie okienka z cechą
::   WE: _a - obj_new() - tablica argumentów wszystkich funkcji gendok_, wynik działania exec('gendok_args','!tte_wyk_dgrp')
::       [_b] - ZL.ref - zlecenie lub bieżący rekord
::       [_c] - ZPARN.ref - partia
::   WY: DK_C.ref lub null jeżeli zrezygnowano z redakcji
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_ref:=null();
{? var_pres('_b')=type_of(ZL.ref())
|| _ref:=_b
?};
_zparn:=null();
{? var_pres('_c')=type_of(ZPARN.ref())
|| _zparn:=_c
?};

_result:=null();
_can_continue:=1;

M_ATR.cntx_psh();
DK.cntx_psh();
ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _party:=exec('zlec_party','zl_common',ZL.ref());

:: Pytam się o cechę wyłącznie jeżeli zlecenie którego dotyczy generacja ma więcej niż jeden atrybut - dla atrybutów
:: Tylko z partią, cecha utworzy się automatycznie w gendok_core
   ZL.KTM().M_ATR();
   _buf_matr:=exec('buffer','mat_atr');
   _buf_matr.get_matr();

   {? ZL.DK_C<>null()
   || ZL.DK_C();
      _buf_matr.get_dkc()
   ?};

   {? _args.DK_C<>null()
   || DK_C.cntx_psh(); DK_C.prefix();
      {? DK_C.seek(_args.DK_C)
      || _buf_matr.get_dkc()
      ?};
      DK_C.cntx_pop()
   ?};
   {? _zparn<>null()
   || _buf_matr.set_part(_zparn)
   ?};

   {? _buf_matr.count()>0 & ZL.MG().TYP*'DOST'>0
   ||
      {? _buf_matr.all_set()=0
      ||
::       Daję komunikat informacyjny
         _msg:='Ponieważ zlecenie %1 posiada przypisaną cechę lub jest partiowane,\n'
               'wymagane jest określenie wartości atrybutów dla cechy dokumentu raportującego produkt zlecenia.'@[ZL.SYM];
         FUN.info(_msg);
::       Tworzę cechę
         DK.blank();
         DK.M:=ZL.KTM;

         ATR.ZPARN_DK:=_zparn;
         _dk_c:=exec('matr_rp','mat_atr',ZL.ref());
         {? _dk_c<>null()
         || _args.DK_C:=_dk_c;
            _result:=_dk_c
         ?}
      ||
::       Zakładam ceche, lub zwracam istniejącą
         _result:=exec('m_atr_sprdod','mat_atr',_buf_matr.WAR01
                                               ,_buf_matr.WAR02
                                               ,_buf_matr.WAR03
                                               ,_buf_matr.WAR04
                                               ,_buf_matr.WAR05
                                               ,_buf_matr.WAR06
                                               ,_buf_matr.WAR07
                                               ,_buf_matr.WAR08
                                               ,_buf_matr.WAR09
                                               ,_buf_matr.WAR10
                                               ,_buf_matr.M_ATR
                                               ,_zparn
                                               )


      ?}
   ?}
?};
ZL.cntx_pop();
DK.cntx_pop();
M_ATR.cntx_pop();
_result


\gendok_struktura_env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Środowisko funkcji gendok_struktura
::   WY: obj_new
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
::UWAGA: _fld, i _mth to formułki pomocnicze, zeby wygodniej tworzyć tablicę i komentować poszczególne jej elementy
::       powiedzmy, że to bedzie pole
         _fld:="31+form(_a)";
::       powiedzmy, że to bedzie metoda
         _mth:="31+form(_a)";

_env:=obj_new(
::             Zmienne pomocnicze
               _fld('DIALOG','Tryb dialogów: 0 - brak, 1 - FUN, 2 - KOMM')
               ,_fld('TYP_ND','Typ elementu - nagłówek dokumentu')
               ,_fld('TYP_DK','Typ elementu - pozycja dokumentu')
               ,_fld('RESULT','Wynik działania funkcji')
               ,_fld('TXT','Komunikat o błędzie')
               ,_fld('CORE_ARGS','Argumenty jądra')

::             tabele tymczasowe
               ,_fld('TAB_DOK','Tabela tymczasowa ze strukturą dokumentów')

::             indeksy tymczasowych tabel
               ,_fld('NDX_DOK_LP','Indeks tabeli tymczasowej .TAB_DOK')
               ,_fld('NDX_DOK_TYP','Indeks tabeli tymczasowej .TAB_DOK')
               ,_fld('NDX_DOK_UID','Indeks tabeli tymczasowej .TAB_DOK')
               ,_fld('NDX_DOK_PAR','Indeks tabeli tymczasowej .TAB_DOK')
               ,_fld('NDX_DOK_MG','Indeks tabeli tymczasowej .TAB_DOK')
               ,_fld('NDX_DOK_ZGP','Indeks tabeli tymczasowej .TAB_DOK')
               ,_fld('NDX_DOK_ND','Indeks tabeli tymczasowej .TAB_DOK')
               ,_fld('NDX_DOK_ZPARN','Indeks tabeli tymczasowej .TAB_DOK')

::             METODY
               ,_mth('select','Pokazuje tabelę ze strukturą')
               ,_mth('add4zlgd','Dodaje dokument/pozycję dokumentu w kontekście ZLGD')
               ,_mth('add4zl_wyrgd','Dodaje dokument/pozycję dokumentu w kontekście ZL_WYRGD')
               ,_mth('add4zgp','Dodaje dokument/pozycję dokumentu w kontekście ZGP')
               ,_mth('add4tab_wyr','Dodaje dokument/pozycję dokumentu w kontekście przygotowanej rozpiski')
             );
_env.TYP_ND:='ND';
_env.TYP_DK:='DK';
_env.RESULT:=1;
_env.TXT:='';
_env.CORE_ARGS:=~~;

_env.TAB_DOK:=tab_tmp(2
   ,'LP','INTEGER','Kolejność'
   ,'TYP','STRING[1]','Typ'
   ,'UID','STRING[20]','Identyfikator'
   ,'PAR','STRING[20]','Identyfikator nadrzędny'
   ,'MG','STRING[16]','Magazyn'
   ,'MG_SYM','STRING[8]','Magazyn symbol'
   ,'ZL','STRING[16]','Zlecenie'
   ,'M','STRING[16]','Materiał'
   ,'M_KTM','STRING[50]','Materiał - indeks'
   ,'ILOSC','REAL','Ilość'
   ,'DK_C','STRING[16]','Cecha'
   ,'EANL','STRING[16]','Lokalizacja'
   ,'ZPARN','STRING[16]','Partia'
   ,'ZGH','STRING[16]','Nagłówek przewodnika'
   ,'ZGP','STRING[16]','Pozycja przewodnika'
   ,'ZLGD','STRING[16]','Robocizna'
   ,'ZL_WYRGD','STRING[16]','Robocizna na wyroby'
   ,'ND','STRING[16]','Ref wygenerowanego dokumentu'
   ,'DK','STRING[16]','Ref wygenerowanego dokumentu'
   ,'TYPYDOK','STRING[16]','Typ dokumentu'
   ,'TW','DATE','Termin ważności'
);
_env.NDX_DOK_LP:=_env.TAB_DOK.ndx_tmp(,,'LP',,);
_env.NDX_DOK_TYP:=_env.TAB_DOK.ndx_tmp(,,'TYP',,,'LP',,);
_env.NDX_DOK_UID:=_env.TAB_DOK.ndx_tmp(,,'UID',,,'LP',,);
_env.NDX_DOK_PAR:=_env.TAB_DOK.ndx_tmp(,,'PAR',,,'LP',,);
_env.NDX_DOK_MG:=_env.TAB_DOK.ndx_tmp(,,'MG',,,'TYP',,,'ZL',,);
_env.NDX_DOK_ZGP:=_env.TAB_DOK.ndx_tmp(,,'ZGP',,,'TYP',,,'MG',,,'M',,,'LP',,);
_env.NDX_DOK_ND:=_env.TAB_DOK.ndx_tmp(,,'ND',,);
_env.NDX_DOK_ZPARN:=_env.TAB_DOK.ndx_tmp(,,'ZPARN',,,'TYP',,,'MG',,,'M',,,'LP',,);

_env.add4zlgd:="

   _args:=_a;

   _mask_zlgd:=ZLGD.name();


   _tab:=.TAB_DOK;

   _tab.cntx_psh();
   _tab.prefix();
   _lp:=_tab.size()+1;
   ZL_WYRGD.cntx_psh();
   ZL_WYRGD.use(5+ZL_WYRGD.name()+(_mask_zlgd+3));
   ZL_WYRGD.index('ZLGD');
   ZL_WYRGD.prefix(ZLGD.ref());
   {? ZL_WYRGD.first()
   ||
::    Są rekordy ZL_WYRGD
      {!
      |? .add4zl_wyrgd(_args);
         ZL_WYRGD.next()
      !}
   ||
::    Dodajemy na podstawie ZLGD
      _mag:=exec('zl_mg','zl_common',ZLGD.ZL);
      _mag_sym:=exec('FindAndGet','#table',MG,_mag,,\"SYM\",'');
      _ktm:=ZLGD.ZL().KTM;
      {? .CORE_ARGS.TYPYDOK<>null()
      || _typydok:=.CORE_ARGS.TYPYDOK
      || _typydok:=ZLGD.ZGP().DOK
      ?};
      _tab.index(.NDX_DOK_MG);
      _tab.prefix($_mag,.TYP_ND,$ZLGD.ZL,);
      _ilosc:=ZLGD.IL-ZLGD.ILGEN;
      _zgp:=ZLGD.ZGP;
      {? _ilosc>0
      ||
         _parent:='';
         {? _tab.first()=0
         || _tab.blank();
            _tab.LP:=_lp;
            _tab.TYP:=.TYP_ND;
            _tab.UID:='Nagłówek_%1'[$_tab.LP];
            _tab.MG:=$_mag;
            _tab.TYPYDOK:=$_typydok;
            _tab.MG_SYM:=_mag_sym;
            _tab.ZL:=$ZLGD.ZL;
            {? _tab.add()
            || _parent:=_tab.UID
            ?}
         || _parent:=_tab.UID
         ?};
         {? ZLGD.ZPARN<>null()
         || _tab.index(.NDX_DOK_ZPARN);
            _tab.prefix($ZLGD.ZPARN,.TYP_DK,$_mag,$_ktm)
         || _tab.index(.NDX_DOK_ZGP);
            _tab.prefix($_zgp,.TYP_DK,$_mag,$_ktm)
         ?};
         _lp+=1;
         {? _parent<>''
         || {? _tab.first()
            || _tab.ILOSC+=_ilosc;
               _tab.put()
            ||
               _tab.blank();
               _tab.PAR:=_parent;
               _tab.LP:=_lp;
               _tab.TYP:=.TYP_DK;
               _tab.UID:='Pozycja_%1'[$_tab.LP];
               _tab.MG:=$_mag;
               _tab.TYPYDOK:=$_typydok;
               _tab.MG_SYM:=_mag_sym;
               _tab.ZL:=$ZLGD.ZL;
               _tab.M:=$_ktm;
               _tab.M_KTM:=ZLGD.ZL().KTM().KTM;
               _tab.ZPARN:=$ZLGD.ZPARN;
               _tab.ZGH:=$ZLGD.ZGH;
               _tab.ZGP:=$_zgp;
               _tab.ZLGD:=$ZLGD.ref();
               _tab.ILOSC:=_ilosc;
               _tab.add()
            ?}
         ?}
      ?}
   ?};
   ZL_WYRGD.cntx_pop();
   _tab.cntx_pop();
   _tab.prefix();
   ~~
";
_env.add4zl_wyrgd:="

   _args:=_a;

   _tab:=.TAB_DOK;
   _tab.cntx_psh();
   _tab.prefix();
   _lp:=_tab.size()+1;

:: Dodajemy na podstawie ZL_WYRGD
   _mag:=ZL_WYRGD.MG;
   _mag_sym:=ZL_WYRGD.MG().SYM;
   _ktm:=ZL_WYRGD.KTM;
   {? .CORE_ARGS.TYPYDOK<>null()
   || _typydok:=.CORE_ARGS.TYPYDOK
   || _typydok:=ZL_WYRGD.ZGP().DOK
   ?};
   _eanl:=ZL_WYRGD.EANL;
   _tab.index(.NDX_DOK_MG);
   _tab.prefix($_mag,.TYP_ND,$ZL_WYRGD.ZGP().ZL,);
   _zgp:=ZL_WYRGD.ZGP;
::   _ilosc_gen:=exec('ilosc_left','zl_guide',_zgp,'M');
   _ilosc:=ZL_WYRGD.IL-ZL_WYRGD.ILGEN;
   {? _ilosc>0
   ||
      _parent:='';
      {? _tab.first()=0
      || _tab.blank();
         _tab.LP:=_lp;
         _tab.TYP:=.TYP_ND;
         _tab.UID:='Nagłówek_%1'[$_tab.LP];
         _tab.MG:=$_mag;
         _tab.TYPYDOK:=$_typydok;
         _tab.MG_SYM:=_mag_sym;
         _tab.ZL:=$ZL_WYRGD.ZGP().ZL;
         {? _tab.add()
         || _parent:=_tab.UID
         ?}
      || _parent:=_tab.UID
      ?};
      {? ZL_WYRGD.ZPARN<>null()
      || _tab.index(.NDX_DOK_ZPARN);
         _tab.prefix($ZL_WYRGD.ZPARN,.TYP_DK,$_mag,$_ktm)
      || _tab.index(.NDX_DOK_ZGP);
         _tab.prefix($_zgp,.TYP_DK,$_mag,$_ktm)
      ?};
      _lp+=1;
      {? _parent<>''
      ||
         {? _tab.first()
         || _tab.ILOSC+=_ilosc;
            _tab.put()
         ||
            _tab.blank();
            _tab.PAR:=_parent;
            _tab.LP:=_lp;
            _tab.TYP:=.TYP_DK;
            _tab.UID:='Pozycja_%1'[$_tab.LP];
            _tab.MG:=$_mag;
            _tab.TYPYDOK:=$_typydok;
            _tab.MG_SYM:=_mag_sym;
            _tab.ZL:=$ZL_WYRGD.ZGP().ZL;
            _tab.M:=$_ktm;
            _tab.M_KTM:=ZL_WYRGD.KTM().KTM;
            _tab.EANL:=$_eanl;
            _tab.ZPARN:=$ZL_WYRGD.ZPARN;
            _tab.ZGH:=$ZL_WYRGD.ZGP().NRPRZ;
            _tab.ZGP:=$ZL_WYRGD.ZGP;
            _tab.ZLGD:=$ZL_WYRGD.ZLGD;
            _tab.ILOSC:=_ilosc;
            _tab.add()
         ?}
      ?}
   ?};
   _tab.cntx_pop();
   _tab.prefix();
   ~~
";

_env.add4zgp:="

   _args:=_a;
   _zparn:=null;
   {? var_pres('_b')=type_of(ZPARN.ref())
   || _zparn:=_b
   ?};

   _tab:=.TAB_DOK;
   _tab.cntx_psh();
   _tab.prefix();
   _lp:=_tab.size()+1;

:: Dodajemy na podstawie ZGP
   _mag:=exec('zl_mg','zl_common',ZGP.ZL);
   _mag_sym:=exec('FindAndGet','#table',MG,_mag,,\"SYM\",'');
   _ktm:=ZGP.ZL().KTM;
   {? .CORE_ARGS.TYPYDOK<>null()
   || _typydok:=.CORE_ARGS.TYPYDOK
   || _typydok:=ZGP.DOK
   ?};
   _tab.index(.NDX_DOK_MG);
   _tab.prefix($_mag,.TYP_ND,$ZGP.ZL,);
   _zgp:=ZGP.ref();
   _ilosc:=_args.ILOSC;
   {? _ilosc=0
   || {? _zparn<>null()
      || _ilosc:=exec('ilosc_left','zl_partie',_zparn,_args.WARIANT)
      || _ilosc:=exec('ilosc_left','zl_guide',ZGP.ref(),_args.WARIANT)
      ?}
   ?};

   {? _ilosc>0
   ||
      _parent:='';
      {? _tab.first()=0
      || _tab.blank();
         _tab.LP:=_lp;
         _tab.TYP:=.TYP_ND;
         _tab.UID:='Nagłówek_%1'[$_tab.LP];
         _tab.MG:=$_mag;
         _tab.TYPYDOK:=$_typydok;
         _tab.MG_SYM:=_mag_sym;
         _tab.ZL:=$ZGP.ZL;
         {? _tab.add()
         || _parent:=_tab.UID
         ?}
      || _parent:=_tab.UID
      ?};

      {? _zparn<>null()
      || _tab.index(.NDX_DOK_ZPARN);
         _tab.prefix($_zparn,.TYP_DK,$_mag,$_ktm)
      || _tab.index(.NDX_DOK_ZGP);
         _tab.prefix($_zgp,.TYP_DK,$_mag,$_ktm)
      ?};
      _lp+=1;
      {? _parent<>''
      ||
         {? _tab.first()
         || _tab.ILOSC+=_ilosc;
            _tab.put()
         ||
            _tab.blank();
            _tab.PAR:=_parent;
            _tab.LP:=_lp;
            _tab.TYP:=.TYP_DK;
            _tab.UID:='Pozycja_%1'[$_tab.LP];
            _tab.MG:=$_mag;
            _tab.TYPYDOK:=$_typydok;
            _tab.MG_SYM:=_mag_sym;
            _tab.ZL:=$ZGP.ZL;
            _tab.M:=$_ktm;
            _tab.M_KTM:=ZGP.ZL().KTM().KTM;
            _tab.ZPARN:=$_zparn;
            _tab.ZGH:=$ZGP.NRPRZ;
            _tab.ZGP:=$ZGP.ref();
            _tab.ILOSC:=_ilosc;
            _tab.add()
         ?}
      ?}
   ?};
   _tab.cntx_pop();
   _tab.prefix();
   ~~
";

_env.add4tab_wyr:="

   _args:=_a;
   _tab_p:=_b;

   _tab:=.TAB_DOK;
   _tab.cntx_psh();
   _tab.prefix();
   _lp:=_tab.size()+1;

:: Dodajemy na podstawie rekordu rozpiski
   _mag:=exec('FindAndGet','#table',MG,_tab_p.MGREF,,,null());
   _mag_sym:=exec('FindAndGet','#table',MG,_mag,,\"SYM\",'');
   _ktm:=_tab_p.MREF;
   {? .CORE_ARGS.TYPYDOK<>null()
   || _typydok:=.CORE_ARGS.TYPYDOK
   || _typydok:=ZGP.DOK
   ?};
   _tab.index(.NDX_DOK_MG);
   _tab.prefix($_mag,.TYP_ND,$ZGP.ZL,);
   _zgp:=ZGP.ref();
   _ilosc:=_tab_p.IL;

   {? _ilosc>0
   ||
      _parent:='';
      {? _tab.first()=0
      || _tab.blank();
         _tab.LP:=_lp;
         _tab.TYP:=.TYP_ND;
         _tab.UID:='Nagłówek_%1'[$_tab.LP];
         _tab.MG:=$_mag;
         _tab.TYPYDOK:=$_typydok;
         _tab.MG_SYM:=_mag_sym;
         _tab.ZL:=$ZGP.ZL;
         {? _tab.add()
         || _parent:=_tab.UID
         ?}
      || _parent:=_tab.UID
      ?};
      {? _tab_p.ZPARN<>''
      || _tab.index(.NDX_DOK_ZPARN);
         _tab.prefix(_tab_p.ZPARN,.TYP_DK,$_mag,_ktm)
      || _tab.index(.NDX_DOK_ZGP);
         _tab.prefix($_zgp,.TYP_DK,$_mag,_ktm)
      ?};
      _lp+=1;
      {? _parent<>''
      ||
         {? _tab.first()
         || _tab.ILOSC+=_ilosc;
            _tab.put()
         ||
            _tab.blank();
            _tab.PAR:=_parent;
            _tab.LP:=_lp;
            _tab.TYP:=.TYP_DK;
            _tab.UID:='Pozycja_%1'[$_tab.LP];
            _tab.MG:=$_mag;
            _tab.TYPYDOK:=$_typydok;
            _tab.MG_SYM:=_mag_sym;
            _tab.ZL:=$ZGP.ZL;
            _tab.M:=_ktm;
            _tab.M_KTM:=_tab_p.KTM;
            _tab.ZPARN:=_tab_p.ZPARN;
            _tab.ZGH:=$ZGP.NRPRZ;
            _tab.ZGP:=$ZGP.ref();
            _tab.ILOSC:=_ilosc;
            _tab.add()
         ?}
      ?}
   ?};
   _tab.cntx_pop();
   _tab.prefix();
   ~~
";


_env.select:="
   _tab:=.TAB_DOK;

   _title:='Struktura dokumentów'@;
   _wer:=_tab.mk_sel(_title,'P',0,'#gendok_strukt',1,1,,,'U');
   _tab.win_fld(_wer,,'LP',,,,,,'Lp.'@,0);
   _tab.win_fld(_wer,,'TYP',,,,,,'Typ'@,0);
   _tab.win_fld(_wer,,'UID',,,,,,'Identyfikator'@,0);
   _tab.win_fld(_wer,,'PAR',,,,,,'Rodzic'@,0);
   _tab.win_fld(_wer,,'MG_SYM',,,,,,'Magazyn'@,0);
   _tab.win_fld(_wer,,'M_KTM',,,,,,'Indeks'@,0);
   _tab.win_fld(_wer,,'ILOSC',,,,,,'Ilość'@,0);

   _fml:=\"sel_exit()\";
   _tab.win_act(_wer,1,'Formuła','Akceptuj'@@,,,_fml,,1,,,,'A');
   _tab.win_act(_wer,,'Formuła','Akceptuj'@@,,,_fml,,1,,,,'A');
   _tab.win_btn(_wer,'text=%1,panel=bottom'['Akceptuj'@@],'menu:A');

   _tab.win_sel(_wer);
   _tab.index(.NDX_DOK_LP);
   _tab.select()
";
_env


\gendok_struktura
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Zwraca tabelkę tymczasową określającą ile nagłówków dokumentów magazynowych należy utworzyć i jakie mają być pozycje w każdym
::   WE: _a - obj_new() - tablica argumentów wszystkich funkcji gendok_, wynik działania exec('gendok_args','!tte_wyk_dgrp')
::       _b - obj_new() - środowisko funkcji, wynik działania exec('gendok_struktura_env','!tte_wyk_dgrp')
::   WY: tab_tmp - tabela tymczasowa ze strukturą
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_env:=_b;
{? var_pres('CORE_ARGS',_env)>100
|| obj_del(_env.CORE_ARGS)
?};
_env.CORE_ARGS:=_args;

{? _args.WARIANT='W'
||
:: Wariant wg robocizny

   _multipart:=0;

   {? var_pres('TAB_PART',_args)>100
   || _tab:=_args.TAB_PART.tab;
      {? _tab.size()>1
      || _multipart:=1
      |? _tab.first() & _args.ZPARN=null()
      || _args.ZPARN:=exec('FindAndGet','#table',ZPARN,_tab.SQL,,,null())
      ?}
   ?};
   {? _multipart>0
   ||
::    wiele partii
      {? _tab.first()
      || {!
         |?
            ZLGD.cntx_psh();
            _zparn:=exec('FindAndGet','#table',ZPARN,_tab.SQL,,,null());
            {? _zparn<>null()
            ||
::             !!! REKURENCJA !!!
               _args.ZPARN:=_zparn;
               {? var_pres('TAB_PART',_args)>100
               || obj_del(_args.TAB_PART)
               ?};
               exec('gendok_struktura','!tte_wyk_dgrp',_args,_env)
            ?};
             ZLGD.cntx_pop();
            _tab.next()
         !}
      ?}
   |? _args.ZPARN<>null()
   ||
::    jedna partia
      _zl:=exec('FindAndGet','#table',ZPARN,_args.ZPARN,,"ZL",null());
      _zparn_left:=exec('get_ilosc_zlgd','zl_partie',_args.ZPARN,_args.ZGP,1,exec('zl_czy_wyr','zl_wyr',_zl));
      {? _zparn_left>0
      ||
         {? exec('zl_czy_wyr','zl_wyr',_zl)>0
         ||
            _zlgd_tab:=exec('get_zl_wyrgd_tab','zl_partie',_args.ZPARN,_args.ZGP);
            _zlgd_tab.prefix();
            {? _zlgd_tab.first()
            || {!
               |? ZL_WYRGD.cntx_psh();
                  ZL_WYRGD.use(ref_name(_zlgd_tab.ZL_WYRGD));
                  ZL_WYRGD.index('ZPARN');
                  ZL_WYRGD.prefix();
                  {? ZL_WYRGD.seek(_zlgd_tab.ZL_WYRGD)
                  || _zlgd_left:=ZL_WYRGD.IL-ZL_WYRGD.ILGEN;

                     {? ZL_WYRGD.ZGP().DOK<>null() & _zlgd_left>0
                     || _env.add4zl_wyrgd(_args)
                     ?}
                  ?};
                  ZL_WYRGD.cntx_pop();
                  _zlgd_tab.next()
               !}
            ?}
         || _zlgd_tab:=exec('get_zlgd_tab','zl_partie',_args.ZPARN,_args.ZGP);
            _zlgd_tab.prefix();
            {? _zlgd_tab.first()
            || {!
               |? ZLGD.cntx_psh();
                  ZLGD.use(ref_name(_zlgd_tab.ZLGD));
                  ZLGD.index('ZPARN');
                  ZLGD.prefix();
                  {? ZLGD.seek(_zlgd_tab.ZLGD)
                  || _zlgd_left:=ZLGD.IL-ZLGD.ILGEN;

                     {? ZLGD.ZGP().DOK<>null() & _zlgd_left>0
                     || _env.add4zlgd(_args)
                     ?}
                  ?};
                  ZLGD.cntx_pop();
                  _zlgd_tab.next()
               !}
            ?}
         ?}
      ||
         _msg:='Generacja działa w oparciu o robociznę, której do partii: %1 '
               'nie zarejestrowano jeszcze w stopniu umożliwiajacym raportowanie produkcji'@[exec('record','#to_string',_args.ZPARN)];
         KOMM.add(_msg,2,,1);
         _env.TXT:=_msg
      ?}
   |? _args.ZLGD<>null()
   ||
::    jedna pozycja robocizny
      ZLGD.cntx_psh();
      ZLGD.use(ref_name(_args.ZLGD));
      ZLGD.prefix();
      {? ZLGD.seek(_args.ZLGD)
      || _zlgd_left:=ZLGD.IL-ZLGD.ILGEN;
         {? ZLGD.ZGP().DOK<>null() & _zlgd_left>0
         || _env.add4zlgd(_args)
         ?}
      ?};
      ZLGD.cntx_pop()
   |? _args.ZGP<>null()
   ||
::    jedna pozycja przewodnika
      ZGP.cntx_psh();
      ZGP.prefix();
      {? ZGP.seek(_args.ZGP)
      ||
         _tab_partie:=exec('ref_table','#table');
         _tab_zlgd:=exec('ref_table','#table');
         _collector:=obj_new('TAB_PART','TAB_ZLGD');
         _collector.TAB_PART:=_tab_partie;
         _collector.TAB_ZLGD:=_tab_zlgd;
         _rule:="
            _args:=_b;
            _tab_partie:=_args.TAB_PART;
            _tab_zlgd:=_args.TAB_ZLGD;
            ZLGD.cntx_psh();
            ZLGD.index('S2');
            ZLGD.prefix(ZGP.ref());
            {? ZLGD.first()
            || {!
               |? _zlgd_left:=ZLGD.IL-ZLGD.ILGEN;
                  {? ZLGD.ZGP().DOK<>null() & _zlgd_left>0
                  || {?  ZLGD.ZPARN<>null()
                     || _tab_partie.add(ZLGD.ZPARN)
                     ?};
                     _tab_zlgd.add(ZLGD.ref())
                  ?};
                  ZLGD.next()
               !}
            ?};
            ZLGD.cntx_pop()
         ";
         exec('for_each_mask','#table',ZLGD,_rule,,,_collector);

         _tab_partie.tab.prefix();
         _tab_zlgd.tab.prefix();

         {? _tab_partie.tab.size()=0
         ||
::          Brak partii
            _left:=exec('ilegen','magdok_prod',null(),'ZGP').ilegen;
            _left:=exec('max','#math',0,_left);
            _ilosc:=exec('min','#math',_left,_args.ILOSC);

            {? _ilosc>0
            ||
               {? _tab_zlgd.tab.first()
               || {!
                  |? ZLGD.cntx_psh();
                     ZLGD.use(ref_name(_tab_zlgd.tab.SQL));
                     ZLGD.index('ZPARN');
                     ZLGD.prefix();
                     {? ZLGD.seek(_tab_zlgd.tab.SQL)
                     ||
                        _args.ZLGD:=ZLGD.ref();
::                      !!! REKURENCJA !!!
                        exec('gendok_struktura','!tte_wyk_dgrp',_args,_env)
                     ?};
                     ZLGD.cntx_pop();
                     _tab_zlgd.tab.next()
                  !}
               ?}
            ?}
         |? _tab_partie.tab.size()=1
         ||
::          jedna partia
            {? _tab_partie.tab.first()
            ||
               _zparn:=exec('FindAndGet','#table',ZPARN,_tab_partie.tab.SQL,,,null());
               _args.ZPARN:=_zparn;
               {? var_pres('TAB_PART',_args)>100
               || obj_del(_args.TAB_PART)
               ?};

::             !!! REKURENCJA !!!
               exec('gendok_struktura','!tte_wyk_dgrp',_args,_env)
            ?}
         |? _tab_partie.tab.size()>1
         ||
::          wiele partii
            {? var_pres('TAB_PART',_args)>100
            || obj_del(_args.TAB_PART)
            ?};
            _args.TAB_PART:=_tab_partie;

::          !!! REKURENCJA !!!
            exec('gendok_struktura','!tte_wyk_dgrp',_args,_env)
         ?}
      ?};
      ZGP.cntx_pop()
   |? _args.ZL<>null()
   ||
::    całe zlecenie
      ZGP.cntx_psh();
      ZGP.index('ZLEC');
      ZGP.prefix(_args.ZL);
      {? ZGP.first()
      ||
         {!
         |?
            {? ZGP.DOK<>null()
            ||
               _args.ZGP:=ZGP.ref();

::             !!! REKURENCJA !!!
               exec('gendok_struktura','!tte_wyk_dgrp',_args,_env)
            ?};
            ZGP.next()
         !}
      ?};
      ZGP.cntx_pop();
      ~~
   ?}
|? _args.WARIANT='M'
||
:: wariant magazynowy
   _multipart:=0;

   {? var_pres('TAB_PART',_args)>100
   || _tab:=_args.TAB_PART.tab;
      {? _tab.size()>1
      || _multipart:=1
      || {? _tab.first()
         || _args.ZPARN:=exec('FindAndGet','#table',ZPARN,_tab.SQL,,,null())
         ?}
      ?}
   ?};
   {? var_pres('TAB_WYR',_args)>100
   ||
::    jest rozpiska
      ZGP.cntx_psh(); ZGP.prefix();
      {? ZGP.seek(_args.ZGP)
      ||
         _tab:=_args.TAB_WYR;
         _tab.prefix();
         {? _tab.first()
         || {!
            |?  _env.add4tab_wyr(_args,_tab);
               _tab.next()
            !}
         ?}
      ?};
      ZGP.cntx_pop()
   |? _multipart>0
   ||
::    wiele partii
      {? _tab.first()
      || {!
         |?
            ZLGD.cntx_psh();
            _zparn:=exec('FindAndGet','#table',ZPARN,_tab.SQL,,,null());
            {? _zparn<>null()
            ||
::             !!! REKURENCJA !!!
               _args.ZPARN:=_zparn;
               {? var_pres('TAB_PART',_args)>100
               || obj_del(_args.TAB_PART)
               ?};
               exec('gendok_struktura','!tte_wyk_dgrp',_args,_env)
            ?};
            ZLGD.cntx_pop();
            _tab.next()
         !}
      ?}
   |? _args.ZPARN<>null()
   ||
::    jedna partia
      {? _args.ZGP=null()
      || ZPARN.cntx_psh(); ZPARN.prefix();
         {? ZPARN.seek(_args.ZPARN)
         ||  _args.ZGP:=exec('first_with_dok','zl_guide',ZPARN.ZL,ZPARN.ZGH);
            {? _args.ZGP=null()
            || _args.ZGP:=exec('last_zgp','zl_guide',ZPARN.ZL,ZPARN.ZGH)
            ?}
         ?};
         ZPARN.cntx_pop()
      ?};

      ZGP.cntx_psh(); ZGP.prefix();
      {? ZGP.seek(_args.ZGP)
      || _env.add4zgp(_args,_args.ZPARN)
      ?};
      ZGP.cntx_pop()
   |? _args.ZGP<>null()
   || ZGP.cntx_psh(); ZGP.prefix();
      {? ZGP.seek(_args.ZGP)
      || _env.add4zgp(_args)
      ?};
      ZGP.cntx_pop()
   ?};
   ~~
?};
~~


\typ_dok_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Formuła walidująca podczas wyboru dokumentu raportującego - parametr _c formuły exec('typ_dok','lmg')
::   WE: [_a] - ZL.ref() - zlecenie, do którego raportowana jest produkcja, jak nie podany to biezący rekord
::----------------------------------------------------------------------------------------------------------------------
_zl:={? var_pres('_a')=type_of(ZL.ref()) || _a || ZL.ref() ?};
_result:=0;
ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| _result:=1;
   {? TYPYDOK.KOD<>''
   || _czy_wyr:=exec('zl_czy_wyr','zl_wyr',_zl);
::    Sprawdzenie, czy wybrany typ dokumentu jest obsługiwany na magazynie zlecenia, do którego generowany jest RP
      MG.cntx_psh();
      _mg:=ZL.MG;
      _mg_sym:=ZL.MG().SYM;
      MG.cntx_pop();
      _wyn:=exec('chk_mg4typ','magdok_wspolne',_mg);
      {? ~_wyn
      || _msg:='Brak dostępu do dokumentu: %1 na magazynie: %2.'@[TYPYDOK.T,_mg_sym];
         {? _czy_wyr>0
         ||
::          Jak zlecenie na wiele wyrobów to komunikat ostrzegający (RP może być generowane na kilka różnych magazynów)
::          Walidacja magazynów robiona w momencie wypełniania rozpiski wg wyrobów
            _msg+='\n\nWyroby będą mogły być zarejestrowane wyłącznie na magazyny, które obsługują dany typ dokumentu.'
                  '\nKontynuować?';
            _result:=FUN.ask(_msg)
         || FUN.emsg(_msg);
            _result:=0
         ?}
      ?};
      _tab:=cur_tab(1,1);
::    Zabezpieczenie na wypadek, gdy dostępny tylko 1 typ dokumentu i nie wyświetli się okno selekcji
      {? _result>0 & var_pres('_tab')=type_of(TYPYDOK) & _tab=TYPYDOK
      || sel_exit()
      ?}
   || FUN.info('Nieuzupełniony kod numeracji dla %1.'@[TYPYDOK.T]);
      _result:=0
   ?}
?};
ZL.cntx_pop();
_result


\ilosc_left
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca ilość pozostałą do zaraportowania na zleceniu
::   WE: _a   - STRING - wariant
::       _b   - ZGP.ref() - pozycja przewodnika
::       [_c] - ZPARN.ref() - partia
::   WY: REAL - ilość pozostała
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_wariant:=_a;
_zgp:=_b;

_zparn:=null();
{? var_pres('_c')=type_of(ZPARN.ref())
|| _zparn:=_c
?};

_result:=0;
_can_continue:=1;

{? _can_continue>0
|| {? _zparn<>null()
   || _result:=exec('ilosc_left','zl_partie',_zparn,_wariant)
   || {? _zgp=null()
      || FUN.error('Błąd wywołania formuły: %1. Nie podano pozycji przewodnika'@['ilosc_left / !tte_wyk_dgrp'])
      ||
         _result:=exec('ilosc_left','zl_guide',_zgp,_wariant)
      ?}
   ?}
?};
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:09:40 8e2b60641db0795680da3b1465adc9a682e8c655e8b16b753032b57463f22d7feabd312425201d3cea68e596170b63286cc47d4b5edb24e6672b06f75c665cbfeda2b9d32c81a925256201e4eed133fcd96478d2e50b4b3b7ab7a61f7660a511205b038987224421bfd64ee2d58c85cfa94d6c064621342d2c36c271d62e5d3f
