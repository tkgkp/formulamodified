:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tte_pzl_dpzg.fml
:: Utworzony: 26.10.2015
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły czynności TTE_PZL_DPZG - Generacja przewodników zlecenia
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła główna czynności generacji przewodnika zlecenia (TTE_PZL_DPZG)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::       context - [obj_new] obiekt służący do przekazywania kontekstu wywołania czynności
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

:: WŁAŚCIWOŚCI CZYNNOŚCI
::# permissions=ODDZ
::# properties=LOOP,SERVICE
::# parses=exec('parses','!tte_pzl_dpzg')
::# condition=Rejestracja przewodnika zlecenia, act_uid=TTE_PZL_DPRZ,   auto=T,  formula=_a.ZGH<>~~ & _a.ZGH<>null()

:: PARAMETRY WE:
::# kind=WE, symbol=ZL, type=_ZL, name=Wskazanie na zlecenie, required=T, keyref=T
::# kind=WE, symbol=GRP_KEY, type=STRING, name=Klucz grupujący, required=N, keyref=N
{? var_pres('ZL',_in)<>type_of(~~) & var_pres('ZL',_in)<>type_of(null()) || return() ?};
{? var_pres('ZL',_in)=type_of(~~) || _in.ZL:=null() ?};

{? var_pres('GRP_KEY',_in)<>type_of(~~) & var_pres('GRP_KEY',_in)<>type_of('') || return() ?};
{? var_pres('GRP_KEY',_in)=type_of(~~) || _in.GRP_KEY:='' ?};

:: Parametry WEW:
::# kind=WEW, symbol=GRP_KEY, type=STRING, name=Klucz grupujący, required=N, keyref=N
{? var_pres('GRP_KEY',_int)<>type_of(~~) & var_pres('GRP_KEY',_int)<>type_of('') || return() ?};
{? var_pres('GRP_KEY',_int)=type_of(~~) || _int.GRP_KEY:='' ?};

:: PARAMETRY WY:
::# kind=WY, symbol=ZGH, type=_ZGH, name=Wskazanie na przewodnik zlecenia, required=N
{? var_pres('ZGH',_out)<>type_of(~~) & var_pres('ZGH',_out)<>type_of(null()) || return() ?};
::# kind=WY, symbol=GRP_KEY, type=STRING, name=Klucz grupujący, required=N
{? var_pres('GRP_KEY',_out)<>type_of(~~) & var_pres('GRP_KEY',_out)<>type_of('') || return() ?};
::# kind=WY, symbol=RESULT, type=STRING, name="Wynik działania (OK, BŁĄD)", required=N

ZL.cntx_psh(); ZGH.cntx_psh();
ZL.prefix(); ZGH.prefix();

_keyRefs:=_mp.getRefs();

_result:=~~;

:: Ustawiam wartość domyślną argumentu LOOP żeby brama się nie zawiesiła
_out.LOOP:='N';

_clean_result:=params_exec('clean','!tte_pzl_dpzg',_mp,_in);
_can_continue:=_clean_result.RESULT;
_zl:=_clean_result.ZL;

:: WSTĘPNE WALIDACJE
{? _can_continue>0 & _mp.isService() & _zl=null()
|| _msg:='Błędna konfiguracja procesu — nie przekazano zlecenia.'@;
   _mp.error(_msg);
   _can_continue:=0
?};

{? _can_continue & ZL.seek(_zl)
||
   _top_level:=exec('top_level','zl_link',ZL.ref());
   _top_rodzaj:=exec('FindAndGet','#table',ZL,_top_level,,"RODZAJ",'');
   _mp.keyRef(ZL.uidref());
   _tktl:='';
   {? ZL.RTKTL<>''
   || _tktl:=ZL.RTKTL
   |? ZL.RKTL<>''
   || _tktl:=ZL.RKTL
   ?};
   _ask:=1;
   {? _mp.isAutoRun()
   || _ask:=0
   |? _mp.isService()
   || _ask:=-1
   ?};

   _ile:=exec('ile','zl_guide',ZL.ref(),ZL.IL);

   {? ZL.TYP().WP='W'
   || _msg:='Nie można uruchomić czynności dla zlecenia: %1. Generowanie przewodników dla zlecenia warsztatowego jest niedozwolone.'@[ZL.SYM];
      {? ~_mp.isService()
      || {? _mp.isGroup()
         || KOMM.add(_msg,2,,1)
         || FUN.info(_msg)
         ?}
      ?};
      _result:=0;
      _mp.error(_msg)

   |? ZL.RODZAJ='N'
   || _msg:='Nie można uruchomić czynności dla zlecenia: %1. Generowanie przewodników dla zlecenia niezależnego jest niedozwolone.'@[ZL.SYM];
      {? ~_mp.isService()
      || {? _mp.isGroup()
         || KOMM.add(_msg,2,,1)
         || FUN.info(_msg)
         ?}
      ?};
      _result:=0;
      _mp.error(_msg)

   |? ZL.STAN='Z'
   || _msg:='Generowanie przewodników dla zlecenia zamkniętego jest niedozwolone.'@;
      {? ~_mp.isService()
      || {? _mp.isGroup()
         || KOMM.add(_msg,2,,1)
         || FUN.info(_msg)
         ?}
      ?};
      _out.RESULT:='OK';
      _result:=1;
      _mp.done()

   |? _top_rodzaj='Z' & _top_level=ZL.ref()
   || _msg:='Nie można uruchomić czynności dla zlecenia: %1. Generowanie przewodników dla zlecenia nadrzędnego jest niedozwolone.'@[ZL.SYM];
      {? ~_mp.isService()
      || {? _mp.isGroup()
         || KOMM.add(_msg,2,,1)
         || FUN.info(_msg)
         ?}
      ?};
      _result:=0;
      _mp.error(_msg)

   |? ZL.TYP().WP='P' & ZL.TYP().TECH='T' & ZL.STAT_T='N'
   || _msg:='Nie można uruchomić czynności dla zlecenia: %1. Redagowanie technologii zlecenia nie zostało zakończone.'@[ZL.SYM];
      {? _mp.isService()
      || _out.RESULT:='BŁĄD';
         _mp.done()
      || {? _mp.isGroup()
         || KOMM.add(_msg,2,,1)
         || FUN.info(_msg)
         ?};
         _mp.cancel()
      ?};
      _result:=0

   |? ZL.STAT_N='N'
   || _msg:='Nie można uruchomić czynności dla zlecenia: %1. Redagowanie nagłówka zlecenia nie zostało zakończone.'@[ZL.SYM];
      {? _mp.isService()
      || _out.RESULT:='BŁĄD';
         _mp.done()
      || {? _mp.isGroup()
         || KOMM.add(_msg,2,,1)
         || FUN.info(_msg)
         ?};
         _mp.cancel()
      ?};
      _result:=0

   |? _tktl<>'' & exec('FindAndGet','#table',TKTL,_tktl,,"TYP().OPER",'N')='N'
   || _msg:='Generowanie przewodników dla zlecenia z technologią bez operacji jest niedozwolone.'@;
      {? ~_mp.isAutoRun() & ~_mp.isService()
      || {? _mp.isGroup()
         || KOMM.add(_msg,2,,1)
         || FUN.info(_msg)
         ?}
      ?};
      _result:=1;
      _out.RESULT:='OK';
      _mp.done()

   |? _ile=0 & _mp.loop()=0
   ||
::    Sprawdzam czy jest jeszcze coś do generowania
      {? _ile=0
      ||
         _msg:='Nie można uruchomić generowania przewodników dla zlecenia: %1. Na zleceniu całą ilość jest już podzielona na przewodniki.'@[ZL.SYM];
         {? ~_mp.isService()
         || {? _mp.isGroup()
            || KOMM.add(_msg,2,,1)
            || FUN.info(_msg)
            ?}
         ?};
         _result:=1;
         _out.RESULT:='OK';
         _mp.done()
      ?}
   || VAR.A_ZLEC:=ZL.ref();
      _key:=_in.GRP_KEY;
      _gen:=1;
      {? _mp.loop()=0 | _mp.akcja()='GENERUJ'
      || _gen:=0;
::       Sprawdzam czy istnieje już zapamiętany klucz grupujący (np nastąpił powrót do tej instancji czynności na skutek
::       jakiejś awarii i instancja nr 1 jest uruchomiona ponownie
         {? _int.GRP_KEY<>''
         || _key:=_int.GRP_KEY
         || _key:=exec('uid','#blank')
         ?};
         {? _key<>''
         ||
::          Zapisuje identyfikator jako parametr wew
            _int.GRP_KEY:=_key;
            _mp.save(_int);

::          Rozpoczynam generowanie
            _grp_key_on:=_key+'1';
            _gen:=exec('generuj','zl_guide',_ask,1,1,_grp_key_on,_mp.isGroup())
         ?}
      ?};

      {? _key<>''
      ||
         _grp_key_on:=_key+'1';
         _grp_key_off:=_key+'0';

::       Wypycham pierwszy przewodnik na wyjście
         ZGH.cntx_psh();
         ZGH.index('GRP_KEY');
         ZGH.prefix(_grp_key_on);
         {? ZGH.first()
         || ZGH.cntx_psh();
            ZGH.prefix();
            ZGH.GRP_KEY:=_grp_key_off;
            do();
            _can_continue:=ZGH.put();
            end();
            {? _can_continue>0
            || _out.ZGH:=ZGH.ref();
               _out.GRP_KEY:=_key
            ?};
            ZGH.cntx_pop();
            {? ZGH.first()
            ||
::             Jeżeli są jeszcze jakieś przewodniki to kontunuuję pętlę
               _out.LOOP:='T'
            ?}
         ?};
         ZGH.cntx_pop();
         {? _gen>=0
         || _result:=1
         ?};
         {? type_of(_context)>100
         || _context.RESULT:=_result
         ?};
         {? _gen>=0
         || {? _mp.isService()
            || {? _gen>0
               || _out.RESULT:='OK'
               || _out.RESULT:='BŁĄD'
               ?}
            || _out.RESULT:='OK'
            ?};
            _mp.done()
         |? _mp.isMicro()>0
         || _mp.cancel()
         ?};
         ~~
      || _mp.error('Brak oczekiwanego parametru GRP_KEY.')
      ?}
   ?}
?};
_mp.save(,_out);

ZL.cntx_pop(); ZGH.cntx_pop();
_result


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Opis dla czynności rejestracji przewodnika zlecenia (TTE_PZL_DPZG)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: zwraca opis Zadania
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_desc:='';
_keyRefs:=_mp.getRefs();
_in:=_mp.load(exec('kind_in','#b_port'));

:: jest rekord kluczowy ZL, to ustawiam odpowiednie ZL
{? var_pres('[1]',_keyRefs)>0 & ref_name(_keyRefs[1])=ZL.name()
|| _tmp:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"SYM",'');
   _desc:={? _tmp<>'' || 'Wygeneruj przewodniki do zlecenia %1'@@[_tmp] || '' ?}
::|| _desc:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"'Wygeneruj przewodniki do zlecenia %1'[SYM]",'')
:: jest parametr wejściowy ZL
|? var_pres('ZL',_in)>0
|| _tmp:=exec('FindAndGet','#table',ZL,_in.ZL,,"SYM",'');
   _desc:={? _tmp<>'' || 'Wygeneruj przewodniki do zlecenia %1'@@[_tmp] || '' ?}
::|| _desc:=exec('FindAndGet','#table',ZL,_in.ZL,,"'Wygeneruj przewodniki do zlecenia %1'[SYM]",'')
?};
_desc


\generuj_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Generuj' w oknie wertowania przewodników, uruchamia czynność
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_top_level:=exec('top_level','zl_link',_env.ZL);
_top_rodzaj:=exec('FindAndGet','#table',ZL,_top_level,,"RODZAJ",'');
ZL.cntx_psh();

{? _top_rodzaj='Z' & _top_level=_env.ZL
||
   _can_continue:=1;

   {? exec('subzlec_exist','zl_link',_top_level)>0
   || _can_continue:=FUN.ask('Generować przewodniki dla wszystkich podzleceń zlecenia złożonego: %1?'@[_env.BUF_ZL.SYM])
   || _can_continue:=0;
      FUN.emsg('Nie można generować przewodników do zlecenia: %1 ponieważ nie ma podzleceń.'@[_env.BUF_ZL.SYM])
   ?};
   {? _can_continue>0
   ||
::    Sprawdzam czy jakiekolwiek podzlecenie ma zakończoną technologię
      _fml:="
         _result:=1;
         {? ZL.STAT_T='N'
         || _result:=0
         ?};
         _result
      ";
      _args_chk1:=exec('for_each_args','zl_common');
      _args_chk1.ZL:=exec('main_podzlec','zl_link',_env.ZL);
      _args_chk1.FORMULA:=_fml;
      _args_chk1.EXPECTED:=0;
      exec('for_each_tree','zl_common',_args_chk1);

      {? _args_chk1.RESULT=0
      || FUN.emsg('Żadnemu z podzleceń nie zakończono redagowania technologii. Generowanie przewodników niemożliwe.'@);
         _can_continue:=0
      ?};

      _fml:="
         _ile:=exec('ile','zl_guide',ZL.ref(),ZL.IL);
         _ile
      ";
      _args_chk2:=exec('for_each_args','zl_common');
      _args_chk2.ZL:=exec('main_podzlec','zl_link',_env.ZL);
      _args_chk2.FORMULA:=_fml;
      _args_chk2.EXPECTED:=0;
      exec('for_each_tree','zl_common',_args_chk2);
      {? _args_chk2.RESULT=0
      || FUN.emsg('Żadnemu z podzleceń nie pozostała ilość do podzielenia na przewodniki. Generowanie przewodników niemożliwe.'@);
         _can_continue:=0
      ?};

      {? _can_continue>0
      ||
         KOMM.init(250,,'Generowanie przewodników'@);
         _fml:="
            _ile:=exec('ile','zl_guide',ZL.ref(),ZL.IL);
            _args:=exec('mp_run_a','#b__box');
            _args.ACT_UID:='TTE_PZL_DPZG';
            _args.GRUPA:='T';
            _args.UIDREF:=ZL.uidref();
            _args.AKCJA:='GENERUJ';
            _args.PROC_START:='T';
            _args.CONTEXT:=obj_new('RESULT');
            _args.CONTEXT.RESULT:=1;
            {? _ile>0
            || _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
               exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',ZL.ref());
               exec('mp_run','#b__box',_args)
            ?};
            _args.CONTEXT.RESULT
         ";

         _args_gen:=exec('for_each_args','zl_common');
         _args_gen.ZL:=exec('main_podzlec','zl_link',ZL.ref());
         _args_gen.FORMULA:=_fml;
         _args_gen.EXPECTED:=1;
         exec('for_each_tree','zl_common',_args_gen);
         KOMM.select()
      ?}
   ?}
||
   _can_continue:=FUN.ask('Generować przewodniki dla zlecenia: %1?'@[_env.BUF_ZL.SYM]);

   {? _can_continue>0
   ||
      _args:=exec('mp_run_a','#b__box');
      _args.ACT_UID:='TTE_PZL_DPZG';
      _args.UIDREF:=ZL.uidref();
      _args.AKCJA:='GENERUJ';
      _args.PROC_START:='T';
      _args.CONTEXT:=obj_new('RESULT');
      _args.CONTEXT.RESULT:=0;
      _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);

      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',ZL.ref());

      exec('mp_run','#b__box',_args)
   ?}
?};
ZL.cntx_pop();
~~


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::   WE: [_a] - _mp - obiekt Menadżera procesów
::       [_b] - tablica z parametrami wejściowymi
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _mp:=_a
|| _mp:=params_get().mp
?};
{? var_pres('_b')>100
|| _in:=_b
|| _in:=params_get().in
?};
params_exec('zl_clean','zl_common',_mp,_in,'ERROR')


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Formuła ustalająca PARSES
::   WE:
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
params_exec('zl_parses','zl_common')

:Sign Version 2.0 jowisz:1048 2023/06/23 14:09:37 804ba1a649cc694084ae62fdb0bf4bf01f05ee42d3e9cd168773b398a597927d1d0034c773e32a5e463ec8cdf3a5b4c01b947b9262357c3bef07bb9704801492c6aaf73db7b672b5f126cc02c70c956733531241cf9f29be72532d91acbf58a976dc507c47994ac0bc19708f0557903d92751d54aaa16d9d578818d388db920d
