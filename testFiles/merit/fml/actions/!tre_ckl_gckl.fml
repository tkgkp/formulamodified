:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tre_ckl_gckl.fml
:: Utworzony: 14.06.2019
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły czynności TRE_CKL_GCKL - Generowanie zdarzeń cyklicznych
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Formuła główna czynności obsługi zdarzeń cyklicznych (TRE_CKL_GCKL)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::       context - [obj_new] obiekt służący do przekazywania kontekstu wywołania czynności
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;
_uid:='TRE_CKL_GCKL';

:: WŁAŚCIWOŚCI CZYNNOŚCI
::# properties=LOOP,SERVICE
::# permissions=ODDZ
::# parses=exec('parses','!tre_ckl_gckl')

:: PARAMETRY WE:
::# kind=WE, symbol=REM_ZAS, type=_REM_ZAS, name=Zasób remontowy, required=N, keyref=T
{? var_pres('REM_ZAS',_in)<>type_of(~~) & var_pres('REM_ZAS',_in)<>type_of(null()) || return() ?};
{? var_pres('REM_ZAS',_in)=type_of(~~) || _in.REM_ZAS:=null() ?};
::# kind=WE, symbol=REM_ZASQ, type=STRING, name=Zasób remontowy (SQL), required=N, keyref=N
{? var_pres('REM_ZASQ',_in)<>type_of(~~) & var_pres('REM_ZASQ',_in)<>type_of('') || return() ?};
{? var_pres('REM_ZASQ',_in)=type_of(~~) || _in.REM_ZASQ:='' ?};

:: PARAMETRY WY:
::# kind=WY, symbol=REM_ZGL, type=_REM_ZGL, name=Zgłoszenie remontowe, required=N
{? var_pres('REM_ZGL',_out)<>type_of(~~) & var_pres('REM_ZGL',_out)<>type_of(null()) || return() ?};
::# kind=WY, symbol=INFO, type=MEMO, name=Informacja, required=N
{? var_pres('INFO',_out)<>type_of(~~) & var_pres('INFO',_out)<>type_of('') || return() ?};
::# kind=WY, symbol=JINFO, type=MEMO, name=Informacja (JSON), required=N
{? var_pres('JINFO',_out)<>type_of(~~) & var_pres('JINFO',_out)<>type_of('') || return() ?};
:: Ustawiam wartość domyślną argumentu LOOP żeby brama się nie zawiesiła
_mp.save(exec('kind_out','#b_port'),'LOOP','N');

_rem_zas:=null();

_clean_result:=exec('clean','!tre_ckl_gckl',_mp,_in);
_can_continue:=_clean_result.RESULT;
_rem_zas:=_clean_result.REM_ZAS;

:: Sprawdzenie zasobu
{? _rem_zas
||
:: Brak sprawdzenia zgodności przekazanego rekordu, ale można wstawić tutaj i zrobić _mp.error(); return()
   ~~

:: Sprawdzenie, gdy nie przekazano zasobu
|? ~_mp.pathProc() & _in.GRPKEY=''
|| _msg:='Niezgodność wywołania czynności %1.\nNie przekazano parametru %2, %3 albo %4.'@@
         [_uid,'REM_ZAS','REM_ZASQ','GRPKEY'];
   FUN.emsg(_msg);
   _mp.error(_msg);
   return()
?};

_key:=_out.GRPKEY:=_mp.grpkey(_out.GRPKEY,_in.GRPKEY);

_done:=0;

{? _mp.pathProc()
|| _msg:='Niezgodność uruchomienia czynności %1.\nNie można uruchomić ze startu procesów.'@@[_uid];
   FUN.emsg(_msg);
   _mp.error(_msg)

|? _mp.loop()>0 | _mp.akcja()='GENERUJ' | _mp.pathTodo()
|| _l_gen:=0;
   _l_inf:=0;
   REM_ZAS.cntx_psh(); REM_CYKL.cntx_psh(); REM_HARM.cntx_psh();
   REM_ZAS.prefix(); REM_HARM.prefix();
   {? _mp.loop()=0 & REM_ZAS.seek(_rem_zas)
   || REM_CYKL.index('REM_ZAS');
      REM_CYKL.prefix(REM_ZAS.ref(),'T');
      {? REM_CYKL.first()
      || {!
         |?
            do();
::          Generowanie zgłoszenia - sprawdzenie warunku harmonogramu/przebiegu
            _res:=exec('find_rem_harm','remonty_cykliczne',REM_CYKL.ref(),2);
            {? _res.REM_HARM<>null() & REM_HARM.seek(_res.REM_HARM)
            || {? REM_CYKL.SERV_GEN='T'
               || REM_ZGL.prefix();
                  REM_ZGL.blank();
                  REM_ZGL.ODDZ:=REM_ZAS.ODDZ;
                  REM_ZGL.REM_KATG:=REM_CYKL.REM_KATG;
                  REM_ZGL.REM_ZAS:=REM_ZAS.ref();
                  REM_ZGL.TYTUL:=exec('title','!tre_ckl_gckl',REM_HARM.ref());
                  REM_ZGL.memo_set(exec('description','!tre_ckl_gckl',REM_HARM.ref(),_res.HP),'OPIS');
                  REM_ZGL.SOURCE:=exec('source_cykl','remonty_zgloszenia');
                  REM_ZGL.STAT_REJ:=exec('status_verified','remonty_zgloszenia');
                  REM_ZGL.DT_ZAT:=date();
                  REM_ZGL.TM_ZAT:=time();
                  REM_ZGL.USR_ZAT:=OPERATOR.USER;
                  REM_ZGL.memo_set(exec('reason','!tre_ckl_gckl',REM_HARM.ref()),'WOPIS');
                  REM_ZGL.DT_PST:=REM_HARM.DATE;
                  REM_ZGL.REM_CYKL:=REM_CYKL.ref();
                  REM_ZGL.PRIORITY:=REM_CYKL.PRIORITY;
                  REM_ZGL.REM_CZYT:=REM_CYKL.REM_CZYT;
                  {? REM_ZGL.add()
                  || POM.TAB:='REM_ZGL';
                     POM.TYPDOK:='ZGL';
                     REM_ZGL.NR:=exec('numer_new','numery','PACZKA');
                     exec('znak','numery','REM_ZGL',1);
                     {? REM_ZGL.REM_CZYT<>null()
                     || exec('rem_czyu_add_templ_auto','zasoby',REM_ZGL.ref(),REM_ZGL.REM_CZYT().KOD)
                     ?};
                     {? REM_ZGL.put()
                     || REM_ZGL.memo_put(,'OPIS');
                        REM_ZGL.memo_put(,'WOPIS');
                        _l_gen+=1;
                        _mp.grpkeyAdd(REM_ZGL.uidref());
                        {? _res.HP='H'
                        || REM_HARM.GENH_GEN:='T'
                        || REM_HARM.GENP_GEN:='T'
                        ?};
                        REM_HARM.put()
                     ?}
                  ?}
               ?}
            ?};
            obj_del(_res);

::          Wysłanie (wystawienie) informacji - sprawdzenie warunku harmonogramu/przebiegu
            _res:=exec('find_rem_harm','remonty_cykliczne',REM_CYKL.ref(),1);
            {? _res.REM_HARM<>null() & REM_HARM.seek(_res.REM_HARM)
            || {? REM_CYKL.SERV_INF='T'
               || _l_inf+=1;
                  _mp.grpkeyAdd(REM_HARM.uidref());
                  {? _res.HP='H'
                  || REM_HARM.GENH_INF:='T'
                  || REM_HARM.GENP_INF:='T'
                  ?};
                  REM_HARM.put()
               ?}
            ?};
            obj_del(_res);

            end();
            REM_CYKL.next()
         !}
      ?}
   ?};
   REM_ZAS.cntx_pop(); REM_CYKL.cntx_pop(); REM_HARM.cntx_pop();

:: Informacja o wygenerowanej liczbie zapisów
:: - tylko dla pierwszego przejścia w pętli przekazane kontekstem do miejsca wywołania
   {? _mp.loop()=0 & _mp.pathArea()
   || {? var_pres('_context')=type_of(~~)
      || FUN.emsg('Nie ustalono zmiennej _context.'@)
      || _context.L_GEN:=_l_gen;
         _context.L_INF:=_l_inf
      ?}
   ?};

:: DEBUG:
::   {? _mp.loop()=0 || FUN.info('_context.L_GEN: %1\n_context.L_INF: %2'[$_l_gen,$_l_inf]) ?};

   _uidref:=_mp.grpkeyGet();
   {? type_of(_uidref)=type_of('')
   ||
      _done:=1;

::    Wypycham pierwszy klucz na wyjście (wygenerowane zgłoszenie, albo info wg definicji zdarzenia cyklicznego)
      REM_ZGL.cntx_psh();
      REM_ZGL.prefix();
      REM_CYKL.cntx_psh();
      REM_CYKL.prefix();
      REM_HARM.cntx_psh();
      REM_HARM.prefix();

::    DEBUG
::      FUN.info('_uidref: %1'[_uidref]);

::    Wygenerowane zgłoszenie
      {? ref_tab(_uidref)=REM_ZGL & REM_ZGL.seek(_uidref)
      || do();
         _mp.save(exec('kind_out','#b_port'),'REM_ZGL',REM_ZGL.ref());
         _mp.save(exec('kind_out','#b_port'),'INFO','');
         _mp.save(exec('kind_out','#b_port'),'JINFO','');
         _mp.grpkeyDel();
         end()
::    Info
      |? ref_tab(_uidref)=REM_HARM & REM_HARM.seek(_uidref)
      || do();
         _mp.save(exec('kind_out','#b_port'),'REM_ZGL',null());
         _mp.save(exec('kind_out','#b_port'),'INFO',exec('info','!tre_ckl_gckl',REM_HARM.ref()));
         _mp.save(exec('kind_out','#b_port'),'JINFO',exec('jinfo','!tre_ckl_gckl',REM_HARM.ref()));
         _mp.grpkeyDel();
         end()
      ?};

::    Jeżeli są jeszcze jakieś elementy klucza, to kontynuuję pętlę
      _uidref:=_mp.grpkeyGet();
      {? type_of(_uidref)=type_of('')
      || _mp.loop_continue()
      ?};

      REM_HARM.cntx_pop();
      REM_CYKL.cntx_pop();
      REM_ZGL.cntx_pop()

:: Nic nie zostało wygenerowane, robię od razu done()
   || _mp.save(exec('kind_out','#b_port'),'REM_ZGL',null());
      _mp.save(exec('kind_out','#b_port'),'INFO','');
      _done:=1
   ?};

   {? _done>0 || _mp.done() ?}

:: Tutaj nie powinno dojść, więc błąd
|| _mp.error('Nieobsłużony kontekst wywołania czynności %1.'@@[_uid])
?};
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Opis dla czynności obsługi zdarzeń cyklicznych (TRE_TRE_GCYK)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: zwraca opis Zadania
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_desc:='';
_keyRefs:=_mp.getRefs();
_in:=_mp.load(exec('kind_in','#b_port'));

:: jest rekord kluczowy to ustawiam odpowiednie REM_ZAS
{? var_pres('[1]',_keyRefs)
|| _tmp:=exec('FindAndGet','#table',REM_ZAS,_keyRefs[1],,"SYMBOL",'');
   _desc:={? _tmp<>'' || 'Obsłuż zdarzenia cykliczne dla zasobu %1'@@[_tmp] || '' ?}
::|| _desc:=exec('FindAndGet','#table',REM_ZAS,_keyRefs[1],,"'Obsłuż zdarzenia cykliczne dla zasobu %1'[SYMBOL]",'')

:: jest parametr wejściowy REM_ZAS
|? var_pres('REM_ZAS',_in)=type_of(null())
|| _tmp:=exec('FindAndGet','#table',REM_ZAS,_in.REM_ZAS,,"SYMBOL",'');
   _desc:={? _tmp<>'' || 'Obsłuż zdarzenia cykliczne dla zasobu %1'@@[_tmp] || '' ?}
::|| _desc:=exec('FindAndGet','#table',REM_ZAS,_in.REM_ZAS,,"'Obsłuż zdarzenia cykliczne dla zasobu %1'[SYMBOL]",'')

:: jest parametr wejściowy REM_ZASQ
|? var_pres('REM_ZASQ',_in)=type_of('')
|| _tmp:=exec('FindAndGet','#table',REM_ZAS,_in.REM_ZASQ,,"SYMBOL",'');
   _desc:={? _tmp<>'' || 'Obsłuż zdarzenia cykliczne dla zasobu %1'@@[_tmp] || '' ?}
::||   _desc:=exec('FindAndGet','#table',REM_ZAS,_in.REM_ZASQ,,"'Obsłuż zdarzenia cykliczne dla zasobu %1'[SYMBOL]",'')

:: nie ma nic...
|| _desc:='Obsłuż zdarzenia cykliczne'@@
?};
_desc


\action_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Akcja 'Generuj zgłoszenia' w oknie definicji zdarzeń cyklicznych
::----------------------------------------------------------------------------------------------------------------------
_grupa:={? REM_ZAS.sel_size()>0 || 'T' || 'N' ?};

{? REM_ZAS.AKT='T'
|| _args:=exec('mp_run_a','#b__box');
   _args.ACT_UID:='TRE_CKL_GCKL';
   _args.UIDREF:=REM_ZAS.uidref();
   _args.AKCJA:='GENERUJ';
   _args.PROC_START:='T';
   _args.GRUPA:=_grupa;
   _args.CONTEXT:=obj_new('L_GEN','L_INF'); _args.CONTEXT.L_GEN:=_args.CONTEXT.L_INF:=0;

   _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'REM_ZAS',REM_ZAS.ref());

   exec('mp_run','#b__box',_args);

   {? _grupa='T'
   || {? _args.CONTEXT.L_GEN>0 | _args.CONTEXT.L_INF>0
      || KOMM.sect_beg('Dla zasobu %1:'@[REM_ZAS.SYMBOL]);
         {? _args.CONTEXT.L_GEN>0
         || KOMM.add('Liczba wygenerowanych zgłoszeń: %1'@[$_args.CONTEXT.L_GEN])
         ?};
         {? _args.CONTEXT.L_INF>0
         || KOMM.add('Liczba wygenerowanych informacji: %1'@[$_args.CONTEXT.L_INF])
         ?};
         KOMM.sect_end()
      || KOMM.sect_beg('Dla zasobu %1:'@[REM_ZAS.SYMBOL]);
         KOMM.add('Liczba wygenerowanych zgłoszeń: %1'@[$0]);
         KOMM.add('Liczba wygenerowanych informacji: %1'@[$0]);
         KOMM.sect_end()
      ?}
   || FUN.info(
         'Dla zasobu %1:\n\n'
         'Liczba wygenerowanych zgłoszeń: %2.\n'
         'Liczba wygenerowanych informacji: %3.'@
         [REM_ZAS.SYMBOL,$_args.CONTEXT.L_GEN,$_args.CONTEXT.L_INF]
      )
   ?}

|| {? _grupa='T'
   || KOMM.add('Zasób %1 nie jest aktywny'@[REM_ZAS.SYMBOL])
   ?}
?};
~~


\action_generate_group_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Akcja 'Generuj zgłoszenia' przed grupą rekordów
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(,,'Generowanie zgłoszeń'@);
1


\action_generate_group_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Akcja 'Generuj zgłoszenia' po grupie rekordów
::----------------------------------------------------------------------------------------------------------------------
KOMM.select();
~~


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::   WE: [_a] - _mp - obiekt Menadżera procesów
::       [_b] - tablica z parametrami wejściowymi
::   WY: obj_new() - obiekt wynikowy
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _mp:=_a
|| _mp:=params_get().mp
?};
{? var_pres('_b')>100
|| _in:=_b
|| _in:=params_get().in
?};

_can_continue:=1;
_obj:=obj_new('RESULT','REM_ZAS');
_obj.RESULT:=0;
_obj.REM_ZAS:=null();

_keyRefs:=_mp.getRefs();

{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];

      {? type_of(_kref)>0
      ||
         {? ref_name(_kref)=REM_ZAS.name()
         || _obj.REM_ZAS:=exec('FindAndGet','#table',REM_ZAS,_kref,,,null());

            {? _obj.REM_ZAS=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego z zasobem (praktycznie niemożliwe), więc robię error
               _can_continue:=0;
               _mp.error('Zasób nie został odnaleziony, prawdopodobnie został usunięty.'@@)
            ?}
         ?}
      ?}
   !}
?};

{? _can_continue>0
||
:: jest parametr wejściowy REM_ZAS
   {? _obj.REM_ZAS=null() & var_pres('REM_ZAS',_in)=type_of(null())
   || _obj.REM_ZAS:=_in.REM_ZAS
   ?};
:: jest parametr wejściowy REM_ZASQ
   {? _obj.REM_ZAS=null() & var_pres('REM_ZASQ',_in)=type_of('')
   || _obj.REM_ZAS:=exec('FindAndGet','#table',REM_ZAS,_in.REM_ZASQ,,,null())
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};

_obj


\title
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zwraca tytuł zgłoszenia generowanego automatycznie
::   WE: _a - REM_HARM.ref()
::----------------------------------------------------------------------------------------------------------------------
_rem_harm:=_a;
_result:='';

REM_HARM.cntx_psh();
REM_HARM.prefix();
{? REM_HARM.seek(_rem_harm)
|| _result:='Zgłoszenie generowane automatycznie'
?};
REM_HARM.cntx_pop();

_result


\description
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zwraca opis zgłoszenia generowanego automatycznie
::   WE: _a - REM_HARM.ref()
::       _b - 'H'armonogram, 'P'rzebiegi
::----------------------------------------------------------------------------------------------------------------------
_rem_harm:=_a;
_hp:=_b;
_result:='';

REM_HARM.cntx_psh(); REM_CYKL.cntx_psh();
REM_HARM.prefix();
{? REM_HARM.seek(_rem_harm)
|| REM_HARM.REM_CYKL();
   _result:=
      'Zgłoszenie na podstawie zdarzenia cyklicznego.'+'\n'+
      {? _hp='H'
      || {? REM_CYKL.TRYB='R'
         || 'Zgłoszenie wygenerowane jednorazowo dnia %1.'[$date()]
         || 'Zgłoszenie wygenerowane według harmonogramu dnia %1.'[$date()]
         ?}+'\n'+
         'Zgłoszenie należy obsłużyć do dnia %1.'[$(REM_HARM.DATE)]
      |? _hp='P'
      || 'Zgłoszenie wygenerowane według przebiegu po przekroczeniu wartości %1 %4.\n'
         'Zgłoszenie należy obsłużyć do przebiegu %2 %4.\n'
         'Aktualny przebieg: %3 %4.'
         [  $(REM_HARM.PRZ),
            $REM_CYKL.PRZ,
            $REM_CYKL.REM_ZAS().PRZ,
            REM_CYKL.REM_ZAS().PRZ_JM().KOD
         ]
      || ''
      ?}
?};
REM_HARM.cntx_pop(); REM_CYKL.cntx_pop();

_result


\reason
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zwraca tekst automatycznego uzasadnienia weryfikacji
::----------------------------------------------------------------------------------------------------------------------
'Zgłoszenie zweryfikowane automatycznie.'


\info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zwraca standardową treść informacji
::   WE: _a - REM_HARM.ref()
::----------------------------------------------------------------------------------------------------------------------
_rem_harm:=_a;
_result:='';

REM_HARM.cntx_psh(); REM_CYKL.cntx_psh();
REM_HARM.prefix();
{? REM_HARM.seek(_rem_harm)
|| REM_HARM.REM_CYKL();
   _result:=
      {? REM_HARM.GENH_INF='T'
      || 'Do dnia %1 należy wykonać %2 dla zasobu %3.\n'
         'Informację wygenerowano dnia %4.'
         [  $(REM_HARM.DATE),
            REM_CYKL.REM_KATG().SYMBOL,
            REM_CYKL.REM_ZAS().SYMBOL,
            $date()
         ]
      |? REM_HARM.GENP_INF='T'
      || 'Przed przekroczeniem przebiegu %1 %2 należy wykonać %3 dla zasobu %4.\n'
         'Informację wygenerowano dnia %5 przy przebiegu %6 %2.'
         [  $REM_HARM.PRZ,
            REM_CYKL.REM_ZAS().PRZ_JM().KOD,
            REM_CYKL.REM_KATG().SYMBOL,
            REM_CYKL.REM_ZAS().SYMBOL,
            $date(),
            $REM_CYKL.REM_ZAS().PRZ
         ]
      || ''
      ?}
?};
REM_HARM.cntx_pop(); REM_CYKL.cntx_pop();

_result


\jinfo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zwraca dane informacyjne w postaci JSON - na tej podstwie można zbudować własny temat i treść maila,
::       oraz informacji na liście zadań w czynności ręcznej
::   WE: _a - REM_HARM.ref()
::----------------------------------------------------------------------------------------------------------------------
_rem_harm:=_a;
_obj:=obj_new(
:: Informacja generowana na podstawie harmonogramu (T/N)
   'H',
:: Informacja generowana na podstawie przebiegu (T/N)
   'P',
:: Kategoria zgłoszenia (ref() + SYMBOL)
   'REM_KATG',
:: Zasób (ref() + SYMBOL)
   'REM_ZAS',
:: Termin wykonania (data)
   'DEADLINE',
:: Data generowania informacji
   'DATE',
:: Przebieg, przy którym należy wykonać obsługę
   'PRZ',
:: Przebieg na chwilę generowania informacji
   'PRZ_AKT',
:: Jednostka miary dla przebiegu (tekst)
   'PRZ_JM'
);
_obj.REM_KATG:=obj_new('Ref','SYMBOL');
_obj.REM_ZAS:=obj_new('Ref','SYMBOL');

REM_HARM.cntx_psh(); REM_CYKL.cntx_psh();
REM_HARM.prefix();
{? REM_HARM.seek(_rem_harm)
|| REM_HARM.REM_CYKL();
   _obj.H:=REM_HARM.GENH_INF;
   _obj.P:=REM_HARM.GENP_INF;
   _obj.REM_KATG.Ref:=REM_CYKL.REM_KATG;
   _obj.REM_KATG.SYMBOL:=REM_CYKL.REM_KATG().SYMBOL;
   _obj.REM_ZAS.Ref:=REM_CYKL.REM_ZAS;
   _obj.REM_ZAS.SYMBOL:=REM_CYKL.REM_ZAS().SYMBOL;
   _obj.DEADLINE:=REM_HARM.DATE;
   _obj.DATE:=date();
   _obj.PRZ:=REM_HARM.PRZ;
   _obj.PRZ_AKT:=REM_CYKL.REM_ZAS().PRZ;
   _obj.PRZ_JM:=REM_CYKL.REM_ZAS().PRZ_JM().KOD
?};
REM_HARM.cntx_pop(); REM_CYKL.cntx_pop();

json_obj(_obj)


\rem_zgl_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Selekcja zgłoszeń remontowych wygenerowanych z definicji zdarzenia cyklicznego
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env_rem_zgl:=exec('env','remonty_zgloszenia',0,REM_CYKL.ref());
_env_rem_zgl.select();
~~


\rem_zgl_src
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Wyświetla informację o źródłowej definicji harmonogramu (reklamacji), z której zostało wygenerowane zgłoszenie
::----------------------------------------------------------------------------------------------------------------------
_env_rem_cykl:=exec('env','remonty_cykliczne');
_env_rem_cykl.PATTERN:=0;
params_set('env_rem_cykl',_env_rem_cykl);

{? REM_ZGL.RREK<>''
|| exec('rem_zgl_show_rek','remonty_zgloszenia')
|| REM_CYKL.cntx_psh();
   REM_CYKL.prefix();
   {? REM_CYKL.seek(REM_ZGL.REM_CYKL)
   || exec('rem_cykl_display','remonty_cykliczne',1,1,1,' — '+'źródło generowania zgłoszenia'@)
   ?};
   REM_CYKL.cntx_pop()

?};
~~


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Formuła ustala PARSES
::   WE: UWAGA. Do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_mp:=params_get().mp;
_result:=0;

{? _mp.isService()
|| _oddz:=exec('FindAndGet','#table',REM_ZAS,_in.REM_ZAS,,"REM_ZAS.ODDZ",'');
   {? _oddz<>''
   || _result:=1;
      __PARSES.setVal('OddzialLogProd',_oddz);
      _args:=__PARSES.args('OkresRok');
      _args.OBSZAR:='LMG';
      _args.AR:=date()~1;
      _args.AM:=date()~2;
      __PARSES.setVal('OkresRok',_args)
   ?}
|| _result:=1
?};
_result

:Sign Version 2.0 jowisz:1045 2021/09/17 15:17:01 1a2dcaac211a153a539a248c14cb80241075c4a7bb6d25b6c771756db70c17925a3f36423ea8bf0aea4a66dadc2a937097da25dc90d3c866784bea91a78957e440c1e376a5711ea8d70604e31859a49adbe173e2e95d2fda1b8a82aad3dd58dd771da34cce1fea5e5799b13262bfa5f31b6d67e3619930253381b82728828f5c
