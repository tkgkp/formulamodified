:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tpp_pps_utag.fml
:: Utworzony: 02.02.2023
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły czynności TPP_PPS_UTAG - Grupowanie obiektów
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuła główna czynności TPP_PPS_UTAG
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

::# permissions=ODDZ

::# properties=SERVICE,LOOP
::# access=exec('access','!tpp_pps_dopl')
::# parses=exec('parses','!tpp_pps_dopl')

:: PARAMETRY WE:
::# kind=WE, symbol=ZK_N, type=_ZK_N, name=Zamówienie sprzedaży, required=N, keyref=T
{? var_pres('ZK_N',_in)<>type_of(~~) & var_pres('ZK_N',_in)<>type_of(null())
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['ZK_N','TPP_PPS_UTAG'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};
::# kind=WE, symbol=ZK_P, type=_ZK_P, name=Pozycja zamówienia, required=N, keyref=T
{? var_pres('ZK_P',_in)<>type_of(~~) & var_pres('ZK_P',_in)<>type_of(null())
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['ZK_P','TPP_PPS_UTAG'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};
::# kind=WE, symbol=PX_OBJ, type=_PX_OBJ, name=Obiekt do planu, required=N, keyref=T
{? var_pres('PX_OBJ',_in)<>type_of(~~) & var_pres('PX_OBJ',_in)<>type_of(null())
|| _msg:='Błędny parametr wejściowy \'%1\' dla czynności %2.'@@['PX_OBJ','TPP_PPS_UTAG'];
   FUN.error(_msg);
   _mp.error(_msg);
   return()
?};

:: PARAMETRY WY:
::# kind=WY, symbol=PX_TAG, type=_PX_TAG, name=Utworzona grupa obiektów, required=N
::# kind=WY, symbol=RESULT, type=STRING, name=Rezultat działania, required=N

ZL.cntx_psh();
ZL.clear();
ZK_N.cntx_psh();
ZK_N.clear();
ZK_P.cntx_psh();
ZK_P.clear();
PX_OBJ.cntx_psh();
PX_OBJ.clear();

_result:=0;
_done:=0;
_px_tag:=null();

:: Ustawiam wartość domyślną argumentu LOOP żeby brama się nie zawiesiła
_mp.save(exec('kind_out','#b_port'),'LOOP','N');

_key:=_out.GRPKEY:=_mp.grpkey(_out.GRPKEY,_in.GRPKEY);

_zl:=null();
_zk_n:=null();
_zk_p:=null();
_px_obj:=null();

_clean_result:=exec('clean','!tpp_pps_utag',_mp,_in);
_can_continue:=_clean_result.RESULT;
_zl:=_clean_result.ZL;
_zk_n:=_clean_result.ZK_N;
_zk_p:=_clean_result.ZK_P;
_px_obj:=_clean_result.PX_OBJ;

{? _px_obj<>null()
|| PX_OBJ.cntx_psh();
   PX_OBJ.prefix();
   {? PX_OBJ.seek(_px_obj)
   || _zl:=PX_OBJ.ZL;
      _zk_p:=PX_OBJ.ZK_P;
      _zk_n:=PX_OBJ.ZK_N
   ?};
   PX_OBJ.cntx_pop()
?};

_what:='';
{? _can_continue>0 & _zl<>null()
|| _can_continue:=ZL.seek(_zl)
?};
{? _can_continue>0
|| {? _zk_n<>null()
   ||
      ZK_N.use(ref_name(_zk_n));
      ZK_N.clear();
      _can_continue:=ZK_N.seek(_zk_n);

      {? _can_continue>0
      || ZK_P.use(5+ZK_P.name()+(ref_name(_zk_n)+3));
         ZK_P.index('NAG')
      ?}
   |? _zk_p<>null()
   || ZK_P.use(ref_name(_zk_p));
      ZK_P.clear();
      _can_continue:=ZK_P.seek(_zk_p);

      {? _can_continue>0
      || ZK_N.use(5+ZK_N.name()+(ref_name(_zk_p)+3))
      ?}
   |? _px_obj<>null()
   || _can_continue:=PX_OBJ.seek(_px_obj)
   ?}
?};
{? _can_continue>0
||
   _mainver:=exec('get_mainversion','px_ver');
   _dialog:=1;
   _edit:=1;
   _win_refresh:=0;
   _ctrl:=1;
   _pathtodo:=1;
   _komm_show:=0;
   _planned:=0;

   _ver:=exec('get_mainversion','px_ver');

   {? type_of(_context)>100 & var_pres('ZK_P',_context)>0
   || {? _context.ZK_P<>null()
      || _zk_p:=_context.ZK_P
      ?}
   ?};

   {? type_of(_context)>100 & var_pres('DEST',_context)>0
   || {? _context.DEST<>null()
      || _drop_dest:=_context.DEST
      ?}
   ?};
   _ver_que:=null();
   {? var_pres('_context')>100 & var_pres('VER_QUE',_context)>0
   || _ver_que:=_context.VER_QUE
   ?};

   {? _mp.akcja()='GRUPUJ'
   || _win_refresh:=1;
      _replan:=0;
      _pathtodo:=0;
      _ver:=PX_VAR.VER_QUE
   || PX_VAR.VER_QUE:=_ver
   ?};

   {? _ver_que=null()
   || _ver_que:=_ver
   ?};

   {? _komm_show>0
   || KOMM.init(250,,'Grupowanie obiektów')
   ?};

   {? _mp.isAutoRun()
   || _dialog:=0;
      _edit:=0
   ?};
   {? _mp.isService()
   || _dialog:=3;
      _edit:=0
   ?};
   {? _mp.isGroup()
   || _win_refresh:=0;
      _dialog:=2;
      _edit:=0;
      _ctrl:=0
   ?};

   {? exec('lock','px_ver',_ver,_dialog)
   ||
      {? _mp.loop()=0
      ||
         {? _zl<>null()
         ||
::          ZLECENIE
            _what:=exec('record','#to_string',_zl);
::          Sekcja sprawdzania

            _can_continue:=0;
            _msg:='Nie można grupować: %1. Grupowanie zleceń niedostępne.'@[_what];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg);

            {? ZL.ILDOK>0 | ZL.ILWYK>0 | ZL.HWYK>0
            || _can_continue:=0;
               _msg:='Zlecenie: %1 posiada już zarejestrowane wykonania.\n'
                     'Nie można dodawać grupować w planie strategicznym.'@[_what];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_ver;
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _mp.error(_msg)
            ?};

            {? ZL.STAN='Z'
            || _can_continue:=0;
               _msg:='Nie można grupować zlecenia: %1 ponieważ jest zamknięte.'@[_what];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_ver;
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _mp.error(_msg)
            ?};
            _top:=exec('top_level','zl_link',_zl);
            _rodz_tex:=exec('FindAndGet','#table',ZL,_top,,"RODZ_TEX",'');
            _what_top:=exec('record','#to_string',_top);
            {? _top<>null() & exec('is_podzlec','zl_link',_zl)>0 & _rodz_tex='Z'
            || _can_continue:=0;
               _msg:='Nie można grupować podzlecenia: %1 ponieważ zlecenie nadrzędne posiada przepis zintegrowany. Należy zaplanować zlecenie nadrzędne: %2'@[_what,_what_top];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_ver;
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _mp.error(_msg)
            ?};

            {? ZL.RODZAJ='N' & exec('subsubzlec_exist','zl_link',ZL.ref())=0
            ||
::             Nie można wrzucić do planu zlecenia niezależnego bez podzleceń (bo tak naprawdę to planują się te podzlecenia)
               _can_continue:=0;
               _msg:='Nie można grupować zlecenia: %1 ponieważ jest to zlecenie niezależne, bez podzleceń.'@[_what];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_ver;
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _mp.error(_msg)
            ?};

::          Sprawdzam czy zlecenie jest już w całości kolejce planu
            {? ZL.IL<>0 & exec('zl_planned','px_obj',_zl,_ver)=ZL.IL
            || _planned:=1;

               {? _planned=1
               ||
::                Jeżeli wszystko już w kolejce to komunikat
                  _can_continue:=0;
                  _msg:='Nie można grupować obiektu: %1, ponieważ cała ilość znajduje się już w kolejce.'@[_what];
                  {? _dialog=1
                  || FUN.emsg(_msg)
                  |? _dialog=2
                  || KOMM.add(_msg,2,,1)
                  |? _dialog=3
                  || _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=_ver;
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args);
                     ~~
                  ?};
                  _mp.error(_msg)
               ?}
            ?};

            {? _can_continue>0
            ||
               {? _planned=0
               ||
::                Zlecenie nie było jeszcze planowane
::                Grupujemy na świeżo zlecenie
                  _px_tag:=exec('create_tag','!tpp_pps_utag',_ver_que,ZL.ref(),,,_dialog);
                  {? _px_tag<>null()
                  || _done:=1
                  ?};
                  ~~
               ?}
            ?}
         |? _zk_n<>null() | _zk_p<>null()
         ||
::          ZAMÓWIENIE SPRZEDAŻY

::          Sekcja sprawdzania
            _stan:='';
            _what:='';
            {? _zk_p<>null()
            || _what:=exec('record','#to_string',_zk_p);
               _stan:=exec('FindAndGet','#table',ZK_P,_zk_p,,"N().STAN",'')
            |? _zk_n<>null()
            || _what:=exec('record','#to_string',_zk_n);
               _stan:=exec('FindAndGet','#table',ZK_N,_zk_n,,"STAN",'')
            ?};

            {? _stan='ZRE'
            ||
               _can_continue:=0;
               _msg:='Zamówienie: %1 zostało już zrealizowane.\n'
                     'Nie można grupować w planie strategicznym.'@[_what];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_ver;
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _mp.error(_msg)
            ?};

            {? _can_continue>0
            ||
               {? _zk_p<>null()
               || _px_tag:=exec('create_tag','!tpp_pps_utag',_ver_que,,ZK_P.ref(),,_dialog);
                  {? _px_tag<>null()
                  || _done:=1
                  ?};
                  ~~
               |? _zk_n<>null()
               || ZK_P.prefix(_zk_n);
                  {? ZK_P.first()
                  ||
                     {? _dialog=1
                     || _can_continue:=FUN.ask('Zgrupować zamówienie: %1?'@[_what]);
                        {? _can_continue>0
                        || _dialog:=0
                        ?}
                     ?};
                     {? _can_continue>0
                     ||

                        {!
                        |? _px_tag:=exec('create_tag','!tpp_pps_utag',_ver_que,,ZK_P.ref(),,_dialog);
                           {? _px_tag<>null()
                           || _done:=1
                           ?};
                           ZK_P.next()
                        !}
                     ?}
                  ?};
                  ~~
               ?}
            ?}
         || _can_continue:=0;
            _msg:='Grupowanie w planie strategicznym nie powiodło się. Nieobsługiwany typ obiektu.'@;
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg)
         ?};
         {? _can_continue>0
         || _out.RESULT:='OK'
         || _out.RESULT:='BŁĄD'
         ?}
      ?};

      {? _key<>''
      ||
::       Generacja - wypycham pierwszą grupę na wyjście
         _tag_uidref:=_mp.grpkeyGet();
         {? type_of(_tag_uidref)=type_of('')
         ||
            _done:=1;

            PX_TAG.cntx_psh();
            PX_TAG.prefix();
            {? PX_TAG.seek(_tag_uidref)
            ||
               _out.PX_TAG:=PX_TAG.ref();
               _out.GRPKEY:=_key;
               _mp.grpkeyDel();

::             Jeżeli są jeszcze jakieś grupy to kontynuuję pętlę
               _tag_uidref:=_mp.grpkeyGet();
               {? type_of(_tag_uidref)=type_of('')
               || _out.LOOP:='T'
               ?}
            ?};
            PX_TAG.cntx_pop()
         ||
::          Zakończenie (nie powstała żadna grupa) - wypycham nullowe grupę na wyjście
            _out.PX_TAG:=null();
            _done:=1
         ?}
      || _mp.error('Brak oczekiwanego parametru %1.'@@['GRPKEY'])
      ?};

::    Obsługa na done
      {? _mp.isService()
      || _mp.done()
      || {? _done>0
         || _mp.done()
         ?}
      ?};
      _mp.save(,_out);

      {? _komm_show>0
      || KOMM.select()
      ?}
   ?};
   exec('unlock','px_ver',_ver);
   ~~
|| _msg:='Błąd konfiguracji czynności TPP_PPS_UTAG - Grupowanie obiektów - nie przekazano obiektu do grupowania'@;
   _mp.error(_msg)
?};

ZK_P.cntx_pop();
ZK_N.cntx_pop();
ZL.cntx_pop();
PX_OBJ.cntx_pop();
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuła na opis TODO czynności TTP_PPS_UTAG
::   WY: STRING - opis zadania
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_desc:='';
_keyRefs:=_mp.getRefs();
_in:=_mp.load(exec('kind_in','#b_port'));
_zk_n:=null();
_zk_p:=null();
_zl:=null();
_grop:=null();
_sym_zkn:='';
_sym_zkp:='';
_sym_zl:='';
_sym_grop:='';

:: jest rekord kluczowy ZK_N, to ustawiam odpowiedniego ZK_N
{? var_pres('[1]',_keyRefs)>0 & 5+ref_name(_keyRefs[1])=5+ZK_N.name()
|| _zk_n:=exec('FindAndGet','#table',ZK_N,_keyRefs[1],,,null())
:: jest parametr wejściowy ZK_N
|? var_pres('ZK_N',_in)>0
|| _zk_n:=exec('FindAndGet','#table',ZK_N,_in.ZK_N,,,null())
?};

:: jest rekord kluczowy ZK_P, to ustawiam odpowiedniego ZK_P
{? var_pres('[1]',_keyRefs)>0 & 5+ref_name(_keyRefs[1])=5+ZK_P.name()
|| _zk_p:=exec('FindAndGet','#table',ZK_P,_keyRefs[1],,,null())
:: jest parametr wejściowy ZK_P
|? var_pres('ZK_P',_in)>0
|| _zk_p:=exec('FindAndGet','#table',ZK_P,_in.ZK_P,,,null())
?};

{? _zk_p<>null()
|| _zk_n:=exec('FindAndGet','#table',ZK_P,_zk_p,,"N",null());
   _sym_zkp:=exec('record','#to_string',_zk_p)
?};

{? _zk_n<>null()
|| _sym_zkn:=exec('record','#to_string',_zk_n)
?};

:: jest rekord kluczowy ZL, to ustawiam odpowiednie ZL
{? var_pres('[1]',_keyRefs)>0 & ref_name(_keyRefs[1])=ZL.name()
|| _zl:=exec('FindAndGet','#table',ZL,_keyRefs[1],,,null())
:: jest parametr wejściowy ZL
|? var_pres('ZL',_in)>0
|| _zl:=exec('FindAndGet','#table',ZL,_in.ZL,,,null())
?};
{? _zl<>null()
|| _sym_zl:=exec('record','#to_string',_zl)
?};

:: jest rekord kluczowy GROP, to ustawiam odpowiednie GROP
{? var_pres('[1]',_keyRefs)>0 & ref_name(_keyRefs[1])=GROP.name()
|| _grop:=exec('FindAndGet','#table',GROP,_keyRefs[1],,,null())
:: jest parametr wejściowy GROP
|? var_pres('GROP',_in)>0
|| _grop:=exec('FindAndGet','#table',GROP,_in.GROP,,,null())
?};
{? _grop<>null()
|| _sym_grop:=exec('record','#to_string',_grop)
?};

{? _sym_zkp<>''
|| _desc:='Zgrupuj %1'@@[-(1+_sym_zkp)+(1-_sym_zkp)]
|? _sym_zkn<>''
|| _desc:='Zgrupuj zamówienie: %1'@@[_sym_zkn]
|? _sym_zl<>''
|| _desc:='Zgrupuj zlecenie %1'@@[_sym_zl]
|? _sym_grop<>''
|| _desc:='Zgrupuj grupę operacji: %1'@@[_sym_grop]
?};
_desc


\access
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuła ograniczajaca uprawnienia do czynności TTP_PPS_UTAG w przypadku pracy na zestawach
::       Sprawdza czy dany użytkownik może zacząć planować dany obiekt tzn czy ma uprawnienia do zestawu
::       startowego danego obiektu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_user:=params_get().user;
_mp:=params_get().mp;

_result:=1;
_can_continue:=1;

{? exec('is_px_set','px_param')>0
||
   _zk_n:=null();
   _zl:=null();
   _keyRefs:=_mp.getRefs();
:: jest rekord kluczowy ZK_N, to ustawiam odpowiedniego ZK_N
   {? var_pres('[1]',_keyRefs)>0 & 5+ref_name(_keyRefs[1])=5+ZK_N.name()
   || _zk_n:=exec('FindAndGet','#table',ZK_N,_keyRefs[1],,,null())
:: jest parametr wejściowy ZK_N
   |? var_pres('ZK_N',_in)>0
   || _zk_n:=exec('FindAndGet','#table',ZK_N,_in.ZK_N,,,null())
   ?};

:: jest rekord kluczowy ZL, to ustawiam odpowiednie ZL
   {? var_pres('[1]',_keyRefs)>0 & ref_name(_keyRefs[1])=ZL.name()
   || _zl:=exec('FindAndGet','#table',ZL,_keyRefs[1],,,null())
:: jest parametr wejściowy ZL
   |? var_pres('ZL',_in)>0
   || _zl:=exec('FindAndGet','#table',ZL,_in.ZL,,,null())
   ?};

   PX_SETU.cntx_psh();
   PX_SETU.index('PX_SET');
   {? _zk_n<>null()
   ||
      ZK_P.cntx_psh();
      ZK_P.use(5+ZK_P.name()+(ref_name(_zk_n)+3));
      ZK_P.index('NAG');
      ZK_P.prefix(_zk_n);
      {? ZK_P.first()
      || {!
         |?
            _can_continue:=exec('zkp2obj','px_obj');
            {? _can_continue>0
            || _result:=0;
               _px_obj:=exec('get_zkp_object','px_obj',ZK_P.ref());
               {? _px_obj<>null()
               || _px_set:=exec('FindAndGet','#table',PX_OBJ,_px_obj,,"PX_SET",null());

                  {? _px_set<>null()
                  ||
::                   Sprawdzam czy użytkownik ma uprawnienie do zestawu chociaż jednej pozycji
                     PX_SETU.prefix(_px_set,_user);
                     {? PX_SETU.size()>0
                     || _result:=1;
                        _can_continue:=0
                     ?}
                  || _result:=1
                  ?}
               ?}
            ?};
            ZK_P.next() & _can_continue>0
         !}
      ?};
      ZK_P.cntx_pop();
      ~~
   |? _zl<>null()
   ||
      ZL.cntx_psh(); ZL.prefix();
      {? ZL.seek(_zl)
      || _can_continue:=exec('zl2obj','px_obj');
         {? _can_continue>0
         || _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
            {? _px_obj<>null()
            || _result:=0;
               _px_set:=exec('FindAndGet','#table',PX_OBJ,_px_obj,,"PX_SET",null());
               {? _px_set<>null()
               ||
::                Sprawdzam czy użytkownik ma uprawnienie do zestawu tego zlecenia
                  PX_SETU.prefix(_px_set,_user);
                  {? PX_SETU.size()>0
                  || _result:=1
                  ?}
               || _result:=1
               ?}
            ?}
         ?}
      ?};
      ZL.cntx_pop();
      ~~
   ?};
   PX_SETU.cntx_pop();
   ~~
?};
_result


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuła ustala PARSES
::   WE: UWAGA. Do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;

_result:=0;

:: Jeżeli jest zamówienie, to oddział, rok, miesiąc wg niego, reszta dziedziczona
{? var_pres('ZK_N',_in)=type_of(null()) & _in.ZK_N
|| ZK_N.cntx_psh();
   ZK_N.use(ref_name(_in.ZK_N));
   ZK_N.prefix();
   {? ZK_N.seek(_in.ZK_N)
   || __PARSES.setVal('OddzialLogProd',ZK_N.ODDZ);
      _args:=__PARSES.args('OkresRok');
      _args.OBSZAR:='LSP';
      _args.AR:=ZK_N.R;
      _args.AM:=ZK_N.M;
      __PARSES.setVal('OkresRok',_args);
      _result:=1
   ?};
   ZK_N.cntx_pop()

:: Jeżeli jest zlecenie, to oddział wg niego, reszta dziedziczona
|? var_pres('ZL',_in)=type_of(null()) & _in.ZL
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_in.ZL)
   || __PARSES.setVal('OddzialLogProd',ZL.ODDZ);
      _args:=__PARSES.args('OkresRok');
      _args.OBSZAR:='LSP';
      _args.AR:=ZL.OD~1;
      _args.AM:=ZL.OD~2;
      __PARSES.setVal('OkresRok',_args);
      _result:=1
   ?};
   ZL.cntx_pop()

:: Nic nie ustawiamy, ale zwracamy 1, w formule przy braku parametrów wejściowych zostanie zgłoszony błąd
|| _result:=1
?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::   WE: [_a] - _mp - obiekt Menadżera procesów
::       [_b] - tablica z parametrami wejściowymi
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _mp:=_a
|| _mp:=params_get().mp
?};
{? var_pres('_b')>100
|| _in:=_b
|| _in:=params_get().in
?};

_can_continue:=1;
_obj:=obj_new('RESULT','ZL','ZK_N','ZK_P','PX_OBJ');
_obj.RESULT:=0;
_obj.ZL:=null();
_obj.ZK_N:=null();
_obj.ZK_P:=null();
_obj.PX_OBJ:=null();

_keyRefs:=_mp.getRefs();
_has_key:=0;
{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];

      {? type_of(_kref)>0
      || _has_key:=1;
         {? ref_name(_kref)=ZL.name()
         || _obj.ZL:=exec('FindAndGet','#table',ZL,_kref,,,null());

            {? _obj.ZL=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZL,_obj.ZL,,"ZL.STAN",'')='Z'
            ||
::            Zlecenie zostało zamknięte, więc robie error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp,,0)
            ?}
         |? ref_name(_kref)=PX_OBJ.name()
         || _obj.PX_OBJ:=exec('FindAndGet','#table',PX_OBJ,_kref,,,null());

            {? _obj.PX_OBJ=null()
            ||
::             Nie znaleziono rekordu kluczowego więc robię error
               _can_continue:=0;
               _msg:='Obiekt do kolejki nie został odnaleziony, prawdopodobnie został usunięty.'@@;
               {? _mp.isService()=0 & _mp.CLEANER=0
               || {? _mp.isGroup()
                  || KOMM.add(_msg,2,,1)
                  || FUN.emsg(_msg)
                  ?}
               ?};
               _mp.error(_msg)
            ?}
         |? (5+ref_name(_kref))=(5+ZK_N.name())
         || _obj.ZK_N:=exec('FindAndGet','#table',ZK_N,_kref,,,null());

            {? _obj.ZK_N=null()
            || _can_continue:=0;
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _msg:='Zamówienie nie zostało odnalezione, prawdopodobnie zostało usunięte.'@;
               {? _mp.isService()=0 & _mp.CLEANER=0
               || FUN.emsg(_msg)
               ?};
               _mp.error(_msg)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZK_N,_obj.ZK_N,,"(name()+2)<>'__'",0)
            ||
::             Zamówienie przeniesione do archiwum, robię error
               _can_continue:=0;
               exec('zam_deleted_in_proc','zamowienia',_mp,,,1)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZK_N,_obj.ZK_N,,"STAT_REJ='A'",0)
            ||
::             Zamówienie anulowane, robię error
               _can_continue:=0;
               exec('zam_deleted_in_proc','zamowienia',_mp,,,2)
            ?}
         |? (5+ref_name(_kref))=(5+ZK_P.name())
         || _obj.ZK_P:=exec('FindAndGet','#table',ZK_P,_kref,,,null());

            {? _obj.ZK_P=null()
            || _can_continue:=0;
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _msg:='Pozycja zamówienia nie została odnaleziona, prawdopodobnie została usunięta.'@;
               {? _mp.isService()=0 & _mp.CLEANER=0
               || FUN.emsg(_msg)
               ?};
               _mp.error(_msg)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZK_P,_obj.ZK_P,,"(name()+2)<>'__'",0)
            ||
::             Zamówienie przeniesione do archiwum, robię error
               _can_continue:=0;
               exec('zam_deleted_in_proc','zamowienia',_mp,,,1)
            |? ~_mp.isMicro()
            || _zk_n:=exec('FindAndGet','#table',ZK_P,_obj.ZK_P,,"N",null);
               {? exec('FindAndGet','#table',ZK_N,_zk_n,,"STAT_REJ='A'",0)
               ||
::                Zamówienie anulowane, robię error
                  _can_continue:=0;
                  exec('zam_deleted_in_proc','zamowienia',_mp,,,2)
               ?}
            ?}
         ?}
      ?}
   !}
?};
{? _has_key=0
|| {? var_pres('ZL',_in)=0 & var_pres('ZK_N',_in)=0 & var_pres('ZK_P',_in)=0 & var_pres('PX_OBJ',_in)=0
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: jest parametr wejściowy ZL
   {? _obj.ZL=null() & var_pres('ZL',_in)=type_of(null())
   || _obj.ZL:=_in.ZL
   ?};
:: jest parametr wejściowy ZK_N
   {? _obj.ZK_N=null() & var_pres('ZK_N',_in)=type_of(null())
   || _obj.ZK_N:=_in.ZK_N
   ?};
:: jest parametr wejściowy ZK_P
   {? _obj.ZK_P=null() & var_pres('ZK_P',_in)=type_of(null())
   || _obj.ZK_P:=_in.ZK_P
   ?};
:: jest parametr wejściowy PX_OBJ
   {? _obj.PX_OBJ=null() & var_pres('PX_OBJ',_in)=type_of(null())
   || _obj.PX_OBJ:=_in.PX_OBJ
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};
_obj


\create_tag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Tworzy nowy PX_OBJ jeżeli go jeszcze nie ma i tworzy nowy PX_TAG, przypina ten PX_TAG do PX_OBJ
::   WE:  _a - PX_VER.ref - wersja planu
::       [_b] - ZL.ref() - zlecenie
::       [_c] - ZK_P.ref() - zamówienie
::       [_d] - PX_OBJ.ref() - obiekt
::       [_e] - INTEGER - czy wyświetlać dialogi
::       [_f] - PX_SET.ref - zestaw planistyczny
::   WY: PX_TAG.ref() lub null()
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_px_ver:=_a;

_zl:=null();
{? var_pres('_b')=type_of(ZL.ref())
|| _zl:=_b
?};
_zk_p:=null();
{? var_pres('_c')=type_of(ZK_P.ref())
|| _zk_p:=_c
?};
_px_obj:=null();
{? var_pres('_d')=type_of(PX_OBJ.ref())
|| _px_obj:=_d
?};
_dialog:=0;
{? var_pres('_e')=type_of(0)
|| _dialog:=_e
?};
_px_set:=null();
{? var_pres('_f')=type_of(PX_SET.ref())
|| _px_set:=_f
?};

_result:=null();
_can_continue:=1;

{? _px_obj=null()
|| {? _zl<>null()
   || ZL.cntx_psh(); ZL.prefix();
      {? ZL.seek(_zl)
      || exec('zl2obj','px_obj');
         _px_obj:=exec('get_zl_object','px_obj',_zl)
      ?};
      ZL.cntx_pop()
   |? _zk_p<>null()
   || ZK_P.cntx_psh(); ZK_P.prefix();
      {? ZK_P.seek(_zk_p)
      || exec('zkp2obj','px_obj');
         _px_obj:=exec('get_zkp_object','px_obj',_zk_p)
      ?};
      ZK_P.cntx_pop()
   ?}
?};

_kind:=exec('get','#params',500393,type_of(''));

{? _px_obj<>null()
|| M.cntx_psh();
   MGR.cntx_psh();
   PX_OBJ.cntx_psh(); PX_OBJ.prefix();
   {? PX_OBJ.seek(_px_obj)
   ||
::    SEKCJA SPRAWDZANIA
      _what:=exec('PX_OBJ','#to_string');
      _can_continue:=exec('can_plan','px_obj',PX_OBJ.ref(),_dialog,,,0);

      {? _can_continue>0
      ||
         {? PX_OBJ.PX_TAG<>null()
         || _can_continue:=0;
            _msg:='Obiekt: %1 znajduje się już w grupie obiektów: %2'@[_what,exec('to_string','px_tag',PX_OBJ.PX_TAG)];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_ver;
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_obj','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            _mp.error(_msg)
         ?}
      ?};

      {? _can_continue>0
      ||
::       SEKCJA TWORZENIA/PRZYPISYWANIA
         _id:='';
         _material:=null();
         {? PX_OBJ.M<>null() & PX_OBJ.TM_REA>0
         ||
            _id:=Plugin.run('PX_GRUPOWANIE',PX_OBJ.ref());
            _material:=PX_OBJ.M;
            {? _id=''
            || _date:=exec('tm_stamp2date','#tm_stamp',PX_OBJ.TM_REA);
               {? _kind='D'
               || _id:='Termin realizacji: %1'@[$_date]
               |? _kind='T'
               || _daty:=exec('get','daty',_date);
                  {? _daty<>null()
                  || _tyg_nr:=exec('FindAndGet','#table',DATY,_daty,,"TYDZIEN",0);
                     {? _tyg_nr>0
                     || _id:='Termin realizacji: tydzień: %1'@[$_tyg_nr]
                     ?}
                  ?}
               |? _kind='I'
               || _id:='Indeks: %1'@[PX_OBJ.M().KTM]
               |? _kind='G'
               || _id:='Grupa materiałowa: %1'@[PX_OBJ.M().MGR().KOD]
               ?}
            ?}
         ?};
         PX_VAR.UTAG_ID:=_id;
         {? _can_continue>0 & _dialog=1
         || _valid:="
               _result:='';
               {? PX_VAR.UTAG_ID=''
               || FUN.emsg('Identyfikator grupujący nie może być pusty'@);
                  _result:='UTAG_ID'
               ?};
               _result
            ";
            PX_OBJ.win_edit('UTAG');
            {? PX_OBJ.edit(_valid)
            || _id:=PX_VAR.UTAG_ID;
               _can_continue:=1
            || _can_continue:=0
            ?}
         ?};

         {? _can_continue>0 & _id<>''
         || _result:=exec('add','px_tag',_id,PX_OBJ.ref(),_px_set);
            {? _result<>null()
            || PX_OBJ.PX_TAG:=_result;
               PX_OBJ.HAS_TAG:='T';
               _can_continue:=PX_OBJ.put();

               {? _can_continue>0
               || _can_continue:=exec('update_after_add','px_tag',_result)
               ?}
            ?}
         ?}
      ?}
   ?};
   PX_OBJ.cntx_pop();
   M.cntx_pop();
   MGR.cntx_pop()
?};

{? _result<>null()
|| _mp.grpkeyAdd(exec('FindAndGet','#table',PX_TAG,_result,,"uidref()",''))
?};

_result


\grupuj_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Grupuj w oknie wertowania PX_OBJ
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZK_N.cntx_psh();
ZK_P.cntx_psh();
_grupa:=0;

{? PX_OBJ.sel_size()>0
|| _grupa:=1
?};

_result:=0;
_args:=exec('mp_run_a','#b__box');
_can_continue:=1;
{? PX_OBJ.ZL<>null()
|| _args.UIDREF:=PX_OBJ.ZL().uidref()
|? PX_OBJ.ZK_P<>null()
|| ZK_N.use(ref_name(PX_OBJ.ZK_N)); ZK_P.use(ref_name(PX_OBJ.ZK_P));
   _args.UIDREF:=PX_OBJ.ZK_P().N().uidref()
|? PX_OBJ.ZK_N<>null()
|| _mask:=ref_name(PX_OBJ.ZK_N);
   ZK_N.use(_mask); ZK_P.use('zkpoz'+(_mask+3));
   _args.UIDREF:=PX_OBJ.ZK_N().uidref()
|| _can_continue:=0
?};

{? _can_continue>0
||
   _args.ACT_UID:='TPP_PPS_UTAG';

   _args.CONTEXT:=obj_new('RESULT','VER_QUE');
   _args.CONTEXT.RESULT:=0;
   _args.CONTEXT.VER_QUE:=null();
   {? exec('is_one_version','px_param')=0
   || _args.CONTEXT.VER_QUE:=PX_VAR.VER_QUE
   ?};
   _args.AKCJA:='GRUPUJ';

   {? _grupa>0
   || _args.GRUPA:='T'
   ?};

   _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZK_N',PX_OBJ.ZK_N);
   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZK_P',PX_OBJ.ZK_P);

   exec('mp_run','#b__box',_args);
   {? _args.CONTEXT.RESULT>0 || _result:=1 ?}
|| _msg:='Obiekt: %1 nie posiada indeksu materiałowego. Grupowanie niemożliwe.'@[exec('PX_OBJ','#to_string')];
   {? _grupa>0
   || KOMM.add(_msg,2,,1)
   || FUN.emsg(_msg)
   ?}
?};
ZL.cntx_pop();
ZK_N.cntx_pop();
ZK_P.cntx_pop();
{? _grupa=0 & exec('get','#params',8061,type_of(''),OPERATOR.USER)='T'
|| grp_disp(PX_TAG,'WER',1)
?};
_result


\grupuj_act_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja grupa przed Grupuj w oknie wertowania PX_OBJ
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(250,,'Grupowanie obiektów w planie strategicznym.'@);
sel_nchk();

_can_continue:=FUN.ask('Zaznaczonych obiektów: %1. Czy rozpocząć ich grupowanie?'@[$PX_OBJ.sel_size()]);
{? _can_continue>0
|| VAR.GRUPA:='T'
?};
_can_continue


\grupuj_act_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja grupa po Grupuj w oknie wertowania PX_OBJ
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
{? exec('get','#params',8061,type_of(''),OPERATOR.USER)='T'
|| grp_disp(PX_TAG,'WER',1)
?};
~~


\planuj_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Do kolejki w oknie PX_TAG
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZK_N.cntx_psh();
ZK_P.cntx_psh();

_grupa:=0;
{? PX_TAG.sel_size()>0
|| _grupa:=1
?};

{? PX_TAG.KIND='N'
||
   _args:=exec('mp_run_a','#b__box');
   _args.ACT_UID:='TPP_PPS_DOPL';

   _args.CONTEXT:=obj_new('RESULT','ZK_P','DEST','TRANSFORMED','VER_QUE');
   _args.CONTEXT.RESULT:=0;
   _args.CONTEXT.ZK_P:=null();
   _args.CONTEXT.DEST:=null();
   _args.CONTEXT.TRANSFORMED:=0;
   _args.CONTEXT.VER_QUE:=null();
   {? exec('is_one_version','px_param')=0
   || _args.CONTEXT.VER_QUE:=PX_VAR.VER_QUE
   ?};
   _args.UIDREF:=PX_TAG.uidref();
   _args.AKCJA:='DO_KOLEJKI';

   {? _grupa>0
   || _args.GRUPA:='T'
   ?};
   _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'PX_TAG',PX_TAG.ref());

   exec('mp_run','#b__box',_args);
   {? _args.CONTEXT.RESULT>0 || _result:=1 ?};
   {? _grupa=0
   || {? exec('is_one_version','px_param')=0 & _args.CONTEXT.TRANSFORMED>0
      || exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp)
      ?};
      grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT,1);
      {? PX_VAR.PL_GROP
      || grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT_G)
      ?};
      ~~
   ?}
?};
ZL.cntx_pop();
ZK_N.cntx_pop();
ZK_P.cntx_pop();
~~


\planuj_act_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Grupa przed akcji Do kolejki w PX_TAG
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

KOMM.init(250,,'Dodawanie obiektów do planu strategicznego.'@);
sel_nchk();
{? exec('is_px_set','px_param') & PX_VAR.PX_SET=null()
|| _can_continue:=0;
   FUN.info('Aby dodawać elementy do kolejki należy pracować w kontekście zestawu planistycznego.'@)
?};
VAR.GRUPA:='T';
_result:=FUN.ask('Zaznaczonych grup obiektów: %1. Zaplanować je wszystkie?'@[$PX_TAG.sel_size()]);
_result


\planuj_act_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Grupa przed akcji Do kolejki w PX_TAG
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
{? exec('is_one_version','px_param')=0
|| exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp)
?};
grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT,1);
{? PX_VAR.PL_GROP
|| grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT_G)
?};
~~


\wygrupuj_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Usuń z grupy w oknie wertowania PX_OBJ
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_grupa:=0;

{? PX_OBJ.sel_size()>0
|| _grupa:=1
?};

_result:=0;

_can_continue:=1;

{? _grupa=0
|| _can_continue:=FUN.ask('Usunąć obiekt: %1 z grupy: %2?'@[exec('PX_OBJ','#to_string'),exec('record','#to_string',PX_OBJ.PX_TAG)])
?};

{? _can_continue>0
|| PX_OBJ.PX_TAG:=null();
   PX_OBJ.HAS_TAG:='N';
   _can_continue:=PX_OBJ.put()
?};

{? _grupa=0 & exec('get','#params',8061,type_of(''),OPERATOR.USER)='T'
|| grp_disp(PX_TAG,'WER',1)
?};
_result


\wygrupuj_act_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja grupa przed Grupuj w oknie wertowania PX_OBJ
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(250,,'Usuwanie obiektów z grupy w planie strategicznym.'@);
sel_nchk();

_can_continue:=FUN.ask('Zaznaczonych obiektów: %1. Czy usunąć je z ich grup obiektów?'@[$PX_OBJ.sel_size()]);
{? _can_continue>0
|| VAR.GRUPA:='T'
?};
_can_continue


\wygrupuj_act_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja grupa po Grupuj w oknie wertowania PX_OBJ
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
{? exec('get','#params',8061,type_of(''),OPERATOR.USER)='T'
|| grp_disp(PX_TAG,'WER',1)
?};
~~


:Sign Version 2.0 jowisz:1048 2023/06/23 14:09:37 e4fd2720f9233f5f22235c3176a27287aa2843cbf67e11fea9707a2880ef2f26f365da1a9171ada64e916d069fcc90feb8579ee1541d3f416e2f14436c40306f9de7996b3872d4186c9b7e38b4dc2035d20e6bcdf8b2ba97bc56c0be02fc7cd87cd5fe6b0792bebb52b1ac124c88587b3e69f4711d496facda6e74ec65638198
