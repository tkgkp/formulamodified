:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tte_pzl_dzle.fml
:: Utworzony: 22.06.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły czynności TTE_PZL_DZLE - Rejestracja zlecenia produkcyjnego prostego
::            Uwaga: większość kodu jest wspólna z czynnościami:
::                   - TTE_PZL_DWAR
::                   - TTE_PZL_DZLP
::                   - TTE_PZL_DZLN
::            w przypadku zmian modyfikować wszystkie pliki
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła główna czynności rejestracji zlecenia produkcyjnego prostego (TTE_PZL_DZLE)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::       context - [obj_new] obiekt służący do przekazywania kontekstu wywołania czynności
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

::# permissions=ODDZ,LMG
::# properties=SERVICE
::# parses=exec('parses','!tte_pzl_dzle')
::# condition=Czy są operacje zlecenia, act_uid=TTE_PZL_DPZG, auto=T, formula=exec('czy_sa_operacje_zlecenia','%gate',_a.ZL)
::# condition=Czy są półfabrykaty zlecenia, act_uid=TTE_PZL_DZLG, auto=T, formula=exec('czy_sa_polfabrykaty_zlecenia','%gate',_a.ZL)

:: PARAMETRY WE:
::# kind=WE, symbol=ZTP, type=_ZTP, name=Typ zlecenia, required=N, fml_val="exec('ztp_select','zl_head','P',0)", fml_exp="exec('ztp_export','zl_head',_a)"
{? var_pres('ZTP',_in)<>type_of(~~) & var_pres('ZTP',_in)<>type_of(null()) || return() ?};
{? var_pres('ZTP',_in)=type_of(~~) || _in.ZTP:=null() ?};
::# kind=WE, symbol=ZL, type=_ZL, name=Wskazanie na zlecenie, required=N, keyref=T
{? var_pres('ZL',_in)<>type_of(~~) & var_pres('ZL',_in)<>type_of(null()) || return() ?};
::# kind=WE, symbol=ZL_NAD, type=_ZL, name=Wskazanie na zlecenie nadrzędne, required=N, keyref=T
{? var_pres('ZL_NAD',_in)<>type_of(~~) & var_pres('ZL_NAD',_in)<>type_of(null()) || return() ?};
{? var_pres('ZL_NAD',_in)=type_of(~~) || _in.ZL_NAD:=null() ?};
::# kind=WE, symbol=TKTL, type=_TKTL, name=Technologia zlecenia, required=N
{? var_pres('TKTL',_in)<>type_of(~~) & var_pres('TKTL',_in)<>type_of(null()) || return() ?};
{? var_pres('TKTL',_in)=type_of(~~) || _in.TKTL:=null() ?};
::# kind=WE, symbol=KTM, type=_M, name=Produkt zlecenia, required=N
{? var_pres('KTM',_in)<>type_of(~~) & var_pres('KTM',_in)<>type_of(null()) || return() ?};
{? var_pres('KTM',_in)=type_of(~~) || _in.KTM:=null() ?};

:: PARAMETRY WY:
::# kind=WY, symbol=ZL, type=_ZL, name=Wskazanie na zlecenie, required=N
{? var_pres('ZL',_out)<>type_of(~~) & var_pres('ZL',_out)<>type_of(null()) || return() ?};
::# kind=WY, symbol=TECH, type=STRING, name=Redagowanie technologii zlecenia, required=N
{? var_pres('TECH',_out)<>type_of('') || _out.TECH:='N' ?};
::# kind=WY, symbol=RESULT, type=STRING, name="Wynik działania (OK, BŁĄD)", required=N

_clean_result:=params_exec('clean','!tte_pzl_dzle',_mp,_in);
{? ~_clean_result.RESULT
|| return(~~)
?};

:: Sprawdzenie typu zlecenia
{? _in.ZTP
|| {? exec('FindAndGet','#table',ZTP,_in.ZTP,,"1+TYP",'')='~'
   || _msg:='Niezgodność wywołania czynności.\nPrzekazany typ nie może być zastrzeżony.'@@;
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg);
      return()
   |? exec('FindAndGet','#table',ZTP,_in.ZTP,,"WP",'')<>'P'
   || _msg:='Niezgodność wywołania czynności.\nPrzekazany typ musi dotyczyć zleceń produkcyjnych.'@@;
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg);
      return()
   ?}
?};

:: Sprawdzenie zlecenia i ustawienie parametru wyjściowego
{? var_pres('ZL',_in)=type_of(null())
|| {? _in.ZL
   || {? exec('FindAndGet','#table',ZL,_in.ZL,,"RODZAJ",'')<>'P'
      || _msg:='Niezgodność wywołania czynności.\nPrzekazane zlecenie musi być zleceniem prostym.'@@;
         {? ~_mp.isService()
         || FUN.emsg(_msg)
         ?};
         _mp.error(_msg);
         return()
      || _out.ZL:=_in.ZL;
         _mp.save(exec('kind_out','#b_port'),'ZL',_in.ZL)
      ?}
   || _msg:='Niezgodność wywołania czynności.\nPrzekazany parametr ZL nie może mieć wartości null().'@@;
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg);
      return()
   ?}
?};

:: Sprawdzenie produktu
{? _in.KTM
|| _err:=exec('chk_ktm4zl','zl_common',_in.KTM,0);
   {? _err
   || {? _err=1
      || _msg:='Niezgodność wywołania czynności.\nNie udało się odnaleźć przekazanego materiału.'@
      |? _err=2
      || _msg:='Niezgodność wywołania czynności.\nPrzekazany indeks materiałowy jest nieaktywny.'@
      |? _err=3
      || _msg:='Niezgodność wywołania czynności.\nPrzekazany indeks materiałowy nie jest produktem.'@
      || _msg:='Niezgodność wywołania czynności.'@
      ?};
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg);
      return()
   ?}
?};

:: Sprawdzenie technologii
{? _in.TKTL
|| _err:=exec('chk_tktl4zl','zl_common',_in.TKTL,0);
   {? _err
   || {? _err=1
      || _msg:='Niezgodność wywołania czynności.\nNie udało się odnaleźć przekazanej technologii.'@
      |? _err=2
      || _msg:='Niezgodność wywołania czynności.\nPrzekazana technologia jest niezaakceptowana.'@
      |? _err=3
      || _msg:='Niezgodność wywołania czynności.\nPrzekazana technologia jest archiwalna.'@
      |? _err=4
      || _msg:='Niezgodność wywołania czynności.\nPrzekazana technologia jest nieaktualna.'@
      || _msg:='Niezgodność wywołania czynności.'@
      ?};
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg);
      return()
   ?}
?};

:: Sprawdzenie zgodności technologi z produktem zlecenia
{? _in.TKTL & _in.KTM
|| {? ~exec('chk_ktm4tktlw','tech_common',_in.TKTL,_in.KTM)
   ||
::    Brak produktu w danej technologii, czyszcenie wartości
      _msg:=
         'Niezgodność wywołania czynności.\n'
         'Przekazany indeks materiałowy musi być zdefiniowany jako produkt przekazanej technologii'@;
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg);
      return()
   ?}
?};

:: Sprawdzenie zlecenia nadrzędnego, pobranie uidref(), sprawdzenie powiązania z typem zlecenia
_keyRef:='';
{? _in.ZL_NAD
|| _kategoria:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"RODZAJ",'');
   _nrnzl:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"NRNZL",0);
   {? ~(_kategoria='N' | _kategoria='P' & _nrnzl<>0)
   || _msg:=
         'Niezgodność wywołania czynności.\n'
         'Zlecenie nadrzędne musi być podzleceniem zlecenia złożonego z półfabrykatami albo zleceniem niezależnym.'@@;
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg);
      return()
   ?};
   _ztp:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"TYP",null());
   {? _in.ZTP & _ztp<>_in.ZTP
   || _msg:=
         'Niezgodność wywołania czynności.\n'
         'Typ zlecenia nadrzędnego musi być zgodny z typem zlecenia przekazanym w procesie.'@@;
      {? ~_mp.isService()
      || FUN.emsg(_msg)
      ?};
      _mp.error(_msg);
      return()
   ?};
   _stan:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"STAN",'');
   {? _stan='Z'
   || {? _mp.isService()
      || _out.RESULT:='BŁĄD';
         _mp.save(,_out);
         _mp.done()
      || FUN.info('Nie można uruchomić czynności.\nZlecenie nadrzędne jest zamknięte.'@)
      ?};
      return()
   ?};
   _keyRef:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"uidref()",'')
?};

:: Wyzwalacz, który po dodaniu nagłówka zlecenia:
:: - add/put: dodaje/aktualizuje rekord kluczowy nagłówka utworzonego zlecenia
::   del: usuwa rekord kluczowy nagłówka utworzonego zlecenia
:: - add/put: zapisuje parametr wyjściowy ZL - wskazanie na nagłówek utworzonego zlecenia
::   del: zapisuje parametr wyjściowy ZL - null()
:: - add/put: usuwa kluczowy rekord nagłówka zlecenia nadrzędnego
::   del: dodaje rekord kluczowy nagłówka zlecenia nadrzędnego
:: - aktualizuje opis na ToDo
::_mp.trigRef('ZL',1,1,1,exec('kind_out','#b_port'),'ZL',_keyRef,$('ZL.uidref()<>\''+_keyRef+'\''));

_keyRefs:=_mp.getRefs();
{? var_pres('[1]',_keyRefs)=type_of('') & _keyRefs[1]<>_keyRef
|| ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_keyRefs[1])
   || _zl:=ZL.ref();
      _zl_uid:=ZL.uidref()
   || _zl:=null();
      _zl_uid:=''
   ?};
   ZL.cntx_pop()
|? _mp.akcja()='KOPIUJ' | _mp.akcja()='POPRAW' | _mp.akcja()='USUŃ' | _mp.akcja()='USUŃ_AUTO' | _mp.akcja()='ZAKOŃCZ'
|| _zl:=_context.ZL;
   _zl_uid:=exec('FindAndGet','#table',ZL,_context.ZL,,"uidref()",'')
|| _zl:=null();
   _zl_uid:=''
?};

{? _mp.isService() & _zl=null()
|| _msg:='Błędna konfiguracja procesu — nie przekazano zlecenia.'@;
   _mp.error(_msg);
   return()
?};

:: Wywołanie automatyczne, jest odpowiedni KeyRef, więc bezwarunkowe zakończenie redagowania nagłówka
:: (chyba, że data realizacji jest zaległa)
{? (_mp.isAutoRun() | _mp.isService()) & _zl<>null()
|| ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zl)
   || {? ZL.DTR=date(0,0,0) | ZL.DTR>=date()
      || ZL.STAT_N:='T';
         {? ZL.put()
         ||
::          Wtyczka - generowanie produktów zlecenia
            {? ZL.RP='T'
            || {? Plugin.runnable('ZL_WYR_GEN_001')
               || _json:=Plugin.run('ZL_WYR_GEN_001',1,ZL.ref());
                  {? type_of(_json)=type_of('') & _json<>''
                  || _tab_plugin:=json_parse(_json);
                     {? type_of(_tab_plugin)>100 & obj_len(_tab_plugin)>0
                     || exec('zl_wyr_from_tab','zl_wyr',_tab_plugin)
                     ?}
                  ?}
               ?}
            ?};
            _out.TECH:=ZL.TYP().TECH;
            _out.RESULT:='OK';
            _mp.save(,_out);
            _mp.done()
         ?}
      || {? _mp.isService()
         || _out.RESULT:='BŁĄD';
            _mp.save(,_out);
            _mp.done()
         || _mp.cancel()
         ?}
      ?}
   || {? _mp.isService()
      || _out.RESULT:='BŁĄD';
         _mp.save(,_out);
         _mp.done()
      || _mp.cancel()
      ?}
   ?};
   ZL.cntx_pop()

:: Wywołanie z listy ToDo, jest odpowiedni KeyRef, więc kontynuacja redagowania nagłówka
|? _mp.pathTodo() & _zl<>null()
|| {? exec('FindAndGet','#table',ZL,_zl,,"STAT_N",'N')='T'
   || FUN.info('Zakończono rejestrację nagłówka zlecenia.'@);
      _out.TECH:=exec('FindAndGet','#table',ZL,_zl,,"TYP().TECH",'N');
      _out.RESULT:='OK';
      _mp.save(,_out);
      _mp.done()
   || _mp.keyRef(_zl_uid);
      {? _keyRef<>''
      || _mp.delRef(_keyRef)
      ?};
      _ok:=exec('zl_popraw','zl_head',_zl,1);
      {? _mp.isMicro()
      || _mp.cancel()
      |? _ok
      || {? exec('FindAndGet','#table',ZL,_zl,,"STAT_N",'N')='T'
         || _out.TECH:=exec('FindAndGet','#table',ZL,_zl,,"TYP().TECH",'N');
            _out.RESULT:='OK';
            _mp.save(,_out);
            _mp.done()
         ?}
      ?}
   ?}

:: Poprawianie zlecenia (obszar roboczy - zlecenie przekazane kontekstem)
|? _mp.akcja()='POPRAW'
|| _mp.keyRef(_zl_uid);
   _ok:=exec('zl_popraw','zl_head',_zl,exec('FindAndGet','#table',ZL,_zl,,"STAT_N",'N')='N');
   {? _mp.isMicro()
   || _mp.cancel()
   |? _ok
   || {? exec('FindAndGet','#table',ZL,_zl,,"STAT_N",'N')='T'
      || _out.TECH:=exec('FindAndGet','#table',ZL,_zl,,"TYP().TECH",'N');
         _out.RESULT:='OK';
         _mp.save(,_out);
         _mp.done()
      ?}
   ?}

:: Wywołanie z panelu czynności - nowy proces, więc nowe zlecenie
:: Wywołanie z listy ToDo, nie ma KeyRef, więc nowe zlecenia
:: Dołączanie nowego zlecenia (obszar roboczy)
:: Dołączanie nowego zlecenia podrzędnego (obszar roboczy)
|? _mp.pathProc() | _mp.pathTodo() | _mp.akcja()='DOŁĄCZ' | _mp.akcja()='DOŁĄCZ_PODZLECENIE'
|| _zl:=exec('zl_dolacz','zl_head','P',_in.ZTP,'P',_in.ZL_NAD,_in.TKTL,_in.KTM);
   {? _mp.isMicro()
   || _mp.cancel()
   |? _zl<>null()
   || ZL.cntx_psh(); ZL.prefix();
      {? ZL.seek(_zl)
      || {? (_in.KTM<>null() | _in.TKTL<>null()) & ~_mp.isAutoRun()
         || FUN.info('Wygenerowano zlecenie produkcyjne o symbolu %1.'@[ZL.SYM])
         ?};
         _uidref:=ZL.uidref();
         _mp.keyRef(_uidref,1,1);
         {? _keyRef<>''
         || _mp.delRef(_keyRef)
         ?};
         _out.TECH:=ZL.TYP().TECH;
         _out.ZL:=ZL.ref();
         _mp.save(,_out);
         {? ZL.STAT_N='T'
         || _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
            _mp.done()
         ?}
      ?};
      ZL.cntx_pop()
   || _mp.cancel()
   ?}

:: Usuwanie zlecenia (obszar roboczy - zlecenie przekazane kontekstem)
|? _mp.akcja()='USUŃ'
|| _uidref:=exec('FindAndGet','#table',ZL,_zl,,"ZL.uidref",'');
   _context.RESULT:=exec('zl_usun','zl_head',_zl,_mp.isGroup());
   {? _context.RESULT
   || _mp.delRef(_uidref);
      _out.ZL:=null();
      _out.TECH:='N';
      _mp.save(,_out);
      _mp.cancel()
   ?}

:: Usuwanie zlecenia (automatycznie podczas np. usuwania zlecenia złożonego - zlecenie przekazane kontekstem)
|? _mp.akcja()='USUŃ_AUTO'
|| _uidref:=exec('FindAndGet','#table',ZL,_zl,,"ZL.uidref",'');
   _context.RESULT:=exec('zl_del','zl_head',_zl);
   {? _context.RESULT
   || _mp.delRef(_uidref,0);
      _out.ZL:=null();
      _out.TECH:='N';
      _mp.save(,_out);
      _mp.cancel()
   ?}

:: Kopiowanie na nowe zlecenie (obszar roboczy - źródłowe zlecenie przekazane kontekstem)
|? _mp.akcja()='KOPIUJ'
|| {? _in.ZTP<>null() & _in.ZTP<>exec('FindAndGet','#table',ZL,_zl,,"TYP",null())
   || FUN.info('Nie można uruchomić procesu — niezgodność typu zlecenia.'@);
      _mp.cancel()
   || _zl:=exec('zl_kopiuj','zl_head',_zl);
      {? _mp.isMicro()
      || _mp.cancel()
      |? _zl<>null()
      || ZL.cntx_psh(); ZL.prefix();
         {? ZL.seek(_zl)
         ||  _uidref:=ZL.uidref();
            _mp.keyRef(_uidref,1,1);
            {? _keyRef<>''
            || _mp.delRef(_keyRef)
            ?};
            _out.TECH:=ZL.TYP().TECH;
            _out.ZL:=ZL.ref();
            _mp.save(,_out);
            {? ZL.STAT_N='T'
            || _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
               _mp.done()
            ?}
         ?};
         ZL.cntx_pop()
      || _mp.cancel()
      ?}
   ?}

:: Zakończenie redagowania nagłówka (obszar roboczy - zlecenie przekazane kontekstem)
|? _mp.akcja()='ZAKOŃCZ'
|| ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zl)
   || _out.ZL:=ZL.ref();
      {? {? _mp.isGroup()
         || 1
         || FUN.ask('Czy zakończyć rejestrację nagłówka zlecenia?'@)
         ?}
      || _ok:=1;
         {?  exec('FindAndGet','#table',TKTL,ZL.RKTL,,"TKTL.ARCH",'')='T'
         || _msg:='Do zlecenia %1 przypisana jest archiwalna karta technologiczna.'@[ZL.SYM];
            {? ZL.sel_size()=0
            || FUN.info(_msg)
            || KOMM.add(_msg)
            ?};
            _ok:=0
         ?};
         {? ZL.KTL<>null & ~exec('tktl_act','tech_head',1)
         || {? ZL.sel_size()=0
            || _msg:='Do zlecenia %1 przypisana jest nieaktualna karta technologiczna. Czy zakończyć redakcję nagłówka zlecenia na jej podstawie?'@[ZL.SYM];
               _choice:=FUN.choice(_msg,,'Tak',,,,'Nie');
              {? _choice || _ok:=1 || _ok:=0 ?}
            || _msg:='Do zlecenia %1 przypisana jest nieaktualna karta technologiczna.'@[ZL.SYM];
               KOMM.add(_msg);
               _ok:=0
            ?}
         ?};

         {? _ok
         || ZL.STAT_N:='T';
            {? ZL.put()
            || {? _mp.isGroup() || KOMM.add('Zakończono rejestrację nagłówka zlecenia %1.'@[ZL.SYM]) ?};
::             Wtyczka - generowanie produktów zlecenia
               {? ZL.RP='T'
               || {? Plugin.runnable('ZL_WYR_GEN_001')
                  || _json:=Plugin.run('ZL_WYR_GEN_001',1,ZL.ref());
                     {? type_of(_json)=type_of('') & _json<>''
                     || _tab_plugin:=json_parse(_json);
                        {? type_of(_tab_plugin)>100 & obj_len(_tab_plugin)>0
                        || exec('zl_wyr_from_tab','zl_wyr',_tab_plugin)
                        ?}
                     ?}
                  ?}
               ?};
               _out.RESULT:='OK';
               _mp.save(,_out);
               _mp.done()
            ?}
         || _mp.keep()
         ?}
      ?}
   || _mp.cancel()
   ?};
   ZL.cntx_pop()

:: Tutaj nie powinno dojść, więc błąd
|| _mp.error('Nieobsłużony kontekst wywołania czynności.')
?};
~~


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opis dla czynności rejestracji nagłówka zlecenia produkcyjnego prostego (TTE_PZL_DZLE)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WY: zwraca opis Zadania
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

_desc:='';
_keyRefs:=_mp.getRefs();
_in:=_mp.load(exec('kind_in','#b_port'));

:: jest parametr wejściowy ZL_NAD, to opis dla podzlecenia
{? var_pres('ZL_NAD',_in)
|| _keyRef:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"uidref()",'');
:: jest rekord kluczowy, to konkretne podzlecenie
   {? var_pres('[1]',_keyRefs)=type_of('') & _keyRefs[1]<>_keyRef
   || _tmp:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"SYM",'');
      _desc:={? _tmp<>'' || 'Zredaguj podzlecenie %1'@@[_tmp] || '' ?}
::   || _desc:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"'Zredaguj podzlecenie %1'[SYM]",'')
   || _tmp:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"SYM",'');
      _desc:={? _tmp<>'' || 'Zredaguj podzlecenie zlecenia %1'@@[_tmp] || '' ?}
::   || _desc:=exec('FindAndGet','#table',ZL,_in.ZL_NAD,,"'Zredaguj podzlecenie zlecenia %1'[SYM]",'')
   ?}

:: nie ma ZL_NAD, a jest rekord kluczowy to ustawiam odpowiednie ZL
|? var_pres('[1]',_keyRefs)
|| _tmp:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"SYM",'');
   _desc:={? _tmp<>'' || 'Zredaguj zlecenie produkcyjne proste %1'@@[_tmp] || '' ?}
::|| _desc:=exec('FindAndGet','#table',ZL,_keyRefs[1],,"'Zredaguj zlecenie produkcyjne proste %1'@@[SYM]",'')

:: nie ma nic...
|| _desc:='Zredaguj nowe zlecenie produkcyjne proste'@@
?};
_desc


\action_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja nagłówka zlecenia produkcyjnego prostego
::       - akcja Dołącz -> Proste
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TTE_PZL_DZLE';
_args.AKCJA:='DOŁĄCZ';
_args.PROC_START:='T';

exec('mp_run','#b__box',_args);
~~


\action_subadd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja nagłówka podzlecenia
::       - akcja Dołącz -> Podzlecenie
::----------------------------------------------------------------------------------------------------------------------
{? ZL.RODZAJ='N' | ZL.RODZAJ='P' & ZL.NRNZL<>0
|| _args:=exec('mp_run_a','#b__box');
   _args.ACT_UID:='TTE_PZL_DZLE';
   _args.UIDREF:=ZL.uidref();
   _args.AKCJA:='DOŁĄCZ_PODZLECENIE';
   _args.PROC_START:='T';
   _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL_NAD',ZL.ref());

   exec('mp_run','#b__box',_args)

|| FUN.info('Zlecenia podrzędne można dołączać tylko do zleceń prostych podrzędnych albo złożonych niezależnych.'@)
?};
~~


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Funkcja czyszcząca czynności - w razie potrzeby jak nie ma rekordu kluczowego zrobi done albo cancel
::       Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::   WE: [_a] - _mp - obiekt Menadżera procesów
::       [_b] - tablica z parametrami wejściowymi
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _mp:=_a
|| _mp:=params_get().mp
?};
{? var_pres('_b')>100
|| _in:=_b
|| _in:=params_get().in
?};
params_exec('zl_clean','zl_common',_mp,_in,'ERROR')


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Formuła ustalająca PARSES
::   WE:
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
params_exec('zl_parses','zl_common')

:Sign Version 2.0 jowisz:1048 2023/06/23 14:09:38 bbc1c83969632bca0dd1115eb6e172a2354ab333a7d5a907cb9bf4edba7d5bcc19ba1fd1a86c99f405e8bab40123b81ab88379e7767c21c19c79b9b46544cd944e2225acfed46e01b0929ee6ae7360c8ee9fc9281f8e7d2e1eafa6f88fa2cfff83321bb525c240616b67ce9e64c74be019dfea56593e03a0ada566879685195d
