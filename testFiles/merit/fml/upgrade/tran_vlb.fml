:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: tran_vlb.fml
:: Utworzony: 10.09.2018
:: Autor: PJ
::======================================================================================================================
:: Zawartość: Funkcje do obsługi transferu danych - walidacja danych przed eksportem z Xpertis
::======================================================================================================================


\start_wal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [18.42]
:: OPIS: Uruchomienie formuł walidacyjnych przed rozpoczęciem eksportu danych z Xpertis
::   WE: [_a] - jeżeli podano _a i _a=1 to mechanizm wywołany podczas transferu, w innym przypadku wywołany samodzielnie
:: ~OST: INFILECHOOSER,INFOPEN
::----------------------------------------------------------------------------------------------------------------------
{? _>0 & type_of(_a)=type_of(0) & _a=1 || _transf:=1 || _transf:=0 ?};
_return:=1;
{? var_pres('KOMM')<100
|| exec('init','communiq');
   KOMM:=obj_new(@.CLASS.JCQ)
?};
:: Powołanie obiektu w przypadku braku jego deklaracji dla danej aplikacji (np. Alert)
{? var_pres('PROGRESS')<>type_of(@.CLASS.PROGRES)
|| PROGRESS:=obj_new(@.CLASS.PROGRES)
?};
{? var_pres('RB')<=0
|| exec('obj_rb','skid_ror');
   RB:=obj_new(@.CLASS.RB)
?};

:: tablica dla procedur naprawczych związanych z walidacją
VAR_DEL.delete('__TABVLB');
__TABVLB:=obj_new('id_srod');
__TABVLB.id_srod:=0;

KOMM.init(150,200,'Uwagi dotyczące poprawności danych w systemie Xpertis');

:: Jeżeli brak zapisów w tabeli FO to dodaje jeden zapis
FO.cntx_psh();
FO.prefix();
{? ~FO.first()
|| exec('add_fo','fo_usr',null,100700,^611,'Czy bufor planu dostaw jest aktywny?','\'N\'','X')
?};
FO.cntx_pop();
:: walidacja Wspólne
exec('skid_wal','tran_vlb',_transf);
:: walidacja Estra
exec('estra_wal','tran_vlb');
:: walidacja Logistyka
exec('emag_wal','tran_vlb');
:: walidacja Kalego
exec('kali_wal','tran_vlb',_transf);
:: walidacja produkcja
exec('prod_wal','tran_vlb');
:: walidacja Wyposażenie
exec('wyp_wal','tran_vlb');
:: walidacja Umowy i zgłoszenia
exec('umowy_wal','tran_vlb');

:: wynik walidacji
{? ~KOMM.empty()
|| _save:="_filter:='*.log';
           _name:='tran_vlb.log';
           ctr_set('!application','filechooser','reset');
           ctr_set('!application','filechooser','setDialogTitle','Zapisz jako'@);
           ctr_set('!application','filechooser','addDefaultFilter',_filter,'log');
           ctr_set('!application', 'filechooser','setAcceptAllFileFilterUsed',1);
           ctr_set('!application','filechooser','setMultiSelectionEnabled',0);
           ctr_set('!application','filechooser','setFileSelectionMode','FILES_ONLY');
           ctr_set('!application','filechooser','setSelectedFile',_name);
           _txt:={? ctr_call('!application','filechooser','showSaveDialog')
                     || ctr_call('!application','filechooser','getSelectedFile')
                     || ''
                     ?};
           {? _txt<>''
           || _f:=fopen('@'+_txt,'uw');
              {? _f
              || .save(_f);
                 fclose(_f)
              ?}
           ?};
           1
          ";
   KOMM.select(,'System / Znalezione problemy',_save);
   {? _transf
   || {? ~FUN.ask('Kontynuować procedurę eksportu danych z systemu Xpertis?')
      || _return:=0
      ?}
   || _lpn:=0; {! _i:=1..obj_len(__TABVLB) |! _lpn+=__TABVLB[_i] !};
      {? _lpn & ~FUN.ask('Uruchomić procedury naprawcze danych z systemu Xpertis?')
      || _return:=0
      ?}
   ?}
?};

:: jeżeli procedura jest kontynuowana i trzeba wykonać formuły naprawcze
{? _return
|| {? __TABVLB.id_srod
   || {? ~exec('id','tran_exp') || _return:=0 ?}
   ?}
?};

VAR_DEL.delete('__TABVLB');
_return


\skid_wal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Formuła kontrolna dla elementów wspólnych.
::   WE: _a [INTEGER] - Czy mechanizm wywołany podczas transferu? [0/1]
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_trn:=_a;
_cnt:=0;

_zws:=KOMM.sect_beg('Elementy wspólne');
_cnt+=exec('firma_chk','tran_vlb');
KOMM.sect_end();

{? _cnt=0
|| KOMM.del(_zws)
?};
~~


\firma_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Sprawdza dane w tabeli FIRMA.
::   WE:
::   WY: liczba znalezionych błędów.
::----------------------------------------------------------------------------------------------------------------------
_cnt:=0;

_err:="
   _err:=0;
   _nfo:='w wierszu %1.'[$#FIRMA.ref()];
   {? FIRMA.SYMBOL=''
   || KOMM.add('Brak symbolu %1'[_nfo]);
      _err+=1
   ?};
   {? FIRMA.Z<>'T' & FIRMA.Z<>'N'
   || KOMM.add('Błędna wartość znacznika \"Zewnętrzna\" %1'[_nfo]);
      _err+=1
   ?};
   _err
";

KOMM.sect_beg('Dane firm');
FIRMA.cntx_psh();
FIRMA.index('SYMBOL');
FIRMA.prefix();
_loop:=FIRMA.first();
{!
|? _loop
|! _cnt+=_err();
   _loop:=FIRMA.next()
!};
FIRMA.cntx_pop();
KOMM.sect_end();

_cnt


\estra_wal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [18.42]
:: OPIS: Formuła kontrolna dla środków trwałych przed rozpoczęciem eksportu
::----------------------------------------------------------------------------------------------------------------------
_return:=1;
_sect:=0;

:: kontrola poprawności identyfikatorów środków (ID) w Xpertis Środki trwałe
{? exec('test_id','tran_exp')
|| _txt:='Wykryto niespójne dane w tabeli SROD i ID_SROD. Przed eksportem zostanie uruchomiona procedura naprawcza.';
   {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
   KOMM.add(_txt,,'0:128:0');

::Kontrola, czy do środek trwałego jest przypisany dokładnie jeden identyfikator w różnych maskach
   _srod:=sql('select ODD, NRI, ID from @SROD');
   _t_size:=0; _sect1:=0;
   {? _srod.size()>0
   || _i_srod:=_srod.ndx_tmp('',1,'ODD',,0, 'ODD',,0,'NRI',,0, 'NRI',,0, 'ID',,0);
      _srod.index(_i_srod);
      _srod.prefix();
      {? _srod.first()
      || {!
         |? _srod.prefix(_srod.ODD,_srod.ODD,_srod.NRI,_srod.NRI,_srod.ID);
            _t_size:=_srod.size();
            _srod.prefix(_srod.ODD,_srod.ODD,_srod.NRI,_srod.NRI,);
            {? _t_size<>_srod.size()
            || {? ~_sect1
               || _txt:='Występują środki trwałe, które mają więcej niż jeden identyfikator (SROD.ID). ';
                  _txt+='Należy poprawić dane ręcznie lub skorzystać z procedury naprawczej.';
                  {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
                  KOMM.add(_txt);
                  KOMM.sect_beg('Środki trwałe z wieloma ID. Numery inwentarzowe środków:');
                  _sect1:=1
               ?};
               KOMM.add('%1'[_srod.NRI])
            ?};
            {! |? _srod.del() !};
            _srod.prefix();
            _srod.first()
         !}
      ?};
      _srod.ndx_drop(_i_srod)
   ?};
   {? _sect1 || KOMM.sect_end() ?};

   __TABVLB.id_srod:=1
?};

:: kontrola zamknięcia okresów Estry
exec('czytaj','stalesys',,KONST);
VAR.AR:=(date()~1); VAR.AM:=(date()~2);
_open:=0;
_nzlata:=tab_tmp(1,'ROK','INTEGER','Rok');
_nzlata.prefix();
OKR_ES.index('OKRESYRM');
OKR_ES.prefix();
{? OKR_ES.find_key(VAR.AR,VAR.AM) & OKR_ES.prev()
|| {! |?
      {? OKR_ES.AMOR='N' || _open+=1; _nzlata.ROK:=OKR_ES.AR; _nzlata.add() ?};
      OKR_ES.prev()
   !}
?};
{? ~OKR_ES.find_key(VAR.AR,VAR.AM)
|| {? OKR_ES.last()
   || {! |?
         {? OKR_ES.AMOR='N' || _open+=1; _nzlata.ROK:=OKR_ES.AR; _nzlata.add() ?};
         OKR_ES.prev()
      !}
   ?}
?};
VAR.AR:=KONST.AR; VAR.AM:=KONST.AM;
{? _open>0
|| _nzsql:=sql('select distinct ROK from :_a',_nzlata);
   _nzsql.prefix(); _nzsql.first();
   _txt:='Znaleziono otwarte okresy systemu Środki trwałe sprzed bieżącego miesiąca. '
        +'Należy je zamknąć. Dane z zamk. okresów nie będą mogły być modyf. w Merit.';
   {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
   KOMM.add(_txt);
   KOMM.sect_beg('Lata, dla których istnieją otwarte okresy dla Środków trwałych (poprzedzające bieżący okres):');
   {! |?
      KOMM.add($_nzsql.ROK);
      _nzsql.next()
   !};
   KOMM.sect_end()
?};

:: kontrola środków wykorzystujących metody amortyzacji nieobsługiwane w Merit
_sql:='SELECT DISTINCT NRI FROM @SROD JOIN @MA USING (SROD.MF, MA.REFERENCE) WHERE MA.T=\'P\' OR MA.T=\'S\'';
_tmp:=sql(_sql);
{? _tmp.first()
|| _txt:='Metody amortyzacji finansowej: Progresywna i SOYD nie są obsługiwane w systemie Merit. ';
   _txt+='Należy zweryfikować metodę amortyzacji.';
   {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
   KOMM.add(_txt);
   KOMM.sect_beg('NRI środków z nieobsługiwaną metodą amortyzacji finansowej:');
   {! |?
      KOMM.add(_tmp.NRI);
      _tmp.next()
   !};
   KOMM.sect_end()
?};

:: kontrola czy Estra nie została wdrożona z przesunięciem okresów w stosunku do roku kalendarzowego
{? exec('jest','stalesys',KONST) & KONST.MP<>0
|| _txt:='Mechanizm transferu nie obsługuje systemów z przesunięciem okresów w stosunku do okresów kalendarzowych.';
   {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
   KOMM.add(_txt)
?};

:: kontrola czy w danych są elementy nie przenoszone przez transfer, które zostaną utracone
:: np. środki w budowie, załączniki
INW_SROD.prefix();
{? INW_SROD.first()
|| _txt:='W systemie znajdują się dane środków trwałych w budowie. Informacje o środkach w budowie nie są przenoszone'
        +' do systemu Merit.';
   {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
   KOMM.add(_txt)
?};

FOTO.prefix();
{? FOTO.first()
|| _txt:='W systemie znajdują się załączniki podpięte pod środki trwałe np. fotografie. Załączniki nie są przenoszone'
        +' do systemu Merit.';
   {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
   KOMM.add(_txt)
?};

:: kontrola czy najwcześniejsze okresy Estry nie są wcześniejsze niż pierwsze okresy obrachunkowe Fiksa
OKR_ES.index('OKRESYRM');
OKR_ES.prefix();
{? OKR_ES.first()
|| {? exec('jest','stalesys',KONST)
   || _rok:=OKR_ES.AR;
      _mies:=OKR_ES.AM+KONST.MP;
      {? _mies<=0
      || _rok-=1;
         _mies+=12
      |? _mies>12
      || _rok+=1;
         _mies-=12
      ?};

      OKRO_F.cntx_psh();
      OKRO_F.index('FIRMA_NR');
      OKRO_F.prefix(REF.FIRMA);
      {? OKRO_F.first() || _fiks:=1 || _fiks:=0 ?};
      OKRO_F.cntx_pop();

      {? _fiks & exec('okresrok','tech_es',date(_rok,_mies,1),1)=null
      || _txt:='W analizowanym systemie Xpertis moduł Środki trwałe został wdrożony wcześniej niż moduł Finanse '
              +'i księgowość (firma:'+REF.FIRMA().SYMBOL+') . Taka sytuacja wymusza przeniesienie danych środków '
              +'trwałych wg stanu z pierwszego roku ewidencji w systemie Finanse i księgowość.';
         {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
         KOMM.add(_txt)
      ?}
   ?}
?};

:: kontrola poprawności zestawów kont kosztowych
ZSKON.cntx_psh(); KKOSZ.cntx_psh();
ZSKON.index('KOD'); KKOSZ.index('KONTO');
ZSKON.prefix();
{? ZSKON.first()
|| {! |?
      KKOSZ.prefix(ZSKON.ref());
      {? ~KKOSZ.first()
      || {? ZSKON.RODZ='P' || _rodzaj:='podatkowy' |? ZSKON.RODZ='F' || _rodzaj:='finansowy' ?};
         _txt:='Niepoprawny '+_rodzaj+' zestaw kont kosztowych: '+ZSKON.KOD+' - brak podpiętych kont. '
              +'Należy uzupełnić dane.';
         {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
         KOMM.add(_txt)
      ?};
      ZSKON.next()
   !}
?};
ZSKON.cntx_pop(); KKOSZ.cntx_pop();

:: kontrola uzupełnienia pola BIL (wskazanie na pozycję bil.) w tabeli TAM (grupy środków trwałych)
TAM.cntx_psh(); TAB.cntx_psh();
_sect2:=0;
TAM.index('KST'); TAM.prefix();
{? TAM.first()
|| {! |?
      {? TAM.BIL=null
      || {? ~_sect2
         || _txt:='W systemie istnieją grupy środków trwałych (TAM) bez uzupełnionych wskazań na pozycje bilansowe. ';
            _txt+='Dane należy uzupełnić ręcznie.';
            {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
            KOMM.add(_txt);
            KOMM.sect_beg('Grupy środków trwałych bez uzupełnionych wskazań na pozycje bilansowe:');
            _sect2:=1
         ?};
         KOMM.add('%1'[TAM.GR])
      ?};
      TAM.next()
   !};
   {? _sect2 || KOMM.sect_end() ?}
?};
TAM.cntx_pop(); TAB.cntx_pop();

::kontrola, czy dokument skreślający zlikwidował środek całkowice
_dokusql:='select DOKU.REFERENCE as REF, DOKU.ST, SROD.NRI, SROD.NST, ODD.OD, DOKU.MO, DOKU.DW '+
          'from @DOKU '+
          'join @SROD using (DOKU.ST, SROD.REFERENCE) '+
          'join @ODD using (ODD.REFERENCE, SROD.ODD) '+
          'where DOKU.W=\'T\' and DOKU.ST not like \'srodplan%\'';
VAR.cntx_psh();
VAR_DEL.delete('__OKRES');
exec('map_okr_es','tran_exp');
__var_ko:=exec('get_par','skid_akt',80);
_dokutmp:=sql(_dokusql);
KONST.cntx_psh();
_tabreftmp:=tab_tmp(,'REF','STRING[16]','REF',
                     'NRI','STRING[15]','NRI',
                     'MO','INTEGER','MO',
                     'OD','STRING[8]','OD');
{? _dokutmp.first()
|| {! |?
      SROD.cntx_psh(); DOKU.cntx_psh(); AMOR.cntx_psh(); ZMIA.cntx_psh(); ADOK.cntx_psh();
      _rokm:=ref_name(_dokutmp.ST)+4;
      KONST.AR:=#_rokm;
      KONST.AM:=_dokutmp.MO;
      exec('varinit','tran_exp');
      exec('ini_kst','varinit');
      SROD.use('srod'+_rokm); DOKU.use('dokw'+_rokm); AMOR.use('amor'+_rokm); ZMIA.use('zmia'+_rokm);
      ADOK.use('adok'+_rokm);
      SROD.prefix(); DOKU.prefix(); AMOR.prefix(); ZMIA.prefix(); ADOK.prefix();
      {? SROD.seek(_dokutmp.ST)
      || exec('narastaj','tran_exp');
         {? VAR.NETF<>0 | VAR.NETP<>0 | VAR.UMOF<>0 | VAR.UMOP<>0
         || _tabreftmp.blank();
            _tabreftmp.REF:=_dokutmp.REF;
            _tabreftmp.NRI:=_dokutmp.NRI;
            _tabreftmp.MO:=_dokutmp.MO;
            _tabreftmp.OD:=_dokutmp.OD;
            _tabreftmp.add()
         ?}
      ?};
      SROD.cntx_pop(); DOKU.cntx_pop(); AMOR.cntx_pop(); ZMIA.cntx_pop(); ADOK.cntx_pop();

      _dokutmp.next()
   !}
?};
KONST.cntx_pop();
VAR.cntx_pop();
_sect2:=0;
{? _tabreftmp.first()
|| {! |?
      {? ~_sect2
      || _txt:='W systemie istnieją środki z nieprawidłowymi wartościami netto i/lub umorzenia w okresie skreślenia. ';
         _txt+='Dane należy poprawić ręcznie przed transferem';
         {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
         KOMM.add(_txt);
         KOMM.sect_beg('Środki z błędnymi wartościami po skreśleniu:');
         _sect2:=1
      ?};
      KOMM.add('Nr inw. %1, rok %2, okres %3, jednostka księgowa %4'[_tabreftmp.NRI,(8+_tabreftmp.REF)+4,$_tabreftmp.MO,
                                                                     _tabreftmp.OD]);
      _tabreftmp.next()
   !};
   {? _sect2 || KOMM.sect_end() ?}
?};
VAR_DEL.delete('__OKRES');

:: kontrola poprawności dokumentów zmiany miejsca
ZMIA.cntx_psh();
_znames:=ZMIA.names();
_txt:='';
{? _znames.first()
|| {! |?
      ZMIA.use(_znames.NAME);
      ZMIA.prefix();
      {? ZMIA.first()
      || {! |?
            {? ZMIA.KONPOD=null | ZMIA.KONFIN=null
            || _txt:='Niepoprawne dokumenty zmiany miejsca użytkowania, puste pola dotyczące kont. ';
               _txt+='Należy poprawić dane ('+ZMIA.SD+').';
               {? ~_sect || KOMM.sect_beg('Środki trwałe'); _sect:=1 ?};
               KOMM.add(_txt)
            ?};
            _txt='' & ZMIA.next()
         !}
      ?};
      _txt='' & _znames.next()
   !}
?};
ZMIA.cntx_pop();

{? _sect || KOMM.sect_end() ?}


\emag_wal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [18.42]
:: OPIS: Formuła kontrolna dla Logistyki przed rozpoczęciem eksportu
::----------------------------------------------------------------------------------------------------------------------
_return:=1;
_sect:=0;

:: kontrola czy dana grupa numeracji nie została wykorzystana dla kilku systemów
NRDOK.cntx_psh();
NRDOK.index('NRDOK_AB');
NRDOK.prefix('FAKS',);
{? NRDOK.first()
|| {!
   |? _nrsys:='000000';
      {! _i:=1..6 |! {? ($('NRDOK.P'+form(_i)))()='SYS' || _nrsys:=((_i-1)+_nrsys)+'1'+(_i-_nrsys) ?} !};
      {! |? (_wsk:=_nrsys*'1'; _wsk)
      |! _ok:=1;
         NR.use('numer'+(-NRDOK.TYP));
::       Walidacja kilku systemów
         _buf:=sql('select distinct NR.P'+form(_wsk)+' from NR');
         _any:=_buf.size()>1;
         obj_del(_buf);
         {? _any
         || {? ~_sect || KOMM.sect_beg('Logistyka'); _sect:=1 ?};
            _txt:='Grupa numeracji '+NRDOK.TYP+' została użyta w kilku systemach. '+
                  'Podczas transferu nie zostanie usunięte z jej definicji pole SYS. '+
                  'Należy to zmienić ręcznie.';
            KOMM.add(_txt)
         ?};
         _nrsys:=_wsk-_nrsys
      !};
      NRDOK.next()
   !}
?};
NRDOK.cntx_pop();
:: kontrola dokładności w kartotece materiałowej
_tab:=sql('select max(DOKL), max(DOKL_C) from M');
{? _tab[1]>10
|| {? ~_sect || KOMM.sect_beg('Logistyka'); _sect:=1 ?};
   _txt:='Uwaga. W kartotece materiałowej maksymalna dokładność ilości została ustawiona na '+$_tab[1]+'.';
   KOMM.add(_txt);
   _txt:='* W okienkach przeglądu pole ilość będzie miało zawsze maksymalną wartość dokładności (np. pozycje dokumentów, zamówień).';
   KOMM.add(_txt);
   _txt:='* W systemie Merit maksymalna dokładność może być większa lub równa 10. Należy to zmienić ręcznie.';
   KOMM.add(_txt)
?};
{? _tab[2]>10
|| {? ~_sect || KOMM.sect_beg('Logistyka'); _sect:=1 ?};
   _txt:='Uwaga. W kartotece materiałowej maksymalna dokładność ceny magazynowej została ustawiona na '+$_tab[2]+'.';
   KOMM.add(_txt);
   _txt:='* W okienkach przeglądu pole cena magazynowa będzie miało zawsze maksymalną wartość dokładności (np. pozycje dokumentów, zamówień).';
   KOMM.add(_txt);
   _txt:='* W systemie Merit maksymalna dokładność może być większa lub równa 10. Należy to zmienić ręcznie.';
   KOMM.add(_txt)
?};
obj_del(_tab);
{? _sect || KOMM.sect_end() ?};
_return


\test_rodzo_kod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [18.42]
:: OPIS: Test czy trzeba naprawić RODZO.KOD - czy nie ma kodów o takich samych pierwszych ośmiu znakach.
::   WY: 1 - jeżeli brak rodzajów wyposażenia, lub ich kody są rozróżnialne na 8 znakach
::       0 - jeżeli kody rodzajów wyposażenia nie są rozróżnialne na 8 znakach
::----------------------------------------------------------------------------------------------------------------------
_tabkod:=tab_tmp(3,
   'NOWY_KOD','STRING[8]','Skrócony kod',
   'BLAD','INTEGER','Błąd',
   'KOD','STRING[20]','Kod'
);
_ndx:=_tabkod.ndx_tmp('',1,'NOWY_KOD',,0, 'BLAD',,0);
_tabkod.index(_ndx);
RODZO.cntx_psh();
RODZO.index('KOD');
RODZO.prefix();
{? RODZO.first()
|| {!
   |? _blad:=0;
      _tabkod.prefix(8+RODZO.KOD);
:: Skoro tabela jest posortowana po polu BLAD rosnąco,
:: to można uznać, że dla każdego kodu jest maksymalnie jeden rekord z BLAD=0
      {? _tabkod.first()
      || {? _tabkod.BLAD=0
         || _tabkod.BLAD:=1;
            _tabkod.put()
         ?};
:: dodanie nowego zapisu oznaczonego jako błąd
         _tabkod.KOD:=RODZO.KOD;
         _tabkod.NOWY_KOD:=8+RODZO.KOD;
         _tabkod.BLAD:=1;
         _tabkod.add()
      || _tabkod.KOD:=RODZO.KOD;
         _tabkod.NOWY_KOD:=8+RODZO.KOD;
         _tabkod.BLAD:=0;
         _tabkod.add()
      ?};
      RODZO.next()
   !}
?};
RODZO.cntx_pop();
_tabkod.ndx_drop(_ndx);
_tabkod


\test_rodzo_mgr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [18.42]
:: OPIS: Test, czy nie istnieją materiały przypisane do takiego samego rodzaju wyposażenia,
::       ale róznych grup materiałowych
::   WY: Tabela tymczasowa z błędnymi rekordami
::----------------------------------------------------------------------------------------------------------------------
_pierwsza:=1;
_tabmgr:=tab_tmp(3,
   'KTM','STRING[50]','Indeks materiałowy',
   'RODZO','STRING[20]','Rodzaj wyposażenia',
   'MGR','STRING[8]','Grupa materiałowa'
);
RODZO.cntx_psh();
RODZO.index('KOD');
RODZO.prefix();
{? RODZO.first()
|| M.cntx_psh();
   _ndx:=M.ndx_tmp('',1,'RODZO',,0, 'MGR',,0);
   M.index(_ndx);
   {!
   |? M.prefix(RODZO.ref());
      _tab:=sql('select distinct M.MGR from M join RODZO where RODZO.REFERENCE=:_a',RODZO.ref());
      {? M.first() & _tab.size()>1
      || _mgr:='';
         _pierwsza:=1;
         {!
         |? {? M.MGR<>null()
            || {? _mgr=''
               || _mgr:=M.MGR().KOD;
                  _ktm:=M.KTM
               || {? _pierwsza
                  || _tabmgr.KTM:=_ktm;
                     _tabmgr.RODZO:=RODZO.KOD;
                     _tabmgr.MGR:=_mgr;
                     _tabmgr.add();
                     _pierwsza:=0
                  ?};
                  _tabmgr.KTM:=M.KTM;
                  _tabmgr.RODZO:=RODZO.KOD;
                  _tabmgr.MGR:=M.MGR().KOD;
                  _tabmgr.add()
               ?}
            ?};
            M.next()
         !}
      ?};
      obj_del(_tab);
      RODZO.next()
   !};
   M.cntx_pop();
   M.ndx_drop(_ndx)
?};
RODZO.cntx_pop();
_tabmgr


\test_rodzo_mgrp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [18.42]
:: OPIS: Test, czy nie istnieją materiały przypisane do takiego samego rodzaju wyposażenia,
::       ale róznych podgrup materiałowych
::   WY: Tabela tymczasowa z błędnymi rekordami
::----------------------------------------------------------------------------------------------------------------------
_pierwsza:=1;
_tabmgrp:=tab_tmp(3,
   'KTM','STRING[50]','Indeks materiałowy',
   'RODZO','STRING[20]','Rodzaj wyposażenia',
   'MGRP','STRING[8]','Grupa materiałowa'
);
RODZO.cntx_psh();
RODZO.index('KOD');
RODZO.prefix();
{? RODZO.first()
|| M.cntx_psh();
   _ndx:=M.ndx_tmp('',1,'RODZO',,0, 'MGRP',,0);
   M.index(_ndx);
   {!
   |? M.prefix(RODZO.ref());
:
      _tab:=sql('select distinct M.MGRP from M join RODZO where RODZO.REFERENCE=:_a',RODZO.ref());
      {? M.first() & _tab.first()
      || _mgrp:='';
         _pierwsza:=1;
         {!
         |? {? M.MGRP<>null()
            || {? _mgrp=''
               || _mgrp:=M.MGRP().KOD;
                  _ktm:=M.KTM
               || {? _pierwsza
                  || _tabmgrp.KTM:=_ktm;
                     _tabmgrp.RODZO:=RODZO.KOD;
                     _tabmgrp.MGRP:=_mgrp;
                     _tabmgrp.add();
                     _pierwsza:=0
                  ?};
                  _tabmgrp.KTM:=M.KTM;
                  _tabmgrp.RODZO:=RODZO.KOD;
                  _tabmgrp.MGRP:=M.MGRP().KOD;
                  _tabmgrp.add()
               ?}
            ?};
            M.next()
         !}
      ?};
      obj_del(_tab);
      RODZO.next()
   !};
   M.cntx_pop();
   M.ndx_drop(_ndx)
?};
RODZO.cntx_pop();
_tabmgrp


\test_mgrp_rodzo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [18.42]
:: OPIS: Test, czy nie istnieją materiały przypisane do tej samej podgrupy, aleróżnych rodzajów wyposażenia,
::   WY: Tabela tymczasowa z błędnymi rekordami
::----------------------------------------------------------------------------------------------------------------------
_pierwsza:=1;
_tabrodz:=tab_tmp(3,
   'KTM','STRING[50]','Indeks materiałowy',
   'MGRP','STRING[8]','Grupa materiałowa',
   'RODZO','STRING[20]','Rodzaj wyposażenia'
);
MGRP.cntx_psh();
MGRP.index('KOD');
MGRP.prefix();
{? MGRP.first()
|| M.cntx_psh();
   _ndx:=M.ndx_tmp('',1, 'MGRP',,0,'RODZO',,0);
   M.index(_ndx);
   {!
   |? M.prefix(MGRP.ref());
      _tab:=sql('select distinct M.RODZO from M join MGRP where MGRP.REFERENCE=:_a',MGRP.ref());
      {? M.first()
      || _rodzo:='';
         _pierwsza:=1;
         {!
         |? {? M.RODZO<>null()
            || {? _rodzo=''
               || _rodzo:=M.RODZO().KOD;
                  _ktm:=M.KTM
               || {? _pierwsza
                  || _tabrodz.KTM:=_ktm;
                     _tabrodz.MGRP:=MGRP.KOD;
                     _tabrodz.RODZO:=_rodzo;
                     _tabrodz.add();
                     _pierwsza:=0
                  ?};
                  _tabrodz.KTM:=M.KTM;
                  _tabrodz.MGRP:=MGRP.KOD;
                  _tabrodz.RODZO:=M.RODZO().KOD;
                  _tabrodz.add()
               ?}
            ?};
            M.next()
         !}
      ?};
      obj_del(_tab);
      MGRP.next()
   !};
   M.cntx_pop();
   M.ndx_drop(_ndx)
?};
MGRP.cntx_pop();
_tabrodz


\wyp_wal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [18.42]
:: OPIS: Formuła kontrolna dla wyposażenia przed rozpoczęciem eksportu
::----------------------------------------------------------------------------------------------------------------------
_return:=1;
_sect:=0;
_pierwszy_blad:=1;

:: kontrola, czy kody wyposażenia są rozróżnialne na 8 pierwszych znakach
_tabkod:=exec('test_rodzo_kod','tran_vlb');
{? _tabkod.first
|| _ndx:=_tabkod.ndx_tmp('',1,'BLAD',,0,'NOWY_KOD',,0);
   _tabkod.index(_ndx);
   _tabkod.prefix(1);
   _kod:='';
   {? _tabkod.first()
   || {? ~_sect || KOMM.sect_beg('Ewidencja wyposażenia'); _sect:=1 ?};
      KOMM.sect_beg('Weryfikacja kodów rodzajów wyposażenia.');
      {!
      |? {? _kod<>_tabkod.NOWY_KOD
         || {? _kod<>''
            || _txt+='.';
               KOMM.add(_txt)
            ?};
            _kod:=_tabkod.NOWY_KOD;
            _txt:='Rodzaj wyposażenia: ' + _tabkod.KOD + ' ma kod o takich samych ośmiu pierwszych znakach jak: ';
            _pierwszy_blad:=1
         || {? _pierwszy_blad
            || _txt+=_tabkod.KOD;
               _pierwszy_blad:=0
            || _txt+=', ' +_tabkod.KOD
            ?}
         ?};
         _tabkod.next()
      !};
      {? _kod<>''
      || _txt+='.';
         KOMM.add(_txt)
      ?};
      KOMM.add('Należy poprawić ręcznie te kody.');
      KOMM.sect_end()

   ?};
   _tabkod.ndx_drop(_ndx)
?};

:: Czy wszystkie materiały danego rodzaju mają tą samą grupę
_tabmgr:=exec('test_rodzo_mgr','tran_vlb');
{? _tabmgr.first
|| {? ~_sect || KOMM.sect_beg('Ewidencja wyposażenia'); _sect:=1 ?};
   KOMM.sect_beg('Weryfikacja, czy materiały danego rodzaju mają te same grupy.');
   _ndx:=_tabmgr.ndx_tmp('',1,'RODZO',,0,'MGR',,0);
   _tabmgr.index(_ndx);
   _tabmgr.first();
   _rodzo:='';
   _mgr:='';
   _ktm:='';
   {!
   |? {? _rodzo<>_tabmgr.RODZO
      || {? _rodzo<>''
         || KOMM.sect_end()
         ?};
         _mgr:=_tabmgr.MGR;
         _rodzo:=_tabmgr.RODZO;
         _ktm:=_tabmgr.KTM;
         _pierwszy_blad:=1
      || {? _pierwszy_blad
         || _txt:='Do rodzaju wyposażenia: ' + _tabmgr.RODZO
             + ' przypisane są materiały mające różne grupy materiałowe. ';
            KOMM.sect_beg(_txt);
            _txt:='Materiał: ' + _ktm;
            {? _mgr=''
            || _txt+=' nie jest przypisany do żadnej grupy.'
            || _txt+=' jest przypisany do grupy: ' + _mgr + '.'
            ?};
            KOMM.add(_txt);
            _pierwszy_blad:=0
         ?};
         _txt:='Materiał: ' + _tabmgr.KTM;
         {? _tabmgr.MGR=''
         || _txt+=' nie jest przypisany do żadnej grupy.'
         || _txt+=' jest przypisany do grupy: ' + _tabmgr.MGR + '.'
         ?};
         KOMM.add(_txt)
      ?};
      _tabmgr.next()
   !};
   {? _mgr<>''
   || KOMM.sect_end()
   ?};
   KOMM.add('Zalecane jest poprawienie ręczne tych przypisań, albo uzupełnienie ich po transferze.');
   _tabmgr.ndx_drop(_ndx);
   KOMM.sect_end()
?};
:: Czy wszystkie materiały danego rodzaju mają tą samą podgrupę
_tabmgrp:=exec('test_rodzo_mgrp','tran_vlb');
{? _tabmgrp.first
|| {? ~_sect || KOMM.sect_beg('Ewidencja wyposażenia'); _sect:=1 ?};
   KOMM.sect_beg('Weryfikacja, czy materiały danego rodzaju mają te same podgrupy.');
   _ndx:=_tabmgrp.ndx_tmp('',1,'RODZO',,0,'MGRP',,0);
   _tabmgrp.index(_ndx);
   _tabmgrp.first();
   _rodzo:='';
   _mgrp:='';
   _ktm:='';
   {!
   |? {? _rodzo<>_tabmgrp.RODZO
      || {? _rodzo<>''
         || KOMM.sect_end()
         ?};
         _mgrp:=_tabmgrp.MGRP;
         _rodzo:=_tabmgrp.RODZO;
         _ktm:=_tabmgrp.KTM;
         _pierwszy_blad:=1
      || {? _pierwszy_blad
         || _txt:='Do rodzaju wyposażenia: ' + _tabmgrp.RODZO
             + ' przypisane są materiały mające różne podgrupy materiałowe. ';
            KOMM.sect_beg(_txt);
            _txt:='Materiał: ' + _ktm;
            {? _mgrp=''
            || _txt+=' nie jest przypisany do żadnej podgrupy.'
            || _txt+=' jest przypisany do podgrupy: ' + _mgrp + '.'
            ?};
            KOMM.add(_txt);
            _pierwszy_blad:=0
         ?};
         _txt:='Materiał: ' + _tabmgrp.KTM;
         {? _tabmgrp.MGRP=''
         || _txt+=' nie jest przypisany do żadnej podgrupy.'
         || _txt+=' jest przypisany do podgrupy: ' + _tabmgrp.MGRP + '.'
         ?};
         KOMM.add(_txt)
      ?};
      _tabmgrp.next()
   !};
   {? _mgrp<>''
   || KOMM.sect_end()
   ?};
   KOMM.add('Zalecane jest poprawienie ręczne tych przypisań, albo uzupełnienie ich po transferze.');
   _tabmgrp.ndx_drop(_ndx);
   KOMM.sect_end()
?};

:: Czy wszystkie materiały danej podgrupy mają ten sam rodzaj
_tabrodz:=exec('test_mgrp_rodzo','tran_vlb');
{? _tabrodz.first
|| {? ~_sect || KOMM.sect_beg('Ewidencja wyposażenia'); _sect:=1 ?};
   KOMM.sect_beg('Weryfikacja, czy materiały danej podgrupy nie są przypisane do różnych rodzajów wyposażenia');
   _ndx:=_tabrodz.ndx_tmp('',1,'MGRP',,0,'RODZO',,0);
   _tabrodz.index(_ndx);
   _tabrodz.first();
   _mgrp:='';
   _rodzo:='';
   _ktm:='';
   {!
   |? {? _mgrp<>_tabrodz.MGRP
      || {? _mgrp<>''
         || KOMM.sect_end()
         ?};
         _mgrp:=_tabrodz.MGRP;
         _rodzo:=_tabrodz.RODZO;
         _ktm:=_tabrodz.KTM;
         _pierwszy_blad:=1
      || {? _pierwszy_blad
         || _txt:='Do podgrupy materiałowej: ' + _tabrodz.MGRP
             + ' przypisane są materiały mające różne rodzaje wyposażenia. ';
            KOMM.sect_beg(_txt);
            _txt:='Materiał: ' + _ktm;
            {? _rodzo=''
            || _txt+=' nie jest przypisany do żadnego rodzaju.'
            || _txt+=' jest przypisany do rodzaju: ' + _rodzo + '.'
            ?};
            KOMM.add(_txt);
            _pierwszy_blad:=0
         ?};
         _txt:='Materiał: ' + _tabrodz.KTM;
         {? _tabrodz.RODZO=''
         || _txt+=' nie jest przypisany do żadnego rodzaju.'
         || _txt+=' jest przypisany do rodzaju: ' + _tabrodz.RODZO + '.'
         ?};
         KOMM.add(_txt)
      ?};
      _tabrodz.next()
   !};
   {? _mgrp<>''
   || KOMM.sect_end()
   ?};
   KOMM.add('Zalecane jest poprawienie ręczne tych przypisań, albo uzupełnienie ich po transferze.');
   _tabrodz.ndx_drop(_ndx);
   KOMM.sect_end()
?};
{? _sect || KOMM.sect_end() ?};
_return


\kali_wal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.42]
:: OPIS: Formuła sprawdzająca poprawność danych dla Kalego.
::   WE: _a [INTEGER] - Czy mechanizm wywołany podczas transferu? [0/1]
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_czyKALI:=(exec('get_par','skid_akt',7)='T');
{? ~_czyKALI
|| return(~~)
?};

_transfer:=_a;

_poz:=0;

:: Zmiana numerów wybranych rubryk (w związku ze zmianami opisanymi w nocie transferowej do wersji 12.41).
_renum:="
   {? R.find_key(_a) & R.RT=_b
   || R.RN:=_c;
      R.put()
   ?}
";
R.cntx_psh();
R.index('RUBKOD');
R.prefix();
_renum(74,'Zwoln. ze św. pracy',7030);
_renum(445,'Wyp. zwol. św. pracy',7031);
_renum(75,'Opieka-Art.188 dni',7032);
_renum(76,'Opieka-Art.188 godz',7033);
_renum(749,'Ryczałt samochodowy',7007);
R.cntx_pop();

:: Usunięcie "śmieci" z tabeli ZO_CEL.
:: Wiemy, ze takie rekordy (ZO_CEL.ZO_PROG=null()) istnieją, ale nie maja prawa być nigdzie wyświetlone.
:: Najprawdopodobniej powstały w wyniku błędów (na portalu?).
ZO_CEL.cntx_psh();
ZO_CEL.prefix();
ZO_CEL.for_each("{? ZO_CEL.ZO_PROG=null() || ZO_CEL.del() ?}");
ZO_CEL.cntx_pop();

:: Obługa ewentualnej sytuacji gdy jednak edp było wgrane, trzeba wyłączyć triggery dla ZALACZ
{? exec('is_edp','tran_vlb',1)
|| ZALACZ.trig_off('*','*')
?};

:: Obsługa śmieci w tabeli ZALACZ. Do rekordów bez załącznika przypinany jest pusty plik.
_fh:=fopen(null(),'bw',,,1);
{? _fh.is_open()
|| ZALACZ.cntx_psh();
   ZALACZ.prefix();
   {? ZALACZ.first()
   || {!
      |? {? ZALACZ.ZAL=null()
         || {? var_pres('WWWE',ZALACZ)=27
            || ZALACZ.WWWE:='T';
               ZALACZ.WWWS:='N';
               ZALACZ.put()
            ?};
            ZALACZ.bl_file('ZAL',1);
            ZALACZ.bl_put('ZAL',_fh,0,,'pusty.txt',1)
         ?};
         ZALACZ.next()
      !}
   ?};
   ZALACZ.cntx_pop();
   _fh.fclose()
?};

:: Obługa ewentualnej sytuacji gdy jednak edp było wgrane, trzeba ponownie włączyć triggery dla ZALACZ
{? exec('is_edp','tran_vlb',1)
|| ZALACZ.trig_on('*','*')
?};

obj_del(_fh);
&_fh;

:: Obsługa bałaganu w załącznikach KZP z poprawki ER/WRT/XP/12.51/1901/0057
:: exec('kali_76','napraw_p'); - ze względu na bałagan z obecnością lub nie aktualizacji eTeczka wyodrębione do
:: osobnej formuły
exec('zal_kzp','tran_vlb');

:: Czy jest ppk, dla kolejnych wywołań:
_j_a65:=exec('jest_a65','aktp1251');

:: Czy jest portal hr, dla kolejnych wywołań:
_j_por:=exec('is_por','aktp1251',1);

:: Przygotowuje listę rachunków, dla których są a nie powinny być naliczone wpłaty PPK.
{? _j_a65
|| exec('rubobj','rubobj');
   {? var_pres('RUB')<0
   || RUB:=obj_new(CLASS.RUB)
   ?};
   RUB.fill();
   exec('test_0006','napraw_p',0)
?};

:: ER/WRT/XP/12.51/1912/0024 Procentowe wysokości wpłat poza okresami obowiązywania umów
{? _j_a65
|| exec('ppk_03','tran_vlb')
?};

:: Lista osób, które miały policzony składnik Przychód - wpł. PPK na wypłacie zasiłku.
{? _j_a65
|| exec('ppk_prz_zas_rh','napraw_p',,0)
?};

_kali:=KOMM.sect_beg('Kadry i płace');
_poz+=exec('osoba_chk','tran_vlb');
_poz+=exec('osoba_obcy','tran_vlb');
_poz+=exec('pdz','tran_vlb');
_poz+=exec('r_rt_uniq','tran_vlb');
{? ~_transfer
|| _poz+=exec('zc_info','tran_vlb')
?};
_poz+=exec('par_pokr','tran_vlb');
{? ~_transfer
|| _poz+=exec('prem_okr','tran_vlb')
?};
_poz+=exec('kom_sp','tran_vlb');
_poz+=exec('szk_opis','tran_vlb');
_poz+=exec('list_kry','tran_vlb');
_poz+=exec('kal_chk','tran_vlb');
_poz+=exec('fm_nad','tran_vlb','177');
:: w 19.42 zdjęto unikalność z indeksu tabeli ADRES
::_poz+=exec('adres_uniq','tran_vlb');
_poz+=exec('rop_uniq','tran_vlb');
_poz+=exec('ru_std','tran_vlb');
{? _j_por
|| _poz+=exec('por_wn','tran_vlb')
?};

{? REF.WFIRM
|| _poz+=exec('czapa','tran_vlb')
?};
KOMM.sect_end();

{? ~_poz
|| KOMM.del(_kali)
?};
~~


\osoba_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.14]
:: OPIS: Funkcja sprawdzająca wypełnienie pól w wierszu tabeli zapewniających unikalność danych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=sql(
   'select OSOBA.OBCY, OSOBA.NAZWISKO, OSOBA.PIERWSZE, OSOBA.DRUGIE, OSOBA.PESEL, OSOBA.PASZPORT, OSOBA.DOWOD '+
   'from OSOBA '+
   'where (OSOBA.OBCY=\'N\' and OSOBA.PESEL=\'\') '+
          'or (OSOBA.OBCY=\'N\' and CHAR_LENGTH(TRIM(OSOBA.PESEL))<>11 and OSOBA.DOWOD=\'\' and OSOBA.PASZPORT=\'\') '+
          'or (OSOBA.OBCY=\'T\' and OSOBA.PASZPORT=\'\') '+
          'or OSOBA.NAZWISKO=\'\' '+
          'or OSOBA.PIERWSZE=\'\' '+
   'order by 1,2,3'
);


{? _TAB.first()
|| KOMM.sect_beg('Dane osobowe - brak wypełnienia pól wymagalnych');
   KOMM.sect_beg('Opis');
   KOMM.add('W tabeli OSOBA stwierdzono istnienie wierszy z niewypełnionymi wartościami');
   KOMM.add('wymaganymi do określenia unikalności danych.');
   KOMM.add('Przed wykonaniem transferu danych należy je poprawić.');
   KOMM.add('Uruchomienie nowej wersji z aktualnymi (niepoprawionymi) danymi NIE będzie możliwe.');
   KOMM.sect_end();
   KOMM.sect_beg('Lista osób');
   {!
   |? {? _TAB.OBCY='T'
      || KOMM.add(_TAB.NAZWISKO+' '+_TAB.PIERWSZE+' (paszport: '+_TAB.PASZPORT+')')
      || KOMM.add(_TAB.NAZWISKO+' '+_TAB.PIERWSZE+' (PESEL: '+_TAB.PESEL+' DOWOD: '+_TAB.DOWOD+' PASZPORT: '+_TAB.PASZPORT+')')
      ?};
      _TAB.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   1
?}


\osoba_obcy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Test unikalności obcokrajowców.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=sql(
   'select OSOBA.NAZWISKO, OSOBA.PIERWSZE, OSOBA.PASZPORT '+
   'from OSOBA '+
   'where OSOBA.OBCY=\'T\''+
   'group by OSOBA.NAZWISKO, OSOBA.PIERWSZE, OSOBA.PASZPORT '+
   'having count(*)>1'
);

{? _TAB.first()
|| KOMM.sect_beg('Dane osobowe - brak unikalności danych identyfikacyjnych obcokrajowców');
   KOMM.sect_beg('Opis');
   KOMM.add('Obecny model danych pozwala wprowadzić dwóch obcokrajowców');
   KOMM.add('o tych samych nazwiskach, imionach i numerach paszportów.');
   KOMM.add('Sytuacja taka jest niedopuszczalna w nowej wersji.');
   KOMM.add('Przed wykonaniem transferu danych należy poprawić dane.');
   KOMM.add('Uruchomienie nowej wersji z aktualnymi (niepoprawionymi) danymi NIE będzie możliwe.');
   KOMM.sect_end();
   KOMM.sect_beg('Lista osób');
   {!
   |? KOMM.add(_TAB.NAZWISKO+' '+_TAB.PIERWSZE+' (paszport: '+_TAB.PASZPORT+')');
      _TAB.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   1
?}


\pdz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.42]
:: OPIS: Test zgodności daty końca umowy (na podstawie \kali_29/napraw_p.fml).
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ile:=0;

_sect:=KOMM.sect_beg('Dane osobowe - data zwolnienia');
KOMM.sect_beg('Opis');
KOMM.add('Znaleziono rozbieżności między datą zwolnienia a datą zakończenia ostatniej umowy o pracę.');
KOMM.add('Dla pracowników wykazanych na liście poniżej należy ponownie wykonać procedurę zwolnienia pracownika.');
KOMM.sect_end();
KOMM.sect_beg('Lista pracowników');

H_UM.cntx_psh();
H_UM.index('OD');
OSOBA.cntx_psh();
OSOBA.prefix();
P.cntx_psh();
P.index('PRACOZAT');
P.prefix('P');
{? P.first()
|| {!
   |? H_UM.prefix(P.ref());
      {? H_UM.last() & H_UM.DO<>P.DZ
      || P.OSOBA();
         _ile+=1;
         {? OSOBA.OBCY='T'
         || KOMM.add(OSOBA.NAZWISKO+' '+OSOBA.PIERWSZE+' (paszport: '+OSOBA.PASZPORT+')')
         || KOMM.add(OSOBA.NAZWISKO+' '+OSOBA.PIERWSZE+' (PESEL: '+OSOBA.PESEL+')')
         ?}
      ?};
      P.next()
   !}
?};
P.cntx_pop();
OSOBA.cntx_pop();
H_UM.cntx_pop();

KOMM.sect_end();
KOMM.sect_end();

{? ~_ile
|| KOMM.del(_sect)
?};
_ile


\r_rt_uniq
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.42]
:: OPIS: Formuła wykrywająca ewentualne konflikty nazw składników płacowych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_root:=obj_new('lp','ile');
_root.lp:=KOMM.sect_beg('Rubryki płacowe - unikalność nazw');
_root.ile:=0;

_rub:=obj_new('X');
{! _lp:=1 .. obj_len(_rub)
|! _rub[_lp]:=obj_new('name','fn','lista','TAB','NDX')
!};

_rub.X.name:='Xpertis';
_rub.X.fn:='rubryki.dfg';

::_rub.M.name:='Merit';
::_rub.M.fn:='rubrykim.dfg';

:: Rubryki importowane jeszcze w Xpertisie (porównaj \napraw_p/tran_exp.fml)
_rub.X.lista:=
::    \kali_06
      '7007,'+
::    \kali_11
      '7008,7009,7010,'+
::    \kali_15
      '7020,7021,'+
::    \kali_22 \kali_41
      '7006,7011,'+
::    \kali_21
      '7025,'+
::    \kali_25
      '7015,7016,'+
::    \kali_27
      '7017,'+
::    \akt_24 - częściowo
      '7018,'+
::    \kali_34
      '7026,7027,'+
::    \kali_41
      '7028,7029,7035,7036,7037,7038,7040,7041,7050,7051,7052,7053,7054,7055,'+
      '120,121,123,'+
::    \kali_46
      '7056,7057,7058,7059,'+
::    \kali_48
      '7060,'+
::    \kali_51
      '465,529,'+
::    \kali_62
      '7068,'+
::    \kali_64
      '7034,7061,'+
::    \kali_70
      '7071,'+
::    \akt_32 \akt_35
      '7030,7031,7032,7033,'+
::    \kali_72
      '7079,'+
::    \akt_1251_26
      '7083,7084,7085,7086,7087,7088,7089,7090,7091,7092,7093,'+
::    \akt_1251_55
      '7094,7095,7096,7097,'+
::    \kali_80
      '7098,'+
::    \kali_81
      '7108,'+
::    \akt_1251_65
      '7109,'+
::    \akt_1251_67
      '7115,7116,7117,'+
::    \akt_1251_83
      '7118,7119,7120,7121,7122,7123,'+
::    \ppk_1251_108
      '7110,7111,7112,7113,7114,'+
::    \akt_1251_126
      '7125,7126,'+
::    \akt_1251_139
      '7140,7141,7142,7143,7144,7145,7146,7147,7148,'+
::    \akt_1251_149
      '7149,7170,7171,7172,'+
::    \akt_1251_150
      '7173,7174,7175,7176,7177,7178,7179,'+
::    \akt_1251_154
      '7074,7191,7192,7193,7194,7195,7196,7197,7198,7199,7200,'+
::    \ppk_08
      '7190,'+
::    \ppk_09
      '7201,7202,'+
::    \akt_1251_158
      '7182,7183,7184,'+
::    \kali_110
      '7210,'+
::    \kali_112
      '7217,'+
::    \kali_113
      '7211,7212,7213,7214,7218,7219,7220,7221,7222,7223,'+
::    \akt_1251_134
      '7132,7133,7134';

:: Rubryki importowane już w Mericie (porównaj \r_imp/transfer.fml)
::_rub.M.lista:=
::   '13,443,500,754,7018,'+
::  ORG: \rubryki_pop/upgrade_1728.fml - część wykonana w X\kali_51/napraw_p.fml
::   '7065,7066,7067,'+
::  ORG: \add_rub_graf/upgrade_1802.fml
::   '120,121,123,7028,7029,7037,7038,7015,7016,7011,7026,7027,7056,7057,7035,7036,7006,7050,7051,7040,7041,7052,'+
::   '7053,7058,7059,7054,7055,7056,7057,'+
::  ORG: \rubatr/upgrade_1822.fml - część wykonana w X\kali_64/napraw_p.fml
::   '499,7068,7069,'+
::  ORG: \stawkaDZ/upgrade_1822.fml
::   '7070';

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

{? {! _lp:=1 .. obj_len(_rub)
   |! {? ~fexists(_rub[_lp].fn,1)
      || _root.ile+=1;
         KOMM.add('Brak dostępu do pliku '+_rub[_lp].fn+' w katalogu '+pth_dir(_rub[_lp].fn)+'.')
      ?}
   !};
   _root.ile
|| ~~

::|? {! _lp:=1 .. obj_len(_rub)
::   |! {? ~KOMM.ask(
::            'Czy plik '+_rub[_lp].fn+' z katalogu '+pth_dir(_rub[_lp].fn)+
::            '\nzawiera aktualną definicję rubryk płacowych systemu '+_rub[_lp].name+'?',
::            1
::         )
::      || _root.ile+=1;
::         KOMM.add(
::            'Plik '+_rub[_lp].fn+' z katalogu '+pth_dir(_rub[_lp].fn)+
::            ' nie zawiera aktualnej definicji rubryk płacowych systemu '+_rub[_lp].name+'.'
::         )
::      ?}
::   !};
::   _root.ile
::|| ~~

|? {! _lp:=1 .. obj_len(_rub)
   |! _rub[_lp].TAB:=tab_tmp(1,'RN','INTEGER','Kod','RT','STRING[20]','Nazwa');
      _rub[_lp].NDX:=obj_new('RN','RT');
      _rub[_lp].NDX.RN:=_rub[_lp].TAB.index('?');
      _rub[_lp].NDX.RT:=_rub[_lp].TAB.ndx_tmp(,,'RT',,);
      {? ~_rub[_lp].TAB.import(_rub[_lp].fn,1,1,%1+';','UTF-8,pth,header',,
            'RN',,1,,
            'RT',,2,
         )
      || _root.ile+=1;
         KOMM.add('Import pliku '+_rub[_lp].fn+' z katalogu '+pth_dir(_rub[_lp].fn)+' nie zakończył sie sukcesem.')
      ?}
   !};
   _root.ile
|| ~~

|| _WYNIK:=tab_tmp(3,
      'RT','STRING['+$MS.fld_len(R,'RT')+']','Nazwa rubryki',
      'RNK','INTEGER','Kod w danych',
      'RNS','INTEGER','Kod standardowy'
   );
   {! _lp:=1 .. obj_len(_rub)
   |! _DUBEL:=sql(
         'select TMP.RN as RNS, TMP.RT, R.RN as RNK '+
         'from :_a as TMP join R using(TMP.RT,R.RT) '+
         'where TMP.RN in (:_b) and TMP.RN<>R.RN '+
         'order by 1',
         _rub[_lp].TAB,_rub[_lp].lista
      );
      {? _DUBEL.first()
      || {!
         |? {? ~_WYNIK.find_key(_DUBEL.RT,_DUBEL.RNK,_DUBEL.RNS)
            || _WYNIK.blank();
               _WYNIK.RT:=_DUBEL.RT;
               _WYNIK.RNK:=_DUBEL.RNK;
               _WYNIK.RNS:=_DUBEL.RNS;
               _WYNIK.add()
            ?};
            _DUBEL.next()
         !}
      ?};
      obj_del(_DUBEL)
   !};
   {? _WYNIK.first()
   || _root.ile+=1;
      KOMM.sect_beg('Opis');
      KOMM.add('Na etapie transferu danych utworzone zostaną nowe rubryki płacowe.');
      KOMM.add('Niestety, ich nazwy występują już w danych klienta, co uniemożliwi dodanie rubryk standardowych.');
      KOMM.add('Dla rubryk, wymienionych poniżej, wymagana jest zatem zmiana nazwy lub powrót do standardowego kodu.');
      KOMM.sect_end();
      KOMM.sect_beg('Lista rubryk');
      {!
      |? KOMM.add(_WYNIK.RT+' | Kod w danych: '+$_WYNIK.RNK+' | Kod standardowy: '+$_WYNIK.RNS);
         _WYNIK.next()
      !};
      KOMM.sect_end()
   ?}

?};

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

KOMM.sect_end();

{? _root.ile
|| 1
|| KOMM.del(_root.lp);
   0
?}


\zc_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.42]
:: OPIS: Test poprawności powiązań danych ubezpieczeniowych (na podstawie \kali_31/napraw_p.fml)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_root:=obj_new('lp','ile');
_root.lp:=KOMM.sect_beg('Rachunki umów cywilnoprawnych - nieprawidłowe powiazania danych ubezpieczeniowych');
_root.ile:=0;

KOMM.sect_beg('Opis');
KOMM.add('Dane ubezpieczeniowe do naliczania rachunku powinny być pobierane wg daty rachunku a nie daty wypłaty.');
KOMM.add('Wykaz rachunków, dla których ta zasada nie jest spełniona znajduje się w sekcji poniżej.');
KOMM.add('Niepoprawienie tych danych może doprowadzić do błędnego tworzenia raportów rozliczeniowych ZUS.');
KOMM.sect_end();

KOMM.sect_beg('Lista rachunków');

P.cntx_psh();
P.index('F_ZATR');
P.prefix('Z');
{? P.first()
|| OSOBA.cntx_psh();
   OSOBA.prefix();
   UD_SKL.cntx_psh();
   UD_SKL.prefix();
   ZC.cntx_psh();
   ZC.index('ZLECPRAC');
   RH.cntx_psh();
   RH.index('RACHUNKC');
   ZC_INFO.cntx_psh();
   ZC_INFO.index('ZC');
   {!
   |? P.OSOBA();
      ZC.prefix(P.ref());
      {? ZC.first()
      || {!
         |? ZC.WYDZIAL();
            RH.prefix(ZC.ref());
            {? RH.first()
            || {!
               |? _ref1:=RH.ZC_INFO;
                  _ref2:=null();
                  ZC_INFO.prefix(ZC.ref());
                  _ref2:={? ZC_INFO.find_le(RH.DRA) || ZC_INFO.ref() ?};
                  {?_ref1<>_ref2
                  || _root.ile+=1;
                     KOMM.add(
                        OSOBA.NAZWISKO+' '+OSOBA.PIERWSZE+'( Id.:'+$P.IP+') | '+
                        'Jedn. org.: '+UD_SKL.SYMBOL+' | '+
                        'Umowa: '+|ZC.NU+' ('+ZC.DZ$1+') | '+
                        'Data rachunku: '+RH.DRA$1+' | '+
                        'Data wypłaty: '+RH.DWY$1
                     )
                  ?};
                  RH.next()
               !}
            ?};
            ZC.next()
         !}
      ?};
      P.next()
   !};
   ZC_INFO.cntx_pop();
   RH.cntx_pop();
   ZC.cntx_pop();
   UD_SKL.cntx_pop();
   OSOBA.cntx_pop()
?};
P.cntx_pop();

KOMM.sect_end();

KOMM.sect_end();

{? _root.ile
|| 1
|| KOMM.del(_root.lp);
   0
?}


\par_pokr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Test poprawności parametryzacji składników okresowych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=sql(
   'select R.RN, R.RT '+
   'from PAR_POKR join R using(PAR_POKR.R,R.REFERENCE) '+
   'group by R.RN, R.RT '+
   'having count(*)>1 '+
   'order by R.RN'
);

{? _TAB.first()
|| KOMM.sect_beg('Składniki okresowe - brak jednoznaczności w parametryzacji');
   KOMM.sect_beg('Opis');
   KOMM.add('Obecna parametryzacja składników okresowych nie jest jednoznaczna i może prowadzić do błędów.');
   KOMM.add('Składnik płacowy może być wykorzystywany wyłącznie przez jeden składnik okresowy.');
   KOMM.add('Lista składników, które nie spełniają tego założenia znajduje sie poniżej.');
   KOMM.add('Przed wykonaniem transferu danych należy poprawić parametryzację.');
   KOMM.add('Naliczanie list płac w nowej wersji z aktualnymi (niepoprawionymi) danymi NIE będzie możliwe.');
   KOMM.sect_end();
   KOMM.sect_beg('Lista składników');
   {!
   |? KOMM.add(form(_TAB.RN,5,0,'9.')+' - '+form(_TAB.RT,20));
      _TAB.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   1
?}


\prem_okr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.42]
:: OPIS: Test poprawności dat składników okresowych (na podstawie \kali_50/napraw_p.fml)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Pozycja elementów jest znacząca.
_sect:=obj_new('g','dp','dz');
{! _lp:=1 .. obj_len(_sect)
|! _sect[_lp]:=obj_new('lp','ile');
   _sect[_lp].ile:=0
!};

_sect.g.lp:=KOMM.sect_beg('Składniki okresowe - błędy w datach');
_sect.dp.lp:=KOMM.sect_beg('Nieprawidłowa data początku okresu lub pokrywające się okresy');
KOMM.sect_end();
_sect.dz.lp:=KOMM.sect_beg('Data zakończenia różni się od zadeklarowanego okresu');
KOMM.sect_end();
KOMM.sect_end();

OSOBA.cntx_psh();
OSOBA.prefix();
P.cntx_psh();
P.prefix();
PAR_POKR.cntx_psh();
PAR_POKR.prefix();
R.cntx_psh();
R.prefix();
PREM_OKR.cntx_psh();
PREM_OKR.index('PREM_OKR');
PREM_OKR.prefix();
{? PREM_OKR.first()
|| {!
   |? _czy:=0;
      _msg:='';
      PREM_OKR.P().OSOBA();
      PREM_OKR.SKP().R();
      {? PREM_OKR.RP<>'S' & exec('czy_od','skl_okr',PREM_OKR.O_OD,PREM_OKR.RP,PREM_OKR.SKP,0,0)=0
      || _czy:={? PREM_OKR.RP<>'I' & PREM_OKR.O_DO<>exec('o_do','skl_okr',PREM_OKR.O_OD,PREM_OKR.RP) || 3 || 2 ?};
         _lp:=KOMM.add(
            OSOBA.NAZWISKO+' '+OSOBA.PIERWSZE+'( Id.:'+$P.IP+') '+
            '| Rubryka:'+$R.RN+' | '+PREM_OKR.RP+' | '+PREM_OKR.O_OD$1+' - '+PREM_OKR.O_DO$1
         );
         KOMM.chngroot(_lp,_sect[_czy].lp);
         _sect[_czy].ile+=1
      ?};
      PREM_OKR.next()
   !}
?};
PREM_OKR.cntx_pop();
R.cntx_pop();
PAR_POKR.cntx_pop();
P.cntx_pop();
OSOBA.cntx_pop();

_sect.g.ile:=_sect.dp.ile+_sect.dz.ile;
{? _sect.g.ile=0
:: Nie ma żadnych błędów (komunikatów) w żadnej sekcji - usuwamy sekcję główną).
|| KOMM.del(_sect.g.lp)

:: Jeżeli powyższy warunek nie jest spełniony, to znaczy, że w choć jednej sekcji jest jakiś komunikat.
:: Tak więc co najwyżej tylko jeden z poniższych warunków może być spełniony.

|? _sect.dp.ile=0
|| KOMM.del(_sect.dp.lp)
|? _sect.dz.ile=0
|| KOMM.del(_sect.dz.lp)
?};
_sect.g.ile


\kom_sp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.42]
:: OPIS: Funkcja sprawdzająca poprawność spłat potrąceń pracowniczych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ile:=0;

OSOBA.cntx_psh();
OSOBA.prefix();

KOM_OS.cntx_psh();
KOM_OS.index('KOM_OS');
KOM_OS.prefix();
{? KOM_OS.first()
|| _lp:=KOMM.sect_beg('Potrącenia pracownicze - nadpłata');
   KOMM.sect_beg('Opis');
   KOMM.add('Suma spłat potrąceń pracowniczych przewyższa kwotę zobowiązania.');
   KOMM.add('Taka sytuacja nie powinna mieć miejsca.');
   KOMM.add('Przed wykonaniem transferu należy poprawić błędne dane (zwrócić nadpłaty?).');
   KOMM.sect_end();
   KOMM.sect_beg('Lista osób');
   KOM_RP.cntx_psh();
   KOM_RP.prefix();
   KOM_SP.cntx_psh();
   KOM_SP.index('KOM_SP');
   {!
   |? {? KOM_OS.WART>0
      || KOM_SP.prefix(KOM_OS.ref());
         _splata:=0;
         {? KOM_SP.first()
         || {!
            |? _splata+=KOM_SP.KW;
               KOM_SP.next()
            !}
         ?};
         {? KOM_OS.WART<_splata
         || KOM_OS.OSOBA();
            KOMM.add(
               OSOBA.NAZWISKO+' '+OSOBA.PIERWSZE+' '+
               {? OSOBA.OBCY='T' || '(paszport: '+OSOBA.PASZPORT+')' || '(PESEL: '+OSOBA.PESEL+')' ?}+' | '+
               KOM_OS.KOM_RP().N+' | '+KOM_OS.OD$2
            );
            _ile+=1
         ?}
      ?};
      KOM_OS.next()
   !};
   KOM_SP.cntx_pop();
   KOM_RP.cntx_pop();
   KOMM.sect_end();
   KOMM.sect_end();
   {? ~_ile
   || KOMM.del(_lp)
   ?}
?};
KOM_OS.cntx_pop();


OSOBA.cntx_pop();

_ile


\szk_opis
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.42]
:: OPIS: Weryfikacja poprawności dat w tabeli SZK_OPIS.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_root:=obj_new('lp','ile');
_root.lp:=KOMM.sect_beg('Opis szkoleń - błędy w danych');
_root.ile:=0;

KOMM.sect_beg('Opis');
KOMM.add('Znaleziono opisy szkoleń, w których nie wszystkie informacje są prawidłowe.');
KOMM.add('Lista błędnych opisów szkoleń znajduje się w sekcji poniżej.');
KOMM.add('Przed wykonaniem transferu należy poprawić błędne dane.');
KOMM.sect_end();
KOMM.sect_beg('Lista');

SZK_ORG.cntx_psh();
SZK_ORG.index('SZK_ORG');
SZK_ORG.prefix();
{? SZK_ORG.first()
|| SZK_TEM.cntx_psh();
   SZK_TEM.prefix();
   SZK_OPIS.cntx_psh();
   SZK_OPIS.index('ORG_DATA');
   _org:=obj_new('lp','ile');
   _opis:=obj_new('lp','ile');
   {!
   |? _org.lp:=KOMM.sect_beg('Organizator: '+SZK_ORG.NAZWA);
      _org.ile:=0;
      SZK_OPIS.prefix(SZK_ORG.ref());
      {? SZK_OPIS.first()
      || {!
         |? _opis.lp:=KOMM.sect_beg(SZK_OPIS.OD$1+' - '+SZK_OPIS.DO$1+' | '+SZK_OPIS.TEMAT().TEMAT);
            _opis.ile:=0;
            {? SZK_OPIS.GODZ<0
            || _opis.ile+=1;
               KOMM.add('Liczba godzin ('+$SZK_OPIS.GODZ+') nie może być ujemna.')
            ?};
            {? SZK_OPIS.LIMIT<0
            || _opis.ile+=1;
               KOMM.add('Limit miejsc ('+$SZK_OPIS.LIMIT+') nie może być ujemny.')
            ?};
            {? SZK_OPIS.POTW_DO>=SZK_OPIS.OD
            || _opis.ile+=1;
               KOMM.add(
                  'Data potwierdzenia uczestnictwa w szkoleniu ('+SZK_OPIS.POTW_DO$1+') musi być wcześniejsza '+
                  'od daty rozpoczęcia szkolenia.'
               )
            ?};
            {? SZK_OPIS.MONIT_OD>=SZK_OPIS.OD
            || _opis.ile+=1;
               KOMM.add(
                  'Data rozpoczęcia wysyłania monitów ('+SZK_OPIS.MONIT_OD$1+') o potwierdzenie uczestnictwa '+
                  'w szkoleniu musi być wcześniejsza od daty rozpoczęcia szkolenia.'
               )
            ?};
            {? SZK_OPIS.WD<>date(0,0,0) & SZK_OPIS.WD<SZK_OPIS.DO
            || _opis.ile+=1;
               KOMM.add(
                  'Data ważności szkolenia ('+SZK_OPIS.WD$1+') nie może być wcześniejsza '+
                  'od daty zakończenia szkolenia.'
               )
            ?};
            KOMM.sect_end();
            {? _opis.ile
            || _org.ile+=1
            || KOMM.del(_opis.lp)
            ?};
            SZK_OPIS.next()
         !}
      ?};
      KOMM.sect_end();
      {? _org.ile
      || _root.ile+=1
      || KOMM.del(_org.lp)
      ?};
      SZK_ORG.next()
   !};
   SZK_OPIS.cntx_pop();
   SZK_TEM.cntx_pop()
?};
SZK_ORG.cntx_pop();

KOMM.sect_end();

KOMM.sect_end();

{? _root.ile
|| 1
|| KOMM.del(_root.lp);
   0
?}


\prod_wal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Formuła kontrolna dla produkcji
::----------------------------------------------------------------------------------------------------------------------
_poz:=0;

_prod:=KOMM.sect_beg('Produkcja');
_poz+=exec('zktl_chk','tran_vlb');
_poz+=exec('zl_chk','tran_vlb');
_poz+=exec('tktl_chk','tran_vlb');
KOMM.sect_end();

{? ~_poz
|| KOMM.del(_prod)
?};
~~


\tktl_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Test poprawności danych dla kart technologicznych
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_msg_napraw:='Należy sprawdzić, czy zostały poprawnie uruchomione formuły potransferowe na wersję 12.41 (\\tktl_archive/skid_trn.fml).';
exec('tktl_cntx_psh','tech1');
exec('tktl_use','tech1');
TKTL.index('ASTN');
TKTL.prefix();
TKTL.prefix('T','T');
{? TKTL.first()
|| KOMM.sect_beg('Wykryto błędne dane w kartotece kart technologicznych.');
   KOMM.add(_msg_napraw);
   KOMM.sect_beg('Znaleziono karty archiwalne w zbiorze roboczym.');
   {!
   |? KOMM.add(TKTL.NRK+' - '+TKTL.WER);
      TKTL.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   _result:=1
?};
TKTL.prefix('W','T');
{? TKTL.first()
|| KOMM.sect_beg('Wykryto błędne dane w kartotece wzorców technologicznych.');
   KOMM.add(_msg_napraw);
   KOMM.sect_beg('Znaleziono wzorce archiwalne w zbiorze roboczym.');
   {!
   |? KOMM.add(TKTL.NRK+' - '+TKTL.WER);
      TKTL.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   _result:=1
?};
TKTL.prefix('Z','T');
{? TKTL.first()
|| KOMM.sect_beg('Wykryto błędne dane w kartotece technologii zleceń.');
   KOMM.add(_msg_napraw);
   KOMM.sect_beg('Znaleziono technologie archiwalne (dotyczące zamkniętych zleceń) w zbiorze roboczym.');
   {!
   |? KOMM.add(TKTL.NRK+' - '+TKTL.WER);
      TKTL.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   _result:=1
?};
exec('tktl_cntx_pop','tech1');
_result


\zl_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Test poprawności danych zleceń
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

_msg_napraw:='Należy sprawdzić, czy zostały poprawnie uruchomione formuły potransferowe na wersję 12.41 (\\akt_zlec/skid_trn.fml).';
_ndx:=ZL.ndx_tmp(,,'NODE',,,'SYM',,);
ZL.index(_ndx);
ZL.prefix();
{? ZL.first() & ZL.NODE=''
|| KOMM.sect_beg('Wykryto błędne dane w kartotece zleceń');
   KOMM.add(_msg_napraw);
   KOMM.sect_beg('Znaleziono nieuzupełnione pole NODE w tabeli zleceń');
   {!
   |? {? ZL.NODE='' || KOMM.add(ZL.SYM) ?};
      ZL.NODE='' & ZL.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   _result:=1
?};
ZL.ndx_drop(_ndx);

_msg_napraw:='Należy zamknąć wskazane zlecenia przed wykonaniem transferu do Merit';
_ndx:=ZL.ndx_tmp(,,'STAN',,,'TYP','TYP',,'SYM',,);
ZL.index(_ndx);
ZL.prefix('O','~');
{? ZL.first()
|| KOMM.sect_beg('Wykryto błędne dane w kartotece zleceń');
   KOMM.add(_msg_napraw);
   KOMM.sect_beg('Znaleziono otwarte zlecenia zastrzeżonych typów');
   {!
   |? KOMM.add(ZL.SYM);
      ZL.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   _result:=1
?};
ZL.ndx_drop(_ndx);

_result


\zktl_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Test wyczyszczenia danych kart technologii zleceń
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_msg_napraw:='Należy sprawdzić, czy zostały poprawnie uruchomione formuły potransferowe na wersję 12.41 (\\tran_z2t/skid_trn.fml).';
ZKTL.prefix();
{? ZKTL.first()
|| KOMM.sect_beg('Wykryto błędne dane w kartotece technologii zleceń.');
   KOMM.add('Znaleziono dane w nieużywanych tabelach.');
   KOMM.add(_msg_napraw);
   KOMM.sect_end();
   _result:=1
?};
_result


\umowy_wal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Walidacja systemu umowy i zgłoszenia
::----------------------------------------------------------------------------------------------------------------------
_poz:=0;

_prod:=KOMM.sect_beg('Umowy i zgłoszenia');
_poz+=exec('hn_chk','tran_vlb');
KOMM.sect_end();

{? ~_poz
|| KOMM.del(_prod)
?};
~~


\hn_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Walidacja harmonogramów umów cyklicznych
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
HN.cntx_psh();
HN.index('NAZ');
HN.prefix();
_sect:='Harmonogramy umów';
{? HN.first()
|| _lp:=KOMM.sect_beg(_sect);
   {!
   |?
::    Pobieram listę harmonogramów wg brygad i samochodów
      {? HN.TYP<=2
      || {? var_pres('_harmon')>100 || obj_del(_harmon) ?};
         _harmon:=exec('transfer_harmon','tran_vlb',,,HN.TYP);

         {? _harmon.size()>1
         || _result:=1;
            _msg:='Harmonogram '+HN.KOD+' w odziale: '+HN.ODDZ
                 +{? HN.TYP=1
                  || ' używa kilku samochodów. Tylko ostatni zostanie przepisany na pozycje umów'
                  |? HN.TYP=2
                  || ' używa kilku brygad. Tylko ostatnia zostanie przepisana na pozycje umów'
                  ?};
            KOMM.add(_msg,,,1)
         ?}
      ?};
      HN.next()
   !};
   KOMM.sect_end();
   {? _result=0
   || KOMM.del(_lp)
   ?}
?};
HN.cntx_pop();
_result


\transfer_harmon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Dla podanego harmonogramu zwraca wszystkie brygady ze wszystkich lat
::       !! UWAGA to jest duplikat formuły z umowy_harm.fml - jak będą błędy to poprawiać też tam !!
::   WE: [_a] - HN.ref lub bieżący rekord
::       [_b] - INTEGER - rok z którego pobrać, jeśli nie podany to ze wszystkich lat
::       [_c] - INTEGER - typ harmonogramu 1-samochody, 2-brygady
::   WY: tab_tmp - tablica tymczasowa z polem REF i LP
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(HN.ref())
|| _ref:=_a
?};
_rok:=0;
{? var_pres('_b')=type_of(0)
|| _rok:=_b
?};
_only_hn:={? var_pres('_c')=type_of(0) || _c || 0 ?};


_result:=tab_tmp(2
   ,'LP','INTEGER','Nazwa pola 1'
   ,'REF','STRING[16]','Nazwa pola 2'
   ,'TYP','INTEGER','Typ harmonogramu'
);
_ndx:=_result.ndx_tmp(,,'REF',,);
_can_continue:=1;

_result.cntx_psh();
_result.index(_ndx);
HN.cntx_psh();
{? _ref<>null()
|| HN.prefix();
   {? HN.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _typ_hn:=HN.TYP;
:: Typ nr 1 oznacza że samochody
:: Typ nr 2 oznacza że brygady
   {? (~_only_hn & _typ_hn<=2) | (_typ_hn=_only_hn)
   ||
      ZLBR.cntx_psh();
      SAM.cntx_psh();
      ZLBR.index('ODDZ');
      SAM.index('ZLP');
      HARMON.cntx_psh();
      {? _rok>0
      || HARMON.index('HN');
         HARMON.prefix(HN.ODDZ,HN.KOD,_rok)
      || HARMON.index('KOD');
         HARMON.prefix(HN.KOD,HN.KOD)
      ?};
      _lp:=1;
      {? HARMON.first()
      || {!
         |? {! _it:=1..date(HARMON.ROK,HARMON.NR,0)~3
            |! _rule:='HARMON.D'+form(_it,-2);
               _value:=($_rule)();
               _value:=form(_value);
               _year:=HARMON.ROK;
               _month:=HARMON.NR;
               _day:=_it;

               {? _value<>''
               ||
                  {? _value*'~'=0
                  || {? _typ_hn=1
                     || SAM.prefix(HN.ODDZ,_value,);
                        {? SAM.first()
                        || _result.prefix($SAM.ref());
                           {? _result.first()=0
                           || _result.blank();
                              _result.LP:=_lp;
                              _result.REF:=$SAM.ref();
                              _result.TYP:=_typ_hn;
                              _result.add();
                              _lp+=1
                           ?}
                        ?}
                     |? _typ_hn=2
                     || ZLBR.prefix(HN.ODDZ,_value,_value);
                        {? ZLBR.first()
                        || _result.prefix($ZLBR.ref());
                           {? _result.first()=0
                           || _result.blank();
                              _result.LP:=_lp;
                              _result.REF:=$ZLBR.ref();
                              _result.TYP:=_typ_hn;
                              _result.add();
                              _lp+=1
                           ?}
                        ?}
                     ?}
                  ?}
               ?}
            !};
            HARMON.next()
         !}
      ?};
      HARMON.cntx_pop();
      SAM.cntx_pop();
      ZLBR.cntx_pop()
   ?}

?};
HN.cntx_pop();
_result.cntx_pop();
_result.clear();
_result.ndx_drop(_ndx);
_result


\zal_kzp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51]
:: OPIS: KOD BŁĘDU: ER/WRT/XP/12.51/1901/0057: KZP - Dołączanie załączników w rejestrze dokumentów.
::   WE:
::   WY: 1/0
:: ~OST: INBLVIEW
::----------------------------------------------------------------------------------------------------------------------
ZALACZ.cntx_psh();
ZALACZ.clear();
ZALACZ.f_clear();
ZALACZ.f_set('DATA',,'RODZAJ=\'KZP_E\' and KZP_E is null');
{? ZALACZ.f_first()
|| FUN.info(
      'Analiza danych wykazała błędy w zapisach załączników dotyczących rejestru dokumentów pożyczek.\n'+
      'Za chwilę wyświetlone zostanie okno z wszystkimi błędnymi zapisami.\n'+
      'Akcja "Otwórz" pozwala na zapoznanie się z treścią załącznika.\n'+
      'Akcja "Popraw" pozwala (F3) na powiązanie załącznika z odpowiednim dokumentem w rejestrze pożyczek.'
   );

   KZP_K.cntx_psh();
   KZP_K.f_clear();
   KZP_K.prefix();

   KZP_P.cntx_psh();
   KZP_P.f_clear();
   KZP_P.prefix();

   KZP_T.cntx_psh();
   KZP_T.f_clear();
   KZP_T.prefix();

   OSOBA.cntx_psh();
   OSOBA.f_clear();
   OSOBA.prefix();

   KZP_E.cntx_psh();
   KZP_E.f_clear();
   KZP_E.prefix();
   _ndx:=KZP_E.ndx_tmp(,,'KZP_K','SYMBOL',,'DATA',,,'NR',,);
   KZP_E.index(_ndx);
   {! _lp:=1 .. KZP_E.fld_num()
   |! KZP_E.fld_fml(KZP_E.fld_acr(_lp),'BLANK')
   !};

   _ws:=KZP_E.mk_sel('Rejestr dokumentów');
   KZP_E.win_fld(_ws,,'KZP_K','SYMBOL');
   KZP_E.win_fld(_ws,,'DATA',);
   KZP_E.win_fld(_ws,,'NR',);
   KZP_E.win_fld(_ws,,'KZP_T','S',,,,,'Operacja');
   KZP_E.win_fld(_ws,OSOBA,'NAZWISKO',,,,,,'Nazwisko',,'Pożyczkobiorca - nazwisko');
   KZP_E.win_fld(_ws,OSOBA,'PIERWSZE',,,,,,'Imię',,'Pożyczkobiorca - imię');
   KZP_E.win_act(_ws,,'Rekord',,,,"KZP_E.KZP_P().OSOBA();~~");
   KZP_E.win_dict(_ws);

   SLO_NAZ.cntx_psh();
   SLO_NAZ.f_clear();
   SLO_NAZ.prefix();

   _ws:=ZALACZ.mk_sel('Załączniki',,,,,,,,'U');
   ZALACZ.win_fld(_ws,,'DATA');
   ZALACZ.win_fld(_ws,,'TYP_ZAL','NAZWA',,40,,,'Typ załącznika');
   ZALACZ.win_fld(_ws,,'ZAL');
   ZALACZ.win_fld(_ws,,'ZAL_NAME',,,40);
   ZALACZ.win_fld(_ws,POMOC,'K1',,,10,,1,'Symbol kasy');
   ZALACZ.win_fld(_ws,,'KZP_E','DATA',,,,,'Data dokumentu');
   ZALACZ.win_fld(_ws,,'KZP_E','NR',,,,,'Numer dokumentu');
   ZALACZ.win_act(_ws,,'Formuła','Popraw',,,
      "  {? ZALACZ.edit()
         || {? var_pres('WWWE',ZALACZ)=27
            || ZALACZ.WWWE:='T';
               ZALACZ.WWWS:='N'
            ?};
            ZALACZ.put()
         ?}
      ",,1);
   ZALACZ.win_act(_ws,,'Formuła','Otwórz',,,"ZALACZ.bl_view('ZAL')");
   ZALACZ.win_act(_ws,,'Rekord',,,,
      "  {? ZALACZ.KZP_E
         || POMOC.K1:=ZALACZ.KZP_E().KZP_K().SYMBOL;
            _ret:=''
         || POMOC.K1:='';
            _ret:='255:0:0'
         ?};
         _ret
      "
   );
   ZALACZ.win_sel(_ws);

   _we:=ZALACZ.mk_edit('Załącznik');
   ZALACZ.win_efld(_we,AH,'H',,,,,1,'Załącznik');
   ZALACZ.win_efld(_we,,'DATA',,,,,1);
   ZALACZ.win_efld(_we,,'TYP_ZAL','NAZWA',,40-3,,1,'Typ załącznika');
   ZALACZ.win_efld(_we,,'ZAL',,,13,,1);
   ZALACZ.win_efld(_we,,'ZAL_NAME',,,40,,1);
   ZALACZ.win_efld(_we,AH,'H',,,,,1,'Dokument');
   ZALACZ.win_efld(_we,POMOC,'K1',,,13,,1,'Symbol kasy');
   ZALACZ.win_efld(_we,,'KZP_E','DATA',_ndx);
   ZALACZ.win_efld(_we,,'KZP_E','NR',,10);
   ZALACZ.win_edit(_we);

   ZALACZ.select();
   ZALACZ.f_rfresh();
   _ret:=ZALACZ.f_size()=0;

   SLO_NAZ.cntx_pop();
   {! _lp:=1 .. KZP_E.fld_num()
   |! KZP_E.fld_fml(KZP_E.fld_acr(_lp),'BLANK',"*")
   !};
   KZP_E.cntx_pop();
   OSOBA.cntx_pop();
   KZP_T.cntx_pop();
   KZP_P.cntx_pop();
   KZP_K.cntx_pop();

   ~~

|| _ret:=1
?};
ZALACZ.f_clear();
ZALACZ.cntx_pop();

_ret


\runtime
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51] (dodał ARTSLO)
:: OPIS: Formuła sprawdza, czy aplikacja została uruchomiona wskazaną lub nowszą wersją runtime'u.
::   WE:  _a  [NUMBER] - Kod wersji produkcyjnej (np. 18.02).
::        _b  [STRING] - Kod wersji rozwojowej (np. 'P.20').
::       [_c] [NUMBER] - Tryb wsadowy (bez komunikatów): 0*/1.
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0)
|| _vp:=_a
|| return(0)
?};
{? var_pres('_b')=type_of('')
|| _vr:=_b
|| return(0)
?};
_batch:=var_pres('_c')=type_of(0) & _c;

_run:=user(11);
{? #_run>=_vp | _run>=_vr
|| 1
|| {? ~_batch
   || FUN.info('Funkcjonalność wymaga MacroBASE co najmniej w wersji '+$_vp+'.')
   ?};
   0
?}


\is_edp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51] (dodał ARTSLO)
:: OPIS: Funkcja sprawdza czy zastosowano aktualizację 12.51_37 (Elektroniczna dokumentacja pracownicza - 'eTeczka').
::       Zakładamy, że jeżeli w DEF-ie są odpowiednie zmiany, to pliki formuł również zostały zaaktualizowane.
::   WE: [_a] [NUMBER] - Tryb wsadowy (bez komunikatów): 0*/1.
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;
_msg:=~_batch;

_ret:=0;
{? var_pres('HASH',ZALACZ)<>27
|| {? _msg
   || FUN.info('Brak aktualizacji w definicji systemu.\nOpcja niedostępna.')
   ?}

|? ~exec('runtime','tran_vlb',19,'P.40',_batch)
|| ~~

|? fexists('zao.fml',1)<>1
|| {? _msg
   || FUN.info('Brak kompletu plików wymaganych przez aktualizację.\nOpcja niedostępna.')
   ?}

:: !!! Poniżej tymczasowa (prymitywna) metoda weryfikacji, czy klient posiada licencję na moduł EDP.
|? fexists('edp.alic',1)<>1
|| {? _msg
   || FUN.info('Brak licencji na moduł EDP.\nOpcja niedostępna.')
   ?}

|| _ret:=1
?};
_ret


\list_kry
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [19.22]
:: OPIS: Funkcja sprawdzająca czy nie ma niestandardowych kryteriów list płac
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,'FM','STRING[30]','Wywoływana formuła');

KT.cntx_psh();
KT.prefix();
KT.first();
{!
|? {? (KT.K * 'exec')>0 & (KT.K<>'exec(\'czy_prac\',\'listplac\')' & KT.K<>'exec(\'czy_zlec\',\'listplac\')')
   || _tab.FM:=KT.K;
      _tab.add()
   ?};
   KT.next()
!};
KT.cntx_pop();

{? _tab.size()>0
|| KOMM.sect_beg('Listy płac - niestandardowe kryteria');
   KOMM.sect_beg('Opis');
   KOMM.add('W tabeli KT stwierdzono istnienie wskazań na niestandardowe formuły kryteriów list płac.');
   KOMM.add('Przed wykonaniem transferu danych należy poprawić wskazania na standardowe kryteria.');
   KOMM.add('Brak podjętych działań w tym zakresie spowoduje wystąpienie błędów podczas zadań potransferowych'+
            ' wykonywanych w systemie Merit.');
   KOMM.sect_end();
   KOMM.sect_beg('Niestandardowe formuły');
   _tab2:=sql('select distinct FM from :_a',_tab);
   _tab2.first();
   {!
   |? KOMM.add(_tab2.FM);
      _tab2.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   1
|| 0
?}


\kal_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [19.22]
:: OPIS: Funkcja sprawdza czy są założone kalendarze dla lat, które będą potrzebne podczas przepisywania nieobecności
::       z przebiegu do tabeli N
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('KAL')<100
|| exec('define','kalend');
   KAL:=obj_new(@.CLASS.KALEND)
?};
{? var_pres('BB')<100
|| exec(,'_bit');
   BB:=obj_new(@.CLASS.BIT)
?};
P.cntx_psh();
P.prefix();
:: zbieramy przebiegi które będą przenoszone do tabeli N
_przeb:=sql('
   select
      max(SUBSTR(to_string(H.DO),1,4)) as ROK,
      P.REFERENCE as REF
   from
      H left join
      H_ZM using (H.KZ,H_ZM.REFERENCE) left join
      P using (H.P,P.REFERENCE)
   where
      H_ZM.KZ<>\'Z\'
   group by
      P.REFERENCE'
   );
_tab:=tab_tmp(2
               ,'ROK','STRING[4]','Rok'
               ,'NAZWA','STRING[20]','Nazwa wzorca'
         );
KAL_NAZW.cntx_psh();
R_WZCZ.cntx_psh();
_ind:=R_WZCZ.ndx_tmp(,1,'P',,);
R_WZCZ.index(_ind);
::wyłączamy komentarze z errorów kalendarzy
errorobl:=1;
{? _przeb.first()
|| {!
   |? {? P.seek(BB.sqlint(_przeb.REF),)
      || _jest:=KAL.set_cal(P.KAL().NAZWA);
        {? _jest & ~exec('yearpres','kalend',KAL,#_przeb.ROK)
        || R_WZCZ.prefix(P.ref());
           {? R_WZCZ.last()
           || _tab.ROK:=_przeb.ROK;
              _tab.NAZWA:=R_WZCZ.KAL().OPIS;
              _tab.add()
           ?}
        || {? ~KAL.set_cal('standard',#_przeb.ROK)
           || _tab.NAZWA:='standard';
              _tab.ROK:=_przeb.ROK;
              _tab.add()
           ?}
        ?}
      ?};
      _przeb.next()
   !}
?};
R_WZCZ.cntx_pop();
R_WZCZ.ndx_drop(_ind);
KAL_NAZW.cntx_pop();
P.cntx_pop();
:: przywracamy komunikaty dla metod obiektu KAL
&errorobl;
:: sprawdzamy ostatni rok wystąpienia kalendarza standard (jeśli nie istnieje żaden kalendarz, to pomijamy sprawdzenie)
_std:=sql(
   'select max(KAL_ROK.ROK) as ROK '
   'from KAL_ROK '
   ' left join KAL_NAZW '
   'where KAL_NAZW.NAZWA=\'standard\' '
   'having max(KAL_ROK.ROK)>0'
);
{? _std.first() & _std.ROK<date()~1
|| _rok:=_std.ROK+1;
   {!
   |? _rok<=date()~1
   |! _tab.NAZWA:='standard';
      _tab.ROK:=$_rok;
      _tab.add();
      _rok+=1
   !}
?};

_tab2:=sql('select distinct :_a.ROK, :_a.NAZWA from :_a',_tab);
{? _tab2.first()
|| KOMM.sect_beg('Kalendarze - brak kalendarzy pracowników');
   KOMM.sect_beg('Opis');
   KOMM.add('Aby transfer przeszedł pomyślnie należy założyć wymienione kalendarze.');
   KOMM.sect_end();
   KOMM.sect_beg('Kalendarze których brakuje');
   {!
   |? KOMM.add(_tab2.NAZWA+' - '+_tab2.ROK);
      _tab2.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   1
|| 0
?}


\fm_nad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [19.22]
:: OPIS: Funckja sprawdza występowanie nadmiarowych formuł płacowych dla wskazanych rubryk
::       Precedensem była rubryka 177, która na mericie straciła formułe płacową przez co import formuł nie nadpisał
::       nieaktualnych wywołań funkcji
::   WE: _a - Napis z lista (odzielona przecinkami) rubryk, które chcemy wykryć
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_rub:=spli_str(_a,',');
_start:=0;
FM.cntx_psh();
_ind:=FM.ndx_tmp(,1,'R','RN',);
FM.index(_ind);
{! _i:=1 .. obj_len(_rub)
|! FM.prefix(#_rub[_i]);
   {? FM.first()
   || {!
      |? {? ~_start
         || KOMM.sect_beg('Formuły płacowe - brak po stronie Merita');
            KOMM.sect_beg('Opis');
            KOMM.add('Dla wskazanych rubryk nie ma formuł płacowych po stronie Merita.');
            KOMM.add('Aby po transferze nie było błędów podczas naliczania listy płac należy dla nich usunąć formuły płacowe.');
            KOMM.sect_end();
            KOMM.sect_beg('Formuły, które należy usunąć:');
            _start:=1
         ?};
         KOMM.add('Formuła typu '+FM.TP+' dla rubryki: '+_rub[_i]);
         FM.next()
      !}
   ?}
!};
FM.cntx_pop();
FM.ndx_drop(_ind);
{? _start
|| KOMM.sect_end();
   KOMM.sect_end();
   1
|| 0
?}


\adres_uniq
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [19.22]
:: OPIS: Funckja sprawdza występowanie zapisów w tabeli ADRES, które nie będą spełniać wymogu unikalności dla jednego z
::       indeksów w Merit
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('BB')<100
|| exec(,'_bit');
   BB:=obj_new(@.CLASS.BIT)
?};

_n_uni_adres:=sql('select
                     ADRES.TYP,
                     ADRES.NAZWA,
                     sum(1)
                   from
                     ADRES
                   group by
                     ADRES.TYP,
                     ADRES.NAZWA,
                   having
                     sum(1)>1
                  ');
_wynik:=0;
ADRES.cntx_psh();
{? _n_uni_adres.first()
|| KOMM.sect_beg('Nieunikalne rekordy tabli ADRES względem indeksu po stronie Merita');
   KOMM.sect_beg('Opis');
   KOMM.add('Wskazane zapisy w tabeli ADRES nie spełniają wymogu unikalności wymuszonego przez indeks ADRES po stronie systemu Merit.');
   KOMM.add('Aby po transferze nie było błędów należy zadbać aby zapisy były unikalne względem pól TYP i NAZWA.');
   KOMM.sect_end();
   KOMM.sect_beg('Rekordy których to dotyczy:');
   ADRES.index('ADRES');
   {!
   |? ADRES.prefix(BB.sqlint(_n_uni_adres.TYP),_n_uni_adres.NAZWA);
      {? ADRES.first()
      || {!
         |? KOMM.add('(ADRES.TYP;ADRES.NAZWA;ADRES.ref) '+$ADRES.TYP+';'+$ADRES.NAZWA+';'+$ADRES.ref());
            ADRES.next()
         !}
      ?};
      _n_uni_adres.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   _wynik:=1
?};
ADRES.cntx_pop();
_wynik


\ppk_03
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: ER/WRT/XP/12.51/1912/0024
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PPK_PWP')<>type_of(SYSLOG)
|| FUN.info('Brak elementów aplikacji PPK.');
   return()
?};
_BUF:=tab_tmp(3,
   'NAZWISKO','STRING['+$MS.fld_len(OSOBA,'NAZWISKO')+']','Nazwisko',
   'PIERWSZE','STRING['+$MS.fld_len(OSOBA,'PIERWSZE')+']','Imię',
   'PESEL','STRING['+$MS.fld_len(OSOBA,'PESEL')+']','PESEL',
   'OD','DATE','Od dnia',
   'RN','INTEGER','Kod',
   'RT','STRING['+$MS.fld_len(R,'RT')+']','Nazwa',
   'PPK_PWP','INTEGER','Rekord',
   'OPIS','STRING['+$MS.fld_len(PPK_WRD,'OPIS')+']','Rodzaj deklaracji'
);

_firma:=exec('ref_firma','war_tech');
P.cntx_psh();
ZC.cntx_psh();
OSOBA.cntx_psh();
PPK_UMO.cntx_psh();
PPK_UMO.index('F_OD');
PPK_UMO.prefix(_firma);
PPK_PWP.cntx_psh();
PPK_PWP.prefix();
PPK_PWP.f_set(
   '',
   'left join PPK_PNW using(PPK_PNW.PPK_PWP, PPK_PWP.REFERENCE) '+
   'left join PPK_WPW using(PPK_WPW.REFERENCE, PPK_PNW.PPK_WPW) '+
   'left join PPK_WNU using(PPK_WNU.REFERENCE, PPK_WPW.PPK_WNU) '+
   'left join PPK_WRD using(PPK_WRD.REFERENCE, PPK_WNU.PPK_WRD)',
   'PPK_PWP.FIRMA=:_a and (PPK_WRD.SYMBOL is null or PPK_WRD.SYMBOL!=\':_b\')',_firma,'DRZW'
   );

_loop:=PPK_PWP.f_first();
_size:=PPK_PWP.f_size();
{! _cnt:=0
|? _loop
|! progress(int(100*_cnt/_size),'Trwa analiza danych...');
   _ok:=1;
   {? ~PPK_UMO.find_ge(PPK_PWP.OD) | (PPK_UMO.DO<>date(0,0,0) & PPK_UMO.DO<PPK_PWP.OD)
::    brak umowy wcześniejszej od daty zmiany lub zmiana nastąpiła po zakończeniu umowy
   || {? PPK_PWP.ZC<>null || PPK_PWP.ZC().P().OSOBA()
      |? PPK_PWP.P<>null || PPK_PWP.P().OSOBA()
      || PPK_PWP.OSOBA()
      ?};
::    Dojście do opisu podpiętej deklaracji:
      _TOPIS:=sql('select PPK_WRD.OPIS '+
                  'from PPK_PWP '+
                     'join PPK_PNW using(PPK_PNW.PPK_PWP, PPK_PWP.REFERENCE) '+
                     'join PPK_WPW using(PPK_WPW.REFERENCE, PPK_PNW.PPK_WPW) '+
                     'join PPK_WNU using(PPK_WNU.REFERENCE, PPK_WPW.PPK_WNU) '+
                     'join PPK_WRD using(PPK_WRD.REFERENCE, PPK_WNU.PPK_WRD) '+
                  'where PPK_PWP.REFERENCE=:_a',PPK_PWP.ref());

      _BUF.OPIS:={? _TOPIS.first() || _TOPIS.OPIS || 'brak' ?};
      obj_del(_TOPIS);

      _BUF.NAZWISKO:=OSOBA.NAZWISKO;
      _BUF.PIERWSZE:=OSOBA.PIERWSZE;
      _BUF.PESEL:=OSOBA.PESEL;
      _BUF.OD:=PPK_PWP.OD;
      _BUF.RN:=PPK_PWP.R().RN;
      _BUF.RT:=PPK_PWP.R().RT;
      _BUF.PPK_PWP:=#PPK_PWP.ref();
      _BUF.add()
   ?};
   _loop:=PPK_PWP.f_next()
!};
prgs_clr();

PPK_PWP.f_clear();
PPK_PWP.cntx_pop();
PPK_UMO.cntx_pop();
OSOBA.cntx_pop();
ZC.cntx_pop();
P.cntx_pop();

_wnd:=_BUF.mk_sel('Procentowe wysokości wpłat poza okresami obowiązywania umów','P',0);
_BUF.win_fld(_wnd,,'NAZWISKO');
_BUF.win_fld(_wnd,,'PIERWSZE');
_BUF.win_fld(_wnd,,'PESEL');
_BUF.win_fld(_wnd,,'OD');
_BUF.win_fld(_wnd,,'RN',,,5);
_BUF.win_fld(_wnd,,'RT');
_BUF.win_fld(_wnd,,'OPIS');
_BUF.win_act(_wnd,,'Formuła','Usuń',,,"
      _TAB:=cur_tab(1,1);
      {? _TAB.sel_size()=0
      || FUN.ask('Czy usunąć bieżący wiersz?')
      || 1
      ?}
   ","
      _BUF:=cur_tab(1,1);
      PPK_PWP.cntx_psh();
      PPK_PWP.index('UNIQUE');
      PPK_PWP.prefix(exec('ref_firma','war_tech'));
      {? PPK_PWP.seek(_BUF.PPK_PWP,)
      || PPK_PWP.del(1,1) & _BUF.del()
      || FUN.emsg('Nie znaleziono rekordu.');
         _BUF.del()
      ?};
      PPK_PWP.cntx_pop();
      0
   ",,1,"
      FUN.ask('Czy usunąć zaznaczone wiersze?')
   "
);
_BUF.win_sel(_wnd);

{? _BUF.first()
|| _BUF.select()
?};

obj_del(_BUF);
~~


\rop_uniq
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [20.42]
:: OPIS: Funkcja sprawdza występowanie zapisów w tabeli R_OPCZYT, które nie będą spełniać wymogu unikalności dla jednego
::       z indeksów w Merit
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_uni_rop:=sql('select R_OPCZYT.K, sum(1) from R_OPCZYT group by R_OPCZYT.K having sum(1)>1');

_wynik:=0;
R_OPCZYT.cntx_psh();
{? _uni_rop.first()
|| KOMM.sect_beg('Nieunikalne rekordy tabli R_OPCZYT względem indeksu po stronie Merita');
   KOMM.sect_beg('Opis');
   KOMM.add('Wskazane zapisy w tabeli R_OPCZYT nie spełniają wymogu unikalności wymuszonego przez indeks R_OPCZYT po stronie systemu Merit.');
   KOMM.add('Aby po transferze nie było błędów należy zadbać aby zapisy były unikalne względem pola K.');
   KOMM.sect_end();
   KOMM.sect_beg('Rekordy których to dotyczy (R_OPCZYT.K;R_OPCZYT.O;R_OPCZYT.SYMBOL;R_OPCZYT.ref):');
   R_OPCZYT.index('R_OPCZYT');
   {!
   |? R_OPCZYT.prefix(_uni_rop.K,_uni_rop.K);
      {? R_OPCZYT.first()
      || {!
         |? KOMM.add($R_OPCZYT.K+';'+$R_OPCZYT.O+';'+$R_OPCZYT.SYMBOL+';'+$R_OPCZYT.ref());
            R_OPCZYT.next()
         !}
      ?};
      _uni_rop.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   _wynik:=1
?};
R_OPCZYT.cntx_pop();
_wynik


\ru_std
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [20.42]
::  AKT: IS [22.26]
:: OPIS: Funkcja sprawdza czy zapisy w tabeli RU odpowiadają standardowym typom umów jakie są wymagane w Merit
::   WE:
::   WY: _bledy [INTEGER] - 1/0 Czy wystąpiły komunikowane błędy?
::----------------------------------------------------------------------------------------------------------------------
_bledy:=0;
_stdRU:=obj_new('TAB','typUMZLEC','typUMPRAC','typ','add');
_stdRU.TAB:=tab_tmp(2
::      Kod typu ('UMZLEC'/'UMPRAC')
       ,'TYP'     ,'STRING[16]' ,'Typ'
::      Unikalny symbol / kod
       ,'KOD'     ,'STRING[1]'  ,'Kod'
::      Krótki opis
       ,'OPIS'    ,'STRING[48]' ,'Opis'
::      Unikalny symbol / kod Xpertis
       ,'XKOD'    ,'STRING[1]'  ,'Kod Xpertis'
::      Krótki opis Xpertis
       ,'XOPIS'   ,'STRING[48]' ,'Opis Xpertis'
::      Komunikowanie błędu 0-zgodność, 1-różnica, 2-brak (nie ma w Xpertis kodu standardowego z Merit)
       ,'KOM'     ,'INTEGER'    ,'Oznaczenie do komunikowania błędu [0/1/2]');
_stdRU.typUMZLEC:=exec('slo_typ','ext_slo','UMZLEC');
_stdRU.typUMPRAC:=exec('slo_typ','ext_slo','UMPRAC');
_stdRU.typ:=
   "_ret:=null();
    {? _a='UMZLEC'
    || _ret:=.typUMZLEC
    |? _a='UMPRAC'
    || _ret:=.typUMPRAC
    ?};
    _ret
   ";
_stdRU.add:=
   ".TAB.TYP:=_a;
    .TAB.KOD:=_b;
    .TAB.OPIS:=_c;
    .TAB.XKOD:='';
    .TAB.XOPIS:='';
    .TAB.KOM:=0;
    .TAB.add()
   ";

:: typ UMZLEC
_typ:='UMZLEC';
_stdRU.add(_typ,'1','umowa-zlecenie');
_stdRU.add(_typ,'2','umowa o dzieło');
_stdRU.add(_typ,'3','prawa autorskie');
_stdRU.add(_typ,'4','rada nadzorcza');
_stdRU.add(_typ,'5','rada nadzorcza KU');
_stdRU.add(_typ,'6','umowa o dzieło (KU 20%)');
_stdRU.add(_typ,'7','świadczenia byłych pracowników');
_stdRU.add(_typ,'8','osoby zagraniczne (art.29)');
_stdRU.add(_typ,'m','prawa majątkowe');
_stdRU.add(_typ,'v','staże uczniowskie');
_stdRU.add(_typ,'y','praktyki absolwenckie');

:: typ UMPRAC
_typ:='UMPRAC';
_stdRU.add(_typ,'A','okres próbny');
_stdRU.add(_typ,'B','czas określony');
_stdRU.add(_typ,'C','czas nieokreślony');
_stdRU.add(_typ,'D','praca na zastępstwo');
_stdRU.add(_typ,'E','umowa do dnia porodu');
_stdRU.add(_typ,'X','inne');

{? _stdRU.TAB.first()
|| RU.cntx_psh;
   RU.index('K');
   RU.prefix();
   {!
   |? {? RU.find_key(_stdRU.typ(_stdRU.TAB.TYP),_stdRU.TAB.KOD,)
      || {? RU.O<>_stdRU.TAB.OPIS
         || _stdRU.TAB.KOM:=1;
            _stdRU.TAB.XKOD:=RU.K;
            _stdRU.TAB.XOPIS:=RU.O;
            _stdRU.TAB.put();
            _bledy:=1
         ?}
      || _stdRU.TAB.KOM:=2;
         _stdRU.TAB.put();
         _bledy:=1
      ?};

      _stdRU.TAB.next()
   !};
   RU.cntx_pop()
?};

{? _bledy
|| KOMM.sect_beg('Niezgodny słownik typów umów względem standardowego słownika po stronie Merita');
   KOMM.sect_beg('Opis');
   {? _stdRU.TAB.find_tab(,'KOM',,'=',1)
   || KOMM.add('Wskazane zapisy w tabeli RU nie odpowiadają zapisom standardowym po stronie systemu Merit.')
   ?};
   {? _stdRU.TAB.find_tab(,'KOM',,'=',2)
   || KOMM.add('Występują zapisy standardowe po stronie systemu Merit, których brak w tabeli RU.')
   ?};
   KOMM.add('Aby po transferze nie było błędów należy uzgodnić zapisy po kodzie i opisie.');
   KOMM.sect_end();
   _stdRU.TAB.f_set(,,'KOM=1');
   {? _stdRU.TAB.f_first()
   || KOMM.sect_beg('Rekordy, w których brak zgodności [RU.TYP | (xpertis)RU.K;RU.O - (merit)RU.K;RU.O]:');
      {!
      |? KOMM.add('%1 | %2;%3 - %4;%5'
                 [_stdRU.TAB.TYP,_stdRU.TAB.XKOD,_stdRU.TAB.XOPIS,_stdRU.TAB.KOD,_stdRU.TAB.OPIS]);

         _stdRU.TAB.f_next()
      !};
      KOMM.sect_end()
   ?};
   _stdRU.TAB.f_clear();
   _stdRU.TAB.f_set(,,'KOM=2');
   {? _stdRU.TAB.f_first()
   || KOMM.sect_beg('Rekordy, których brak w Xpertis [RU.TYP | (merit)RU.K;RU.O]:');
      {!
      |? KOMM.add('%1 | %2;%3'
                 [_stdRU.TAB.TYP,_stdRU.TAB.KOD,_stdRU.TAB.OPIS]);

         _stdRU.TAB.f_next()
      !};
      KOMM.sect_end()
   ?};
   _stdRU.TAB.f_clear();
   KOMM.sect_end()
?};
obj_del(_stdRU);

_bledy


\por_wn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [21.37]
:: OPIS: Funkcja sprawdza czy zapisy w tabeli są zapisy w tabeli WOZ które są nie zakończone
::   WE:
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_woz:=sql('select * from WOZ where WOZ.P=null or WOZ.OSOBA=null');

_wynik:=0;
{? _woz.first()
|| KOMM.sect_beg('Istnieją niezakończone wnioski o zatrudnienie złożone w Portal HR');
   KOMM.sect_beg('Opis');
   KOMM.add('Proces zatrudnienia z wniosku Portalu HR strukturalnie różni się w Merit; dane z Xpertis nie są przenoszone');
   KOMM.add('Przed rozpoczęciem transferu należy zakończyć wskazane wnioski o zatrudnienie.');
   KOMM.sect_end();
   KOMM.sect_beg('Wnioski dla osób których to dotyczy:');
   {!
   |? KOMM.add(_woz.KA_NAZ+' '+_woz.KA_IM+' ('+_woz.EMAIL+')');
      _woz.next()
   !};
   KOMM.sect_end();
   KOMM.sect_end();
   _wynik:=1
?};
_wynik


\czapa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [19.22]
:: OPIS: Funkcja sprawdza dla wersji wielofirmowej czy translacja firmy 000 na rekord UD_SKL zgadza się z tym co
::       faktycznie jest wykorzystane w strukturze drzewiastej schematu PODZORG jako element nadrzędny Grupy kapitałowej
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_kom_przed:=_start:=0;
_err_typ:=_err_sys:=_err_fir:=_err_uf:='';

:: znajdź UD_TYP PODZORG
UD_TYP.cntx_psh();
UD_TYP.index('SYMBOL');
{? UD_TYP.find_key('PODZORG')
|| _typ:=UD_TYP.ref()
|| _err_typ:='Nie udało się znaleźć typu PODZORG.';
   _kom_przed:=1
?};
UD_TYP.cntx_pop();

:: znajdź schemat domyślny
UD_SYS.cntx_psh();
UD_SYS.index('TYPSYS');
UD_SYS.prefix(_typ,'KALI');
{? UD_SYS.first()
|| _sch:=UD_SYS.UD_SCH
|| _err_sys:='Nie udało się ustalić schematu domyślnego dla typu PODZORG.';
   _kom_przed:=1
?};
UD_SYS.cntx_pop();

::znajdź co jest czapa dla znalezionego schematu w danym typie w UD_DEF
_tab:=sql('select UD_DEF.UD_SKL as SKL from UD_DEF where UD_DEF.UD_SCH=\':_a\' and UD_DEF.UD_DEF=0',$_sch);
{? _tab.first() & _tab.size()=1
|| _ud_skl:=_tab.SKL
?};

::ustal wskazanie na firme 000
FIRMA.cntx_psh();
FIRMA.index('SYMBOL');
{? FIRMA.find_key('000')
|| _firm:=FIRMA.ref()
|| _err_fir:='Nie udało się ustalić firmy 000.';
   _kom_przed:=1
?};
FIRMA.cntx_pop();

::znajdz jaki ud_skl jest wskazany w UD_FIR
UD_FIR.cntx_psh();
UD_FIR.index('UD_SKL');
UD_FIR.prefix(_firm);
{? UD_FIR.first()
|| _firm_skl:=UD_FIR.UD_SKL
|| _err_uf:='Nie udało się ustalić elementu struktury dla firmy 000.';
   _kom_przed:=1
?};
UD_FIR.cntx_pop();

::porównanie składnika w drzewie i w firmie
{? ~_kom_przed & $_firm_skl<>_ud_skl
|| _start:=1
?};

{? _kom_przed
|| KOMM.sect_beg('Powiązanie elementu struktury z firmą 000');
   KOMM.sect_beg('Opis');
   KOMM.add('Wystąpiły nieoczekiwane problemy, które uniemożliwiają stwierdzenie czy prawidłowo zostalo ustalone powiązanie elementu struktury z definicją firmy');
   KOMM.sect_end();
   KOMM.sect_beg('Lista problemów:');
   {? _err_typ<>'' || KOMM.add(_err_typ) ?};
   {? _err_sys<>'' || KOMM.add(_err_sys) ?};
   {? _err_fir<>'' || KOMM.add(_err_fir) ?};
   {? _err_uf<>'' || KOMM.add(_err_uf) ?};
   KOMM.sect_end();
   KOMM.sect_end();
   1
|? _start
|| KOMM.sect_beg('Powiązanie firmy 000 z elementem struktury drzewa dla schematu PODZORG');
   KOMM.sect_beg('Opis');
   KOMM.add('Element struktury użyty jako składnik grupujący w definicji drzewa typu PODZORG różni się od tego'+
            ', który został wskazany jako powiązany z firmą 000.');
   KOMM.add('Należy przeanalizować schematy danych i uzgodnić dane');
   KOMM.sect_end();
   KOMM.sect_end();
   1
|| 0
?}


:Sign Version 2.0 jowisz:1048 2023/06/23 14:16:36 900ea82150dd678f7950914e7aa2c4a9ddac9b4e63626ef7c808ac4afdffd76c1c7abd124b43b36566af3130c37861746844a360146158b7ec7de0e5f2c37aacb8638ffc903529d2304f7334f0299f5267cd87b82832ef3c2b91f8d53f06cf0314640108f56331b254df2e4dad3091915eebc3b96c3fe66953bb4b5da371008e
