:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: %event.fml
:: Utworzony: 07.03.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły dla zdarzeń warunkowych
::======================================================================================================================


\poczekaj_na_robocizne
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Oczekiwanie na zarejestrowaną robociznę - obsługa zdarzenia warunkowego pośredniego,
::       po którym uruchomiona zostanie rejestracja dokumentu magazynowego
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('poczekaj_na_robocizne','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - są rekordy ZLGD bez wygenerowanych ilości na dokumentach
::       0 - żaden rekord ZLGD nie wymaga generowania dokumentu
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
_zl:=null();
{? var_pres('_a')=type_of(null())
|| _zl:=_a
?};

_result:=0;

{? _zl<>null() & exec('FindAndGet','#table',ZL,_zl,,"STAN<>'Z'",1)
|| ST.ODDZ:=exec('FindAndGet','#table',ZL,_zl,,"ODDZ",'_');
   ST.AR:=date()~1;
   ST.AM:=date()~2;
   exec('open','open_tab',ST.ODDZ,($ST.AR)+2);

   ZLGD.cntx_psh();
   _names:=ZLGD.names();
   {? _names.first()
   || {!
      |? ZLGD.use(_names.NAME);
         ZLGD.index('ZLECENIE');
         ZLGD.prefix(_zl);
         {? ZLGD.first()
         || {!
            |? _ilegen:=exec('ilegen','magdok_prod',ZLGD.ZPARN).ilegen;
               {? _ilegen>0
               || _result:=1
               ?};
               _result=0 & ZLGD.next()
            !}
         ?};
         _result=0 & _names.next()
      !}
   ?};
   ZLGD.cntx_pop()
?};

_result


\poczekaj_na_przewodniki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [17.00]
:: OPIS: Oczekiwanie na wygenerowanie przewodników - obsługa zdarzenia warunkowego pośredniego,
::       po którym uruchomiona zostanie generacja limitów i akceptacja zlecenia
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('poczekaj_na_przewodniki','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - dla zlecenia wygenerowano juz przewodniki na całą zadaną ilość
::       0 - nie cała ilość ze zlecenia znajduje się na przewodnikach
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
|| return(exec('zl_deleted_msg','zl_common'))
?};

_result:=0;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| _il:=ZL.IL;
   ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(_zl);
   {? ZGH.first()
   || {!
      |? _ilegen:=ZGH.ILNPRZ;
         {? _ilegen>=_il || _result:=1 ?};
         _result=0 & ZGH.next()
      !}
   ?};
   ZGH.cntx_pop()
?};
ZL.cntx_pop();
_result


\poczekaj_na_zapotrzebowania
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [17.00]
:: OPIS: Oczekiwanie na zakończenie redakcji zapotrzebowań dla przewodników
::       - obsługa zdarzenia warunkowego pośredniego, po którym uruchomiona zostanie akceptacja zlecenia
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('poczekaj_na_zapotrzebowania','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - dla przewodników zlecenia zakończono już rejestrację zapotrzebowań
::       0 - w przeciwnym wypadku
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
|| return(exec('zl_deleted_msg','zl_common'))
?};

_result:=0;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| _il:=ZL.IL;
   ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(_zl);
   {? ZGH.first()
   || _result:=1;
      {!
      |? {? ZGH.STAT_L='N'
         || _result:=0
         ?};
         _result=0 & ZGH.next()
      !}
   ?};
   ZGH.cntx_pop()
?};
ZL.cntx_pop();
_result


\czy_zamykac_zlecenie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [17.00]
:: OPIS: Oczekiwanie na zarejestrowanie ilosci wykonanej na zleceniu - obsługa zdarzenia warunkowego pośredniego,
::       po którym uruchomione zostanie zamknięcie zlecenia
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_zamykac_zlecenie','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - dla zlecenia wykonano już wymaganą ilość
::       0 - nie cała wymagana ilość ze zlecenia została wykonana
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
|| return(exec('zl_deleted_msg','zl_common'))
?};

_result:=0;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| {? ZL.RP='T'
   || _result:=ZL.TYP().TOL>=100-(ZL.ILDOK/ZL.IL*100)
   || _result:=ZL.TYP().TOL>=100-(ZL.ILWYK/ZL.IL*100)
   ?}
?};
ZL.cntx_pop();

_result


\poczekaj_na_akceptacje
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [17.00]
:: OPIS: Oczekiwanie na akceptację całej rodziny zlecenia - obsługa zdarzenia warunkowego pośredniego,
::       po którym uruchomiona zostanie generacja limitów i akceptacja zlecenia
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('poczekaj_na_akceptacje','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - zlecenie i jego podrzędne są już zaakceptowane
::       0 - przynajmniej jedno zlecenie z rodziny podanego jest niezaakceptowane
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
|| return(exec('zl_deleted_msg','zl_common'))
?};

_result:=0;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| _result:=(ZL.STAN='O');
   {? _result=1 & ZL.RODZAJ<>'P'
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? {? ZL.STAN='N'
            || _result:=0
            ?};
            _result & ZL.next()
         !}
      ?}
   ?}
?};
ZL.cntx_pop();
_result


\czy_realizowac_zam_wewn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [17.00]
:: OPIS: Oczekiwanie na możliwość realizacji zamówień wewnętrznych powiązanych ze zleceniem
::          exec('czy_realizowac_zam_wewn','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - można realizować zamówienia wewnętrzne powiązane ze zleceniem
::       0 - nie można realizować zamówień wewnętrznych powiązanych ze zleceniem
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
_zl:=null();
{? var_pres('_a')=type_of(null())
|| _zl:=_a
?};

_result:=0;

ZL.cntx_psh();
ZK_N.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| {? ZL.RODZAJ='P'
   || ZL.index('UNRZL');
      ZL.prefix(ZL.UNRZL)
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL)
   ?};
   {? ZL.first()
   || {!
      |? ZK_N.use('zknag'+ZL.ODDZ+'__');
         ZK_N.index('ZLALW');
         ZK_N.prefix(ZL.ref(),'A','T');
         {? ZK_N.first()
         || {!
            |? {? ZK_N.STAN*'REA'
               || _result:=1
               ?};
               ~_result & ZK_N.next()
            !}
         ?};
         ~_result & ZL.next()
      !}
   ?}
?};
ZK_N.cntx_pop();
ZL.cntx_pop();
_result


\czyOper2Real
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Sprawdzenie czy operacja mobilna została zakończona i jest do realizacji
::       odpowiednik ikony "słoneczka"
::          exec('czyOper2Real','%event',_a.p01)
::   WE: _a - EANN.ref()
::   WY: 1 - operacja ma stan do realizacji
::       2 - operacja nie istnieje (została zrealizowana, anulowana)
::       3 - parametr wejściowy jest błędny
::       0 - operacji nie można zrealizować
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_msk:=ref_name(_a)+3;
{? (+_msk)=3
|| EANN.cntx_psh();
   EANP.cntx_psh();
   exec('openean','open_tab',_msk);
   EANN.clear();
   {? EANN.seek(_a)
   || _wyn:={? EANN.STAN='Z'
            || 1
            |? EANN.STAN='A' | EANN.STAN='+'
            || 2
            || 0
            ?}
   || _wyn:=2
   ?};
   EANN.cntx_pop();
   EANP.cntx_pop()
|| _wyn:=3
?};
_wyn


\endOperac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: kontroluje czy choć jedna operacja podanego typu jest do realizacji
::   WE: _a - rodzaj operacji
::       [_b] - ref magazynu
::   WY: 1 - jest operacja do realizacji
::       0 - nie ma
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_mag:={? var_pres('_b')=type_of(null()) || _b || null() ?};

_eann:=sql('select '+
           '  EANN.REFERENCE REF '+
           'from @EANN '+
           ' where EANN.REFERENCE like '+'''eann_\\_\\_%'' escape ''\\'''
           '   and EANN.AKT=''T'''+
           '   and EANN.TYP='':_a'''+
           '   and EANN.STAN=''Z''',_a);

_eann.clear();
{? _eann.first()
|| {!
   |? _oddz:=1+(4-_eann.REF);
      exec('openean','open_tab',_oddz+'__');
      {? (EANN.clear(); EANN.seek(_eann.REF))
       & (_mag=null() | _mag=exec('one_mag','magazyn_mob',EANN.ref()))
       & exec('ctrlEANN','magazyn_mob',_a,1)
      || _wyn:=1
      ?};
      _eann.next()
   !}
?};
obj_del(_eann);
_wyn


\czy_zlecenie_zamkniete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Oczekiwanie na zamknięcie zlecenia - obsługa zdarzenia warunkowego pośredniego
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_zlecenie_zamkniete','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 0 - zlecenie jeszcze nie zamknięte
::       1 - zlecenie jest zamknięte
::       STRING - komunikat błędu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
||
:: Jeżeli w _a przekazane ~~ to znak że zlecenie usunięte i można puścić te zdarzenia dalej
:: bo one prowadzą do zakończenia procesów
   return(1)
?};

_result:=0;
ZL.cntx_psh(); ZL.prefix();
{? ZL.seek(_zl)
|| {? ZL.STAN='Z'
   || _result:=1
   ?}
?};
ZL.cntx_pop();
_result


\czy_zlecenie_zaakceptowane
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Oczekiwanie na zaakceptowanie zlecenia - obsługa zdarzenia warunkowego pośredniego
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_zlecenie_zaakceptowane','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 0 - zlecenie jeszcze nie zaakceptowane
::       1 - zlecenie jest zaakceptowane
::       STRING - komunikat błędu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_zl:=null();
{? var_pres('_a')=type_of(null())
|| _zl:=_a
?};

_result:=0;
ZL.cntx_psh(); ZL.prefix();
{? ZL.seek(_zl)
|| {? ZL.STAN='O'
   || _result:=1
   ?}
?};
ZL.cntx_pop();
_result


\czy_naprawiac_braki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Oczekiwanie czy są zarejestrowane braki bez operacji naprawczych - obsługa zdarzenia warunkowego pośredniego
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_naprawiac_braki','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 0 - nie ma braków do obsługi
::       1 - należy wygenerować operacje naprawcze dla zarejestrowanych braków
::       STRING - komunikat błędu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
|| return(exec('zl_deleted_msg','zl_common'))
?};

_result:=0;

ZL.cntx_psh(); ZL.prefix();
{? ZL.seek(_zl)
|| {? ZL.STAN<>'Z'
   || _result:=exec('has_braki_todo','braki')
   ?}
?};
ZL.cntx_pop();
_result


\czy_wydanie_do_kooperacji
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Oczekiwanie, czy są do zlecenia dostępne operacje kooperacji magazynowej, które nie zostały wydane
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_wydanie_do_kooperacji','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 0 - brak operacji do wydania
::       1 - są operacje do wydania
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
_zl:=null();
{? var_pres('_a')=type_of(null())
|| _zl:=_a
?};

_result:=0;
{? _zl<>null()
||
   ST.ODDZ:=exec('FindAndGet','#table',ZL,_zl,,"ODDZ",'_');

   _chkak:=exec('get','#params',500631,2);
   _from:=_where:='';
   _from:='join ZGH using(ZGP.NRZLP,ZGH.REFERENCE) join ZL using(ZGP.ZL,ZL.REFERENCE)';
   _sort:='ZL';
   _where+='ZGP.WEW=\'N\''
           ' and ZL.ODDZ=\''+ST.ODDZ+'\''
           ' and ZL.STAN=\'O\''
           ' and ZGH.STAT_REJ=\'T\''
           ' and ZGP.SRW=\'M\''
           ' and ZGP.ZL=\''+$_zl+'\'';
:: Jest kontrola ilości na przewodnikach zleceń - pokazuje operacje wykonywane
   {? _chkak='T'
   || _where+=' and ZGP.STATUS = \''+exec('status_pending','zl_guide')+'\''
:: Nie ma kontroli ilości na przewodnikach zleceń - pokazujemy wszystkie operacje oprócz wykonanych
   |? _chkak='N'
   || _where+=' and ZGP.STATUS <> \''+exec('status_end','zl_guide')+'\''
   ?};
   ZGP.prefix();
   ZGP.f_set(_sort,_from,_where);
   {? ZGP.f_first()
   || {!
      |? {? exec('do_wydania','zl_koop')>0 || _result:=1 ?};
         _result=0 & ZGP.f_next()
      !}
   ?};
   ZGP.f_clear()
?};
_result


\czy_przyjecie_z_kooperacji
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Oczekiwanie, czy są do zlecenia dostępne wydania do kooperacji, które nie zostały przyjęte
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_przyjecie_z_kooperacji','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 0 - brak pozycji do przyjęcia
::       1 - są pozycje do przyjęcia
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
_zl:=null();
{? var_pres('_a')=type_of(null())
|| _zl:=_a
?};

_result:=0;

{? _zl<>null()
||
   ST.ODDZ:=exec('FindAndGet','#table',ZL,_zl,,"ODDZ",'_');

   _sck:=exec('koop_akt_table','zl_koop');
   exec('koop_akt_load','zl_koop',_sck,null(),_zl,null());

   _sck.clear();
   _jestsd:=0;
   {? _sck.first()
   || {!
      |? {? _sck.SD>0 || _jestsd:=1 ?};
         _jestsd=0 & _sck.next()
      !}
   ?};
   {? _jestsd || _result:=1 ?}
?};

_result


\czy_podzlecenia_gotowe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy zlecenie ma już wygenerowaną całą strukturę podzleceń (całe drzewo do najniższego poziomu)
::       Formuła do użycia na zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          params_exec('czy_podzlecenia_gotowe','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 0 - nie wszystkie podzlecenia już wygenerowane
::       1 - wszystkie podzlecenia wygenerowane
::       STRING - komunikat błędu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
|| return(exec('zl_deleted_msg','zl_common'))
?};

_result:=0;

{? type_of(_zl)=type_of(ZL.ref())
||
   ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zl)
   || {? exec('subzlec_generated','zl_link')>0
      || _result:=1
      ?}
   ?};
   ZL.cntx_pop()
?};
_result


\czy_rekord_usuniety
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy przekazany argument jest typu złączeniowego, jeśli nie, to znaczy że odpowiedni rekord został
::       usunięty. Do zastosowania w zdarzeniu warunkowym pośrednim, np. po bramie sterowanej zdarzeniami,
::       w celu zabezpieczenie procesu przed usuniętym rekordem.
::       Przykładowe wywołanie:
::          params_exec('czy_rekord_usuniety','%event',_a.p01)
::   WE: _a - oczekiwany typ złączeniowy
::   WY: 0 - parametr wejściowy jest typu złączeniowego, co oznacza, że odpowiedni rekord nadal jest w bazie
::       1 - parametr wejściowy nie jest typu złączeniowego, co oznacza, że odpowiedni rekord został usunięty
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _result:=0
|| _result:=1
?};
_result


\descRef_ToDo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Formuła TO-DO
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WE: _a - opis na ToDo
::       _b - numer parametru
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=_mp.load(exec('kind_in','#b_port'));
_par:='p'+form(_b,-2,0,'99');

{? var_pres(_par,_in)<>type_of(~~) & _in[_b]
|| _a+exec('record','#to_string',_in[_b])
|| _a
?}


\czy_nadrzedne_akc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [17.00]
:: OPIS: Oczekiwanie na akceptację zlecenia nadrzędnego - obsługa zdarzenia warunkowego pośredniego,
::       po którym uruchomiona zostanie realizacja.
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_nadrzedne_akc','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - zlecenie nadrzędne już zaakceptowane
::       0 -  zlecenie nadrzędne nie jest zaakceptowane
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
|| return(exec('zl_deleted_msg','zl_common'))
?};

_result:=0;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
   {? ZL.first()
   || _result:=(ZL.STAN='O')
   ?}
?};
ZL.cntx_pop();
_result


\czy_akceptowac_zlecenie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Oczekiwanie na zakończenie rejestracji przewodników i zapotrzebowań
::       po którym uruchomiona zostanie akceptacja zlecenia.
::       Musi być conajmniej jeden przewodnik, ale wszystkie które są muszą być zakończone.
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_akceptowac_zlecenie','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - zlecenie można już akceptować
::       0 - zlecenia nie można jeszcze akceptować
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
|| return(exec('zl_deleted_msg','zl_common'))
?};

_result:=0;

:: Czy zlecenie z operacjami (wymagane sprawdzenie przewodników)
_oper:=exec('FindAndGet','#table',ZL,_zl,,"
   {? ZL.RODZAJ='P' &
      (  ZL.TYP().TECH='N'
         & exec('FindAndGet','#table','TKTL',ZL.RKTL,,\"TYP().OPER\",'T')='N'
            |
         ZL.TYP().TECH='T'
         & exec('FindAndGet','#table','TKTL',ZL.RTKTL,,\"TYP().OPER\",'T')='N'
      )
   || 0
   || 1
   ?}
",1);

ZGH.cntx_psh();
ZGH.index('ZLNR');
ZGH.prefix(_zl);
{? ZGH.first()
|| _result:=1;
   {!
   |? {? {? _oper || ZGH.STAT_REJ<>'T' || 0 ?} | ZGH.STAT_L<>'T'
      || _result:=0
      ?};
      ZGH.next()
   !}
|| _result:=0
?};
ZGH.cntx_pop();

_result


\czy_akceptowac_niezalezne
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Oczekiwanie na zakończenie rejestracji zlecenia podrzędnego
::       po którym uruchomiona zostanie akceptacja zlecenia nadrzędnego.
::       Musi być conajmniej jedno zlecenie, ale wszystkie które są muszą być zakończone.
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_akceptowac_niezalezne','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - zlecenie można już akceptować
::       0 - zlecenia nie można jeszcze akceptować
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _zl:=_a
|| return(exec('zl_deleted_msg','zl_common'))
?};

_result:=0;

ZL.cntx_psh();
ZL.index('NRNZL');
ZL.prefix(exec('FindAndGet','#table',ZL,_zl,,"UNRZL",0));
{? ZL.first()
|| _result:=1;
   {!
   |? {? ZL.STAN<>'O'
      || _result:=0
      ?};
      ZL.next()
   !}
|| _result:=0
?};
ZL.cntx_pop();

_result


\jest_do_wykonania
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Oczekiwanie na możliwość rejestrowania wykonań do zlecenia
::       Przechodzimy, gdy ilość wykonana na zleceniu produkcyjnym jest mniejsza niż planowana
::       albo jest to zlecenie warsztatowe otwarte
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('jest_do_wykonania','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - można rejestrować wykonania
::       0 - nie można rejestrować wykonania
::----------------------------------------------------------------------------------------------------------------------
_zl:=null();
{? var_pres('_a')=type_of(null())
|| _zl:=_a
?};

_result:=0;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| {? ZL.TYP().WP='P'
   || ZGP.cntx_psh();
      ZGP.clear();
      ZGP.f_clear();
      {? ZGP.find_tab(,'ZL',,'=',_zl,'STATUS',,'<>',exec('status_end','zl_guide'))
      ||
         _result:=ZL.STAN='O'
::         _result:=ZL.ILWYK_D<ZL.IL
      ?};
      ZGP.cntx_pop()
   || _result:=ZL.STAN='O'
   ?}
?};
ZL.cntx_pop();
_result


\czy_zlecenie_zaraportowane
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Oczekiwanie na zarejestrowanie ilosci wykonanej na zleceniu - obsługa zdarzenia warunkowego pośredniego,
::       po którym uruchomione zostanie zamknięcie zlecenia
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_zlecenie_zaraportowane','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - dla zlecenia zarejestrowano całą ilość
::       0 - nie cała ilość ze zlecenia została zarejestrowana
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
_zl:=null();
{? var_pres('_a')=type_of(null())
|| _zl:=_a
?};

_result:=0;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| {? ZL.RP='T'
   || _result:=(ZL.ILDOK>=ZL.IL)
   || _result:=(ZL.ILWYK>=ZL.IL)
   ?}
?};
ZL.cntx_pop();

_result


\zamDELorARCH
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.14]
:: OPIS: Sprawdza czy dane zamówienie sprzedaży lub wewnętrzne nie zostało przypadkiem w tym czasie
::       usunięte lub zarchiwizowane
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZK_N):
::          exec('zamDELorARCH','%event',_a.p01)
::   WE: _a - ZK_N.ref()
::   WY: 1 - usunięto zamówienie
::       2 - zarchiwizowano zamówienie lub anulowano
::       0 - zamówienie istnieje
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
{? _a=null() | exec('FindAndGet','#table',ZK_N,_a,,,null())=null()
|| _res:=1
|? exec('FindAndGet','#table',ZK_N,_a,,"(name()+2)<>'__' | STAT_REJ='A'",0)
|| _res:=2
?};
_res


\doKomplWys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.42]
:: OPIS: Sprawdza czy dane zamówienie sprzedaży lub wewnętrzne podlega jeszczee kompletacji wysyłki
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZK_N):
::          exec('doKomplWys','%event',_a.p01)
::       Uwaga. Formuła nie analizuje magazynów do realizacji
::   WE: _a - ZK_N.ref()
::       _b - 1-analizuj magazyny 0(domyślnie)-nie
::   WY: 1 - pozostało coś do kompletacji
::       0 - nic już nie ma lub nie ma zamówienia lub zostało zarchiwizowane
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_ctrlmg:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_rsql:=$_a;
{? _a=null() | (form(8+_rsql)+2)<>'__'
|| _res:=0
|| _msk:=ZK_N.name();
   _mzk:=form(8+_rsql)+3;
   ZK_N.cntx_psh();
   ZK_P.cntx_psh();
   {? _msk<>_mzk
   ||  ZK_N.use('zknag'+_mzk);
       ZK_P.use('zkpoz'+_mzk)
   ?};
   _tab:=tab_tmp(1,'M','STRING[16]','','ILP','REAL','');
   ZK_P.index('NAG');
   ZK_P.prefix(_a);
   {? ZK_P.first() & ZK_P.N().T().MOB='T'
   || _rodz:=ZK_P.N().T().R;
      {!
      |? {? ZK_P.A='A' & ZK_P.ILP>0 & ZK_P.M().RODZ='T' & ZK_P.M().KODK<>''
           & {? _ctrlmg
             || {? ZK_P.RMAG<>null() || ZK_P.RMAG().SL='T' || exec('sprUprMob','magdok_wspolne',_rodz) ?}
             || 1
             ?}
         || _tab.clear();
            {? ~_tab.find_key($ZK_P.M,)
            || _tab.blank();
               _tab.M:=$ZK_P.M;
               _tab.ILP:=ZK_P.ILP;
               _tab.add(1)
            || _tab.ILP+=ZK_P.ILP;
               _tab.put(1)
            ?}
         ?};
         ZK_P.next()
      !}
   ?};
   ZK_N.cntx_pop();
   ZK_P.cntx_pop();
   {? _tab.size()
   || EANN.cntx_psh();
      EANP.cntx_psh();
      exec('openean','open_tab',(1+_mzk)+'__');
      EANN.index('REFSQL');
      EANN.prefix(_rsql,);
      {? EANN.first()
      || {!
         |? EANP.index('EANN');
            EANP.prefix(EANN.ref());
            {? EANP.first()
            || {!
               |? {? EANP.M<>null()
                  || _ile:={? EANP.EANN().STAN<>'Z' || EANP.IL || EANP.ILS ?};
                     _tab.clear();
                     {? _tab.find_key($EANP.M,)
                     || _tab.ILP-=_ile;
                        {? _tab.ILP<=0 || _tab.del() || _tab.put(1) ?}
                     ?}
                  ?};
                  EANP.next()
               !}
            ?};
            EANN.next()
         !}
      ?};
      EANN.cntx_pop();
      EANP.cntx_pop()
   ?};
   _tab.clear();
   _res:=_tab.size()>0;
   obj_del(_tab)
?};
_res


\doReoWys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.42]
:: OPIS: Sprawdza czy dana reorganizacja podlega wysyłce
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _DK_LN):
::          exec('doReoWys','%event',_a.p01)
::   WE: _a - DK_LN.ref()
::   WY: 1 - podlega wysyłce
::       0 - ne podlega
::----------------------------------------------------------------------------------------------------------------------
_dk_ln:={? var_pres('_a')=type_of(null()) || _a || null() ?};
_res:=0;
{? _dk_ln<>null()
|| _rsql:=$_dk_ln;
   _mzk:=form(8+_rsql)+3;
   _res:=exec('FindAndGet','#table',DK_LN,_dk_ln,,"(';SI'*RODZ)>1",0);
   {? _res
   || EANN.cntx_psh();
      EANP.cntx_psh();
      exec('openean','open_tab',(1+_mzk)+'__');
      _akt:={? exec('FindInSet','#table','EANN','AKT',_rsql,'T')<>null
            || 'T'
            |? exec('FindInSet','#table','EANN','AKT',_rsql,'N',"EANN.STAN",,,'')='+'
            || 'A'
            || ''
            ?};
      EANN.cntx_pop();
      EANP.cntx_pop();
      {? _akt<>'' || _res:=0 ?}
   ?}
?};
_res


\czy_zamykac_zgloszenie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Oczekiwanie na minięcie planowanego terminu naprawy
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _REM_ZGL):
::          exec('czy_zamykac_zgloszenie','%event',_a.p01)
::   WE: _a - REM_ZGL.ref()
::   WY: 1 - dla zlecenia wykonano już wymaganą ilość
::       0 - nie cała wymagana ilość ze zlecenia została wykonana
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _rem_zgl:=_a
|| return(exec('rem_zgl_deleted_msg','remonty_zgloszenia'))
?};

_result:=0;

REM_ZGL.cntx_psh();
::exec('rem_open','open_tab','___');
REM_ZGL.prefix();
{? REM_ZGL.seek(_rem_zgl)
|| {? REM_ZGL.DT_PUA=date(0,0,0)
      | exec('create','#tm_stamp',REM_ZGL.DT_PUA,REM_ZGL.TM_PUA)<exec('create','#tm_stamp',date(),time())
   || _result:=1
   ?}
?};
REM_ZGL.cntx_pop();

_result


\czy_zgloszenie_zamkniete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Oczekiwanie na zamknięcie zgłoszenia - obsługa zdarzenia warunkowego pośredniego
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _REM_ZGL):
::          exec('czy_zgloszenie_zamkniete','%event',_a.p01)
::   WE: _a - REM_ZGL.ref()
::   WY: 0 - zgłoszenie jeszcze nie zamknięte
::       1 - zgłoszenie jest zamknięte
::       STRING - komunikat błędu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _rem_zgl:=_a
|| return(exec('rem_zgl_deleted_msg','remonty_zgloszenia'))
?};

_result:=0;

REM_ZGL.cntx_psh();
::exec('rem_open','open_tab','___');
REM_ZGL.prefix();
{? REM_ZGL.seek(_rem_zgl)
|| {? REM_ZGL.STAT_REJ=exec('status_closed','remonty_zgloszenia')
   || _result:=1
   ?}
?};
REM_ZGL.cntx_pop();

_result


\czyTransport
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [19.42]
:: OPIS: Sprawdzenie czy zrealizowano transport
::   WE: _a - TR_NZL.ref()
::   WY:  1 - transport został zrealizowany
::       -1 - transport nie został zrealizowany podlega ponownej realizacji
::        0 - transport oczekuje na realizację
::       -2 - transport nie istnieje - usunięty/anulowany
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_tr_nzl:={? var_pres('_a')=type_of(null()) || _a
         |? var_pres('_a')=type_of('') & ((+_a)=48 | (+_a)=16) || exec('FindAndGet','#table',TR_NZL,_a,,,null())
         || null()
         ?};

{? _tr_nzl=null()
|| _res:=-2
|| _msk:=ref_name(_tr_nzl)+4;
   {? (+_msk)=4
   || exec('opentr_psh','open_tab');
      exec('opentr','open_tab',_msk);
      TR_NZL.clear();
      {? TR_NZL.seek(_tr_nzl)
      || _res:={? (';TX'*TR_NZL.REAL)>1
               || 1
               |? TR_NZL.REAL='A' & TR_NZL.TR_NAG=null() & TR_NZL.PLAN='N'
               || -1
               || 0
               ?}
      ?};
      exec('opentr_pop','open_tab')
   ?}
?};
_res


\czyENDreaTran
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [19.42]
:: OPIS: Sprawdzenie czy transport można zakwalifikować jako zrealizowany
::   WE: _a - TR_NAG.ref()
::   WY:  1 - wszystkie trasy transportu zostały oznaczone albo jako zrealizowane albo niezrealizowane
::        2 - transport został zakończony ustawiono znacznik i podano datę
::        3 - transport nie posiada pozycji ale ma zakończoną redakcję = wszystkie pozycje zostały zrealizowane
::        0 - transport oczekuje na realizację
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_msk:=ref_name(_a)+4;
{? (+_msk)=4
|| exec('opentr_psh','open_tab');
   exec('opentr','open_tab',_msk);
   TR_NAG.prefix();
   {? TR_NAG.seek(_a)
   || {? TR_NAG.STAT_REJ='T'
      || _res:=2
      |? TR_NAG.STAT_REJ='Z'
      || TR_NZL.index('TR_NAG');
         TR_NZL.prefix(TR_NAG.ref());
         {? TR_NZL.first()
         || _res:=1;
            {!
            |? {? TR_NZL.REAL='N'
               || _res:=0;
                  0
               || TR_NZL.next()
               ?}
            !}
         || _res:=3
         ?}
      ?}
   ?};
   exec('opentr_pop','open_tab')
?};
_res


\poczekaj_na_kpo_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Oczekiwanie na status karty przekazania odpadów
::       - obsługa zdarzenia warunkowego pośredniego, po którym proces zostanie uruchomiony dalej
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _KPO):
::          exec('poczekaj_na_kpo_status','%event',_a.p01,'REJECTED;TRANSPORT_CONFIRMATION')
::   WE: _a - KPO.ref()
::       _b - kolejne statusy (oddzielone średnikami)
::   WY: 1 - karta ma jeden ze statusów
::       0 - w przeciwnym wypadku
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _kpo:=_a
|| return(exec('kpo_deleted_msg','odpady'))
?};
{? var_pres('_b')=type_of('')
|| _stats:=spli_str(_b,';')
|| return('Błędny parametr %1 formuły.'@@['_b'])
?};
_result:=0;
{! _it:=1 .. obj_len(_stats)
|! {? exec('FindAndGet','#table',KPO,_kpo,,"KPO.KPO_STAT().KOD",'')=_stats[_it] || _result:=1 ?}
!};
_result


\wait_MG_dysp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [20.14]
:: OPIS: Sprawdzenie czy magazyny zostały uzupełnione na pozycji dyspozycji transportowej
::   WE: _a - TR_NZL.ref()
::       [_b] - 1-tryb komunikatu 0(domyślnie) nie
::   WY: 1 - uzupełniono
::       0 - w przeciwnym wypadku
::----------------------------------------------------------------------------------------------------------------------
_info:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_res:=1;
_tr_nzl:=_a;
exec('opentr_psh','open_tab');
exec('opentr','open_tab','____');
TR_ZL.index('POZ');
TR_ZL.prefix(_tr_nzl);
{? TR_ZL.first()
|| {!
   |? {? TR_ZL.M().RODZ='T' || _res:=TR_ZL.MG<>null() ?};
      _res & TR_ZL.next()
   !}
?};
exec('opentr_pop','open_tab');
{? ~_res & _info
|| FUN.info('Istnieją pozycje dyspozycji transportowej bez przypisanego magazynu.\n'
    'W celu dalszej kontynuacji procesu magazyny należy uzupełnić na pozycjach dyspozycji transportowej.'@)
?};
_res



\ctrlPACK
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [20.42]
:: OPIS: Kontrola dostarczenia przesyłki/przesyłek
::   WE: _a - TR_NZL.ref()
::   WY: 1 - dostarczono/zakończono
::       0 - w przeciwnym wypadku
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_tr_nzl:=_a;
exec('opentr_psh','open_tab');
exec('opentr','open_tab','____');
TR_PACK.index('TR_NZL');
TR_PACK.prefix(_tr_nzl);
{? TR_PACK.first()
|| {!
   |? {? (';Odebrana;Nieodebrana;'*TR_PACK.STAN)>1 || _res:=1?};
      _res & TR_PACK.next()
   !}
?};
exec('opentr_pop','open_tab');
_res


\ctrlPTWrea
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [20.42]
:: OPIS: Kontrola możliwości realizacji potwierdzenia dostaw
::   WE: _a - wskazanie na ZDP_NAG
::   WY: 1-tak 0-nie 2-częściowo zrealizowane
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_zdp_nag:=_a;
_msk:=ref_name(_zdp_nag)+3;
{? _msk<>''
|| _stoddz:=ST.ODDZ;
   ST.ODDZ:=1+_msk;
   exec('openzd_psh','open_tab');
   exec('openzd','open_tab',_msk);
   ZDP_NAG.prefix();
   {? ZDP_NAG.seek(_zdp_nag) || _res:=exec('ctrlREA','zamdst_ptw') ?};
   exec('openzd_pop','open_tab');
   ST.ODDZ:=_stoddz
?};
_res


\potDELorARCH
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AK] [20.42]
:: OPIS: Sprawdza czy dane zamówienie dostaw lub potwierdzenie nie zostało przypadkiem w tym czasie
::       usunięte lub zarchiwizowane
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZK_N):
::          exec('potDELorARCH','%event',_a.p01)
::   WE: _a - ZDP_NAG.ref()
::   WY: 1 - usunięto zamówienie
::       2 - zarchiwizowano zamówienie lub anulowano
::       0 - zamówienie istnieje
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
{? exec('FindAndGet','#table',ZDP_NAG,_a,,,null)=null()
|| _res:=1
|? exec('FindAndGet','#table',ZDP_NAG,_a,,"(name()+2)<>'__'",0)
|| _res:=2
?};
_res


\czy_zlecenie_rozliczone
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Oczekiwanie na zarejestrowanie rozliczenia surowców i odpadów do dokumentów raportujących produkcję
::       - obsługa zdarzenia warunkowego pośredniego, po którym uruchomione zostanie zamknięcie zlecenia
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _ZL):
::          exec('czy_zlecenie_rozliczone','%event',_a.p01)
::   WE: _a - ZL.ref()
::   WY: 1 - zlecenie rozliczone
::       0 - do zlecenia nie wykonano rozliczeń
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
_zl:=null();
{? var_pres('_a')=type_of(null())
|| _zl:=_a
?};

_result:=0;

ZL.cntx_psh(); ZGH.cntx_psh(); ZGP.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
||
:: Zlecenie proste
   {? ZL.RODZAJ='P'
   ||
::    Jak zamknięte, to uznajemy za rozliczone (zalecane jest, aby stan zlecenia badać osobnym zdarzeniem)
      {? ZL.STAN='Z'
      || _result:=1
      ||
::       Każde zlecenie może wymagać rozliczenia nielimitów do operacji
         _result:=1;
         {? _result>0
         || ZGP.index('S1');
            ZGP.prefix(ZL.ref());
            {? ZGP.first()
            || {!
               |? _result*=(~exec('czy_sa_nielimity_zgp','zl_nlimit',ZGP.ref(),1));
                  _result>0 & ZGP.next()
               !}
            ?}
         ?};

         {? _result>0
         ||
::          Zlecenie raportowane na magazyn może wymagać rozliczenia nielimitów i odpadów
            {? ZL.RP='T'
            ||
::             Nie sprawdzamy ilości zdanej dokumentami, a tylko fakt rozliczenia tych dokumentów co są zarejestrowane
::               _result:=(ZL.ILDOK>=ZL.IL);
               {? _result>0 & exec('czy_sa_nielimity','zl_nlimit',ZL.ref(),1)
               || _result:=exec('czy_rozliczone_nielimity','zl_nlimit',ZL.ref())
               ?};
               {? _result>0 & exec('czy_sa_odpady','zl_nlimit',ZL.ref(),1)
               || _result:=exec('czy_rozliczone_odpady','zl_nlimit',ZL.ref())
               ?}
::          Każde inne
            ||
::             Nie sprawdzamy wg ilości wykonanej, tlyko uznajemy, że jest zawsze rozliczone
::               _result:=(ZL.ILWYK>=ZL.IL)
               _result:=1
            ?}
         ?}
      ?}
:: Zlecenie złożone (także niezależne)
   ||
::    Jak zamknięte, to uznajemy za rozliczone (zalecane jest, aby stan zlecenia badać osobnym zdarzeniem)
      {? ZL.STAN='Z'
      || _result:=1
::    Pętla po podzleceniach - wszystkie muszą być nie rozliczane, albo rozliczone
      || _result:=1;
         ZL.cntx_psh();
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |? _result*=exec('czy_zlecenie_rozliczone','%event',ZL.ref());
               _result>0 & ZL.next()
            !}
         ?};
         ZL.cntx_pop()
      ?}
   ?}
?};
ZL.cntx_pop(); ZGH.cntx_pop(); ZGP.cntx_pop();

_result


\czy_edok_akc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JK [22.26]
:: OPIS: Oczekiwanie na zamknięcie lub wycofanie dokumentu w obiegu
::       - obsługa zdarzenia warunkowego pośredniego, po którym proces się zakończy
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _EDOKUM):
::          exec('czy_edok_akc','%event',_a.p01)
::   WE: _a - EDOKUM.ref()
::   WY: 1 - dokument został zamknięty lub wycofany
::       0 - nie podjęto akcji na dokumencie
::       STRING - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',EDOKUM,_a,,"@.EDOKUM.ZAM='T' | @.EDOKUM.WYCOFAJ<>''",1)
|| 1
?}


\czy_dok_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy dokumentu księgowy został usunięty
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _DOK):
::          exec('czy_dok_del','%event',_a.p01)
::   WE: _a - DOK.ref()
::   WY: 1 - usunięto dokument księgowy
::       0 - dokument księgowy istnieje
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',DOK,_a,,,null)=null()
|| 1
?}


\czy_dok_akc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy dokumentu księgowy został usunięty lub zaksięgowany próbnie
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _DOK):
::          params_exec('czy_dok_akc','%event',_a.p01)
::   WE: _a - DOK.ref()
::   WY: 1 - usunięto lub zaksięgowano próbnie dokument księgowy
::       0 - dokument księgowy istnieje
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',DOK,_a,,"@.DOK.ZP='T'",1)
|| 1
?}


\czy_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy jest dokument księgowy
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _DOK):
::          params_exec('czy_dok','%event',_a.DOK)
::   WE: _a - DOK.ref()
::   WY: 1 - jest dokument księgowy
::       0 - brak dokumentu księgowego
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',DOK,_a,,,null)<>null()
|| 0
?}


\czy_pwn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy jest wyciąg bankowy
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _PWN):
::          params_exec('czy_pwn','%event',_a.PWN)
::   WE: _a - PWN.ref()
::   WY: 1 - jest wyciąg bankowy
::       0 - brak wyciągu bankowego
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',PWN,_a,,,null)<>null()
|| 0
?}


\czy_grsik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy jest sprawozdanie
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _GR_SIK):
::          params_exec('czy_grsik','%event',_a.GR_SIK)
::   WE: _a - GR_SIK.ref()
::   WY: 1 - jest wezwanie
::       0 - brak wezwania
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',GR_SIK,_a,,,null)<>null()
|| 0
?}


\czy_parnag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy jest plan
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _PAR_NAG):
::          params_exec('czy_parnag','%event',_a.PAR_NAG)
::   WE: _a - PAR_NAG.ref
::   WY: 1 - jest plan
::       0 - brak planu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',PAR_NAG,_a,,,null)<>null()
|| 0
?}


\czy_vatdek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy jest deklaracja
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _VAT_DEK):
::          params_exec('czy_vatdek','%event',_a.DEKLARACJA)
::   WE: _a - VAT_DEK.ref
::   WY: 1 - jest deklaracja
::       0 - brak deklaracji
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',VAT_DEK,_a,,,null)<>null()
|| 0
?}


\czy_przelew
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy jest przelew
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _PB):
::          params_exec('czy_przelew','%event',_a.PB)
::   WE: _a - PB.ref
::   WY: 1 - jest przelew
::       0 - brak przelew
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',PB,_a,,,null)<>null()
|| 0
?}


\czy_zaliczka
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy jest zaliczka
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _EZAL):
::          params_exec('czy_zaliczka','%event',_a.EZAL)
::   WE: _a - EZAL.ref
::   WY: 1 - jest zaliczka
::       0 - nie ma zaliczki
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',EZAL,_a,,,null)<>null()
|| 0
?}


\czy_sernag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy jest nagłowek korespondencji
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _SER_NAG):
::          params_exec('czy_pwn','%event',_a.SER_NAG)
::   WE: _a - SER_NAG.ref()
::   WY: 1 - jest nagłówek korespondencji
::       0 - brak nagłówka korespondencji
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',SER_NAG,_a,,,null)<>null()
|| 0
?}


\czy_seod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy faktura w obiegu seod
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _EDOKUM):
::          params_exec('czy_seod','%event',_a.EDOKUM)
::   WE: _a - EDOKUM.ref()
::   WY: 1 - SEOD
::       0 - Standardowa
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',EDOKUM,_a,,
      "ETYPY.cntx_psh();
       _result:=-(TYP().W_PORTAL)='s';
       ETYPY.cntx_pop();
       _result
      ",0)
|| 0
?}


\czy_edokum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [22.26]
:: OPIS: Sprawdza czy jest dokument w obiegu
::       Formuła do zastosowania w zdarzeniu warunkowym - przykładowe wywołanie (p01 jest portem typu _EDOKUM):
::          params_exec('czy_edokum','%event',_a.EDOKUM)
::   WE: _a - EDOKUM.ref()
::   WY: 1 - jest dokument w obiegu
::       0 - brak dokumentu w obiegu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| exec('FindAndGet','#table',EDOKUM,_a,,,null)<>null()
|| 0
?}

:Sign Version 2.0 jowisz:1048 2023/06/23 14:15:44 ad583c6abf08b4acfaf18ddca565f79dacc6efe868cb89eb2090b44a7d032c8aea66cef3c830e199045c1ff27dad4f6eee7a8f2c0c602e0161669b7de7a9d3e38479cc1efe900fb7ed70879bdc900dfc38394af8f95e63dfc87dcbbbc4ca4db1aebe2aca8c5b89035761b3e27983272da6a47821af38b0064115614d9400e096
