:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: %transfer.fml
:: Utworzony: 09.06.2020
:: Autor: GZ
:: Systemy: Merit
::======================================================================================================================
:: Zawartość: Formuły procesu nanoszącego nową wersję aplikacji
::======================================================================================================================


\workdir
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [21.14]
:: OPIS: Wskazuje katalog roboczy do przygotowania paczek
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
pth_dir('merit.zip')


\get_svn_data
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Pobiera rekord tabeli POCZTAM
::   WE: POCZTAM.KOD
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
_kod:='';
{? var_pres('_a')=type_of('')
|| _kod:=_a
?};
{? _kod=''
|| return(null)
?};
POCZTAM.cntx_psh();
POCZTAM.index('SERVER');
POCZTAM.prefix(REF.FIRMA,'S',_kod);
{? POCZTAM.first()
|| _result:=POCZTAM.ref()
?};
POCZTAM.cntx_pop();
_result


\gen_def_mail_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat maila dla nieudanego generowania definicji
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Nieudane generowanie definicji na serwerze: ' + _a + '.')
|| return('[BLAD] Nieudane generowanie definicji na serwerze.')
?}


\check_pth_mail_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat maila dla nieudanego sprawdzenia na svn zgodności katalogu pth
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Na svn zmieniono katalog pth na serwerze: ' + _a + '.')
|| return('[BLAD] Na svn zmieniono katalog pth na serwerze.')
?}


\check_mod_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat maila dla przykrywaniu standardu przez zmiany standardowe
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Zmiany wdrożeniowe przykryją zmiany standardowe na serwerze: ' + _a + '.')
|| return('[BLAD] Zmiany wdrożeniowe przykryją zmiany standardowe na serwerze.')
?}


\transfer_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat i treść maila, gdy transfer się nie udał
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Tranfer się nie powiódł na serwerze: ' + _a + '.')
|| return('[BLAD] Tranfer się nie powiódł na serwerze.')
?}


\ok_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat maila, gdy proces powiódł się
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| {? (_a*'<?xml')<>0
   || return('[OK] Proces uaktualniajacy system powiódł się na serwerze: ' +
           exec('get_elem','%transfer',_a,'nazwa_instancji') + '.')
   || return('[OK] Proces uaktualniajacy system powiódł się na serwerze: ' + _a + '.')
   ?}
|| return('[OK] Proces uaktualniajacy system powiódł się na serwerze.')
?}


\nieokr_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca temat i treść maila, gdy cos się nie udało
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Nieokreślony problem blokujący proces: ' + _a + '.')
|| return('[BLAD] Nieokreślony problem blokujący proces.')
?}


\wyn_wer_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Sprawdza poziom problemow wstepnej weryfikacji
::   WE: _a - xml z wynikiem
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? exec('get_elem','%transfer',_a,'definicja_systemu')*'BŁĄD'=1
|| 'gen_def_mail'
|? exec('get_elem','%transfer',_a,'zgodność_katalogu_pth')*'BŁĄD'=1
|| 'check_pth_mail'
|? exec('get_elem','%transfer',_a,'zmiany_w_standardzie_przykryte_przez_modified')*'BŁĄD'=1
|| 'check_mod'
|| 'nieokr'
?}


\ok_body
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca treść maila, gdy proces ZWS_TRAN powiódł się
::   WE: _a - nazwa instancji serwera
::       _b - wynik czynności sprawdzenia, czy wygenerowano lub skopiowano definicję systemu
::       _c - wynik czynności weryfikacji katalogu pth
::       _d - wynik czynności weryfikacji katalogu modified
::       _e - wynik czynności aktualizacji svn
::       _f - wynik czynności webserwer start
::       _g - wynik czynności transferu danych
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| _msg:='Proces uaktualniajacy system powiódł się na serwerze: ' + _a + '.\n\n'
|| _msg:='Proces uaktualniajacy system powiódł się na serwerze.\n\n'
?};
{? var_pres('_b')=type_of('') & _b <> ''
|| _msg+='Definicja systemu:\n';
   _msg+=_b+'\n\n'
?};
{? var_pres('_c')=type_of('') & _c <> ''
|| _msg+='Sprawdzenie, czy pth nie ulegną zmianie podczas aktualizacji svn:\n';
   _msg+=_c+'\n\n'
?};
{? var_pres('_d')=type_of('') & _d <> ''
|| _msg+='Sprawdzenie, czy zmiany w modified nie przykryją zmian w standardzie:\n';
   _msg+=_d+'\n\n'
?};
{? var_pres('_e')=type_of('') & _e <> ''
|| _msg+='Aktualizacja SVN:\n';
   _msg+=_e+'\n\n'
?};
{? var_pres('_f')=type_of('') & _f <> ''
|| _msg+='Start webserwera:\n';
   _msg+=_f+'\n\n'
?};
{? var_pres('_g')=type_of('') & _g <> ''
|| _msg+='Transfer danych:\n';
   _msg+=_g+'\n\n'
?};
return(_msg)


\trex_ok_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat i treść maila, gdy proces naniesienia paczki powiódł się
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[OK] Proces wgrania paczki u klienta powiódł się na serwerze: ' + _a + '.')
|| return('[OK] Proces wgrania paczki u klienta powiódł się na serwerze.')
?}


\trex_ok_body
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca treść maila, gdy proces TRPR powiódł się
::   WE: _a - nazwa instancji serwera
::       _b - wynik czynności rozpakowania paczki
::       _c - wynik czynności wyliczenia sumy kontrolnej
::       _d - wynik czynności transferu danych
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| _msg:='Proces wgrania paczki u klienta powiódł się na serwerze: ' + _a + '.\n\n'
|| _msg:='Proces wgrania paczki u klienta powiódł się na serwerze.\n\n'
?};
{? var_pres('_b')=type_of('') & _b <> ''
|| _msg+='Rozpakowanie paczki:\n';
   _msg+=_b+'\n\n'
?};
{? var_pres('_c')=type_of('') & _c <> ''
|| _msg+='Weryfikacja sumy kontrolnej:\n';
   _msg+=_c+'\n\n'
?};
{? var_pres('_d')=type_of('') & _d <> ''
|| _msg+='Transfer danych:\n';
   _msg+=_d+'\n\n'
?};
return(_msg)


\trpr_ok_body
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca treść maila, gdy proces TRPR powiódł się
::   WE: _a - nazwa instancji serwera
::       _b - wynik czynności naniesienia zmian na def
::       _c - wynik czynności weryfikacji katalogu pth
::       _d - wynik czynności weryfikacji katalogu modified
::       _e - wynik czynności sprawdzenia aktualizacji svn
::       _f - wynik czynności przygotowania paczki sprzed aktualizacji
::       _g - wynik czynności przygotowania paczki aktualizacyjnej
::       _h - wynik czynności aktualizacji svn katalogu merit
::       _i - wynik czynności aktualizacji svn katalogu modified
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| _msg:='Została przygotowana paczka aktualizacyjna na serwerze: ' + _a + '.\n\n'
|| _msg:='Została przygotowana paczka aktualizacyjna na serwerze.\n\n'
?};
{? var_pres('_b')=type_of(0)
|| _msg+='Naniesienie zmian na def:\n';
   _msg+=$_b+'\n\n'
?};
{? var_pres('_c')=type_of('') & _c <> ''
|| _msg+='Sprawdzenie, czy pth nie ulegną zmianie podczas aktualizacji svn:\n';
   _msg+=_c+'\n\n'
?};
{? var_pres('_d')=type_of('') & _d <> ''
|| _msg+='Sprawdzenie, czy zmiany w modified nie przykryją zmian w standardzie:\n';
   _msg+=_d+'\n\n'
?};
{? var_pres('_e')=type_of('') & _e <> ''
|| _msg+='Aktualizacja SVN:\n';
   _msg+=_e+'\n\n'
?};
{? var_pres('_h')=type_of('') & _h <> ''
|| _msg+='Aktualizacja SVN katalogu merit:\n';
   _msg+=_h+'\n\n'
?};
{? var_pres('_i')=type_of('') & _i <> ''
|| _msg+='Aktualizacja SVN katalogu modified:\n';
   _msg+=_i+'\n\n'
?};
{? var_pres('_f')=type_of('') & _f <> ''
|| _msg+='Przygotowanie paczki ze stanem systemu przed aktualizacją:\n';
   _msg+=_f+'\n\n'
?};
{? var_pres('_g')=type_of('') & _g <> ''
|| _msg+='Przygotowanie paczki aktualizacyjnej:\n';
   _msg+=_g+'\n\n'
?};
return(_msg)


\trpr_ok_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat i treść maila, gdy proces przygotowania paczki powiódł się
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[OK] Została przygotowana paczka aktualizacyjna na serwerze: ' + _a + '.')
|| return('[OK] Została przygotowana paczka aktualizacyjna na serwerze.')
?}


\hash_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat i treść maila dla przykrywaniu standardu przez zmiany standardowe
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Suma kontrolna plików u klienta nie jest zgodna z sumą kontrolną na serwerze przed aktualizacją na serwerze: ' + _a + '.')
|| return('[BLAD] Suma kontrolna plików u klienta nie jest zgodna z sumą kontrolną na serwerze przed aktualizacją na serwerze.')
?}


\unpack_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat maila dla nieudanego rozpakowania paczki
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Nieudane rozpakowanie paczki aktualizacyjnej na serwerze: ' + _a + '.')
|| return('[BLAD] Nieudane rozpakowanie paczki aktualizacyjnej na serwerze: na serwerze.')
?}


\unpack_body
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca treść maila dla nieudanego rozpakowania paczki
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('Nieudane rozpakowanie paczki aktualizacyjnej na serwerze: ' + _a + '.\n'+
          'Czynność zwróciła wynik: ' + _b)
|| return('Nieudane rozpakowanie paczki aktualizacyjnej na serwerze: na serwerze.\n'+
         'Czynność zwróciła wynik: ' + _b)
?}


\nanies_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat i treść maila dla nieudanego nanoszenia zmian na def
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Nieudane nanoszenie zmian na definicję w MacroBuilderze na serwerze przed aktualizacją na serwerze: ' + _a + '.')
|| return('[BLAD] Nieudane nanoszenie zmian na definicję w MacroBuilderze na serwerze.')
?}


\gen_bck_pack_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat i treść maila dla nieudanego generowania paczki backup
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Nieudane tworzenie paczki z plikami przezd aktualizacją systemu na serwerze: ' + _a + '.')
|| return('[BLAD] Nieudane tworzenie paczki z plikami przezd aktualizacją systemu na serwerze.')
?}


\svn_up_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat maila dla nieudanego svn update
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Nieudana aktualizacja svn na serwerze: ' + _a + '.')
|| return('[BLAD] Nieudana aktualizacja svn na serwerze.')
?}


\compare_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat i treść maila dla nieudanego svn update
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Transfer nie jest możliwy do wykonania przez proces na serwerze: ' + _a + '.')
|| return('[BLAD] Transfer nie jest możliwy do wykonania przez proces na serwerze.')
?}


\compare_body
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat i treść maila dla nieudanego svn update
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of('') & _b <> ''
|| {? var_pres('_a')=type_of('') & _a <> ''
   || return(_b+' ' + 'Sytuacja wystąpiła na serwerze: ' + _a + '.')
   || return(_b)
   ?}
|| return('Transfer nie jest możliwy do wykonania przez proces na serwerze.')
?}


\svn_konflikt_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca temat i treść maila gdy Wystąpiły konflikty podczas aktualizacji svn
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Wystąpiły konflikty podczas aktualizacji svn na serwerze: ' + _a + '.')
|| return('[BLAD] Wystąpiły konflikty podczas aktualizacji svn.')
?}


\get_conf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Obiekt zwracający konfigurację automatu do transferu
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_conf_obj:=obj_new('ODBC_NAME','SVN_PATH','SVN_EXE_PATH');
_conf_obj.ODBC_NAME:='';
_conf_obj.SVN_PATH:='';
_conf_obj.SVN_EXE_PATH:='';
return(_conf_obj)


\gen_def_odbc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Pobieranie defa poprzez odbc
::   WE: _a - json z konfiguracja procesu
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_odbc_name:='';
{? exec('latest_proc','%transfer')
|| _odbc_name:=exec('cfg_get_elem','%transfer',_a,'builder_dsn');
   _dane_builder:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'MB_record_id'))
||
::   WE: _a - nazwa źródła danych odbc
::       _b - rekord do poświadczeń odbc do MacroBuildera
   {? var_pres('_a')=type_of('')
   || _odbc_name:=_a
   || _conf_obj:=exec('get_conf','%transfer');
      _odbc_name:=_conf_obj.ODBC_NAME
   ?};
   _dane_builder:=_b
?};
{? _odbc_name<>''
|| POCZTAM.cntx_psh();
   POCZTAM.prefix();
   {? var_pres('_dane_builder')=type_of(null()) & POCZTAM.seek(_dane_builder)
   || _username:=POCZTAM.USER;
      _password:=exec('pwd_decode','#string',POCZTAM.PASS,exec('encode_key','#mailbox'),1);
      _ocon:=odbc_con(_odbc_name,_username,_password)
   || _ocon:=odbc_con(_odbc_name)
   ?};
   POCZTAM.cntx_pop();
   _ocon.prepare('{call gen_def@batch(?)}');
   _ocon.prm_set(1,'@'+pth_dir('merit.def'));
   _tab:=_ocon.exec_tab();
   {? var_pres('_tab')>100 & _tab.first()
   || _can_continue:=_tab.RES;
      {? _tab.OPIS*'powodzenie'>0
      || return(1)
      || return(0)
      ?}
   || return(0)
   ?}
|| return(0)
?}


\czy_transfer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ, WH [20.42]
:: OPIS: Wywołuje i przetwarza wynik porównania defów. Zwraca tekst informujący, czy transfer jest wymagany.
::   WE:  _a - json z konfiguracja procesu
::        _b - xml z wynikami procesu
::       [_c]- xml z wynikiem po recznych
::   WY: STRING - informacja, czy transfer wymagany.
::----------------------------------------------------------------------------------------------------------------------
{? exec('latest_proc','%transfer')
|| _cfg:=exec('cfg_get_elem','%transfer',_a,'macro_cfg_linux')
||
::   WE: [_a] [STRING] - Ścieżka do katalogu konfiguracyjnego serwera. Parametr niezbędny pod Linuxem, jeżeli serwer
::                       nie używa domyślnej wartości parametru "synchr_num".
::       [_b] [STRING] - xml z wynikami procesu
   {? var_pres('_a')=type_of('')
   || _cfg:=_a
   || _cfg:=''
   ?}
?};

_sep:=exec('sep','#file',1);
_new:=exec('czy_transfer','zws');
_result:='';
{? _new>0
||
::    Jest plik new, uruchamiam madmin.exe
   _workdir:=exec('workdir','%transfer');
   _filepath:=_workdir+_sep+$SYSLOG.tm_stamp()+'.txt';
   _mad:=exec('madmin_compare','%transfer',_filepath,_cfg);
   _diff_none:=0;
   _diff_tran:=0;
   _can_continue:=1;
   {? _mad=0
   ||
::       Analizuję plik
      _file:=fopen(_filepath,'r',0,,1);
      _conv:=iconv('UTF-8');
      {? _file.is_open()
      ||
         _txt:='';
         {!
         |?
            _line:=_file.fread();
            {? _line<>'\n'
            ||
               {? sys_name(1)='WINDOWS'
               || _line:=STR.s852maz(_line)
               |? sys_name(1)='U_LINUX'
               || _line:=_conv.from(_line)
               ?};
               _txt+=_line+'\n';
               {? _line*'nie wykryto'>0 & _line*'w strukturze tabel'>0
               || _diff_none:=1;
                  _can_continue:=0
               |? _line*'tabela'>0
               || _diff_tran:=1;
                  _can_continue:=0
               ?}
            ?};
            _line<>'\n' & _can_continue
         !};
         _file.fclose();
         {? _diff_tran>0
         ||
:: transfer wymagany
            _result:='OK. Transfer wymagany. Wykryto różnice w strukturach.'
         ?};
         {? _diff_none>0
         ||
:: transfer niepotrzebny
            _result:='OK. Transfer niewymagany. Brak różnic w strukturach.'
         ?}
      || _result:='BŁĄD. Zapis pliku z wynikiem porównania definicji się nie udał. Transfer w locie może się nie powiedzie.'
      ?}
   ||
:: Compare zwrócił wartość <>0, transfer się nie uda
      _result:='UWAGA. Transfer wymagany. Transfer w locie się nie powiedzie.'
   ?};
   ferase(_filepath,0)
||
:: Brak pliku new
   _result:='BŁĄD. Brak pliku new. Transfer w locie się nie powiedzie.'
?};
{? var_press('_b')=type_of('') & _b<>''
|| _result:=exec('set_elem','%transfer',_b,'transfer_możliwy',_result);
   {? var_pres('_c')>0 & _c<>''
   || _ptf_m:=exec('get_elem','%transfer',_c,'zgodność_katalogu_pth');
      _mod_m:=exec('get_elem','%transfer',_c,'zmiany_w_standardzie_przykryte_przez_modified');
      _result:=exec('set_elem','%transfer',_result,'zgodność_katalogu_pth',_ptf_m);
      _result:=exec('set_elem','%transfer',_result,'zmiany_w_standardzie_przykryte_przez_modified',_mod_m)
   ?}
?};
_result


\madmin_compare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Uruchamia madmin.exe z opcją compare i zapisuje wynik do pliku do dalszego przetworzenia
::   WE: _a  - STRING - ścieżka do pliku który wypełnić zawartością
::      [_b] - [STRING] - Ścieżka do katalogu konfiguracyjnego serwera. Parametr niezbędny pod Linuxem, jeżeli serwer
::                        nie używa domyślnej wartości parametru "synchr_num".
::      [_c] - [STRING] - typ compare który wymuszać 'compare'/'compare-map', domyślnie typ compare zależny od tego
::                        czy istnieje plik merit.mapnew
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_file:=_a;
{? var_pres('_b')=type_of('')
|| _cfg:=_b
|| _cfg:=''
?};
{? var_pres('_c')=type_of('') & (_c='compare' | _c='compare-map')
|| _type_cmp:=_c
|| _type_cmp:=''
?};
_sep:=exec('sep','#file',1);
_itg:=pth_dir('systems.itg')+_sep+'systems.itg';
_cmd:=
   {? sys_name(1)='U_LINUX'
   || {? (_type_cmp='' & exec('czy_mapnew','zws')='') | _type_cmp='compare'
      || 'sh -c \"%1/MacroADMIN %2 -compare %3 > %4\"'[exe_dir(1),{? _cfg='' || '' || '-p'+_cfg ?}, _itg, _file]
      || 'sh -c \"%1/MacroADMIN %2 -compare-map %3 > %4\"'[exe_dir(1),{? _cfg='' || '' || '-p'+_cfg ?}, _itg, _file]
      ?}
   || {? (_type_cmp='' & exec('czy_mapnew','zws')='') | _type_cmp='compare'
      || envget('COMSPEC')+' /c ' + '\"\"%1madmin.exe\" -compare \"%2\" > \"%3\"\"'[exe_dir(1)+_sep,_itg,_file]
      || envget('COMSPEC')+' /c ' + '\"\"%1madmin.exe\" -compare-map \"%2\" > \"%3\"\"'[exe_dir(1)+_sep,_itg,_file]
      ?}
   ?};
_err:=system(_cmd,1);
_err


\czy_new
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [19.22]
:: OPIS: Formuła sprawdzająca czy jest nowa definicja systemu
::   WY: Czy jest plik merit.new
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',2);
_file:=pth_dir('merit.def')+_sep+'merit.new';

_wyn:=fexists(_file,0);
_wyn


\local_info_pth
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS:
::   WE: [_a] - Ścieżka do wypakowanego katalogu z paczką aktualizacyjną
::   WY: (0,1) - 1, gdy są zmianyw  katalogu pth
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_res:=fexists(_a+_sep+'pth',0);
{? _res=1
|| return('Błąd. W paczce znajduje się katalog pth. Należy wykonać transfer na wyłączonym serwerze.')
|| return('Ok. Podczas kopiowania paczki katalog pth nie zostanie zmieniony.')
?}


\svn_info_pth
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: svn_info dla katalogu pth
::   WE: _a - json z konfuguracja procesu
::      [_b] - xml z wynikiem procesu
::   WY: [STRING] - BŁĄD(...) gdy są zmiany na svn w danym katalogu., OK(...) gdy nie ma zmian w danym katalogu
::       gdy podany parametr _b wynikiem jest xml ze zaktualizowanym statusem
::----------------------------------------------------------------------------------------------------------------------
{? exec('latest_proc','%transfer')
|| _svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));
   _sep:=exec('sep','#file',2);
   _pth_dir:=exec('cfg_get_elem','%transfer',_a,'pth_path');

   {? var_pres('_pth_dir')=type_of('') & _pth_dir=''
   || _pth_dir:=((pth_dir()*(_sep+'pth'))+3)+pth_dir()
   ?};
   _status:=exec('svn_refresh','%transfer',_pth_dir,_svn);
   {? var_pres('_b')=type_of('') & _b<>''
   || _status:=exec('set_elem','%transfer',_b,'zgodność_katalogu_pth',_status)
   ?}
||
::   WE: _a - POCZTAM.ref()
::       _b - ścieżka do kalagu pth
::       _c - [STRING] xml - statusy procesu
::   WY: [STRING] - BŁĄD(...) gdy są zmiany na svn w danym katalogu., OK(...) gdy nie ma zmian w danym katalogu
::       gdy podany parametr _c wynikiem jest xml ze zaktualizowanym statusem
   _sep:=exec('sep','#file',2);

   {? var_pres('_b')=type_of('') & _b<>''
   || _pth_dir:=_b
   || _pth_dir:=((pth_dir()*(_sep+'pth'))+3)+pth_dir()
   ?};
   _status:=exec('svn_refresh','%transfer',_pth_dir,_a);
   {? var_pres('_c')=type_of('') & _c<>''
   || _status:=exec('set_elem','%transfer',_c,'zgodność_katalogu_pth',_status)
   ?}
?};
_status


\svn_refresh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42] MOD GZ [20.42]
:: OPIS: Sprawdza, czy zawartość katalogu była zmodyfikowana od ostatniego update
::   WE: [_a] - ścieżka do katalogu lokalnej kopii svn
::       [_b] - POCZTAM.ref()
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_path:='';
{? var_pres('_a')=type_of('')
|| _path:=_a
|| _path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()
?};

_status:='';
_can_continue:=1;
{? _path<>''
|| {? fexists(_path)<>2
   || _status:='Brak katalogu: %1'@[_path];
      _can_continue:=0
   ?};
:: w jakiej rewizji jest lokalna kopia svn
   {? _can_continue>0
   || _res_local:=exec('parse_svn_info','%transfer',_path,_b);
      {? _res_local.ERROR=''
      ||
:: w jakiej rewizja jest na serwerze
         {? _res_local.URL<>''
         || _res_remote:=exec('parse_svn_info','%transfer',_res_local.URL,_b);

            {? _res_remote.ERROR=''
            ||

               {? _res_local.COMMIT_REVISION<>'' & _res_remote.COMMIT_REVISION<>''
               || _r_loc:=#_res_local.COMMIT_REVISION;
                  _r_rem:=#_res_remote.COMMIT_REVISION;
                  {? _r_loc<>_r_rem
                  || _status:='BŁĄD. Nowa rewizja na SVN: %1 [%2]'@[_res_remote.COMMIT_REVISION,_res_remote.AUTHOR]
                  || _status:='OK. Lokalna kopia zgodna z serwerem. Aktualna rewizja: %1'@[_res_remote.COMMIT_REVISION]
                  ?}
               || _can_continue:=0;
                  _status:='BŁĄD. Nie udało się pobranie numerów rewizji'@
               ?}
            || _can_continue:=0;
               _status:=_res_remote.ERROR
            ?}
         ?}
      || _can_continue:=0;
         _status:=_res_local.ERROR
      ?}
   ?}
?};
_status


\parse_svn_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Pobiera informacje z SVN.
::   WE: _a - STRING - ścieżka do repo
::       _b - POCZTAM.ref()
::   WY: obiekt
::----------------------------------------------------------------------------------------------------------------------
_repo:=_a;

_obj:=obj_new('ELEMENT','ERROR','URL','COMMIT_REVISION','ENTRY_REVISION','AUTHOR');
_obj.ELEMENT:='';
_obj.ERROR:='';
_obj.URL:='';
_obj.COMMIT_REVISION:='';
_obj.ENTRY_REVISION:='';
_obj.AUTHOR:='';

_can_continue:=1;

_sep:=exec('sep','#file',1);
_workdir:=exec('workdir','%transfer');
_filename:=_workdir+_sep+$SYSLOG.tm_stamp()+'.xml';
_errlog:=pth_dir('svninerr.log')+_sep+'svninerr.log';
_iter:=2;
{!
|?
   _can_continue:=exec('svn_info','%transfer',_filename,_repo,,_b);
   {? _can_continue>0
   ||
      _file:=fopen(_filename,'r',0,,1);

      {? _file.is_open()
      ||

         params_set('obj',_obj);

         xml_sax_parse(_file
::    Start document
         ,""
::    End document
         ,""
::    Start element
         ,
         "
            _obj:=params_get().obj;
            _obj.ELEMENT:=_a;

            {? _obj.ELEMENT='entry'
            || {? type_of(_e)>100
               || {? _e[1]='revision'
                  || _obj.ENTRY_REVISION:=_e[4]
                  ?}
               ?}
            |? _obj.ELEMENT='commit'
            || {? type_of(_e)>100
               || {? _e[1]='revision'
                  || _obj.COMMIT_REVISION:=_e[4]
                  ?}
               ?}
            ?};
            1
         "
::    End element
         ,"
            _obj:=params_get().obj;
            _obj.ELEMENT:='';
            1
         "
::    Text
         ,
         "
            _obj:=params_get().obj;
            _txt:=_a;
            {? _txt<>'' & _txt<>'\n'
            || {? _obj.ELEMENT='url'
               || _obj.URL:=_txt
               |? _obj.ELEMENT='author'
               || _obj.AUTHOR:=_txt
               ?}
            ?};
            1
         "
::    Comment
         ,""
         )
      ?};
      fclose(_file);
      ferase(_filename,0);
      ~~
   || _iter-=1;
      exec('queue_restart','%transfer');
      delay(60);
      _filelog:=pth_dir('svninerr.log')+_sep+'svninfo.log';
      _can_continue:=exec('svn_info','%transfer',_filelog,_repo,,_b,0)
   ?};
   _can_continue=0 & _iter>0
!};
{? _can_continue=0 & _iter=0
|| _filel:=fopen(_errlog,'r',0,,1);
   _obj.ERROR:='Błąd wykonywania polecenia: \'%1\'\n'['svn info'];
   {? _filel.is_open()
   || {!
      |? (_wiersz:=fread(_filel))<>'\n'
      |! _obj.ERROR+=_wiersz+'\n'
      !};
      fclose(_filel)
   ?};
   ferase(_errlog,0)
?};
_obj


\svn_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Uruchamia polecenie svn z opcją info i wynik wypluwa do pliku
::   WE:
::       [_a] - STRING - ścieżka do pliku który wypełnić zawartością
::       [_b] - STRING - ścieżka do SVN
::       [_c] - ścieżka do pliku wykonywalnego svn_exe
::       [_d] - POCZTAM.ref()
::       [_e] - domyślnie 1 - czy wynik zwracać w postaci xml
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_c')=type_of('')
|| _exe_path:=_c
|| _exe_path:=''
?};
{? var_pres('_e')=type_of(1) & _e=0
|| _par_xml:=''
|| _par_xml:='--xml'
?};
_file:=_a;
_path:=_b;
_sep:=exec('sep','#file',1);
_result:=0;
_username:='';
_password:='';
POCZTAM.cntx_psh();
POCZTAM.prefix();
{? var_pres('_d')=type_of(null()) & POCZTAM.seek(_d)
|| _username:=POCZTAM.USER;
   _password:=POCZTAM.PASS
?};
POCZTAM.cntx_pop();
_errlog:=pth_dir('svninerr.log')+_sep+'svninerr.log';
:: Złożenie komendy svn
{? _exe_path<>'' & sys_name(1)<>'U_LINUX'
|| _command:='"%1svn.exe" '[_exe_path+_sep]
|| _command:='svn '
?};
{? sys_name(1)='U_LINUX'
|| {? _username<>''
   || _command+='info --username %1 --password %2 --trust-server-cert --non-interactive --no-auth-cache '
                '%5 %3 > %4 2> %6'
                [_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1)
                ,_path,_file,_par_xml,_errlog]
   || _command+='info --non-interactive %3 %1 > %2 2> %4'[_path,_file,_par_xml,_errlog]
   ?}
|| {? _username<>''
   || _command+='info --username %1 --password %2 --trust-server-cert --non-interactive --no-auth-cache '
                '%5 \"%3\" > \"%4\" 2> \"%6\"'
                [_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1)
                ,_path,_file,_par_xml,_errlog]
   || _command+='info --non-interactive %3 \"%1\" > \"%2\" 2> \"%4\"'[_path,_file,_par_xml,_errlog]
   ?}
?};

:: Wykonanie komendy svn
{? sys_name(1)='U_LINUX'
|| _sys_res:=system('sh -c \"' + _command +'\"',1)
|| _sys_res:=system(envget('COMSPEC')+' /c ' + '\"'+ _command + '\"',1)
?};
{? _sys_res<>0
|| _result:=0
|| _result:=1
?};
_result


\svn_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Uruchamia aktualizację SVN
::   WE: [_a] - ścieżka (domyślnie katalog główny aplikacji)
::       [_b] - POCZTAM.ref - wskazanie na dane logowania do svn
::       [_c] - ścieżka do loga.
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_path:='';
_username:='';
_password:='';
_sep:=exec('sep','#file',1);
_workdir:=exec('workdir','%transfer');
_errlog:=pth_dir('svnuperr.log')+_sep+'svnuperr.log';
{? var_pres('_a')=type_of('') & _a<>'modified' & _a<>'def' & _a<>'pth' & _a<>'merit'
|| _path:=_a
|? var_pres('_a')=type_of('') & _a='modified'
|| _path:=((pth_dir('.m.fml')*(_sep+'fml'))-1)+pth_dir('.m.fml')
|? var_pres('_a')=type_of('') & _a='pth'
|| _path:=exec('dir_from_path','#file',pth_dir('pth'))
|? var_pres('_a')=type_of('') & _a='def'
|| _path:=(((pth_dir()*(_sep+'pth'))-1)+pth_dir())+_sep+'defy'+_sep+'merit.def'
|| _path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
?};
POCZTAM.cntx_psh();
POCZTAM.prefix();
{? var_pres('_b')=type_of(null()) & POCZTAM.seek(_b)
|| _username:=POCZTAM.USER;
   _password:=POCZTAM.PASS
?};
POCZTAM.cntx_pop();
{? var_pres('_c')=type_of('')
|| _log_path:=_c
|| _log_path:=_workdir+_sep+'svn'+$SYSLOG.tm_stamp()+'.log'
?};
_log_cl_path:=_workdir+_sep+'svn_cl_'+$SYSLOG.tm_stamp()+'.log';
{? var_pres('_a')=type_of('') & _a='modified'
|| _local_log_path:=_workdir+_sep+'svn_update_modified'+$SYSLOG.tm_stamp()+'.log'
|? var_pres('_a')=type_of('') & _a='pth'
|| _local_log_path:=_workdir+_sep+'svn_update_pth'+$SYSLOG.tm_stamp()+'.log'
|? var_pres('_a')=type_of('') & _a='def'
|| _local_log_path:=_workdir+_sep+'svn_update_def'+$SYSLOG.tm_stamp()+'.log'
|| _local_log_path:=_workdir+_sep+'svn_update'+$SYSLOG.tm_stamp()+'.log'
?};

:: revert
_exe_path:='';
{? _path<>''
||
   _path:=gsub(_path,'\\\\','\\');

   _result:=0;
   {? _exe_path<>''
   || _command:='"%1TortoiseProc.exe" /command:revert /path:"%2"'[_exe_path+_sep,_path]
   || {? sys_name(1)='U_LINUX'
      || {? _username<>''
         ||
            _command:='svn revert %1 --recursive --username %2 --password %3 --non-interactive --trust-server-cert '
                      '--no-auth-cache > %4'
                      [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_cl_path]
         || _command:='svn revert %1 --recursive --non-interactive --trust-server-cert > %2'[_path,_log_cl_path]
         ?}
      || {? _username<>''
         ||
            _command:='svn revert "%1" --recursive --username %2 --password %3 --non-interactive --trust-server-cert '
                      '--no-auth-cache > "%4"'
                      [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_cl_path]
         || _command:='svn revert "%1" --recursive --non-interactive --trust-server-cert > "%2"'[_path,_log_cl_path]
         ?}
      ?}
   ?};
   {? sys_name(1)='U_LINUX'
   || _sys_res:=system('sh -c \"' + _command +'\"',1)
   || _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1)
   ?};
   ferase(_log_cl_path);
:: cleanup
   {? _exe_path<>''
   || _command:='"%1TortoiseProc.exe" /command:cleanup /path:"%2"'[_exe_path+_sep,_path]
   || {? sys_name(1)='U_LINUX'
      || {? _username<>''
         ||
            _command:='svn cleanup %1 --username %2 --password %3 --non-interactive --trust-server-cert '
                      '--no-auth-cache > %4'
                      [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_cl_path]
         || _command:='svn cleanup %1 --non-interactive --trust-server-cert > %2'[_path,_log_cl_path]
         ?}
      || {? _username<>''
         ||
            _command:='svn cleanup "%1" --username %2 --password %3 --non-interactive --trust-server-cert '
                      '--no-auth-cache > "%4"'
                      [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_cl_path]
         || _command:='svn cleanup "%1" --non-interactive --trust-server-cert > "%2"'[_path,_log_cl_path]
         ?}
      ?}
   ?};
   {? sys_name(1)='U_LINUX'
   || _sys_res:=system('sh -c \"' + _command +'\"',1)
   || _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1)
   ?};
   ferase(_log_cl_path);
   {? _exe_path<>''
   || _command:='"%1TortoiseProc.exe" /command:update /path:"%2"'[_exe_path+_sep,_path]
   || {? sys_name(1)='U_LINUX'
      || {? _username<>''
         ||
            _command:='svn update %1 --username %2 --password %3 --accept theirs-full --non-interactive --trust-server-cert '
                      '--no-auth-cache > %4 2> %5'
                      [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1)
                      ,_local_log_path,_errlog]
         || _command:='svn update %1 --accept theirs-full --non-interactive --trust-server-cert > %2 2> %3'[_path,_local_log_path,_errlog]
         ?};
         _command2:='cat %1 >> %2'[_local_log_path,_log_path]
      || {? _username<>''
         ||
            _command:='svn update "%1" --username %2 --password %3 --accept theirs-full --non-interactive --trust-server-cert '
                      '--no-auth-cache > "%4" 2> "%5"'
                      [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1)
                      ,_local_log_path,_errlog]
         || _command:='svn update "%1" --accept theirs-full --non-interactive --trust-server-cert > "%2" 2> "%3"'[_path,_local_log_path,_errlog]
         ?};
         _command2:='type "%1" >> "%2"'[_local_log_path,_log_path]
      ?}
   ?};
   {? sys_name(1)='U_LINUX'
   || _sys_res:=system('sh -c \"' + _command +'\"',1);
      _sys_res:=system('sh -c \"' + _command2 +'\"',1)
   || _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1);
      _sys_res:=system(envget('COMSPEC')+' /c ' + _command2,1)
   ?};
   ferase(_local_log_path)
?};
:: przetwarzamy wynik
_result:='';
_updated:=0;
_conflicts:=0;
_skipped:='';
_flog:=fopen(_log_path,'r',0);
_conv:=iconv('Windows-1250');
{? _flog
|| {!
   |? (_wiersz:=fread(_flog))<>'\n'
   |!
      {? sys_name(1)<>'U_LINUX' || _wiersz:=_conv.from(_wiersz) ?};
      {? _wiersz*'At revision'>0 | _wiersz*'Updated to revision'>0
         | _wiersz*'W wersji'>0 | _wiersz*'Uaktualniono do wersji'>0
      || _updated:=1
      ?};
      {? _wiersz*'Summary of conflicts'>0 | _wiersz*'Podsumowanie konfliktów'>0
      || _conflicts:=1
      ?};
      {? _wiersz*'Skipped'>0 & _wiersz*'Skipped paths:'=0
      || _skipped+=(_wiersz*'Skipped'+(+'Skipped')-1-_wiersz)
      ?};
      {? _wiersz*'Pominięto'>0 & _wiersz*'Pominięte ścieżki:'=0
      || _skipped+=(_wiersz*'Pominięto'+(+'Pominięto')-1-_wiersz)
      ?};
      _result+=_wiersz+'\n'
   !};
   fclose(_flog)
?};
{? _conflicts
|| {? +_skipped
   || _result:='BŁĄD.\nPominięte lokalizacje:\n'+_skipped+'\nPełny wynik:\n'+_result
   || _result:='OK, ale wystąpiły konflikty.\n'+_result
   ?}
|? _updated
|| _result:='OK.\n'+_result
|| _result:='BŁĄD.\n'+_result
?};
{? var_pres('_c')<>type_of('')
|| ferase(_log_path,0)
?};
_result


\svn_up_def
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [21.14]
:: OPIS: Wywołuje formułę svn_update z parametrami potrzebnymi do update katalogu z defem standardowym
::   WE: [_a] - json z konfiguracja procesu
::       [_b] - 1/0 czy wykonywać update defa standardowego
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_iter:=1;
_blad:=0;
_result:='';
{? exec('latest_proc','%transfer')
|| _svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));
   _copy_path:=exec('cfg_get_elem','%transfer',_a,'new_def');
   _do:={? exec('cfg_get_elem','%transfer',_a,'zws_tran_wer')='T' || _b || 1 ?}
||
::   WE: [_a] - ścieżka (domyślnie katalog główny aplikacji)
::       [_b] - POCZTAM.ref - wskazanie na dane logowania do svn
   _svn:=_b;
   _copy_path:=_a;
   _do:=1
?};
{? _do
|| {!
   |?
      {? var_pres('_copy_path')<>type_of('') | _copy_path = ''
      || _result:=params_exec('svn_update','%transfer','def',_svn)
      || _result:=params_exec('svn_update','%transfer',_copy_path,_svn)
      ?};
      {? 4+_result='BŁĄD'
      || _iter-=1;
         exec('queue_restart','%transfer');
         delay(30);
         _blad:=1
      || _blad:=0
      ?};
      _blad=1 & _iter>0
   !}
|| _result:='OK, nie wykonywano aktualizacji defa'
?};
_result


\svn_up_merit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [21.14]
:: OPIS: Wywołuje formułę svn_update z parametrami potrzebnymi do update katalogu merit
::   WE: [_a] - ścieżka (domyślnie katalog główny aplikacji)
::       [_b] - POCZTAM.ref - wskazanie na dane logowania do svn
::       [_c] - wynik exec('svn_plik','%transfer')
::       [_d] - xml z wynikami procesu
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_result:='';
_iter:=1;
_blad:=0;
{!
|?
   {? var_pres('_a')<>type_of('') | _a = ''
   || _pth_autotran:=pth_dir('autotran.cfg')+_sep+'autotran.cfg';
      fcopy(_pth_autotran,_pth_autotran+'.bak',0,0,1);
      {? var_pres('_c')<>type_of('') | _c = ''
      || _result:=params_exec('svn_update','%transfer','merit',_b)
      ||
::   dla ZWS_TRPR ścieżka pliku merit jest pierwsza
         {? _c*';' || _c:=spli_str(_c,';')[1] ?};
         _result:=params_exec('svn_update','%transfer','merit',_b,_c)
      ?}
   || _pth_autotran:=_a+_sep+'system'+_sep+'autotran.cfg';
      fcopy(_pth_autotran,_pth_autotran+'.bak',0,0,1);
      {? var_pres('_c')<>type_of('') | _c = ''
      || _result:=params_exec('svn_update','%transfer',_a,_b)
      ||
::   dla ZWS_TRPR ścieżka pliku merit jest pierwsza
         {? _c*';' || _c:=spli_str(_c,';')[1] ?};
         _result:=params_exec('svn_update','%transfer',_a,_b,_c)
      ?}
   ?};
   {? 4+_result='BŁĄD'
   || _iter-=1;
      exec('queue_restart','%transfer');
      delay(30);
      _blad:=1
   || _blad:=0
   ?};
   _blad=1 & _iter>0
!};
{? var_press('_d')=type_of('') & _d<>''
|| _result:=exec('set_elem','%transfer',_d,'aktualizacja_svn_merit',_result)
?};
_result


\svn_up_modified
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [21.14]
:: OPIS: Wywołuje formułę svn_update z parametrami potrzebnymi do update katalogu modified
::   WE: [_a] - json z konfiguracja procesu
::       [_b] - xml z wynikami procesu
::       [_c] - wynik exec('svn_plik','%transfer')
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
{? exec('latest_proc','%transfer')
|| _path:=exec('cfg_get_elem','%transfer',_a,'modified_path');
   {? var_pres('_modified_path')<>type_of('') | (var_pres('_modified_path')=type_of('') & _modified_path='')
   || _modified_path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'modified'
   ?};
   _svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));
   _wynik:=_b
||
::   WE: [_a] - ścieżka (domyślnie katalog główny aplikacji)
::       [_b] - POCZTAM.ref - wskazanie na dane logowania do svn
::       [_c] - wynik exec('svn_plik','%transfer')
::       [_d] - xml z wynikami procesu
   _path:=_a;
   _svn:=_b;
   _wynik:=_d
?};
_iter:=1;
_blad:=0;
{!
|?
   {? var_pres('_c')<>type_of('') | _c = ''
   ||
      {? var_pres('_path')<>type_of('') | _path = ''
      || _result:=params_exec('svn_update','%transfer','modified',_svn)
      || _result:=params_exec('svn_update','%transfer',_path,_svn)
      ?}
   ||
::   dla ZWS_TRPR ścieżka pliku modified jest druga
      {? _c*';' || _c:=spli_str(_c,';')[2] ?};
      {? var_pres('_path')<>type_of('') | _path = ''
      || _result:=params_exec('svn_update','%transfer','modified',_svn,_c)
      || _result:=params_exec('svn_update','%transfer',_path,_svn,_c)
      ?}
   ?};
   {? 4+_result='BŁĄD'
   || _iter-=1;
      exec('queue_restart','%transfer');
      delay(30);
      _blad:=1
   || _blad:=0
   ?};
   _blad=1 & _iter>0
!};
{? var_press('_wynik')=type_of('') & _wynik<>''
|| _result:=exec('set_elem','%transfer',_wynik,'aktualizacja_svn_modified',_result)
?};
_result


\svn_up_pth
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [21.14]
:: OPIS: Wywołuje formułę svn_update z parametrami potrzebnymi do update katalogu pth
::   WE: [_a] - json z konfiguracja procesu
::       [_b] - xml z wynikami procesu
::       [_c] - wynik exec('svn_plik','%transfer')
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
{? exec('latest_proc','%transfer')
|| _pth_dir:=exec('cfg_get_elem','%transfer',_a,'pth_path');
   {? var_pres('_pth_dir')=type_of('') & _pth_dir=''
   || _pth_dir:=((pth_dir()*(_sep+'pth'))+3)+pth_dir()
   ?};
   _svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));
   _wynik:=_b
||
::   WE: [_a] - ścieżka (domyślnie katalog główny aplikacji)
::       [_b] - POCZTAM.ref - wskazanie na dane logowania do svn
::       [_c] - wynik exec('svn_plik','%transfer')
::       [_d] - xml z wynikami procesu
   _pth_dir:=_a;
   _svn:=_b;
   _wynik:=_d
?};
_iter:=1;
_blad:=0;
{!
|?
   {? var_pres('_c')<>type_of('') | _c = ''
   ||
      {? var_pres('_pth_dir')<>type_of('') | _pth_dir = ''
      || _result:=params_exec('svn_update','%transfer','pth',_svn)
      || _result:=params_exec('svn_update','%transfer',_pth_dir,_svn)
      ?}
   ||
::   dla ZWS_TRPR ścieżka pliku pth jest trzecia
      {? _c*';' || _c:=spli_str(_c,';')[3] ?};
      {? var_pres('_pth_dir')<>type_of('') | _pth_dir = ''
      || _result:=params_exec('svn_update','%transfer','pth',_svn,_c)
      || _result:=params_exec('svn_update','%transfer',_pth_dir,_svn,_c)
      ?}
   ?};
   {? 4+_result='BŁĄD'
   || _iter-=1;
      exec('queue_restart','%transfer');
      delay(30);
      _blad:=1
   || _blad:=0
   ?};
   _blad=1 & _iter>0
!};
{? var_press('_wynik')=type_of('') & _wynik<>''
|| _result:=exec('set_elem','%transfer',_wynik,'aktualizacja_svn_pth',_result)
?};
_result


\svn_plik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca ścieżki do plików z wynikami svn update dla folderu merit i modified oddzielone ";"
::   WE:
::   WY: STRING - ściezki do plików
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_workdir:=exec('workdir','%transfer');
_res:=_workdir+_sep+'svn_update_merit'+$SYSLOG.tm_stamp()+'.log';
_res+=';';
_res+=_workdir+_sep+'svn_update_modified'+$SYSLOG.tm_stamp()+'.log';
_res+=';';
_res+=_workdir+_sep+'svn_update_pth'+$SYSLOG.tm_stamp()+'.log';
_res+=';';
_res+=_workdir+_sep+'svn_switch'+$SYSLOG.tm_stamp()+'.log';
return(_res)


\webserver_restart
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Restartuje usługę webservera (windows)
::   WE: _a - nazwa usługi
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('')
|| _service:=_a
|| _service:=''
?};
{? _service<>''
|| _command:='net stop %1'[_service];
   _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1);
   _command:='timeout 20';
   _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1);
   _command:='net start %1'[_service];
   _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1)
?};
~~


\webserver_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [21.14]
:: OPIS: Restartuje usługę webservera (windows)
::   WE: _a - json z konfiguracja procesu
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? exec('latest_proc','%transfer')
|| _service:=exec('cfg_get_elem','%transfer',_a,'webserver_service_name');
   _lin_comm:=exec('cfg_get_elem','%transfer',_a,'webserver_start')
||
::   WE: _a - nazwa usługi
::       _b polecenie dla Linux
   {? var_pres('_a')=type_of('')
   || _service:=_a
   || _service:=''
   ?};
   {? var_pres('_b')=type_of('')
   || _lin_comm:=_b
   || _lin_comm:=''
   ?}
?};

:: wyrejestrowanie użytkowników; uwaga wymaga aktualnego silnika 20.32
:: w przeciwnym wypadku wykonuje polecenie systemu przekazane parametrem lub restart usługi Windows
{? exec('is_fun','#file','__madmin','new')
|| exec('new','__madmin').del_mbasic_users()
|| {? sys_name(1)='U_LINUX'
   || {? _lin_comm<>''
      || _sys_res:=system('sh -c \"' + _lin_comm +'\"',1)
      ?}
   || {? _lin_comm<>''
      ||  _sys_res:=system(envget('COMSPEC')+' /c ' + _lin_comm,1)
      || {? _service<>''
         || _command:='net start %1'[_service];
            _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1)
         ?}
      ?}
   ?}
?};
~~


\webserver_stop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [21.14]
:: OPIS: Restartuje usługę webservera (windows)
::   WE: _a - json z konfiguracja procesu
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? exec('latest_proc','%transfer')
|| _service:=exec('cfg_get_elem','%transfer',_a,'webserver_service_name');
   _lin_comm:=exec('cfg_get_elem','%transfer',_a,'webserver_stop')
||
::   WE: _a - nazwa usługi
::       _b polecenie dla Linux
   {? var_pres('_a')=type_of('')
   || _service:=_a
   || _service:=''
   ?};
   {? var_pres('_b')=type_of('')
   || _lin_comm:=_b
   || _lin_comm:=''
   ?}
?};

{? exec('is_fun','#file','__madmin','new')
|| 1
:: Powyżej miejsce na formułę wdrożeniową
|| {? sys_name(1)='U_LINUX'
   || {? _lin_comm<>''
      || _sys_res:=system('sh -c \"' + _lin_comm +'\"',1)
      ?}
   || {? _lin_comm<>''
      ||  _sys_res:=system(envget('COMSPEC')+' /c ' + _lin_comm,1)
      || {? _service<>''
         || _command:='net stop %1'[_service];
            _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1)
         ?}
      ?}
   ?}
?};
~~


\kopiuj_defa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Kopiuje definicję systemu z katalogu defy do katalogu system
::   WE:
::   WY: (1,0) - wynik operacji kopiowania
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
{? exec('latest_proc','%transfer')
|| _copy_path:=exec('cfg_get_elem','%transfer',_a,'new_def');
   _svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));
   _zws_tran_wer:=exec('cfg_get_elem','%transfer',_a,'zws_tran_wer')='T'
|| _copy_path:=_a;
   _zws_tran_wer:=0
?};

{? var_pres('_copy_path')=type_of('') & _copy_path<>''
|| _src:=_copy_path
|| _src:=(((pth_dir()*(_sep+'pth'))-1)+pth_dir())+_sep+'defy'+_sep+'merit.def'
?};
_dest:=pth_dir('merit.def')+_sep+'merit.new';
{? _zws_tran_wer
|| _url_new_def:=exec('cfg_get_elem','%transfer',_a,'svn_url_new');
  {? _url_new_def<>''
  || exec('svn_export','%transfer',_url_new_def+'/defy/merit.def',_dest,_svn);
     _wynik:=fexists(_dest)
  ?}
|| _wynik:=fcopy(_src,_dest,0,0,1)
?};
exec('uprawnienia','%transfer',_dest);
_wynik


\uprawnienia
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [21.14]
:: OPIS: ustawia uprawnienia, dla systemu LINUX
::   WE: _a - [STRING] ścieżka do pliku
::       _b - [STRING] user do polecenia chown
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? sys_name(1)='U_LINUX' & var_press('_a')=type_of('') & _a<>''
||
::   {? var_press('_b')=type_of('') & _b<>''
::   || _user:=_b
::   || _user:='macroadm'
::   ?};
::   _command:='chown '+_user+':'+_user+' '+_a;
::   _sys_res:=system('sh -c \"' +_command + '\"',1);
   _command:='chmod 4400 '+_a;
   _sys_res:=system('sh -c \"' +_command + '\"',1)
?}


\czy_def_ok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca informacje, czy kopiowanie lub generowanie defa się udało
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? exec('latest_proc','%transfer')
|| _name:=exec('cfg_get_elem','%transfer',_e,'name')
|| _name:=_e
?};
_result:='OK, def nie był generowany ani kopiowany.';
{? var_pres('_a')=type_of(0)
|| {? _a=1
   || _result:='OK. Generowanie definicji systemu zakończone powodzeniem.'
   || _result:='BŁĄD. Generowanie definicji systemu zakończone niepowodzeniem.'
   ?}
|? var_pres('_b')=type_of(0)
|| {? _b=1
   || _result:='OK. Kopiowanie definicji systemu zakończone powodzeniem.'
   || _result:='BŁĄD. Kopiowanie definicji systemu zakończone niepowodzeniem.'
   ?}
|? var_pres('_c')=type_of('')
|| _result:=exec('get_elem','%transfer',_c,'definicja_systemu')
|? var_pres('_c')=type_of(0)
|| {? _c=1
   || _result:='OK. Nanoszenie zmian definicji systemu zakończone powodzeniem.'
   || _result:='BŁĄD. Nanoszenie zmian definicji systemu zakończone niepowodzeniem.'
   ?}
?};
{? var_pres('_d')=type_of('')
|| _result:=exec('set_elem','%transfer',_d,'definicja_systemu',_result);
   {? var_pres('_name')=type_of('')
   || _result:=exec('set_elem','%transfer',_result,'nazwa_instancji',_name)
   ?}
?};
_result


\parse_update_log
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS:
::   WE: _a - pierwszy log svn_update
::       [_b] - drugi log svn_update
::       [_c] - trzeci log svn_update
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? var_pres('_a')=type_of('')
|| {? _a * 'konflikty' > 0
   || _result:='konflikty'
   |? 2+(-_a) = 'ok'
   || _result:='Ok'
   || _result:='BŁĄD'
   ?}
?};
{? var_pres('_b')=type_of('') & (_result='Ok' | _result='')
|| {? _b * 'konflikty' > 0
   || _result:='konflikty'
   |? 2+(-_b) = 'ok'
   || _result:='Ok'
   || _result:='BŁĄD'
   ?}
?};
{? var_pres('_c')=type_of('') & (_result='Ok' | _result='')
|| {? _c * 'konflikty' > 0
   || _result:='konflikty'
   |? 2+(-_c) = 'ok'
   || _result:='Ok'
   || _result:='BŁĄD'
   ?}
?};
_result


\copy2temp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Kopiuje pliki z otrzymanej tablicy do katalogu tymczasowego
::   WE: _a - tablica z polami REP_STAT FILENAME PATH
::       _b - [STRING] ścieżka względem katalogu workdir\backup do której będzie wykonana kopia
::      [_c] - ścieżka do kopii lokalnej gdy inna niż wskazuje pth_dir
::   WY: 1 / [STRING] lista plików z niepowodzeniem
::----------------------------------------------------------------------------------------------------------------------
{? _>1 & type_of(_a)=118 & type_of(_b)=type_of('') & +_b>0
|| _tab:=_a;
   _wynik:=1;
   _sep:=exec('sep','#file',1);
   _workdir:=exec('workdir','%transfer');
   {? _tab.first()
   ||
      {? fexists(_workdir+_sep+'backup',0)=0
      || fmkdir(_workdir,'backup')
      ?};
      {? fexists(_workdir+_sep+'backup'+_sep+ _b,0)=0
      || exec('create_catalog','%transfer',_workdir+_sep+'backup'+_sep+_b)
      ?};
      {? var_pres('_c')=type_of('')
      || _prefix_pth:=_c
      || _prefix_pth:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()
      ?};
      _length_prefix:=+_prefix_pth;
      {! |?
         {? _tab.REP_STAT<>'' & _tab.FILENAME<>''
         ||
            _out:=_workdir+_sep+'backup'+_sep+_b+ (_length_prefix-_tab.PATH);
            {? _tab.REP_STAT='added'
            ||
               exec('create_catalog','%transfer',_out-(+_tab.FILENAME+1));
               _f:=fopen(_out+'.add','uw',0);
               {? _f
               || fclose(_f)
               || {? type_of(_wynik)=type_of(1)
                  || {? _tab.FILENAME=''
                     || _wynik+=_tab.PATH
                     || _wynik+=_tab.FILENAME
                     ?}
                  || {? _tab.FILENAME=''
                     || _wynik+=';'+_tab.PATH
                     || _wynik+=';'+_tab.FILENAME
                     ?}
                  ?}
               ?}
            |? _tab.REP_STAT='modified'
            ||
               {? fcopy(_tab.PATH,_out+'.mod',0,0)=0
               || exec('create_catalog','%transfer',_out-(+_tab.FILENAME+1));
                  {? fcopy(_tab.PATH,_out+'.mod',0,0)=0
                  || {? type_of(_wynik)=type_of(1)
                     || {? _tab.FILENAME=''
                        || _wynik+=_tab.PATH
                        || _wynik+=_tab.FILENAME
                        ?}
                     || {? _tab.FILENAME=''
                        || _wynik+=';'+_tab.PATH
                        || _wynik+=';'+_tab.FILENAME
                        ?}
                     ?}
                  ?}
               ?}
            |? _tab.REP_STAT='deleted'
            ||
               {? fexists(_tab.PATH,0) & fcopy(_tab.PATH,_out+'.del',0,0)=0
               || exec('create_catalog','%transfer',_out-(+_tab.FILENAME+1));
                  {? fcopy(_tab.PATH,_out+'.del',0,0)=0
                  || {? type_of(_wynik)=type_of(1)
                     || {? _tab.FILENAME=''
                        || _wynik+=_tab.PATH
                        || _wynik+=_tab.FILENAME
                        ?}
                     || {? _tab.FILENAME=''
                        || _wynik+=';'+_tab.PATH
                        || _wynik+=';'+_tab.FILENAME
                        ?}
                     ?}
                  ?}
               ?}
            |? _tab.REP_STAT='copy'
            ||
               {? fexists(_tab.PATH,0) & fcopy(_tab.PATH,_out,0,0)=0
               || exec('create_catalog','%transfer',_out-(+_tab.FILENAME+1));
                  {? fcopy(_tab.PATH,_out,0,0)=0
                  || {? type_of(_wynik)=type_of(1)
                     || {? _tab.FILENAME=''
                        || _wynik+=_tab.PATH
                        || _wynik+=_tab.FILENAME
                        ?}
                     || {? _tab.FILENAME=''
                        || _wynik+=';'+_tab.PATH
                        || _wynik+=';'+_tab.FILENAME
                        ?}
                     ?}
                  ?}
               ?}

            ?}
         ?};
         _tab.next()
      !}
   ?}
||
   _wynik:=0
?};
_wynik


\create_catalog
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Tworzy katalogi ze ścieżki przekazanej w parametrze
::   WE: _a - [STRING] ścieżka katalogów (bez nazwy pliku)
::   WY: (1,0) - wynik operacji
::----------------------------------------------------------------------------------------------------------------------
{? _>0 & type_of(_a)=type_of('')
||
   _pth:=_a;
   _wynik:=1;
   _sep:=exec('sep','#file',1);
   _array:=spli_str(_pth,_sep);
   _pozycja:=+_array[1];
   {! _i:=2..(obj_len(_array)-1)
   |! _pozycja+=+_array[_i] +1;
      {? fexists(_pozycja+_pth+_sep+_array[_i+1],0)
      ||
         1
      ||
         fmkdir(_pozycja+_pth,_array[_i+1])
      ?}
   !};
   _wynik
?}


\del_catal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Usuwa katalog z zawartością znajdujący się w _workdir według ścieżki przekazanej w parametrze
::   WE: _a - [STRING] ścieżka katalogu. Może być względem _workdir lub bezwzględna
::   WY: (1,0) - wynik operacji
::----------------------------------------------------------------------------------------------------------------------
{? _>0 & type_of(_a)=type_of('')
||
   _pth:=_a;
   _sep:=exec('sep','#file',1);
   _workdir:=exec('workdir','%transfer');
   {? _pth*_workdir=0 || _pth:=_workdir+ {? 1+_pth=_sep || '' || _sep ?} + _pth ?};
   {? fexists(_pth,0)=2
   ||
      {? sys_name(0)='U_LINUX'
      || _command:='rm -r '+_pth;
         _sys_res:=system( _command);
         {? _sys_res=0 || return(1) ?}
      ||
         _command:='rmdir '+_pth;
         _sys_res:=system(envget('COMSPEC')+' /C ' + _command + ' /s /q',1);
         {? _sys_res=0 || return(1) ?}
      ?}
   || return(0)
   ?}
|| 0
?}


\paczka_backup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Przygotowuje paczkę z kopią zapasową
::       UWAGA na parametry _d i _e. Należy podać parametry _d i _e lub żaden z wymienionych (wtedy ścieżki szukane
::             według pth).
::   WE: _a - POCZTAM.ref()
::       [_b] - [STRING] ścieżka do merit.def, jeśli niepodana to ustawiana według parametru _d lub pth_dir
::       [_c] - [STRING] ścieżka do miejsca zapisu paczki
::       [_d] - [STRING] ścieżka do merit
::       [_e] - [STRING] ścieżka do modified

::   WY: [STRING] 'OK' / lista plików z niepowodzeniem
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_wynik:=1;
_workdir:=exec('workdir','%transfer');
{? var_pres('_c')=type_of('')
|| _dest:=_c
|| _dest:=_workdir+_sep+'backup'
?};
{? var_pres('_d')=type_of('')
|| _path_merit:=_d
|| _path_merit:=''
?};
{? var_pres('_e')=type_of('')
|| _path_modified:=_e
|| _path_modified:=''
?};
{? var_pres('_b')=type_of('') & _b<>''
|| _loc_def_old:=_b
|| {? _path_merit<>''
   || _loc_def_old:=_path_merit+_sep+'system'+_sep+'merit.def'
   || _loc_def_old:=pth_dir('merit.def')+_sep+'merit.def'
   ?}
?};
{? _path_merit<>'' & _path_modified<>''
|| _tab_mer:=exec('svn_status','%transfer',_path_merit,_a);
   _tab_mod:=exec('svn_status','%transfer',_path_modified,_a);
   _wynik_mer:=exec('copy2temp','%transfer',_tab_mer,'old'+_sep+'merit',_path_merit);
   _wynik_mod:=exec('copy2temp','%transfer',_tab_mod,'old'+_sep+'modified',_path_modified)
||
   _path_root:=((pth_dir()*(_sep+'pth'))-1)+pth_dir();
   _tab_mer:=exec('svn_status','%transfer',_path_root+_sep+'merit',_a);
   _tab_mod:=exec('svn_status','%transfer',_path_root+_sep+'modified',_a);
   _wynik_mer:=exec('copy2temp','%transfer',_tab_mer,'old'+_sep+'merit',_path_root+_sep+'merit');
   _wynik_mod:=exec('copy2temp','%transfer',_tab_mod,'old'+_sep+'modified',_path_root+_sep+'modified')
?};
{? type_of(_wynik_mer)=type_of(1) &  type_of(_wynik_mod)=type_of(1)
|| _wynik:=_wynik_mer & _wynik_mod
|| _wynik:=0
?};
{? type_of(_wynik)=type_of(1)
||  _wynik:={? _wynik || 'OK' || 'BŁĄD' ?}
?};
::   kopia defa
_loc_def:=_workdir+_sep+'backup'+_sep+'old'+_sep+'merit'+_sep+'system';
exec('create_catalog','%transfer',_loc_def);
::   kopiowanie hash'a systemu wykonanego w poprzedniej czynności procesu
{? fcopy(_workdir+_sep+'hash_system.csv',_workdir+_sep+'backup'+_sep+'old'+_sep+'hash_system.csv',0,0,1)=0
|| {? type_of(_wynik)=type_of('') || _wynik+=' ;hash_system.csv' || _wynik:='hash_system.csv' ?}
?};

{? fcopy(_loc_def_old,_loc_def+_sep+'merit.def',0,0,1)=0
|| {? type_of(_wynik)=type_of('') || _wynik+=' ;merit.def' || _wynik:='merit.def' ?}
?};
::   pakowanie
{? fexists(_workdir+_sep+'backup'+_sep+'old',0)<>0
||
   _new_fname:='old'+$SYSLOG.tm_stamp()+'.zip';
   {? fpack_add(_dest+_sep+_new_fname,_workdir+_sep+'backup'+_sep+'old')=0
   || {? type_of(_wynik)=type_of('')
      || _wynik+=' ;Błąd pakowania do zip ' + _dest+_sep+_new_fname + ' katalogu: ' + _workdir+_sep+'backup'+_sep+'old'
      || _wynik:='Błąd pakowania do zip ' + _dest+_sep+_new_fname + ' katalogu: ' + _workdir+_sep+'backup'+_sep+'old'
      ?}
   || {? type_of(_wynik)=type_of('')
      || _wynik+=' ;Spakowano do zip ' + _dest+_sep+_new_fname
      || _wynik:='Spakowano do zip ' + _dest+_sep+_new_fname
      ?}
   ?}

|| {? type_of(_wynik)=type_of('')
   || _wynik+=' Brak katalogu: ' + _workdir+_sep+'backup'+_sep+'old'
   || _wynik:='Brak katalogu: ' + _workdir+_sep+'backup'+_sep+'old'
   ?}
?};
exec('del_catal','%transfer',_workdir+_sep+'backup'+_sep+'old');
::   ferase(_workdir+_sep+'hash_system.csv')
{? type_of(_wynik)=type_of(1)
||  _wynik:={? _wynik || 'OK' || 'BŁĄD' ?}
?};
_wynik


\paczka_aktualizacyjna
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Kopiuje pliki wskazane w pliku z formuły svn_update
::   WE:  _a  - [STRING] ścieżki do plików z wynikiem svn update
::       [_b] - [STRING] ścieżka do katalogu merit
::       [_c] - [STRING] ścieżka do katalogu modified
::       [_d] - [STRING] ścieżka do merit.def bez nazwy pliku jeśli inna niż wskazuje pth_dir
::       [_e] - [STRING] ścieżka do folderu zapisu paczki
::   WY: [STRING] 'OK' / lista plików z niepowodzeniem
::----------------------------------------------------------------------------------------------------------------------
_workdir:=exec('workdir','%transfer');
_sep:=exec('sep','#file',1);
{? var_pres('_a')=type_of('')
|| {? _a*';'
   || _spli:=spli_str(_a,';');
      _path_merit_log:=_spli[1];
      _path_modified_log:=_spli[2]
   || return('Błędny parametr _a - [STRING] ścieżki do plików z wynikiem svn update')
   ?}
|| return('Błędny parametr _a - [STRING] ścieżki do plików z wynikiem svn update')
?};
{? var_pres('_b')=type_of('')
|| _path_merit:=_b
|| _path_merit:=''
?};
{? var_pres('_c')=type_of('')
|| _path_modified:=_c
|| _path_modified:=''
?};
{? var_pres('_d')=type_of('')
|| _loc_def:=_d
|| _loc_def:=pth_dir('merit.def')
?};
{? var_pres('_e')=type_of('')
|| _dest:=_e
|| _dest:=_workdir+_sep+'backup'
?};

:: odczyt merit update
_wynik:=1;
{? fexists(_path_merit_log)
|| _tab_mer:=exec('read_svn_update_log','%transfer',_path_merit_log)
|| _wynik:=0
?};
::  odczyt modified log
{? _wynik & fexists(_path_modified_log)
|| _tab_mod:=exec('read_svn_update_log','%transfer',_path_modified_log)
|| _wynik:=0
?};
{? _wynik
||
   {? _path_merit<>'' & _path_modified<>''
   || _wynik_mer:=exec('copy2temp','%transfer',_tab_mer,'new'+_sep+'merit',_path_merit);
      _wynik_mod:=exec('copy2temp','%transfer',_tab_mod,'new'+_sep+'modified',_path_modified)
   ||
      _path_root:=((pth_dir()*(_sep+'pth'))-1)+pth_dir();
      _wynik_mer:=exec('copy2temp','%transfer',_tab_mer,'new'+_sep+'merit',_path_root+_sep+'merit');
      _wynik_mod:=exec('copy2temp','%transfer',_tab_mod,'new'+_sep+'modified',_path_root+_sep+'modified')
   ?};
   {? var_press('_wynik_mer')=type_of('') || _wynik:=_wynik_mer ?};
   {? var_press('_wynik_mod')=type_of('')
   ||
      {? var_press('_wynik')=type_of('') || _wynik+=';'+_wynik_mod || _wynik:=_wynik_mod  ?}
   ?}
?};
{? type_of(_wynik)=type_of(1)
||  _wynik:={? _wynik || 'OK' || 'BŁĄD' ?}
?};
::   kopia defa
_loc_def_paczka:=_workdir+_sep+'backup'+_sep+'new'+_sep+'merit'+_sep+'system';
exec('create_catalog','%transfer',_loc_def_paczka);
{? fcopy(_loc_def+_sep+'merit.def',_loc_def_paczka+_sep+'merit.def',0,0,1)=0
|| {? _wynik='OK' || _wynik:='merit.def' || _wynik+=';merit.def' ?}
?};
{? fcopy(_loc_def+_sep+'merit.new',_loc_def_paczka+_sep+'merit.new',0,0,1)=0
|| {? _wynik='OK' || _wynik:='merit.new' || _wynik+=';merit.new' ?}
?};
::    kopia pliku merit.mapnew
{? fcopy(pth_dir('merit.def')+_sep+'merit.mapnew',_loc_def_paczka+_sep+'merit.mapnew',0,0,1)=0
|| {? _wynik='OK' || _wynik:='merit.mapnew' || _wynik+=';merit.mapnew' ?}
?};
{? fcopy(_workdir+_sep+'hash_system.csv',_workdir+_sep+'backup'+_sep+'new'+_sep+'hash_system.csv',0,0,1)=0
|| {? _wynik='OK' || _wynik:='hash_system.csv' || _wynik+=';hash_system.csv' ?}
?};
{? _wynik<>'OK' || _wynik:='BŁĄD. Błąd przygotowywania plików: '+_wynik ?};
{? fexists(_workdir+_sep+'backup'+_sep+'new',0)<>0
||
   _new_fname:='new'+$SYSLOG.tm_stamp()+'.zip';
   {? fpack_add(_dest+_sep+_new_fname,_workdir+_sep+'backup'+_sep+'new')=0
   || {? type_of(_wynik)=type_of('')
      || _wynik+='\nBłąd pakowania do zip ' + _dest+_sep+_new_fname + ' katalogu: ' + _workdir+_sep+'backup'+_sep+'new'
      || _wynik:='BŁĄD. Błąd pakowania do zip ' + _dest+_sep+_new_fname + ' katalogu: ' + _workdir+_sep+'backup'+_sep+'new'
      ?}
   || {? type_of(_wynik)=type_of('')
      || _wynik+='\nSpakowano do zip ' + _dest+_sep+_new_fname
      || _wynik:='BŁĄD. Spakowano do zip ' + _dest+_sep+_new_fname
      ?}
   ?}
|| {? type_of(_wynik)=type_of('')
   || _wynik+='\nBrak katalogu: ' + _workdir+_sep+'backup'+_sep+'new'
   || _wynik:='BŁĄD. Brak katalogu: ' + _workdir+_sep+'backup'+_sep+'new'
   ?}
?};
exec('del_catal','%transfer',_workdir+_sep+'backup'+_sep+'new');
{? type_of(_wynik)=type_of(1)
||  _wynik:={? _wynik || 'OK' || 'BŁĄD' ?}
?};
_wynik


\read_svn_update_log
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [21.14]
:: OPIS: Odczytuje wyniki svn update zapisane w pliku
::   WE: _a - [STRING] ścieżka do pliku log z wynikiem svn update
::   WY: tabela z wynikiem
::----------------------------------------------------------------------------------------------------------------------
_path_log:=_a;
_tab:=tab_tmp(2,
   'PATH','STRING[255]','Ścieżka do pliku',
   'REP_STAT','STRING[30]','Status kopiowania',
   'FILENAME','STRING[100]','Nazwa pliku z rozszerzeniem'
);
_conv:=iconv('Windows-1250');
_file:=fopen(_path_log,'r',0);
{? _file
|| {!
   |? {? sys_name(1)='U_LINUX'
      || _wiersz:=fread(_file)
      || (_wiersz:=_conv.from(fread(_file)))
      ?};
      _wiersz<>'\n'
   |!
      _kod:=gsub(5+_wiersz,' ','');
      {? +_kod=1
      ||
         _tab.blank();
         _tab.PATH:=5-_wiersz;
         {? fexists(_tab.PATH,0)=1
         || _tab.FILENAME:=exec('filename','#string',_tab.PATH)
         ||
            _tab.FILENAME:=''
         ?};
         {? _kod='A' | _kod='U' | _kod='E'
         || _tab.REP_STAT:='copy'
         |? _kod='D'
         || _tab.REP_STAT:='deleted'
         ?};
         _tab.add()
      ?}
   !};
   fclose(_file)
|| _wynik:=0
?};
_tab


\pack_download
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Pozwala na pobranie paczek: backup, aktualizacyjnej i pliku z hashem systemu
::   WE: _a - wynik czynności przygotowanie paczki backup
::       _b - wynik czynności przygotowanie paczki
::   WY: 0 - zapis plików się nie powiódł, 1 - powiódł się
:: ~OST: INFCOPY,INFILECHOOSER
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_workdir:=exec('workdir','%transfer');
_msg:='';
{? var_pres('_a')=type_of('')
||
   {? 4+_a<>'BŁĄD'
   || _cut:=_a*'Spakowano do zip ';
      _backup_path:=form((_cut+16)-_a)
   || _msg+='Błąd przygotowania paczki plików przed aktualizacją.\n'@+_a
   ?}
?};
{? var_pres('_b')=type_of('')
||
   {? 4+_b<>'BŁĄD'
   || _cut:=_b*'Spakowano do zip ';
      _new_path:=form((_cut+16)-_b)
   || _msg+='Błąd przygotowania paczki plików po aktualizacji.\n'@+_b
   ?}
?};
{? var_pres('_a')<>type_of('') & var_pres('_b')<>type_of('')
|| _msg:='Błąd przygotowania paczki.'
?};
{? ~exec('interm','#system')
||
   {? _msg='' || _dest_path:=exec('filechooser','#file','Wybierz katalog zapisu paczek',,,,,'DIRECTORIES_ONLY',1,) ?};
   _result:=0;
   {? _msg='' & _dest_path<>''
   || {? fexists(_backup_path,0)
      || _sep:=exec('sep','#file');
         {? fcopy(_backup_path,'@'+_dest_path+_sep+'old.zip',0,0,1)
         || _msg+=('Zapis paczki plików przed aktualizacją zakończony powodzeniem.\n'@);
            ferase(_backup_path,0);
            _result:=1
         || _msg+=('Zapis paczki plików przed aktualizacją się nie powiódł.\n'@);
            _result:=2
         ?}
      || _msg+=('Zapis paczki plików przed aktualizacją się nie powiódł.\n'@);
         _result:=2
      ?};
      {? fexists(_new_path,0)
      || {? fcopy(_new_path,'@'+_dest_path+_sep+'new.zip',0,0,1)
         || _msg+=('Zapis paczki plików po aktualizacji zakończony powodzeniem.\n'@);
            ferase(_new_path,0)
         || _msg+=('Zapis paczki plików po aktualizacji się nie powiódł.\n'@);
            _result:=2
         ?}
      || _msg+=('Zapis paczki plików po aktualizacji się nie powiódł.\n'@);
         _result:=2
      ?}
   || _result:=0
   ?};
   {? _msg<>''
   || {? _result=1
      || FUN.info(_msg)
      |? _result=2
      || _result:=FUN.ask(_msg+'Czy zakończyć czynność pobierania paczki?'@)
      ?}
   ?}
||
:: Wątek dla interm
   {? _msg=''
   || {? fexists(_backup_path,0)
      || _msg:='Paczka z plikami sprzed aktualizacji zapisana została w miejscu: %1'@[_backup_path]
      ?};
      {? fexists(_new_path,0)
      || _msg:='\nPaczka z plikami po aktualizacji zapisana została w miejscu: %1'@[_new_path]
      ?}
   ?};
   {? _msg<>''
   || _result:=FUN.ask(_msg+'\nCzy zakończyć czynność pobierania paczki?'@)
   ?}
?};
_result


\unpack
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Rozpakowuje paczkę aktualizacyjną
::   WE: _a - [STRING] ścieżka do paczki
::   WY: STRING - ścieżka do katalogu
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_workdir:=exec('workdir','%transfer');
{? var_pres('_a')=type_of('')
|| _path_zip:=_a
|| return('BŁĄD. Brak pliku zip')
?};
_sep:=exec('sep','#file',1);
_unpack_pth:=_workdir+_sep+'unpacked';
{? fexists(_path_zip)
||
   {? funpack(,_path_zip,_unpack_pth)
   || _result:='OK.'+'Paczka została wypakowana do katalogu: ' + _unpack_pth
   || _result:='BŁĄD. Nieudane rozpakowanie paczki'
   ?}
|| _result:='BŁĄD. Brak pliku zip z paczką aktualizacyjną'
?};
_result


\copy_def
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Kopiuje defa i zmienia nazwę na new. Przed wywołaniem wymagana rozpakowana paczka formułą unpack
::   WE:
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_workdir:=exec('workdir','%transfer');
_sep:=exec('sep','#file',1);
_def_new:=_workdir+_sep+'unpacked'+_sep+'merit'+_sep+'system'+_sep+'merit.new';
{? fexists(_def_new) & fcopy(_def_new,pth_dir('merit.def')+_sep+'merit.new',0,0,1)
|| return(1)
|| _def_new:=_workdir+_sep+'unpacked'+_sep+'merit'+_sep+'system'+_sep+'merit.def';
   {? fexists(_def_new) & fcopy(_def_new,pth_dir('merit.def')+_sep+'merit.new',0,0,1)
   || return(1)
   || return(0)
   ?}
?}


\copy_nondef
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Kopiuje pliki poza defem. Przed wywołaniem wymagana rozpakowana paczka formułą unpack
::   WE:
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_workdir:=exec('workdir','%transfer');
_sep:=exec('sep','#file',1);
_unpack_pth:=_workdir+_sep+'unpacked';
_prefix_pth:=((pth_dir()*(_sep+'pth'))-1)+pth_dir();
_wynik:=1;
_tab:=exec('dir_sys','%transfer',_unpack_pth);
::exec('select','#table',_tab);
{? _tab.first()
||
   {! |?
      {? _tab.TYPE='f' & _tab.NAME<>'merit.def' & _tab.NAME<>'merit.new'
      ||
         _dir_out:=_prefix_pth+_sep+((+_unpack_pth)-_tab.DIR);
         {? fexists(_dir_out)=0
         || exec('create_catalog','%transfer',_dir_out)
         ?};
         {? _tab.NAME+4='.del'
         ||
            {? ferase(_dir_out+_sep+_tab.NAME-4,0) = 0 || _wynik:=0 ?}
         ||
            {? fcopy(_tab.DIR+_sep+_tab.NAME,_dir_out+_sep+_tab.NAME,0,0,1) = 0 || _wynik:=0 ?}
         ?}
      ?};
      _tab.next()
   !}
|| _wynik:=0
?};
{? _wynik=1 || exec('del_catal','%transfer',_unpack_pth) ?};
_wynik


\no_transfer_def
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Kopiuje new i zmienia nazwę na def.
::   WE:
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);

_def_new:=pth_dir('merit.def')+_sep+'merit.new';
{? fexists(_def_new)
 & fcopy(pth_dir('merit.def')+_sep+'merit.new',pth_dir('merit.def')+_sep+'merit.def',0,0,1)
|| ferase(pth_dir('merit.def')+_sep+'merit.new');
   exec('uprawnienia','%transfer',pth_dir('merit.def')+_sep+'merit.def');
   return(1)
|| return(0)
?}


\hash_sys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: wykonuje plik z hash'em głównym oraz hash'ami plików merit.new oraz folderów merit, modified
::   WE: [_a] - [STRING] ścieżka do katalogu docelowego tworzonego pliku z hash'em systemu
::       [_b] - [STRING] ścieżka do katalogu merit kopii lokalnej jeśli inna niż wskazuje pth_dir
::       [_c] - [STRING] ścieżka do katalogu modified kopii lokalnej jeśli inna niż wskazuje pth_dir
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_workdir:=exec('workdir','%transfer');
{? var_pres('_a')=type_of('')
|| _path_dest:=_a
|| _path_dest:=_workdir
?};
{? var_pres('_b')=type_of('')
|| _path_mer:=-_b
|| _path_mer:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
?};
{? var_pres('_c')=type_of('')
|| _path_mod:=-_c
|| _path_mod:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'modified'
?};
_path_sys:=((pth_dir()*(_sep+'pth'))-1)+pth_dir();

_dir_t1:=exec('dir_sys','%transfer',_path_mer);
_dir_t11:=exec('dir_sys','%transfer',_path_mod);
{? _dir_t11.first()
||
   {! |?
      _dir_t1.NAME:=_dir_t11.NAME;
      _dir_t1.TYPE:=_dir_t11.TYPE;
      _dir_t1.DIR:=_dir_t11.DIR;
      _dir_t1.add();
      _dir_t11.next()
   !}
?};
_dir_t2:=sql('select * from :_a where TYPE=\'f\' AND (DIR like \':_c%\' OR DIR like \':_b%\')'+
             ' AND DIR NOT like \':_d%\' AND NAME NOT like \'%.old\' ',
         _dir_t1,
         _path_mer,
         _path_mod,
         _path_mer+_sep+'rpt');

:: od tego momentu nie modyfikuję
_tab_hash:=tab_tmp(2,'FILE','STRING[255]','Plik','HASH','STRING[40]','Hash pliku');
_pth_len:=+_path_sys;
{? _dir_t2.first()
|| {! |?
      _tab_hash.FILE:=_pth_len-_dir_t2.DIR+_sep+_dir_t2.NAME;
      _file:=fopen(_path_sys+_tab_hash.FILE,'r',,,1);
      _tab_hash.HASH:=hash(_file,'sha1');
      _file.fclose();
      obj_del(_file);
      _tab_hash.add();
      _dir_t2.next()
   !}
?};
_res:=_tab_hash.export(_path_dest+_sep+'hash_system.csv',,,'UTF-8,header,nopth',,
'FILE'  ,,1 ,,
'HASH' ,,2 , );
{? _res
|| return('OK')
|| return('BŁĄD')
?}


\compare_hash_sys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: wykonuje hash_sys na uruchomionym systemie oraz porównuje go z rozpakowanym z paczki aktualizacyjnej
::   WE: [_a] - [STRING] ścieżka do katalogu merit jeśli inna niż wskazuje pth_dir
::       [_b] - [STRING] ścieżka do katalogu modified jeśli inna niż wskazuje pth_dir
::   WY: tablica z wynikiem porównania
::----------------------------------------------------------------------------------------------------------------------
_workdir:=exec('workdir','%transfer');
_merit_pth:={? var_press('_a')=type_of('') || _a || ~~ ?};
_modified_pth:={? var_press('_b')=type_of('') || _b || ~~ ?};
_tab_hash_repo:=tab_tmp(2,'FILE','STRING[255]','Plik','HASH','STRING[40]','Hash pliku');
_tab_hash_client:=tab_tmp(2,'FILE','STRING[255]','Plik','HASH','STRING[40]','Hash pliku');
_sep:=exec('sep','#file',1);
_tab_hash_repo.import( _workdir+_sep+'unpacked'+_sep+'hash_system.csv',,,,'UTF-8*,nopth,header',,
'FILE',,1,,
'HASH',,2,);
:: wywołanie hash_sys na uruchomionym systemie
exec('hash_sys','%transfer',,_merit_pth,_modified_pth);
_tab_hash_client.import( _workdir+_sep+'hash_system.csv',,,,'UTF-8*,nopth,header',,
'FILE',,1,,
'HASH',,2,);
_tab_compare:=tab_tmp(2,'FILE','STRING[255]','Plik','STATUS','STRING[40]','Status pliku');
:: analiza plików które są w _tab_hash_repo
_res:=1;
{? _tab_hash_repo.first()
||
   {! |?
      _tab_compare.FILE:=_tab_hash_repo.FILE;
      {? _tab_hash_client.find_tab('first','FILE',,'=',_tab_hash_repo.FILE)
      || {? _tab_hash_repo.HASH=_tab_hash_client.HASH
         || _tab_compare.STATUS:='Plik bez zmian'
         || _tab_compare.STATUS:='PLIK ZMIENIONY';
            _res:=0
         ?}
      || _tab_compare.STATUS:='BRAK PLIKU W SYSTEMIE';
         _res:=0
      ?};
      _tab_compare.add();
      _tab_hash_repo.next()
   !}
?};
:: analiza plików których nie ma w _tab_hash_repo a są w _tab_hash_client
{? _tab_hash_client.first()
||
   {! |?
      _tab_compare.FILE:=_tab_hash_client.FILE;
      {? _tab_hash_repo.find_tab('first','FILE',,'=',_tab_hash_client.FILE)=0
      || _tab_compare.STATUS:='BRAK PLIKU W REPOZYTORIUM';
         _tab_compare.add();
         _res:=0
      ?};
      _tab_hash_client.next()
   !}
?};
{? _res
|| _result:='OK. Nie znaleziono zmian w plikach.'
|| _result:='BŁĄD. Istnieją różnice pomiędzy systemem klienta, a kopią lokalną'
?};
_result


\dir_sys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Pobiera listę folderów i plików wraz z zagnieżdżonymi folderami, w wyniku tabela podobna ze strukturą
::       wyniku systemowego fdir
::       UWAGA, NIE UŻYWAĆ DLA FOLDERÓW O ZŁOŻONEJ STRUKTURZE PODFOLDERÓW - DŁUGI CZAS WYKONANIA
::   WE: _a   - STRING - ścieżka do folderu lokalnego lub na serwerze
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=2
|| _path:=_a
|| return(0)
?};
_tab:=exec('dir_rek','%transfer',_path);
_result:=tab_tmp(3,
:: 'POLE','TYP','Nazwa w oknie',
   'NAME','STRING[255]','Nazwa',
   'TYPE','STRING[1]','Typ',
   'DIR','STRING[255]','Katalog'
);
_ndx:=_result.ndx_tmp(,1,'TYPE',,,'NAME',,0);
_result.index(_ndx);

{? _tab.first()
|| {? _tab.FILEPATH*'/'
   || _sep:='/'
   || _sep:='\\'
   ?};
   {! |?
      _array:=spli_str(_tab.FILEPATH,_sep);
      _suf_len:=+_array[obj_len(_array)];
      _result.NAME:=_tab.FILENAME;
      {? _tab.IS_FILE
      || _result.TYPE:='f'
      || _result.TYPE:='d'
      ?};
      _result.DIR:=_tab.FILEPATH-_suf_len-1;
      _result.add();
      {? var_pres('_array')>0 || &_array ?};
      _tab.next()
   !}
?};
_result


\dir_rek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [20.42]
:: OPIS: Pobiera listę folderów i plików wraz z zagnieżdżonymi folderami. fdir wywoływane rekurencyjnie dla
::       zagnieżdżonych folderów
::       UWAGA, NIE UŻYWAĆ DLA FOLDERÓW O ZŁOŻONEJ STRUKTURZE PODFOLDERÓW - DŁUGI CZAS WYKONANIA
::   WE: _a   - STRING - ścieżka do folderu lokalnego lub na serwerze
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=2
|| _path:=_a
|| return(0)
?};
_tab_wyn:=exec('dir','#file',_path,1);
:: tworzę kopie roboczą tabeli by pracować na kopii a dodawać rekordy do tabeli wynikowej
_tab_rob:=sql('select * from :_a', _tab_wyn);
_ndx_rob:=_tab_rob.ndx_tmp('',1,'IS_DIR',,1, 'FILENAME',,0);
_tab_rob.index(_ndx_rob);
_tab_rob.prefix(1);
{? _tab_rob.first()
||
   {! |?
      {? _tab_rob.FILENAME<> '.svn'
      || _tab_rek:=exec('dir_rek','%transfer',{? 1+_path='@' || '@' || '' ?} + _tab_rob.FILEPATH,1);
         {? _tab_rek.first()
         ||
            {! |?
               _tab_wyn.FILENAME:=_tab_rek.FILENAME;
               _tab_wyn.FILEPATH:=_tab_rek.FILEPATH;
               _tab_wyn.IS_FILE:=_tab_rek.IS_FILE;
               _tab_wyn.IS_DIR:=_tab_rek.IS_DIR;
               _tab_wyn.add();
               _tab_rek.next()
            !}
         ?};
         {? var_pres('_tab_rek')>0 || &_tab_rek ?}
      ?};
      _tab_rob.next()
   !}
?};
_tab_wyn


\sprawdzenie_warstwy_m
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Sprawdzenie, czy pliki z m nie kolidują z zaktualizowanymi
::   WE: _a - json z konfiguracja procesu
::       _b - czy wyświetlać okno z tabelą z konfliktami(0 - domyślnie nie, 1 - tak)
::      [_c] - xml z wynikami procesu
::   WY: STRING - 'OK' - brak konfliktów
::                'BŁĄD' - są konflikty. W dalszych linijkach wypisane konflikty
::                xml - z wynikami procesu gdy podany parametr _d
::----------------------------------------------------------------------------------------------------------------------
_path:='';
_result:='';
_not_analized:='';
_sep:=exec('sep','#file',1);
_workdir:=exec('workdir','%transfer');
_forced_continue:='';
{? exec('latest_proc','%transfer')
|| _path:=exec('cfg_get_elem','%transfer',_a,'merit_path');
   {? var_pres('_path')<>type_of('') | (var_pres('_path')=type_of('') & _path='')
   || _path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
   ?};
   _svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));
   {? var_pres('_svn')<>type_of(null())
   || &_svn;
      _svn:=null()
   ?};
   {? var_pres('_b')<>type_of(0)
   || _b:=0
   ?};
   _zws_tran_wer:=exec('cfg_get_elem','%transfer',_a,'zws_tran_wer')='T';
   _okno:=_b;
   _wynik:=_c;
   _forced_continue:={? exec('cfg_get_elem','%transfer',_a,'force_mod_update')='1' || 'T' || '' ?}

||
::   WE: _a - ścieżka do kopii lokalnej (domyślnie katalog merit)
::       _b - rekord POCZTAM
::       _c - czy wyświetlać okno z tabelą z konfliktami(0 - domyślnie nie, 1 - tak)
::      [_d]- xml z wynikami procesu
   {? var_pres('_a')=type_of('')
   || _path:=_a
   || _path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
   ?};
   {? var_pres('_b')<>type_of(null())
   || _svn:=null()
   || _svn:=_b
   ?};
   {? var_pres('_c')<>type_of(0)
   || _okno:=0
   || _okno:=_c
   ?};
   _wynik:=_d
?};


:: tabela przechowująca dane plików *.m.*
_m_files_tab:=files('*.m.*');

:: tabela przechowująca dane plików, które będą zaktualizowane (svn status --show-updates)
{? exec('latest_proc','%transfer') & _zws_tran_wer
|| _new_files_tab:=exec('upg_svn_status','%transfer',_path,_svn)
|| _new_files_tab:=exec('svn_status','%transfer',_path,_svn)
?};
_new_files_ndx:=_new_files_tab.ndx_tmp('',1,'FILENAME',,0);
_new_files_res_ndx:=_new_files_tab.ndx_tmp('',1,'RESULT',,0);
_new_files_tab.index(_new_files_ndx);

:: lista rozszerzen plikow ktore nie biorą udziału w analizie
_banned:='.doc;.xlsx;.dotx;.xls;.bak';

:: Wyznaczenie plików z modified, które mogą kolidować
{? _m_files_tab.first()
|| {? exec('latest_proc','%transfer') & _zws_tran_wer
   || _loop:=_m_files_tab.first();
      {!
      |? _loop
      |! {? ~(_m_files_tab.FILENAME+4='.sql' & (_m_files_tab.FILENAME*'list_par' | _m_files_tab.FILENAME*'list_sql'))
         || {? _banned*(_m_files_tab.FILENAME+4) | _banned*(_m_files_tab.FILENAME+5)
            || _not_analized+=_m_files_tab.FILENAME+'\n'
            || _real_filename:=exec('repl_substr','#string',_m_files_tab.FILENAME,'.m.','.');
               _new_files_tab.FILENAME:=_real_filename;
               _new_files_tab.RESULT:='DALEJ';
               _new_files_tab.PATH:=pth_dir(_real_filename)+_sep+_real_filename;
               _new_files_tab.PATHMOD:=pth_dir(_m_files_tab.FILENAME)+_sep+_m_files_tab.FILENAME;
               _new_files_tab.add()
            ?}
         ?};
         _loop:=_m_files_tab.next()
      !}
   ||
:: Wyznaczenie plików z modified, które mogą kolidować ze zwróconymi przez svn-status
      {!
      |? {? ~(_m_files_tab.FILENAME+4='.sql' & (_m_files_tab.FILENAME*'list_par' | _m_files_tab.FILENAME*'list_sql'))
         || _dot_ind:=_m_files_tab.FILENAME*'.m.';
            _real_filename:=exec('repl_substr','#string',_m_files_tab.FILENAME,'.m.','.');
            _new_files_tab.prefix(_real_filename,);
::        {? _new_files_tab.first() & (_new_files_tab.REP_STAT='modified' | _new_files_tab.REP_STAT='replaced')
            {? _new_files_tab.first()
            || {? _banned*(_real_filename+4) | _banned*(_real_filename+5)
               || _not_analized+=_m_files_tab.FILENAME+'\n'
               || _new_files_tab.RESULT:='DALEJ';
                  _new_files_tab.PATHMOD:=pth_dir(_m_files_tab.FILENAME)+_sep+_m_files_tab.FILENAME;
                  _new_files_tab.put()
               ?}
            ?}
         ?};
         _m_files_tab.next()
      !}
   ?}
|| _result:='OK. Nie znaleziono konfliktów pomiędzy zmianami na repozytorium i w warstwie modified.'
?};

:: backup plików, które mogą kolidować
_new_files_tab.index(_new_files_res_ndx);
_new_files_tab.prefix('DALEJ');
{? _new_files_tab.first()
|| {? exec('latest_proc','%transfer') & _zws_tran_wer
   ||
:: tworze katalogi tymczasowe na pliki ze starego svn oraz nowego svn
      _compare_dir:=fmkdir(_workdir,'compare');
      _new_svn:=fmkdir(_workdir+_sep+'compare','new');
      _old_svn:=fmkdir(_workdir+_sep+'compare','old');
      {!
      |? {? fexists(_new_files_tab.PATH)
         ||
:: pobieram plik ze starego repo
            _res_local:=exec('parse_svn_info','%transfer',_new_files_tab.PATH,_svn);
            {? _res_local.URL<>''
            || exec('svn_export','%transfer',_res_local.URL,_old_svn,_svn);
               _new_files_tab.PATH:=_old_svn+_sep+_new_files_tab.FILENAME
            || _new_files_tab.PATH:=''
            ?};
:: pobieram plik z nowego repo
            _new_url:=exec('cfg_get_elem','%transfer',_a,'svn_url_new');
            _tmp_file_pth:=gsub(pth_dir(_new_files_tab.FILENAME),((pth_dir()*(_sep+'pth'))-1)+pth_dir(),'');
            _new_url+=gsub(_tmp_file_pth,'\\','/');
            _new_url+='/'+_new_files_tab.FILENAME;
            exec('svn_export','%transfer',_new_url,_new_svn,_svn);
            {? fexists(_new_svn+_sep+_new_files_tab.FILENAME)
            || _new_files_tab.PATHNEW:=_new_svn+_sep+_new_files_tab.FILENAME
            ?};
            &_res_local;
            &_tmp_file_pth;
            _new_files_tab.put();
            _new_files_tab.next()
         || _new_files_tab.PATH:='';
            _new_files_tab.PATHNEW:='';
            _new_files_tab.put();
            _new_files_tab.next()
         ?}
      !};
      _new_files_tab.prefix();
      _new_files_tab.first();
      {!
      |? {? _new_files_tab.PATH='' & _new_files_tab.PATHNEW=''
         || _new_files_tab.RESULT:='';
            _new_files_tab.put()
         ?};
         _new_files_tab.next()
      !}
   ||
:: tworze katalogi tymczasowe na pliki z kopii roboczej i repozytorium
      _bckp_dir:=fmkdir(_workdir,'backup');
      _bckp_new_dir:=fmkdir(_workdir+_sep+'backup','new');
      {!
      |?
:: kopiuję plik z kopii roboczej
         fcopy(_new_files_tab.PATH,_bckp_dir+_sep+_new_files_tab.FILENAME,0,0,1);
:: pobietram adres repo dla pliku i ściągam plik w wersji aktualnej na repo
         _res_local:=exec('parse_svn_info','%transfer',_new_files_tab.PATH,_svn);
         exec('svn_export','%transfer',_res_local.URL,_bckp_new_dir,_svn);
         _new_files_tab.PATHNEW:=_bckp_new_dir+_sep+_new_files_tab.FILENAME;
         _new_files_tab.put();
         &_res_local;
         _new_files_tab.next()
      !}
   ?}
|| {? _not_analized=''
   || _result:='OK. Nie znaleziono konfliktów pomiędzy zmianami na repozytorium i w warstwie modified.'
   ?}
?};

_new_files_tab.ndx_drop(_new_files_ndx);
_new_files_tab.ndx_drop(_new_files_res_ndx);
:: porównanie plików
_analize_tab:=sql('select PATH, PATHMOD, PATHNEW, FILENAME from :_a where RESULT = \'DALEJ\'',_new_files_tab);
_tab:=exec('analizuje_liste','%transfer',_analize_tab,_okno);
{? type_of(_tab)=type_of(0)
|| _result:='BŁĄD. Nie udało się wykonać analizy.\n';
   {? var_press('_wynik')=type_of('') & _wynik<>''
   || _result:=exec('set_elem','%transfer',_wynik,'zmiany_w_standardzie_przykryte_przez_modified',_result)
   ?};
   return(_result)
?};
_tab.prefix();

{? _tab.first()
|| {!
   |? {? _tab.MOD<>'' & _tab.MODM<>''
      || _result+=_tab.FILE+'\n'
      ?};
      _tab.next()
   !};
   {? _not_analized='' & _result=''
   || _result:='OK. Nie znaleziono konfliktów pomiędzy zmianami na repozytorium i w warstwie modified.'
   || _path_default:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep;
      _rev_merit:=exec('parse_svn_info','%transfer',_path_default+'merit',_svn);
      _rev_pth:=exec('parse_svn_info','%transfer',_path_default+'pth',_svn);
      _rev_defy:=exec('parse_svn_info','%transfer',_path_default+'defy',_svn);
      _rev_modified:=exec('parse_svn_info','%transfer',_path_default+'modified',_svn);
      _result:={? _forced_continue<>''
               || 'OK. Zgodnie z konfiguracją mimo znalezionych konfliktów proces będzie kontynuowany.\n'
               || 'BŁĄD. Znaleziono konflikty pomiędzy zmianami na repozytorium i w warstwie modified.\n'
               ?}+
               'Konflikty występują w plikach: \n'+
               _result+'\n'+
               'Katalogi pozostały w rewizjach: \n'+
               'merit - '+_rev_merit.ENTRY_REVISION+'\n'+
               'pth - '+_rev_pth.ENTRY_REVISION+'\n'+
               'defy - '+_rev_defy.ENTRY_REVISION+'\n'+
               'modified - '+_rev_modified.ENTRY_REVISION+'\n'
   ?}
?};
{? _not_analized<>''
|| {? _result=''
   || _path_default:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep;
      _rev_merit:=exec('parse_svn_info','%transfer',_path_default+'merit',_svn);
      _rev_pth:=exec('parse_svn_info','%transfer',_path_default+'pth',_svn);
      _rev_defy:=exec('parse_svn_info','%transfer',_path_default+'defy',_svn);
      _rev_modified:=exec('parse_svn_info','%transfer',_path_default+'modified',_svn);
      _result:={? _forced_continue<>''
               || 'OK. Zgodnie z konfiguracją mimo znalezionych konfliktów proces będzie kontynuowany.\n'
               || 'BŁĄD. Znaleziono konflikty pomiędzy zmianami na repozytorium i w warstwie modified.\n'
               ?}+
               'Konflikty występują w plikach: \n'+
               _not_analized+'\n'+
               'Katalogi pozostały w rewizjach: \n'+
               'merit - '+_rev_merit.ENTRY_REVISION+'\n'+
               'pth - '+_rev_pth.ENTRY_REVISION+'\n'+
               'defy - '+_rev_defy.ENTRY_REVISION+'\n'+
               'modified - '+_rev_modified.ENTRY_REVISION+'\n'
   || _result+=_not_analized
   ?}
|| {? _result='' || _result:='OK. Nie znaleziono konfliktów pomiędzy zmianami na repozytorium i w warstwie modified.' ?}
?};
{? _new_files_tab.first()
|| exec('del_catal','%transfer',_workdir+_sep+'backup')
?};
{? var_press('_wynik')=type_of('') & _wynik<>''
|| _result:=exec('set_elem','%transfer',_wynik,'zmiany_w_standardzie_przykryte_przez_modified',_result)
?};
_result


\svn_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Wyznacza pliki, które zostaną zmodyfikowane podczas svn-update (wykonuje svn status)
::   WE: _a - path - ścieżka do kopii lokalnej
::       _b - POCZTAM.ref()
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_path:='';
_exe_path:='';
_workdir:=exec('workdir','%transfer');
{? var_pres('_a')=type_of('')
|| _path:=_a
|| _path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
?};
_new_files_tab:=tab_tmp(2,
   'PATH','STRING[255]','Ścieżka do pliku oryginalnego',
   'PATHNEW','STRING[255]','Ścieżka do pliku nowego',
   'PATHMOD','STRING[255]','Ścieżka do pliku zmodyfikowanego',
   'WC_STAT','STRING[30]','Status w kopii roboczej',
   'REP_STAT','STRING[30]','Status w repozytorium',
   'WC_REV','INTEGER','Rewizja w kopii roboczej',
   'REP_REV','INTEGER','Rewizja w repozytorium',
   'FILENAME','STRING[100]','Nazwa pliku z rozszerzeniem',
   'RESULT','STRING[16]','Decyzja - DALEJ - do dalszej obrobki',
   'TYPE','STRING[4]','Typ pliku'
);

_username:='';
_password:='';
POCZTAM.cntx_psh();
POCZTAM.prefix();
{? var_pres('_b')=type_of(null()) & _b<>null & POCZTAM.seek(_b)
|| _username:=POCZTAM.USER;
   _password:=POCZTAM.PASS
?};
POCZTAM.cntx_pop();
_sep:=exec('sep','#file',1);
_log_path:=_workdir+_sep+$SYSLOG.tm_stamp()+'.xml';

:: Wykonuję svn status
{? _exe_path='' | sys_name(1)='U_LINUX'
|| _command:='svn '
|| _command:='"%1svn.exe" '[_exe_path+_sep]
?};
{? sys_name(1)='U_LINUX'
|| {? _username<>''
   || _command+='status --show-updates %1 --username %2 --password %3 --non-interactive '
                      '--no-auth-cache --trust-server-cert --xml > %4'
                      [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_path]
   || _command+=' status --show-updates %1 --non-interactive '
                      '--no-auth-cache --trust-server-cert --xml > %2'
                      [_path,_log_path]
   ?}
|| {? _username<>''
   || _command+='status --show-updates "%1" --username %2 --password %3 --non-interactive '
                      '--no-auth-cache --trust-server-cert --xml > "%4"'
                      [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_path]
   || _command+=' status --show-updates %1 --non-interactive '
                      '--no-auth-cache --trust-server-cert --xml > "%2"'
                      [_path,_log_path]
   ?}
?};
{? sys_name(1)='U_LINUX'
|| _sys_res:=system('sh -c \"' +_command + '\"',1)
|| _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1)
?};
_file:=fopen( _log_path,'r',0,,1);

params_set('new_files_tab',_new_files_tab);
:: przetwarzanie xml
{? _file.is_open()
|| xml_sax_parse(_file
::    Start document
      ,""
::    End document
      ,""
::    Start element
      ,
      "
         _new_files_tab:=params_get().new_files_tab;
         {? _a='entry'
         || {? type_of(_e)>100
            || _new_files_tab.blank();
               {? _e[1]='path'
               || _new_files_tab.PATH:=_e[4];
                  {? fexists(_new_files_tab.PATH,0)=1
                  || _new_files_tab.FILENAME:=exec('filename','#string',_e[4]);
                     _new_files_tab.TYPE:=_new_files_tab.FILENAME+4
                  |? fexists(_new_files_tab.PATH,0)=0
                  ||
                     {? exec('filename','#string',_e[4])*'.'>0
::                        gdy plik lub katalog .pth
                     ||
                           {? (_e[4]+4)='.pth'
                           ||
                              {? (_e[4]-4)*'.'>0
                              || _new_files_tab.FILENAME:=exec('filename','#string',_e[4]);
                                 _new_files_tab.TYPE:=_new_files_tab.FILENAME+4
                              || _new_files_tab.FILENAME:='';
                                 _new_files_tab.TYPE:=''
                              ?}
                           ||
                              _new_files_tab.FILENAME:=exec('filename','#string',_e[4]);
                              _new_files_tab.TYPE:=_new_files_tab.FILENAME+4
                           ?}

                     ?}
::                        katalog
                  ||
                     _new_files_tab.FILENAME:='';
                     _new_files_tab.TYPE:=''
                  ?}
               ?}
            ?}
         |? _a='wc-status'
         || {? type_of(_e)>100
            || {? _e[1]='item'
               || _new_files_tab.WC_STAT:=_e[4]
               |? _e[5]='item'
               || _new_files_tab.WC_STAT:=_e[8]
               |? obj_len(_e)>8 & _e[9]='item'
               || _new_files_tab.WC_STAT:=_e[12]
               ?};
               {? _e[1]='revision'
               || _new_files_tab.WC_REV:=#(_e[4])
               |? _e[5]='revision'
               || _new_files_tab.WC_REV:=#(_e[8])
               |? obj_len(_e)>8 & _e[9]='revision'
               || _new_files_tab.WC_REV:=#(_e[12])
               ?}
            ?}
         |? _a='repos-status'
         || {? type_of(_e)>100
            || {? _e[1]='item'
               || _new_files_tab.REP_STAT:=_e[4]
               |? _e[5]='item'
               || _new_files_tab.REP_STAT:=_e[8]
               |? obj_len(_e)>8 & _e[9]='item'
               || _new_files_tab.REP_STAT:=_e[12]
               ?}
            ?}
         |? _a='commit'
         || {? type_of(_e)>100
            || {? _e[1]='revision'
               || _new_files_tab.REP_REV:=#(_e[4])
               ?}
            ?}
         ?};
         1
      "
::    End element
      ,"
         _new_files_tab:=params_get().new_files_tab;
         {? _a='entry'
         || _new_files_tab.add()
         ?};
         1
      "
::    Text
      ,""
::    Comment
      ,""
      );
   _file.fclose()
?};
ferase(_log_path);
return(_new_files_tab)


\upg_svn_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca strukture tabeli do analizy plikow modify
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(2,
   'PATH','STRING[255]','Ścieżka do pliku oryginalnego',
   'PATHNEW','STRING[255]','Ścieżka do pliku nowego',
   'PATHMOD','STRING[255]','Ścieżka do pliku zmodyfikowanego',
   'WC_STAT','STRING[30]','Status w kopii roboczej',
   'REP_STAT','STRING[30]','Status w repozytorium',
   'WC_REV','INTEGER','Rewizja w kopii roboczej',
   'REP_REV','INTEGER','Rewizja w repozytorium',
   'FILENAME','STRING[100]','Nazwa pliku z rozszerzeniem',
   'RESULT','STRING[16]','Decyzja - DALEJ - do dalszej obrobki',
   'TYPE','STRING[4]','Typ pliku'
)


\svn_export
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Wykonuje export pliku z repo na dysk lokalny
::   WE: _a - url pliku w repozytorium svn
::       _b - ścieżka lokalna gdzie zapisać plik
::       _c - POCZTAM.ref
::
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_ulr:='';
{? var_pres('_a')=type_of('')
|| _url:=_a
?};
_path:='';
_exe_path:='';
_workdir:=exec('workdir','%transfer');
{? var_pres('_b')=type_of('')
|| _path:=_b
|| _path:=_workdir
?};
_log_path:=_workdir+exec('sep','#file')+'svn_export.xml';
_err_path:=_workdir+exec('sep','#file')+'svn_export_err.xml';
_username:='';
_password:='';
POCZTAM.cntx_psh();
POCZTAM.prefix();
{? var_pres('_c')=type_of(null()) & _c<>null & POCZTAM.seek(_c)
|| _username:=POCZTAM.USER;
   _password:=POCZTAM.PASS
?};
POCZTAM.cntx_pop();
{? _exe_path<>'' & sys_name(1)<>'U_LINUX'
|| _command:='"%1svn.exe" '[_exe_path+_sep]
|| _command:='svn '
?};
{? sys_name(1)='U_LINUX'
|| {? _username<>''
   || _command+='export %1 %2 --username %3 --password %4 --non-interactive '
                      '--no-auth-cache --trust-server-cert > %5 2> %6'
                      [_url, _path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_path,_err_path]
   || _command+='export %1 %2 --non-interactive --trust-server-cert --no-auth-cache > %3 2> %4'
                      [_url, _path,_log_path,_err_path]
   ?}
|| {? _username<>''
   || _command+='export %1 "%2" --username %3 --password %4 --non-interactive '
                      '--no-auth-cache --trust-server-cert > "%5" 2> "%6"'
                      [_url, _path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_path,_err_path]
   || _command+='export %1 "%2" --non-interactive --trust-server-cert --no-auth-cache > "%3" 2> "%4"'
                      [_url, _path,_log_path,_err_path]
   ?}
?};
{? sys_name(1)='U_LINUX'
|| _sys_res:=system('sh -c \"' +_command + '\"',1)
|| _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1)
?}


\analizuje_liste_args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Argument dla formuły analizuje_liste
::   WY: tabela tymczasowa, której pola są wykorzystywane przez formułę analizuje_liste
:: UWAGA! Ścieżki porównywanych plików muszą być trzema pierwszymi polami tabeli
::  OLD: \analiza_w/skid_sap
::----------------------------------------------------------------------------------------------------------------------
_fmls:=tab_tmp(3,
   'PATH','STRING[255]','Ścieżka do pliku lokalnego',
   'PATH_N','STRING[255]','Ścieżka do pliku w repozytorium',
   'PATH_M','STRING[255]','Ścieżka do pliku w modified',
   'PATH','STRING[255]','Ścieżka do pliku lokalnego',
   'PATHNEW','STRING[255]','Ścieżka do pliku w repozytorium',
   'PATHMOD','STRING[255]','Ścieżka do pliku w modified'
   'FILENAME','STRING[64]','Nazwa w oknie'
);
return(_fmls)


\analizuje_liste
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Formuła dokonuje analizy przekazanej listy plików
::   WE: _a - obiekt tabeli tymczasowej z nazwami plików i ścieżkami do ich lokalizacji
::       _b - czy wyświetlać tabelę wynikową
::   WY: tabela tymczasowa z listą zmienionych formuł w plikach
::  OLD: \analiza_w/skid_sap
::----------------------------------------------------------------------------------------------------------------------
_fmls:=_a;
_view:=_b;
_tabs:=exec('create_tabs','%transfer');

_filelist:=_tabs.filelist;
_ndx_filelist:=_tabs.ndx_filelist;
_formtab:=_tabs.formtab;
_ndx_f:=_tabs.ndx_f;
_ndx_s:=_tabs.ndx_s;
_wiersztab:=_tabs.wiersztab;
_ndx_w:=_tabs.ndx_w;
_ndx_wo:=_tabs.ndx_wo;
_ndx_wm:=_tabs.ndx_wm;
_ndx_wn:=_tabs.ndx_wn;
_win_f:=_tabs.win_f;
_wierszwin:=_tabs.wierszwin;
_wierszwin_o:=_tabs.wierszwin_o;
_wierszwin_l:=_tabs.wierszwin_l;

:: dla każdego pliku z listy wykonujemy działania
{? _fmls.first()
|| {? _view
   || _prog_iter:=0;
      FUN.prg_start(_fmls.size(),'Wyznaczanie róznic pomiędzy formułami')
   ?};
   {!
   |? {? _view
      || _prog_iter+=1;
         FUN.prg_next(_prog_iter)
      ?};
      _old:=_fmls[1];
      _mod:=_fmls[2];
      _new:=_fmls[3];


::    sprawdzamy czy w podanej lokalizacji istnieje odpowiednik w postaci pliku z kopii lokalnej
      {? fexists(_old,0)
      ||
         _f_old:=fopen(_old,'ur',0,0,1);
         {? ~_f_old.is_open()
         || FUN.emsg('Błąd otwarcia pliku: %1'@[_old]);
            &_f_old;
            return(0)
         ?};

         _f_new:=fopen(_new,'ur',0,0,1);
         {? ~_f_new.is_open()
         || FUN.emsg('Błąd otwarcia pliku: %1'@[_new]);
            &_f_new;
            return(0)
         ?};

         _f_mod:=fopen(_mod,'ur',0,0,1);
         {? ~_f_mod.is_open()
         || FUN.emsg('Błąd otwarcia pliku: %1'@[_f_mod]);
            &_f_mod;
            return(0)
         ?};

::         hash(_f_old)=hash(_f_mod) & hash(_f_new) = hash(_f_mod);
:: jeżeli znaleziono plik z kopii lokalnej to zaczynamy jego przetwarzanie
         _nr:=_nr_f:=_lp:=0;
         _wiersztab.FORMULA:=_wiersztab.WIERSZ:='';
         _formtab.blank();
         _formtab.FORMULA:=_formtab.FORMULAN:=_formtab.FORMULAM:='Nagłówek pliku: %1'[_fmls.FILENAME];
         _formtab.FILE:=_fmls.FILENAME;
::         _formtab.prefix();
         _formtab.add();
         {!
         |? (_wiersz:=_f_old.fread())<>'\n'
         |! {? (5+_wiersz)<>':Sign'
            ||
               _lp+=1;
               {? (1+_wiersz)='\\' | (5+_wiersz)='proc'
               || _wiersz:=32+_wiersz;
                  _sp:=_wiersz*' ';
                  {? _sp>0 || _wiersz:=(_sp-1)+_wiersz ?};
                  _nr_f+=1;
                  _formtab.FORMULA:=_wiersz;
                  _formtab.FORMULAN:='';
                  _formtab.FORMULAM:='';
                  _formtab.add();
                  _nr:=0
               || _nr+=1;
                  _wiersztab.FORMULA:=_formtab.FORMULA;
                  _wiersztab.FILE:=_formtab.FILE;
                  _wiersztab.WIERSZ:=_wiersz;
                  _ww:=STR.gsub(_wiersz,' ','');
                  _ww:=STR.gsub(_ww,'\n','');
                  _ww:=STR.gsub(_ww,'\r','');
                  _wiersztab.W:=_ww;
                  _wiersztab.NR:=_nr;
                  _wiersztab.add()
               ?}
            ?}
         !};
         _f_old.fclose();
         &_f_old
      ?};


:: przetwarzamy plik .fml z repozytorium
      _nr:=_nr_f:=_lp:=0;
      _formtab.find_key(_fmls.FILENAME,'Nagłówek pliku: %1'[_fmls.FILENAME],'Nagłówek pliku: %1'[_fmls.FILENAME]);
      {!
      |? (_wiersz:=_f_new.fread())<>'\n'
      |! {? (5+_wiersz)<>':Sign'
         ||
            _lp+=1;
            {? (1+_wiersz)='\\' | (5+_wiersz)='proc'
            || _wiersz:=32+_wiersz;
               _sp:=_wiersz*' ';
               {? _sp>0 || _wiersz:=(_sp-1)+_wiersz ?};
               _nr_f+=1;
               _formtab.cntx_psh();
               _formtab.prefix(_fmls.FILENAME,_wiersz,_wiersz);
               {? _formtab.first() || _find:=_formtab.ref() || _find:=null ?};
               _formtab.cntx_pop();
               {? _find<>null
               || _formtab.seek(_find);
                  _formtab.FORMULAN:=_wiersz;
                  _formtab.put()
               || _formtab.blank();
                  _formtab.FORMULAN:=_wiersz;
                  _formtab.add()
               ?};
               _nr:=0
            || _nr+=1;
               _ww:=STR.gsub(_wiersz,' ','');
               _ww:=STR.gsub(_ww,'\n','');
               _ww:=STR.gsub(_ww,'\r','');
               {? _formtab.FORMULA=_formtab.FORMULAN
               || {? _wiersztab.find_key(_fmls.FILENAME,_formtab.FORMULA,_formtab.FORMULA,_nr)
                  || _wiersztab.WIERSZN:=_wiersz;
                     _wiersztab.WN:=_ww;
                     _wiersztab.NRN:=_nr;
                     _wiersztab.put()
                  || _wiersztab.FILE:=_formtab.FILE;
                     _wiersztab.FORMULA:=_formtab.FORMULA;
                     _wiersztab.WIERSZN:=_wiersz;
                     _wiersztab.WN:=_ww;
                     _wiersztab.WIERSZ:='';
                     _wiersztab.NRN:=_wiersztab.NR:=_wiersztab.NRM:=_nr;
                     _wiersztab.add()
                  ?}
               || _wiersztab.FILE:=_formtab.FILE;
                  _wiersztab.FORMULA:=_formtab.FORMULAN;
                  _wiersztab.WIERSZN:=_wiersz;
                  _wiersztab.WN:=_ww;
                  _wiersztab.NRN:=_wiersztab.NR:=_wiersztab.NRM:=_nr;
                  _wiersztab.WIERSZ:='';
                  _wiersztab.add()
               ?}
            ?}
         ?}
      !};

:: przetwarzamy plik .fml z modified

      _nr:=_nr_f:=_lp:=0;
      _formtab.find_key(_fmls.FILENAME,'Nagłówek pliku: %1'[_fmls.FILENAME],'Nagłówek pliku: %1'[_fmls.FILENAME]);
      {!
      |? (_wiersz:=_f_mod.fread())<>'\n'
      |!
         {? (5+_wiersz)<>':Sign'
         ||
            _lp+=1;
            {? (1+_wiersz)='\\' | (5+_wiersz)='proc'
            || _wiersz:=32+_wiersz;
               _sp:=_wiersz*' ';
               {? _sp>0 || _wiersz:=(_sp-1)+_wiersz ?};
               _nr_f+=1;
               _formtab.cntx_psh();
               _formtab.prefix(_fmls.FILENAME,_wiersz,_wiersz);
               {? _formtab.first() || _find:=_formtab.ref() || _find:=null ?};
               _formtab.cntx_pop();
               {? _find<>null
               || _formtab.seek(_find);
                  _formtab.FORMULAM:=_wiersz;
                  _formtab.put()
               || _formtab.blank();
                  _formtab.FORMULAM:=_wiersz;
                  _formtab.add()
               ?};
               _nr:=0
            || _nr+=1;
               _ww:=STR.gsub(_wiersz,' ','');
               _ww:=STR.gsub(_ww,'\n','');
               _ww:=STR.gsub(_ww,'\r','');
               {? _formtab.FORMULA=_formtab.FORMULAM
               || {? _wiersztab.find_key(_fmls.FILENAME,_formtab.FORMULA,_formtab.FORMULA,_nr)
                  || _wiersztab.WIERSZM:=_wiersz;
                     _wiersztab.WM:=_ww;
                     _wiersztab.NRM:=_nr;
                     _wiersztab.put()
                  || _wiersztab.FORMULA:=_formtab.FORMULA;
                     _wiersztab.FILE:=_formtab.FILE;
                     _wiersztab.WIERSZM:=_wiersz;
                     _wiersztab.WM:=_ww;
                     _wiersztab.WIERSZ:='';
                     _wiersztab.NRM:=_wiersztab.NR:=_wiersztab.NRN:=_nr;
                     _wiersztab.add()
                  ?}
               || _wiersztab.FORMULA:=_formtab.FORMULAM;
                  _wiersztab.FILE:=_formtab.FILE;
                  _wiersztab.WIERSZM:=_wiersz;
                  _wiersztab.WM:=_ww;
                  _wiersztab.NRM:=_wiersztab.NR:=_wiersztab.NRN:=_nr;
                  _wiersztab.WIERSZ:='';
                  _wiersztab.add()
               ?}
            ?}
         ?}
      !};

      _f_new.fclose();
      &_f_new;
      _f_mod.fclose();
      &_f_mod;

:: uzupełnianie kolumny sortujacej
      params_set('formtab',_formtab,'filelist',_filelist,'wiersztab',_wiersztab,'fmls',_fmls,
                 'wierszwin',_wierszwin,'wierszwin_o',_wierszwin_o,'wierszwin_l',_wierszwin_l,
                 'ndx_wo',_ndx_wo,'ndx_wn',_ndx_wn,'ndx_wm',_ndx_wm);
      _formtab.for_each("
                 _formtab:=params_get.formtab;
                 {? _formtab.SORT=''
                 || {? _formtab.FORMULA<>''
                    || _formtab.SORT:=_formtab.FORMULA
                    |? _formtab.FORMULAN<>''
                    || _formtab.SORT:=_formtab.FORMULAN
                    |? _formtab.FORMULAM<>''
                    || _formtab.SORT:=_formtab.FORMULAM
                    ?};
                    {? _formtab.FORMULA='' | _formtab.FORMULAN=''
                    || _formtab.MOD:='M'
                    ?};
                    _formtab.put()
                 ?}");

:: wyszukiwanie zmodyfikowanych formuł pomiędzy kopią lokalną i repozytorium
:: oraz między kopią lokalną, a modified
:: najpierw wyliczany jest hash całych formuł
      _formtab.for_each("
                 _formtab:=params_get.formtab;
                 {? _formtab.FORMULAM<>''
                 ||
                 _wiersztab:=params_get.wiersztab;
                 _warunek_n:=_formtab.FORMULAN<>'' & _formtab.FORMULA=_formtab.FORMULAN;
                 _warunek_m:=_formtab.FORMULAM<>'' & _formtab.FORMULA=_formtab.FORMULAM;
                 {? _formtab.FORMULA<>'' & (_warunek_n | _warunek_m)
                 || _wiersztab.cntx_psh();
                    _wiersztab.prefix(_formtab.FILE,_formtab.FORMULA,_formtab.FORMULA);
                    {? _wiersztab.first()
                    || _form_o:=_form_n:=_form_m:='';
                       {! |?
                             {? _wiersztab.W<>'' & _wiersztab.W<>'\n'
                             || _form_o+=_wiersztab.W
                             ?};
                             {? _warunek_n & _wiersztab.WN<>'' & _wiersztab.WN<>'\n'
                             || _form_n+=_wiersztab.WN
                          ?};
                             {? _warunek_m & _wiersztab.WM<>'' & _wiersztab.WM<>'\n'
                             || _form_m+=_wiersztab.WM
                          ?};
                          _wiersztab.next()
                       !}
                    ?};
                    _wiersztab.cntx_pop();
                    {? _form_o<>'' || _hash_o:=hash(_form_o) || _hash_o:='' ?};
                    {? _form_n<>'' || _hash_n:=hash(_form_n) || _hash_n:='' ?};
                    {? _form_m<>'' || _hash_m:=hash(_form_m) || _hash_m:='' ?};
                       _formtab.HASH:=_hash_o;
                       _formtab.HASHM:=_hash_m;
                       _formtab.HASHN:=_hash_n;
                       _formtab.put();
                    {? _hash_o<>_hash_n
                    || _formtab.MOD:='M';
                       _formtab.put()
                    ?};
                    {? _hash_n<>_hash_m
                    || _formtab.MODM:='M';
                       _formtab.put()
                    ?}
                 ?}
                 ?}
              ");

:: analiza wierszy w zmodyfikowanych formulach, czyli tam, gdzie hash znalazł różnice
      _formtab.for_each("
                 _ndx_wo:=params_get().ndx_wo;
                 _ndx_wn:=params_get().ndx_wn;
                 _ndx_wm:=params_get().ndx_wm;
                 _formtab:=params_get.formtab;
                 _wiersztab:=params_get.wiersztab;
                 _wiersztab.cntx_psh();
                 {? _formtab.MOD='M' & _formtab.MODM='M'
                 || _wiersztab.prefix(_formtab.FILE,_formtab.FORMULA,_formtab.FORMULA);
:: które wiersze z pliku w kopii lokalnej będą zmienione przez wiersze z repozytorium
                    _mod:=0;
                    _modm:=0;
                    {? _wiersztab.first()
                    || {! |?
:: Wiersze linii o tym samy nrze w znormalizowane
                           _wo:=_wiersztab.W;
                           _wn:=_wiersztab.WN;
                           _wm:=_wiersztab.WM;
                           {? _wo=_wn
                           || _ident:=1;
                              _wiersztab.MOD_O:='N';
                              _wiersztab.MOD_N:='N';
                              {? _wm=_wn
                              || _wiersztab.MOD_M:='N'
                              ?}
                           ||
                              _mod:=1;
:: czy wiersz z pliku lokalnego ma swój odpowiednik na svn?
                              {? _wo<>''
                           ||
                              _wiersztab.cntx_psh();
                                 _wiersztab.index(_ndx_wn);
                                 _wiersztab.prefix(_formtab.FILE,_formtab.FORMULA,_formtab.FORMULA,_wo);
                                 _ident:=0;
                                 {? _wiersztab.first()
                                 ||
                                    {! |?
                                          {? _wiersztab.MOD_N<>'N'
                                          || {? _wo=_wiersztab.WN
                                             || _ident:=1;
                                                _wiersztab.MOD_N:='N';
                                                _wiersztab.put()
                                             ?}
                                          ?};
                                          _wiersztab.next() & ~_ident
                                    !}
                                 ?};
                                 _wiersztab.cntx_pop()
                              || _ident:=1
                              ?};

                              {? _ident
                              || _wiersztab.MOD_O:='N'
                              || _wiersztab.MOD_O:='T'
                              ?};
                              _wiersztab.put();
:: czy wiersz z svn znajdzie swój odpowiednik w pliku lokalnym
                              {? _ident
                              || {? _wiersztab.MOD_N<>'N'
                                 || {? _wn<>''
                                    ||
                                       _wiersztab.cntx_psh();
                                       _wiersztab.index(_ndx_wo);
                                       _wiersztab.prefix(_formtab.FILE,_formtab.FORMULA,_formtab.FORMULA,_wn);
                              _ident:=0;
                                       {? _wiersztab.first()
                                       ||
                              {! |?
                                                {? _wn=_wiersztab.W
                                                || _ident:=1
::                                             _wiersztab.MOD_N:='N';
::                                             _wiersztab.put()
                                                ?};
                                    _wiersztab.next() & ~_ident
                                          !}
                                       ?};
                                       _wiersztab.cntx_pop()
                                    || _ident:=1
                                    ?};

                              {? _ident
                              || _wiersztab.MOD_N:='N'
                                    || _wiersztab.MOD_N:='T'
                                    ?};
                                    _wiersztab.put()
                                 ?}
                              ?};

: wiersz będzie zmodyfikowany podczas svn update, sprawdzamy czy w wersji modified jest ten wiersz
                              {? _wiersztab.MOD_M='N' | _wn=_wm
                                 || _wiersztab.MOD_M:='N'
                              || _modm:=1;
                                 {? _wm<>''
                                 ||
                                    _wiersztab.cntx_psh();
                                    _wiersztab.index(_ndx_wn);
                                    _wiersztab.prefix(_formtab.FILE,_formtab.FORMULA,_formtab.FORMULA,_wm);
                                    _wiersztab.first();
                                    _identm:=0;
                                    {! |?
                                          {? _wm=_wiersztab.WN
                                          ||
::                                          _wiersztab.MOD_M:='N';
                                             _identm:=1
                                          ?};
                                          _wiersztab.next() & ~_identm
                                    !};
                                    _wiersztab.cntx_pop()
                                 || _identm:=1
                                 ?};

                                    {? _identm
                                    || _wiersztab.MOD_M:='N'
                                    || _wiersztab.MOD_M:='T'
                                    ?}
::                                 _wiersztab.put()

::                                 {? _identm
::                                 || _wiersztab.cntx_psh();
::                                    _wiersztab.index(_ndx_wm);
::                                    _wiersztab.prefix(_formtab.FILE,_formtab.FORMULA,_formtab.FORMULA,_wn);
::                                    _identm:=0;
::
::                                    _wiersztab.first();
::                                    {! |?
::                                          {? _wiersztab.WM=_wn
::                                          || _identm:=1
::                                          ?};
::                                          _wiersztab.next() & ~_identm
::                                    !};
::                                    _wiersztab.cntx_pop()
::                                 ?};
::
::                                 {? _identm
::                                 || _wiersztab.MOD_M:='N'
::                                 || _wiersztab.MOD_M:='T'
::                                 ?}
                              ?}
                           ?};
                           _wiersztab.put();
                           _wiersztab.next()
                        !};
                        {? _mod=0
                        || _formtab.MOD:='';
                           _formtab.put()
                        ?};
                        {? _modm=0
                        || _formtab.MODM:='';
                           _formtab.put()
                        ?}
                    ?}
                 ?};
                 _wiersztab.cntx_pop()
               ");
:: wyszukujemy zmodyfikowane formuły względem pliku w kopii lokalnej (gdy nie ma pliku w kopii lokalnej
:: wszystkie formuły z docelowego pliku .fml powinny trafić na listę
      _formtab.cntx_psh();
      _filelist.cntx_psh();
      _formtab.index(_ndx_f);
      _filelist.index(_ndx_filelist);
      _formtab.prefix(_fmls.FILENAME);
      {? _formtab.first()
      || {!
         |?
:: We wszystkich trzech plikach są dane formuły i różnią się
            {? _formtab.FORMULA<>'' & _formtab.FORMULAN<>'' & _formtab.FORMULAM <>''
             & _formtab.FORMULA=_formtab.FORMULAN & _formtab.FORMULA=_formtab.FORMULAM
            || {? _formtab.MOD='M' & _formtab.MODM='M'
               || _filelist.prefix(_fmls.FILENAME);
                  {? _filelist.first()
                  || _filelist.MOD:='M';
                     _filelist.MODM:='M';
                     _filelist.put()
                  || _filelist.FILE:=_fmls.FILENAME;
                     _filelist.PATH:=_fmls.PATH;
                     _filelist.PATHNEW:=_fmls.PATHNEW;
                     _filelist.PATHMOD:=_fmls.PATHMOD;
                     _filelist.MOD:='M';
                     _filelist.MODM:='M';
                     _filelist.add()
                  ?}
               ?}
:: Brakuje formuły w pliku new, ale jest w old i w modified
            |? _formtab.FORMULA<>'' & _formtab.FORMULAN='' & _formtab.FORMULAM<>''
            || {? _formtab.FORMULA<>'' & _formtab.FORMULAN=''
               || _filelist.prefix(_fmls.FILENAME);
                  {? _filelist.first()
                  || _filelist.MOD:='M';
                     _filelist.MODM:='M';
                     _filelist.put()
                  || _filelist.FILE:=_fmls.FILENAME;
                     _filelist.MOD:='M';
                     _filelist.MODM:='M';
                     _filelist.PATH:=_fmls.PATH;
                     _filelist.PATHNEW:=_fmls.PATHNEW;
                     _filelist.PATHMOD:=_fmls.PATHMOD;
                     _filelist.add()
                  ?}
               ?}
:: nie było formuły w old, ale jest w modified i new
            |? _formtab.FORMULA='' & _formtab.FORMULAN<>'' & _formtab.FORMULAM<>''
            || {? _formtab.MODM='M'
               || _filelist.prefix(_fmls.FILENAME);
                  {? _filelist.first()
                  || _filelist.MOD:='M';
                     _filelist.MODM:='M';
                     _filelist.put()
                  || _filelist.FILE:=_fmls.FILENAME;
                     _filelist.MOD:='M';
                     _filelist.MODM:='M';
                     _filelist.PATH:=_fmls.PATH;
                     _filelist.PATHNEW:=_fmls.PATHNEW;
                     _filelist.PATHMOD:=_fmls.PATHMOD;
                     _filelist.add()
                  ?}
               ?}
            ?};
            _formtab.next()
         !}
      ?};
      _formtab.cntx_pop();
      _filelist.cntx_pop();
      _fmls.next()
   !};
   {? _view
   || FUN.prg_stop()
   ?}
?};
{? _view
|| _filelist.select()
?};
_filelist


\create_tabs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_filelist:=tab_tmp(1,'FILE','STRING[32]','Plik'@,
                  'MOD','STRING[1]','Typ modyfikacji'@,
                  'MODM','STRING[1]','Typ modyfikacji M'@,
                  'PATH','STRING[255]','Ścieżka do pliku lokalnego',
                  'PATHNEW','STRING[255]','Ścieżka do pliku w repozytorium',
                  'PATHMOD','STRING[255]','Ścieżka do pliku w modified');
_ndx_filelist:=_filelist.ndx_tmp(,1,'FILE',,);
_filelist.index(_ndx_filelist);

:: tabela formul
_formtab:=tab_tmp(1,'FORMULA','STRING[48]','Formuła lokalna'@,
                  'FORMULAN','STRING[48]','Formuła na repozytorium'@,
                  'FORMULAM','STRING[48]','Formuła w warstwie klienckiej'@,
                  'SORT','STRING[16]','Sortowanie'@,
                  'MOD','STRING[1]','Czy formuła modyfikowana w repozytorium zmodyfikowana?'@,
                  'MODM','STRING[1]','Czy formuła modyfikowana w modified zmodyfikowana?'@,
                  'HASH','STRING[1]','Hash lokalny?'@,
                  'HASHM','STRING[1]','Hash modified'@,
                  'HASHN','STRING[1]','Hash svn'@,
                  'FILE','STRING[32]','Plik'@);

_ndx_f:=_formtab.ndx_tmp(,1,'FILE',,,'FORMULA',,,'FORMULA',,,'MOD',,,'MODM',,);
_formtab.index(_ndx_f);
_ndx_s:=_formtab.ndx_tmp(,1,'SORT',,);

:: tabela wierszy formul
_wiersztab:=tab_tmp(2,'FORMULA','STRING[32]','Formuła'@,
                    'WIERSZ','STRING[255]','Wiersz lokalny'@,
                    'WIERSZN','STRING[255]','Wiersz w repozytorium'@,
                    'WIERSZM','STRING[255]','Wiersz w modified'@,
                    'W','STRING[255]','Wiersz lokalny - postać znormalizowana'@,
                    'WN','STRING[255]','Wiersz w repozytorium - postać znormalizowana'@,
                    'WM','STRING[255]','Wiersz w modified - postać znormalizowana'@,
                    'NR','INTEGER','Nr lok.'@,
                    'NRN','INTEGER','Nr repo.'@,
                    'NRM','INTEGER','Nr mod.'@,
                    'MOD_O','STRING[1]','Modyfikacja w kopii lokalnej'@,
                    'MOD_N','STRING[1]','Modyfikacja w w wersji z repozytorium'@,
                    'MOD_M','STRING[1]','Modyfikacja w modified'@,
                    'FILE','STRING[32]','Plik'@);
_ndx_w:=_wiersztab.ndx_tmp(,1,'FILE',,,'FORMULA',,,'FORMULA',,,'NR',,);
_ndx_wo:=_wiersztab.ndx_tmp(,1,'FILE',,,'FORMULA',,,'FORMULA',,,'W',,);
_ndx_wn:=_wiersztab.ndx_tmp(,1,'FILE',,,'FORMULA',,,'FORMULA',,,'WN',,);
_ndx_wm:=_wiersztab.ndx_tmp(,1,'FILE',,,'FORMULA',,,'FORMULA',,,'WM',,);
_wiersztab.index(_ndx_w);


_win_p:=_filelist.mk_sel('Pliki'@,,0,'#filelist',,,,,'U');
_filelist.win_fld(_win_p,,'FILE',,,,,,'Plik'@);
_filelist.win_act(_win_p,,'Formuła','Formuły'@@,,,"
                                              params_set(params_get());
                                              _filelist:=params_get.filelist;
                                              _formtab:=params_get.formtab;
                                              _ndx_f2:=_formtab.ndx_tmp(,1,'FILE',,,'MOD',,,'MODM',,);
                                              _formtab.index(_ndx_f2);
                                              _formtab.prefix(_filelist.FILE,'M','M');
                                              _formtab.hdr_sel();
                                              _formtab.hdr_sel('Plik: %1'@[_filelist.FILE]);
                                              _formtab.select()
                                             ",,1);
{? ~exec('interm','#system')
|| _filelist.win_act(_win_p,,'Formuła','Otwórz w &MacroEdytorze'@@,,,"exec('openME','%transfer')");
   _filelist.win_act(_win_p,,'Formuła','Porównanie &zewnętrznym programem'@@,,,"exec('openWinMerge','%transfer')")
?};
_filelist.win_sel(_win_p);

_win_f:=_formtab.mk_sel(,,0,'#formwin',,,,,'U');
_formtab.win_fld(_win_f,_formtab,'FORMULA',,, 20,,0,'Formuły lokalne'@);
_formtab.win_fld(_win_f,_formtab,'FORMULAN',,,20,,0,'Formuły na repozytorium'@);
_formtab.win_fld(_win_f,_formtab,'FORMULAM',,,20,,0,'Formuły z modified'@);
_formtab.fld_fml('FORMULA','BEFORE_DISPLAY',"params_exec('flddisp','color','__FORM#01#01')");
_formtab.fld_fml('FORMULAN','BEFORE_DISPLAY',"params_exec('flddisp','color','__FORM#01#02')");
_formtab.fld_fml('FORMULAM','BEFORE_DISPLAY',"params_exec('flddisp','color','__FORM#01#03')");
_formtab.win_act(_win_f,0,'Formuła','Wiersze'@@,,,,"
                                                params_set(params_get());
                                                _formtab:=params_get().formtab;
                                                _wiersztab:=params_get().wiersztab;
                                                _wierszwin:=params_get().wierszwin;
                                                _wierszwin_o:=params_get().wierszwin_o;
                                                _wierszwin_l:=params_get().wierszwin_l;
                                                {? _formtab.FORMULA<>'' & _formtab.FORMULAN<>'' & _formtab.FORMULA=_formtab.FORMULAN
                                                || _wiersztab.win_sel(_wierszwin);
                                                   _wiersztab.prefix(_formtab.FILE,_formtab.FORMULA,_formtab.FORMULA);
                                                   _wiersztab.hdr_sel();
                                                   _wiersztab.hdr_sel('Formuła: %1'@[_formtab.FORMULA]);
                                                   _wiersztab.select()
                                                |? _formtab.FORMULA='' & _formtab.FORMULAN<>''
                                                || _wiersztab.win_sel(_wierszwin_l);
                                                   _wiersztab.prefix(_formtab.FILE,_formtab.FORMULAN,_formtab.FORMULAN);
                                                   _wiersztab.hdr_sel();
                                                   _wiersztab.hdr_sel('Formuła: %1'@[_formtab.FORMULAN]);
                                                   _wiersztab.select();
                                                   _wiersztab.win_sel(_wierszwin)
                                                |? _formtab.FORMULA<>'' & _formtab.FORMULAN=''
                                                || _wiersztab.win_sel(_wierszwin_o);
                                                   _wiersztab.prefix(_formtab.FILE,_formtab.FORMULA,_formtab.FORMULA);
                                                   _wiersztab.hdr_sel();
                                                   _wiersztab.hdr_sel('Formuła: %1'@[_formtab.FORMULA]);
                                                   _wiersztab.select();
                                                   _wiersztab.win_sel(_wierszwin)
                                                || FUN.info('Sytuacja nieobsługiwana.'@@)
                                                ?}"
                                                ,1);
::_formtab.win_act(_win_f,0,'Rekord',,,,"params_exec('rekprzed','color','__FORM#01')","",0);
_formtab.win_act(_win_f,0,'Formuła','Legenda'@@,,,"exec('legenda','color','__FORM#01')","",0);
_formtab.win_sel(_win_f);


_wiersztab.fld_fml('WIERSZ','BEFORE_DISPLAY',"params_exec('flddisp','color','__WIERSZ#01#01')");
_wiersztab.fld_fml('WIERSZN','BEFORE_DISPLAY',"params_exec('flddisp','color','__WIERSZ#01#02')");
_wiersztab.fld_fml('WIERSZM','BEFORE_DISPLAY',"params_exec('flddisp','color','__WIERSZ#01#03')");
_wiersztab.fld_fml('NR','BEFORE_DISPLAY',"params_exec('flddisp','color','__WIERSZ#01#04')");
_wiersztab.fld_fml('NRN','BEFORE_DISPLAY',"params_exec('flddisp','color','__WIERSZ#01#04')");
_wiersztab.fld_fml('NRM','BEFORE_DISPLAY',"params_exec('flddisp','color','__WIERSZ#01#04')");
_ndx_w:=_wiersztab.ndx_tmp(,1,'FILE',,,'FORMULA',,,'FORMULA',,,'NR',,);
::      _ndx_n:=_wiersztab.ndx_tmp(,1,'FORMULAN',,,'FORMULAN',,,'NR',,);
::      _ndx_m:=_wiersztab.ndx_tmp(,1,'FORMULAM',,,'FORMULAM',,,'NR',,);
_wiersztab.index(_ndx_w);
:: okno porowania
_wierszwin:=_wiersztab.mk_sel(,,0,'#wierszwin',,,,,'U');
_wiersztab.win_fld(_wierszwin,_wiersztab,'NR'     ,,,3 ,,0,'Nr'@);
_wiersztab.win_fld(_wierszwin,_wiersztab,'WIERSZ' ,,,56,,0,'Wiersze z pliku lokalnego'@);
_wiersztab.win_fld(_wierszwin,_wiersztab,'NRN'    ,,,3 ,,0,'Nr'@);
_wiersztab.win_fld(_wierszwin,_wiersztab,'WIERSZN',,,56,,0,'Wiersze z pliku na repozytorium'@);
_wiersztab.win_fld(_wierszwin,_wiersztab,'NRM'    ,,,3 ,,0,'Nr'@);
_wiersztab.win_fld(_wierszwin,_wiersztab,'WIERSZM',,,56,,0,'Wiersze z pliku w modified'@);
_wiersztab.win_act(_wierszwin,0,'Formuła','Legenda'@@,,,"exec('legenda','color','__WIERSZ#01')","",1);
:: okno dla formul z OLD
_wierszwin_o:=_wiersztab.mk_sel(,,0);
_wiersztab.win_fld(_wierszwin_o,_wiersztab,'NR'     ,,,4 ,,0,'Nr'@);
_wiersztab.win_fld(_wierszwin_o,_wiersztab,'WIERSZ' ,,,80,,0,{? UPD.DIFF_SEL='O' || 'Wiersze z pliku OLD'@ || 'Wiersze z nowego pliku'@ ?});
:: okno dla formul lokalnych
_wierszwin_l:=_wiersztab.mk_sel(,,0);
_wiersztab.win_fld(_wierszwin_l,_wiersztab,'NRN'     ,,,4 ,,0,'Nr'@);
_wiersztab.win_fld(_wierszwin_l,_wiersztab,'WIERSZN' ,,,80,,0,'Wiersze z pliku lokalnego'@);

_wiersztab.win_sel(_wierszwin);

_tabs:=obj_new('ctr_id'
               ,'filelist'
               ,'ndx_filelist'
               ,'formtab'
               ,'ndx_f'
               ,'ndx_s'
               ,'wiersztab'
               ,'ndx_w'
               ,'ndx_wo'
               ,'ndx_wm'
               ,'ndx_wn'
               ,'win_f'
               ,'wierszwin'
               ,'wierszwin_o'
               ,'wierszwin_l');

_tabs.filelist:=_filelist;
_tabs.ndx_filelist:=_ndx_filelist;
_tabs.formtab:=_formtab;
_tabs.ndx_f:=_ndx_f;
_tabs.ndx_s:=_ndx_s;
_tabs.wiersztab:=_wiersztab;
_tabs.ndx_w:=_ndx_w;
_tabs.ndx_wo:=_ndx_wo;
_tabs.ndx_wm:=_ndx_wm;
_tabs.ndx_wn:=_ndx_wn;
_tabs.win_f:=_win_f;
_tabs.wierszwin:=_wierszwin;
_tabs.wierszwin_o:=_wierszwin_o;
_tabs.wierszwin_l:=_wierszwin_l;
return(_tabs)


\kol_formul
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Kolor formul w oknie z lista formul pliku
::   WY: Kod koloru
::----------------------------------------------------------------------------------------------------------------------
_formtab:=params_get.formtab;
{? _formtab.MOD='M' & _formtab.MODM='M'
|| '__FORM#01#04'
|? _formtab.MOD='M' | _formtab.MODM='M'
|| '__FORM#01#01'
|| ''
?}


\kol_formuln
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Kolor formul w oknie z lista formul pliku
::   WY: Kod koloru
::----------------------------------------------------------------------------------------------------------------------
_formtab:=params_get.formtab;
{? _formtab.MOD='M' & _formtab.MODM='M'
|| '__FORM#01#04'
|? _formtab.MOD='M'
|| '__FORM#01#02'
?}


\kol_formulm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Kolor formul w oknie z lista formul pliku
::   WY: Kod koloru
::----------------------------------------------------------------------------------------------------------------------
_formtab:=params_get.formtab;
{? _formtab.MOD='M' & _formtab.MODM='M'
|| '__FORM#01#04'
|? _formtab.MODM='M'
|| '__FORM#01#03'
?}


\kol_formuly
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Kolor formul w oknie z lista formul pliku
::   WY: Kod koloru
::----------------------------------------------------------------------------------------------------------------------
_formtab:=params_get.formtab;
{? _formtab.MOD='M' & _formtab.MODM='M' || '__FORM#01#04'
|| ''
?}


\kol_wierszo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Kolor pola WIERSZ w oknie porownywania formul
::   WY: Kod koloru
::----------------------------------------------------------------------------------------------------------------------
_wiersztab:=params_get.wiersztab;
{? _wiersztab.MOD_O='T' || '__WIERSZ#01#01' || '' ?}


\kol_wierszl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Kolor pola WIERSZL w oknie porownywania formul
::   WY: Kod koloru
::----------------------------------------------------------------------------------------------------------------------
_wiersztab:=params_get.wiersztab;
{? _wiersztab.MOD_N='T' || '__WIERSZ#01#02' || '' ?}


\kol_wierszm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Kolor pola WIERSZL w oknie porownywania formul
::   WY: Kod koloru
::----------------------------------------------------------------------------------------------------------------------
_wiersztab:=params_get.wiersztab;
{? _wiersztab.MOD_M='T' || '__WIERSZ#01#03' || '' ?}


\wiersz_nr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Kolor pola NR i NRM w oknie porownywania lub wyswietlania formul
::   WY: Kod koloru
::----------------------------------------------------------------------------------------------------------------------
'__WIERSZ#01#04'


\openME
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Funkcja otwierająca plik w MacroEdytorze
::   WE:
::   WY:
:: ~OST: INENVGET,INFILECHOOSER,INSYSTEM
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file');
_path:=exec('get','#params',4300,,OPERATOR.USER);
{? _path=''
|| _f_def:="_path:=exec('filechooser','#file','Plik wykonywalny MacroEdytora'@,,'jar; exe; bat');
            {? _path<>''
            || VAR.STRING:=_path
            ?}";

   VAR.cntx_psh();
   _string:=VAR.STRING;
   VAR.STRING:='';
   VAR.fld_fml('STRING','F3',_f_def);
   _path_win:=VAR.mk_edit('Ścieżka do pliku wykonywalnego Macroedytora'@,0,'#pathwin4300');
   VAR.win_efld(_path_win,VAR,'STRING',,,100,,0,'Ścieżka'@,,'Plik wykonywalny programu porównującego pliki'@);
   VAR.win_ebtn(_path_win,'text=&OK'+',icon=xwin16.png:13,btn_label_align=center,panel=bottom,align=end','key:F2');
   VAR.win_ebtn(_path_win,'text=%1,icon=xwin16.png:14,btn_label_align=center,panel=bottom,align=end'['&Anuluj'@],'key:Esc');
   VAR.win_edit(_path_win);
   {? VAR.edit()
   || exec('set','#params',4300,VAR.STRING,OPERATOR.USER);
      _path:=VAR.STRING
   ?};
   VAR.STRING:=_string;
   VAR.cntx_pop()
?};
{? _path<>''
|| _filepath:=exec('filechooser','#file','Zapisz plik new i otwórz w MacroEdytorze'@,,,,,'DIRECTORIES_ONLY',1);
   {? _filepath<>''
   || VAR.STRING:=_filepath;
      fcopy(cur_tab().PATHNEW,_filepath,0,0,1);
      {? _path+4='.jar' & 4+_path<>'java'
      || _command:='java -jar ' + _path + ' ' + _filepath +_sep + cur_tab().FILE
      || _command:=_path + ' ' + _filepath + _filepath + _sep + cur_tab().FILE
      ?};
      _sys_res:=system('@'+envget('@COMSPEC')+' /c ' + _command,0)
   ?}
?}


\openWinMerge
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Funkcja otwierająca plik w zewnętrznym programie do porównywania plików.
::       Pliki kopiowane są do katalogu tymczasowego
::   WE:
::   WY:
:: ~OST: INENVGET,INFILECHOOSER,INSYSTEM
::----------------------------------------------------------------------------------------------------------------------
_workdir:=exec('workdir','%transfer');
_path:=exec('get','#params',4301,,OPERATOR.USER);
_sep:=exec('sep','#file');
{? _path=''
|| _f_def:="_path:=exec('filechooser','#file','Plik wykonywalny programu porównującego pliki'@,,'exe',,,,,
                     {? VAR.STRING<>'' || VAR.STRING ?});
            {? _path<>''
            || VAR.STRING:=_path
            ?}";

   VAR.cntx_psh();
   _string:=VAR.STRING;
   VAR.STRING:='';
   VAR.fld_fml('STRING','F3',_f_def);
   _path_win:=VAR.mk_edit('Ścieżka do programu porównującego pliki'@,0,'#pathwin4301');
   VAR.win_efld(_path_win,VAR,'STRING',,,100,,0,'Ścieżka'@,,'Plik wykonywalny programu porównującego pliki'@);
   VAR.win_ebtn(_path_win,'text=&OK'+',icon=xwin16.png:13,btn_label_align=center,panel=bottom,align=end','key:F2');
   VAR.win_ebtn(_path_win,'text=%1,icon=xwin16.png:14,btn_label_align=center,panel=bottom,align=end'['&Anuluj'@],'key:Esc');
   VAR.win_edit(_path_win);
   {? VAR.edit()
   || exec('set','#params',4301,VAR.STRING,OPERATOR.USER);
      _path:=VAR.STRING
   ?};
   VAR.STRING:=_string;
   VAR.cntx_pop()
?};
{? _path<>''
|| fcopy(cur_tab().PATH,_workdir+_sep+cur_tab().FILE+'.old',0,0,1);
   fcopy(cur_tab().PATHNEW,_workdir+_sep+cur_tab().FILE+'.new',0,0,1);
   fcopy(cur_tab().PATHMOD,_workdir+_sep+cur_tab().FILE+'.mod',0,0,1);

   _command:='"%1" "%2" "%3" "%4"'[_path, _workdir+_sep+cur_tab().FILE+'.old'
                                        , _workdir+_sep+cur_tab().FILE+'.new'
                                        , _workdir+_sep+cur_tab().FILE+'.mod'];
   _sys_res:=system('@' + _command,0)
::   _sys_res:=system('@'+envget('@COMSPEC')+' /c ' + _command,1)
?}


\nanies_def
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Naniesienie zmian klienckich na definiję systemu
::   WE: _a - json z konfiguracja procesu
::       [_b] - skąd brać definicję klienta
::              1 - [domyślnie] - według pth_dir
::              2 - według ścieżki z parametru _d
::              3 - brać z buildera (z połączenia odbc)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_workdir:=exec('workdir','%transfer');
_sep:=exec('sep','#file',1);
_bak_def:=_workdir+_sep+'merit.def_bak';

{? exec('latest_proc','%transfer')
|| _epilog:="{? _b=1
             || _result:='OK. Nanoszenie zmian definicji systemu zakończone powodzeniem.'
             || _result:='BŁĄD. Nanoszenie zmian definicji systemu zakończone niepowodzeniem.\n';
                _result+='Napotkane problemy: \n';
                _loop:=__batch_error.first();
                {!
                |? _loop
                |! _result+=$__batch_error.NR+'. '+__batch_error.TXT+'\n';
                   _loop:=__batch_error.next()
                !}
             ?};
             exec('set_elem','%transfer',exec('result_blank','%transfer',_a),'definicja_systemu',_result)
            ";
   _dsn:=exec('cfg_get_elem','%transfer',_a,'builder_dsn');
   {? _a=''
   || {? var_pres('__batch_comp')>0  || obj_del(__batch_comp);&__batch_comp  ?};
      {? var_pres('__batch_error')>0 || obj_del(__batch_error);&__batch_error ?};
      exec('error_set','%transfer');
      __batch_comp.error('Nie podane źródło danych ODBC'@);
      {? exec('latest_proc','%transfer')
      || return(_epilog(_a,-1))
      || return(-1)
      ?}
   ?};
   _zws_tran_wer:=exec('cfg_get_elem','%transfer',_a,'zws_tran_wer');
   {? _zws_tran_wer='T'
   ||
:: Najpierw pobieramy standardowego defa z nowej wersji
     _url_new_def:=exec('cfg_get_elem','%transfer',_a,'svn_url_new');
     _svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));
     _standard:=_workdir+_sep+'merit.def';
     {? _url_new_def<>''
     || exec('svn_export','%transfer',_url_new_def+_sep+'defy'+_sep+'merit.def',_standard,_svn)
     ?}
   || _standard:=exec('cfg_get_elem','%transfer',_a,'new_def')
   ?};
   {? _standard=''
   || _standard:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'defy'+_sep+'merit.def'
   ?};
   _cfg:=exec('cfg_get_elem','%transfer',_a,'macro_cfg_linux');
   _merit_pth:=exec('cfg_get_elem','%transfer',_a,'merit_path');
   {? _merit_pth=''
   || _merit_pth:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
   ?};
   {? var_pres('_b')=type_of(0)
   || {? _b<=3 & _b>=1
      || _klient_mode:=_b
      || _klient_mode:=1
      ?}
   || _klient_mode:=1
   ?};
   _restore:={? exec('cfg_get_elem','%transfer',_a,'restore_def')='1' || 1 || 0 ?};
   _builder_user:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'MB_record_id'))
||
::   WE: _a - źródło danych odbc
::       [_b] - ścieżka do defa standardowego
::       [_c] - ścieżka do katalogu konfiguracyjnego serwera linux
::       [_d] - ścieżka do katalogu merit (według tej ścieżki zostanie wygenerowana nowa definicja)
::       [_e] - skąd brać definicję klienta
::              1 - [domyślnie] - według pth_dir
::              2 - według ścieżki z parametru _d
::              3 - brać z buildera (z połączenia odbc)
::       [_f] - czy mimo powodzenia nanoszenia zmian klienckich przywracać w builderze definicję sprzed zmian
::       [_g] - rekord z poświadczeniami mbuildera (POCZTAM)
   {? var_pres('_a')=type_of('') & _a<>''
   || _dsn:=_a
   || {? var_pres('__batch_comp')>0  || obj_del(__batch_comp);&__batch_comp  ?};
      {? var_pres('__batch_error')>0 || obj_del(__batch_error);&__batch_error ?};
      exec('error_set','%transfer');
      __batch_comp.error('Nie podane źródło danych ODBC'@);
      {? exec('latest_proc','%transfer')
      || return(_epilog(_a,-1))
      || return(-1)
      ?}
   ?};

   {? var_pres('_b')=type_of('')
   || _standard:=_b
   || _standard:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'defy'+_sep+'merit.def'
   ?};

   {? var_pres('_c')=type_of('')
   || _cfg:=_c
   || _cfg:=''
   ?};
   {? var_pres('_d')=type_of('') & _d <>''
   || _merit_pth:=_d
   || _merit_pth:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
   ?};
   {? var_pres('_e')=type_of(0)
   || {? _e<=3 & _e>=1
      || _klient_mode:=_e
      || _klient_mode:=1
      ?}
   || _klient_mode:=1
   ?};
   {? var_pres('_f')=type_of(0) & _f='1'
   || _restore:=1
   || _restore:=0
   ?};
   _builder_user:=_g
?};

:: sprawdzamy czy działa połączenie z builderem i przy okazji odkładamy kopię defa z buildera
{? var_pres('__batch_comp')>0  || obj_del(__batch_comp);&__batch_comp  ?};
{? var_pres('__batch_error')>0 || obj_del(__batch_error);&__batch_error ?};
exec('error_set','%transfer');
_out:=_workdir+_sep;
{? fexists(_out+_sep+'merit.new',0)
|| ferase(_out+_sep+'merit.new')
?};
_gen:=exec('gen_call','%transfer',_dsn,_out,_builder_user);
{? _gen<>1
|| __batch_comp.error('Błąd generowania definicji'@);
   {? exec('latest_proc','%transfer')
   || return(_epilog(_a,-1))
   || return(-1)
   ?}
?};
fcopy(_out+_sep+'merit.new',_bak_def,0,0,1);
ferase(_out+_sep+'merit.new');

:: ustalamy miejsce poboru defa klienta
{? _klient_mode=1
|| _klient:=pth_dir('merit.def')+_sep+'merit.def'
|? _klient_mode=2
|| _klient:=_merit_pth+_sep+'system'+_sep+'merit.def'
|? _klient_mode=3
|| _klient:=_workdir+_sep+'merit.def';
   fcopy(_bak_def,_klient,0,0,1)
?};
{? _standard+4='.def'
|| fcopy(_standard,_workdir+_sep+'merit.new',0,0,1);
   _standard:=_workdir+_sep+'merit.new'
?};

:: próbujemy nanieś w builderze zmiany klienckie na defa standardowego
_wyn:=exec('batch_call','%transfer',_dsn,_standard,_klient,_merit_pth+_sep+'system',0,_cfg,_builder_user);
:: w przypadu niepowodzenia przywracamy w builderze def pierwotny
{? _wyn<>1 | _restore
|| _rest_def:=_workdir+_sep+'merit.new';
   fcopy(_bak_def,_rest_def,0,0,1);
   _import_bak:=exec('import_call','%transfer',_dsn,_rest_def,_builder_user);
:: w przypadku powodzenia czyścimy zbędne definicje
   {? _import_bak<>-1
   || ferase(_rest_def)
   || {? exec('latest_proc','%transfer')
      || return(_epilog(_a,-1))
      || return(-1)
      ?}
   ?}
?};
{? _klient*_workdir>0
|| ferase(_workdir+_sep+'merit.def')
?};
{? _standard*_workdir>0
|| ferase(_workdir+_sep+'merit.new')
?};
ferase(_bak_def);
__batch_error.export('error.txt',0,,,,'NR',,1,,'TXT',,2,);
{? exec('latest_proc','%transfer')
|| return(_epilog(_a,_wyn))
|| return(_wyn)
?}


\parse_config_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Przetwarza plik konfiguracyjny i pobiera wartość wskazanego argumentem parametru
::   WE: _a - STRING - ścieżka do pliku konfiguracyjnego
::       [_b] - 1/0 jeżeli podany, równy 1 oraz działamy z najnowszą wersją procesu ZWS_TRAN to parametry parsujemy i
::              trzymamy w xml w MEMO pomiędzy kolejnymi elementami procesu
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? exec('latest_proc','%transfer') & var_pres('_b')=type_of(1) & _b=1
|| _param_tab:=json_parse(exec('blank_cfg_json','%transfer'));
   {? type_of(_a)<>type_of('') | _a=''
   || _plik:=fopen(exec('cfg_file_name','%transfer','autotran.cfg'),'ur',1)
   || _plik:=fopen(_a,'ur',0)
   ?};
   {? _plik
   || {!
      |? (_wiersz:=fread(_plik))<>'\n'
      |! _wiersz:=|_wiersz;
         {? _wiersz<>'' & 1+_wiersz<>';'
         || {! _i:=1..obj_len(_param_tab)
            |! {? _param_tab[_i].VALUE='' & (+_param_tab[_i].NAME)+gsub(_wiersz,' ','')=_param_tab[_i].NAME
               || _param_tab[_i].VALUE:=exec('delspace','#string',(_wiersz*'=')-_wiersz);
                  _i:=obj_len(_param_tab)
               ?}
            !}
         ?}
      !};
      fclose(_plik)
   ?};
   _cfg_json:=json_obj(_param_tab);
:: wczytanie parametrów które mogły przyjść z rozpoczęcia procesu ZWS_TRAN_WER
   _par:=params_get().in;
   {? var_pres('p02',_par)=type_of('') & _par.p02<>''
   || _cfg_json:=exec('set_cfg_elem','%transfer',_cfg_json,'zws_tran_wer',_par.p02)
   ?};
   {? var_pres('p03',_par)=type_of('') & _par.p03<>''
   || _cfg_json:=exec('set_cfg_elem','%transfer',_cfg_json,'svn_url_new',_par.p03)
   ?};
   {? var_pres('p04',_par)=type_of('') & _par.p04<>''
   || _cfg_json:=exec('set_cfg_elem','%transfer',_cfg_json,'svn_url_mod',_par.p04)
   ?};

   return(_cfg_json)
||
::   WE: _a - STRING - nazwa parametru konfiguracyjnego
   {? var_pres('_a')=type_of('')
   || _parametr:=_a
   || return()
   ?};
   _path:='';
   {? var_pres('in',params_get())>100
   || _path:=params_get().in.p01
   ?};
   {? type_of(_path)<>type_of('') | _path=''
   || _plik:=fopen('autotran.cfg','ur',1)
   || _plik:=fopen(_path,'ur',0)
   ?};
   _can_continue:=1;
   {? _plik
   || {!
      |? (_wiersz:=fread(_plik))<>'\n' & _can_continue
      |! _wiersz:=|_wiersz;
         {? _wiersz<>'' & 1+_wiersz<>';'
         ||
            {? _wiersz*_parametr
            || _start:=_wiersz*'=';
               _wartosc:=(_start)-_wiersz;
               _wartosc:=exec('delspace','#string',_wartosc);
               _can_continue:=0;
               fclose(_plik);
               return(_wartosc)
            ?}
         ?}
      !};
      fclose(_plik)
   ?};
   ''
?}


\blank_cfg_json
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca pusty json z configuracja procesu. Na potrzeby testow
::----------------------------------------------------------------------------------------------------------------------
_params_list:=spli_str(exec('cfg_par_list','%transfer'),';');
_param_tab:=obj_new(obj_len(_params_list));
{! _i:=1..obj_len(_params_list)
|! _param_tab[_i]:=obj_new('NAME','VALUE');
   _param_tab[_i].NAME:=_params_list[_i];
   _param_tab[_i].VALUE:=''
!};
return(json_obj(_param_tab))


\cfg_par_list
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca liste parametrow dla konfiguracji procesu
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
'macro_cfg_builder;MB_record_id;macro_cfg_linux;new_def;pth_path;merit_path;modified_path;update_pth_if_diff;'+
'webserver_start;webserver_stop;copy_def;name;mail_address;webserver_service_name;builder_dsn;svn_record_id;'+
's_mail_address;smtp;restore_def;zws_tran_wer;svn_url_new;svn_url_mod;upg_cfg_file;force_mod_update'


\set_cfg_elem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [22.26]
:: OPIS: Uzupelnia wartosc podanego parametru w json konfiguracji procesu
::   WE: _a - json z konfiguracja procesu
::       _b - nazwa parametru do uzupelnienia
::       _c - wartosc parametru
::   WY: uaktualniony json z konfiguracja procesu
::----------------------------------------------------------------------------------------------------------------------
_cfg:=json_parse(_a);
{? type_of(_cfg)>100
|| {! _i:=1..obj_len(_cfg)
   |! {? _cfg[_i].NAME=_b
      || _cfg[_i].VALUE:=_c;
         _i:=obj_len(_cfg)
      ?}
   !}
?};
return(json_obj(_cfg))


\file_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Przemyslaw Grochowski [wersja: 20.32]
:: OPIS: Wydobycie nazwy pliku ze sciezki
::   WE: _a - sciezka
::   WY: nazwa pliku
::----------------------------------------------------------------------------------------------------------------------
_path:=gsub(_a,'\\','/');
_file:=spli_str(_path,'/');
_last:=obj_len(_file);
_file[_last]


\error_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Przemyslaw Grochowski [wersja: 20.32]
:: OPIS: Obiekt do przechowywania bledow
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__batch_comp')<0
||
   __batch_comp:=obj_new('error');
   __batch_comp.error:="__batch_error.NR:=__batch_error.size()+1;__batch_error.TXT:=_a;__batch_error.add()";
   {? var_pres('__batch_error')<0
   || __batch_error:=tab_tmp(,'NR','INTEGER','NR','TXT','STRING[255]','Wynik')
   ?}
?}


\restore_call
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Przemyslaw Grochowski [20.32]
:: OPIS: Przywrocenie backupu poprzez procedure wbudowana
::  WE:  _a - zrodlo danych
::       _b - ścieżka do zipa
::----------------------------------------------------------------------------------------------------------------------
_odb:=_a;
_path:=_b;
_down:=odbc_con(_odb);
{? type_of(_down) = type_of(~~) ||
   __batch_comp.error('Błąd otwarcia źródła odbc'@);
   return(-1)
?};
{? 1+_path='@'
||
   {? ~fexists(_path,0)
   ||
      __batch_comp.error('Błędna ścieżka lub brak dostępu do pliku %1'@[_path]);
      return(-1)
   ?};
   _tmpdir:=fmk_tmp_dir();
   {? type_of(_tmpdir) = type_of(~~)
   ||
      __batch_comp.error('Błąd utworzenia katalogu tymczasowego'@);
      return(-1)
   ?};
   _path_tmp:=gsub(_tmpdir.get_path,'\\','/');
   _f_name:=exec('file_name','%transfer',_path);
:: Kopiowanie pliku na serwer aplikacji jterma
   {? ~fcopy(_path,_path_tmp+'/'+_f_name,0, 0, 1)
   ||
      __batch_comp.error('Błąd przy kopiowaniu pliku %1'@[_path]);
      return(-1)
   || _path:='@'+_path_tmp+'/'+_f_name
   ?}
?};
_cur:=_down.exec_cur('{call restore@batch(\'%1\',1)}'[_path]);
{? ~_cur ||
   __batch_comp.error('Błąd wykonania zapytania dla restore'@);
   return(-1)
||
   _buf:=_down.mk_buf;
  {? _down.fetch(_buf)
  ||
     __batch_comp.error(_buf.OPIS);
     return(_buf.RES)
  ||
     __batch_comp.error('Błąd pobrania rekordu wyniku dla restore'@);
     return(-1)
  ?}
?};
__batch_comp.error('Nieoczekiwany błąd'@);
return(-1)


\comp_call
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Przemyslaw Grochowski [20.32]
:: OPIS: Porownanie definicji poprzez procedure wbudowana
::  WE:  _a - zrodlo danych
::       _b - sciezka do new
::       _c - sciezka do def
::       _d - rekord do poświadczeń odbc do MacroBuildera
::----------------------------------------------------------------------------------------------------------------------
_odb:=_a;
_new:=_b;
_old:=_c;
POCZTAM.cntx_psh();
POCZTAM.prefix();
{? var_pres('_d')=type_of(null()) & POCZTAM.seek(_d)
|| _username:=POCZTAM.USER;
   _password:=exec('pwd_decode','#string',POCZTAM.PASS,exec('encode_key','#mailbox'),1);
   _down:=odbc_con(_odb,_username,_password)
|| _down:=odbc_con(_odb)
?};
POCZTAM.cntx_pop();
{? type_of(_down) = type_of(~~) ||
   __batch_comp.error('Błąd otwarcia źródła odbc'@);
   return(-1)
?};
_path_tmp:='';
{? 1+_new='@'
||
   {? ~fexists(_new, 0)
   ||
      __batch_comp.error('Błędna ścieżka lub brak dostępu do pliku %1'@[_new]);
      return(-1)
   ?};
   _tmpdir:=fmk_tmp_dir();
   {? type_of(_tmpdir) = type_of(~~)
   ||
      __batch_comp.error('Błąd utworzenia katalogu tymczasowego'@);
      return(-1)
   ?};
   _path_tmp:=gsub(_tmpdir.get_path,'\\','/');
   _new_name:=exec('file_name','%transfer',_new);
   {? ~fcopy(_new,_path_tmp+'/'+_new_name,0, 0, 1)
   ||
      __batch_comp.error('Błąd przy kopiowaniu pliku %1'@[_new]);
      return(-1)
   || _new:='@'+_path_tmp+'/'+_new_name
   ?}
|| _new:='@'+_new
?};
{? 1+_old='@'
||
   {? ~fexists(_old, 0)
   ||
      __batch_comp.error('Błędna ścieżka lub brak dostępu do pliku %1'@[_old]);
      return(-1)
   ?};
   {? _path_tmp=''
   ||
      _tmpdir:=fmk_tmp_dir();
      {? type_of(_tmpdir) = type_of(~~)
      ||
         __batch_comp.error('Błąd utworzenia katalogu tymczasowego'@);
         return(-1)
      ?};
      _path_tmp:=gsub(_tmpdir.get_path,'\\','/')
   ?};
   _old_name:=exec('file_name','%transfer',_old);
   {? ~fcopy(_old,_path_tmp+'/'+_old_name,0, 0, 1)
   ||
      __batch_comp.error('Błąd przy kopiowaniu pliku %1'@[_old]);
      return(-1)
   || _old:='@'+_path_tmp+'/'+_old_name
   ?}
|| _old:='@'+_old
?};
_cur:=_down.exec_cur('{call comp_def@batch(\'%1\',\'%2\')}'[_new,_old]);
{? ~_cur ||
   __batch_comp.error('Błąd wykonania zapytania dla comp_def'@);
   return(-1)
||
   _buf:=_down.mk_buf;
  {? _down.fetch(_buf)
  ||
     __batch_comp.error(_buf.OPIS);
     return(_buf.RES)
  ||
     __batch_comp.error('Błąd pobrania rekordu wyniku dla comp_def'@);
     return(-1)
  ?}
?};
__batch_comp.error('Nieoczekiwany błąd'@);
return(-1)


\gen_call
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Przemyslaw Grochowski [20.32]
:: OPIS: Generowanie poprzez procedure wbudowana
::  WE:  _a - zrodlo danych
::       _b - sciezka do generowania
::       _c - rekord do poświadczeń odbc do MacroBuildera
::----------------------------------------------------------------------------------------------------------------------
_odb:=_a;
_path:=gsub(_b,'\\','/');

POCZTAM.cntx_psh();
POCZTAM.prefix();
{? var_pres('_c')=type_of(null()) & POCZTAM.seek(_c)
|| _username:=POCZTAM.USER;
   _password:=exec('pwd_decode','#string',POCZTAM.PASS,exec('encode_key','#mailbox'),1);
   _down:=odbc_con(_odb,_username,_password)
|| _down:=odbc_con(_odb)
?};
POCZTAM.cntx_pop();

{? type_of(_down) = type_of(~~) ||
   __batch_comp.error('Błąd otwarcia źródła odbc'@);
   return(-1)
?};
{? 1+_path='@'
||
   {? ~fexists(_path, 0)
   ||
      __batch_comp.error('Błędna ścieżka lub brak dostępu do katalogu %1'@[_path]);
      return(-1)
   ?};
   _tmpdir:=fmk_tmp_dir();
   {? type_of(_tmpdir) = type_of(~~)
   ||
      __batch_comp.error('Błąd utworzenia katalogu tymczasowego'@);
      return(-1)
   ?};
   _path_tmp:=gsub(_tmpdir.get_path,'\\','/');
   _path_call:='@'+_path_tmp
|| _path_call:='@'+_path
?};
_cur:=_down.exec_cur('{call gen_def@batch(\'%1\')}'[_path_call]);
{? ~_cur ||
   __batch_comp.error('Błąd wykonania zapytania dla gen_def'@);
   return(-1)
||
   {? 1+_path='@'
   ||
      _defy:=fdir(_path_tmp,1,1);
      {? _defy.first()
      ||
         _def_name:=_defy.NAME;
         {? ~fcopy(_path_tmp+'/'+_def_name, _path+'/'+_def_name,0, 0, 1)
         ||
            __batch_comp.error('Błąd przy kopiowaniu pliku %1'@[_path_tmp+'/'+_def_name]);
            return(-1)
         ?}
      ?}
   ?};
   _buf:=_down.mk_buf;
  {? _down.fetch(_buf)
  ||
     __batch_comp.error(_buf.OPIS);
     return(_buf.RES)
  ||
     __batch_comp.error('Błąd pobrania rekordu wyniku dla gen_def'@);
     return(-1)
  ?}
?};
__batch_comp.error('Nieoczekiwany błąd'@);
return(-1)


\import_call
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Przemyslaw Grochowski [20.32]
:: OPIS: Import definicji
::  WE:  _a - plik z definicja
::       _b - ścieżka do standardowego pliku def
::       _c - rekord do poświadczeń odbc do MacroBuildera
::----------------------------------------------------------------------------------------------------------------------
_odb:=_a;
_path:=_b;

POCZTAM.cntx_psh();
POCZTAM.prefix();
{? var_pres('_c')=type_of(null()) & POCZTAM.seek(_c)
|| _username:=POCZTAM.USER;
   _password:=exec('pwd_decode','#string',POCZTAM.PASS,exec('encode_key','#mailbox'),1);
   _down:=odbc_con(_odb,_username,_password)
|| _down:=odbc_con(_odb)
?};
POCZTAM.cntx_pop();

{? type_of(_down) = type_of(~~) ||
   __batch_comp.error('Błąd otwarcia źródła odbc'@);
   return(-1)
?};
{? 1+_path='@'
||
   {? ~fexists(_path,0)
   ||
      __batch_comp.error('Błędna ścieżka lub brak dostępu do pliku %1'@[_path]);
      return(-1)
   ?};
   _tmpdir:=fmk_tmp_dir();
   {? type_of(_tmpdir) = type_of(~~)
   ||
      __batch_comp.error('Błąd utworzenia katalogu tymczasowego'@);
      return(-1)
   ?};
   _path_tmp:=gsub(_tmpdir.get_path,'\\','/');
   _f_name:=exec('file_name','%transfer',_path);
:: Kopiowanie pliku na serwer aplikacji jterma
   {? ~fcopy(_path,_path_tmp+'/'+_f_name,0, 0, 1)
   ||
      __batch_comp.error('Błąd przy kopiowaniu pliku %1'@[_path]);
      return(-1)
   || _path:='@'+_path_tmp+'/'+_f_name
   ?}
|| _path:='@'+_path
?};
_cur:=_down.exec_cur('{call import@batch(\'%1\')}'[_path]);
{? ~_cur ||
   __batch_comp.error('Błąd wykonania zapytania dla importu'@);
   return(-1)
||
   _buf:=_down.mk_buf;
  {? _down.fetch(_buf)
  ||
     __batch_comp.error(_buf.OPIS);
     return(_buf.RES)
  ||
     __batch_comp.error('Błąd pobrania rekordu wyniku dla importu'@);
     return(-1)
  ?}
?};
__batch_comp.error('Nieoczekiwany błąd'@);
return(-1)


\backup_call
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Przemyslaw Grochowski [20.32]
:: OPIS: Backup danych
::  WE:  _a - zrodlo odbc
::       _b - sciezka do macro.cfg
::       _c - rekord do poświadczeń odbc do MacroBuildera
::----------------------------------------------------------------------------------------------------------------------
_odb:=_a;
_cfg:=_b;
POCZTAM.cntx_psh();
POCZTAM.prefix();
{? var_pres('_c')=type_of(null()) & POCZTAM.seek(_c)
|| _username:=POCZTAM.USER;
   _password:=exec('pwd_decode','#string',POCZTAM.PASS,exec('encode_key','#mailbox'),1);
   _down:=odbc_con(_odb,_username,_password)
|| _down:=odbc_con(_odb)
?};
POCZTAM.cntx_pop();
{? type_of(_down) = type_of(~~) ||
   __batch_comp.error('Błąd otwarcia źródła odbc'@);
   return(-1)
?};
_cur:=_down.exec_cur('{call backup@batch(\'%1\')}'[_cfg]);
{? ~_cur ||
   __batch_comp.error('Błąd wykonania zapytania dla backupu'@);
   return(-1)
||
   _buf:=_down.mk_buf;
  {? _down.fetch(_buf)
  ||
     __batch_comp.error(_buf.OPIS);
     return(_buf.RES)
  ||
     __batch_comp.error('Błąd pobrania rekordu wyniku dla backupu'@);
     return(-1)
  ?}
?};
__batch_comp.error('Nieoczekiwany błąd'@);
return(-1)


\test_call
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Przemyslaw Grochowski [20.32]
:: OPIS: Przyklad wsadowego nanoszenia zmian poprzez ODBC
::  WE:  _a - zrodlo danych (zrodło na logice, czyli tam gdzie serwer aplikacji do ktorego laczymy się jtermem)
::            mozna podac nazwe lub odbc_dsn
:: dla ścieżek @ - oznacza plik na koncowce, jej brak plik na serwerze mbuildera,
:: pliki pod linuxem powinny mieć prawa +r dla innych użytkownikow
::       _b - sciezka do pliku zip dla restore
::       _c - sciezka do pliku z definicja merita
::       _d - sciezka do pliku z aktualna definicja klienta
::       _e - sciezka docelowa dla definicji klienta
::       _f - wyswietlenie wyniku w postaci tabeli
::----------------------------------------------------------------------------------------------------------------------
_odbc:=_a;
_zip:=_b;
_standard:=_c;
_klient:=_d;
_out:=_e;
_select:=_f;
{? cfg_info('long_names')='0'
|| FUN.emsg('Funkcjonalność wymaga uruchomienia aplikacji z obsługą długich nazw.'@);
   return(-1)
?};
{? var_pres('__batch_comp')>0  || obj_del(__batch_comp);&__batch_comp  ?};
{? var_pres('__batch_error')>0 || obj_del(__batch_error);&__batch_error ?};
_wyn:=1;
exec('error_set','%transfer');
_restore:=exec('restore_call','%transfer',_odbc,_zip);
{? _restore=-1
||
   __batch_comp.error('Błąd wykonania restore bazy danych'@);
   _wyn:=-1
||
   _comp:=exec('comp_call','%transfer',_odbc,_standard,_klient);
   {? _comp=-1
   ||
      __batch_comp.error('Błąd nanoszenia zmian'@);
      _wyn:=-1
   ||
      _gen:=exec('gen_call','%transfer',_odbc,_out);
      {? _gen<>1
      ||
         __batch_comp.error('Błąd generowania definicji'@);
         _wyn:=-1
      ?}
   ?}
?};
{? _select
||
   __batch_error.win_sel(__batch_error.mk_sel('Wsadowe nanoszenie zmian S1+'@,,1,'#batch',,,,,'U'));
   __batch_error.select()
?};
_wyn


\batch_call
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Przemyslaw Grochowski [20.32]
:: OPIS: Przyklad wsadowego nanoszenia zmian poprzez ODBC
::  WE:  _a - zrodlo danych (zrodło na logice, czyli tam gdzie serwer aplikacji do ktorego laczymy się jtermem)
::            mozna podac nazwe lub odbc_dsn
:: dla ścieżek @ - oznacza plik na koncowce, jej brak plik na serwerze mbuildera,
:: pliki pod linuxem powinny mieć prawa +r dla innych użytkownikow
::       _b - sciezka do pliku z definicja merita
::       _c - sciezka do pliku z aktualna definicja klienta
::       _d - sciezka docelowa dla definicji klienta
::       _e - wyswietlenie wyniku w postaci tabeli
::       _f - sciezka do pliku macro.cfg serwera Linuxowego (dopuszczalna wartosc pusta)
::       _g - rekord do poświadczeń odbc do MacroBuildera
::----------------------------------------------------------------------------------------------------------------------
_odbc:=_a;
_standard:=_b;
_klient:=_c;
_out:=_d;
_select:=_e;
_cfg:=_f;
_auth:=_g;
{? cfg_info('long_names')='0'
|| FUN.emsg('Funkcjonalność wymaga uruchomienia aplikacji z obsługą długich nazw.'@);
   return(-1)
?};
{? var_pres('__batch_comp')>0  || obj_del(__batch_comp);&__batch_comp  ?};
{? var_pres('__batch_error')>0 || obj_del(__batch_error);&__batch_error ?};
_wyn:=1;
exec('error_set','%transfer');
:: Ponieważ jest generowany i przywracany def - nie ma sensu każdorazowy backup źródeł MB
_backup:=1;
::_backup:=exec('backup_call','%transfer',_odbc,_cfg,_auth);
{? _backup=-1
||
   __batch_comp.error('Błąd wykonania backupu'@);
   _wyn:=-1
||
   _import:=exec('import_call','%transfer',_odbc,_standard,_auth);
   {? _import=-1
   ||
      __batch_comp.error('Błąd wykonania importu'@);
      _wyn:=-1
   ||
      _comp:=exec('comp_call','%transfer',_odbc,_standard,_klient,_auth);
      {? _comp=-1
      ||
         __batch_comp.error('Błąd nanoszenia zmian'@);
         _wyn:=-1
      ||
         _gen:=exec('gen_call','%transfer',_odbc,_out,_auth);
         {? _gen<>1
         ||
            __batch_comp.error('Błąd generowania definicji'@);
            _wyn:=-1
         ?}
      ?}
   ?}
?};
{? _select
||
   __batch_error.win_sel(__batch_error.mk_sel('Wsadowe nanoszenie zmian S1+'@,,1,'#batch',,,,,'U'));
   __batch_error.select()
?};
_wyn


\refresh_task
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Podczytanie zadań potransferowych (zerowanie znacznika restartu serwera i restart kolejek)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('none_S_IDTIME','#upgrade');
exec('queue_restart','%transfer');
1


\queue_restart
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [21.37]
:: OPIS: Wykonuje restart kolejek
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
B_WORKER.cntx_psh();
B_WORKER.index('KOD');
B_WORKER.prefix();
{? B_WORKER.first()
|| {!
   |? B_WORKER.STOP:='T';
      B_WORKER.put();
      B_WORKER.next()
   !}
?};
B_WORKER.cntx_pop()


\czy_trex_transfer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [21.14]
:: OPIS: Sprawdza, czy wymagany transfer w procesie ZWS_TREX
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? exec('copy_def','%transfer')
|| exec('czy_transfer','%transfer', params_get().in.p01)
|| 'Transfer niewymagany'
?}


\mapnew_prepare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [21.14]
:: OPIS: Przygotowuje plik merit.mapnew
::   WE:  _a - proces z którego formuła jest wywoływana 'ZWS_TRAN'/'ZWS_TREX'
::        _b - json z konfiguracja procesu
::   WY: 'OK (...)'/'BŁĄD (...)'
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
{? var_pres('_a')=type_of('')
|| _proc:=_a
|| return('BŁĄD. Błędny parametr _a')
?};
{? exec('latest_proc','%transfer')
|| _svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_b,'svn_record_id'));
   _cfg:=exec('cfg_get_elem','%transfer',_b,'macro_cfg_linux');
   _new_def:=exec('cfg_get_elem','%transfer',_b,'copy_def');
   _def:=exec('cfg_get_elem','%transfer',_b,'merit_path');
   {? var_pres('_def')<>type_of('') | (var_pres('def')=type_of('') & _def='')
   || _def:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
   ?}
||
::   WE:  _a - proces z którego formuła jest wywoływana 'ZWS_TRAN'/'ZWS_TREX'
::       [_b] - POCZTAM.ref - wskazanie na dane logowania do svn wymagane dla 'ZWS_TRAN'
::       [_c] - sciezka do pliku macro.cfg serwera Linuxowego (dopuszczalna wartosc pusta)
::       [_d] - sciezka do katalogu z defami domyślnie katalog defy
   {? var_pres('_b')=type_of(null())
   || _svn:=_b
   || _svn:=null
   ?};
   {? var_pres('_c')=type_of('')
   || _cfg:=_c
   || _cfg:=''
   ?};
   _new_def:=_d;
   _def:=_e
?};

{? var_pres('_new_def')=type_of('') & _new_def<>''
|| _mapnew_pth:=exec('dir_from_path','#file',_new_def)+_sep+'merit.mapnew'
|| _mapnew_pth:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'defy'+_sep+'merit.mapnew'
?};
{? var_pres('_def')=type_of('') & _def<>''
|| _mapnew_tran:=_def+_sep+'system'+_sep+'merit.mapnew'
|| _mapnew_tran:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'+_sep+'system'+_sep+'merit.mapnew'
?};
_workdir:=exec('workdir','%transfer');

::    pobranie pliku merit.mapnew pochodzącego z svn
{? _proc='ZWS_TRAN'
|| _update:=exec('svn_update','%transfer',_mapnew_pth,_svn);
   {? _update *'BŁĄD'
   || return(200+('BŁĄD. svn update pliku mefit.mapnew zwrócił wartość: '+_update))
   ?}
|? _proc='ZWS_TREX'
||
   _mapnew:=_workdir+_sep+'unpacked'+_sep+'defy'+_sep+'merit.mapnew';
   {? fexists(_mapnew)
   || fcopy(_mapnew,pth_dir('merit.def')+_sep+'merit.mapnew',0,0,1)
   ?}
|| return('BŁĄD. Błędny parametr _a')
?};
{? fexists(_mapnew_pth)=1
||
   _mapnew_svn:=tab_tmp(1,'NR','INTEGER','Numer','WIERSZ','STRING[255]','Wiersz');
   _file:=fopen(_mapnew_pth,'ur');
   _nr:=1;
   {! |? (_wiersz:=fread(_file))<>'\n'
   |! _mapnew_svn.NR:=_nr;
      _mapnew_svn.WIERSZ:=_wiersz;
      _mapnew_svn.add;
      _nr+=1
   !};
   fclose(_file);
   ferase(_mapnew_tran);
   _filepath:=_workdir+_sep+$SYSLOG.tm_stamp()+'.txt';
   exec('madmin_compare','%transfer',_filepath,_cfg,'compare-map');
   ferase(_filepath);
::   odczytanie i wstępne uzupełnienie wzorcowego pliku .mapnew
   _mapnew_blank:=tab_tmp(1,'NR','INTEGER','Numer','WIERSZ','STRING[255]','Wiersz');
   {? fexists(_mapnew_tran)
   || _file:=fopen(_mapnew_tran,'ur');
      _nr:=1;
      {! |? (_wiersz:=fread(_file))<>'\n'
      |! _mapnew_blank.NR:=_nr;
         {? 1+_wiersz<>'#'
         || {? +_wiersz>4 & _mapnew_svn.find_tab('first','WIERSZ',,':*',_wiersz)
            || _wiersz:=_mapnew_svn.WIERSZ
            ?};
            {? _mapnew_blank.find_tab('first','WIERSZ',,'=',_wiersz)=0
            || _mapnew_blank.WIERSZ:=_wiersz;
               _mapnew_blank.add;
               _nr+=1
            ?}
         ?}
      !};
      fclose(_file)
   || return('OK. Plik .mapnew niewymagany do transferu')
   ?};
::   dodanie wierszy dla zmiany z tabeli niemaskowanej na maskowaną
   {? _mapnew_svn.first & form(_mapnew_svn.WIERSZ)<>''
   || {! |?
         {? _mapnew_svn.WIERSZ*'MSK:'
         ||
            _tab:=(_mapnew_svn.WIERSZ*'MSK:'+4)-_mapnew_svn.WIERSZ;
            _spli:=spli_str(4-_mapnew_blank.WIERSZ,'.');
            _tab:=_spli[1];
            _msk:={? obj_len(_spli)>=2 || form(_spli[2]*'=>'-1+_spli[2]) || '' ?};
            {? _tab<>''
            || _tab:=($_tab)();
               _names:=_tab.names;
               {? _names.first() & _names.size=1 & _names.NAME=_msk
                  & _mapnew_blank.find_tab(,'WIERSZ',,'=',_mapnew_svn.WIERSZ)=0
               || _mapnew_blank.WIERSZ:=_mapnew_svn.WIERSZ;
                  _mapnew_blank.add
               ?}
            ?};
            &_tab;
            &_spli;
            &_names
         ?};
         _mapnew_svn.next()
      !}
   ?};
::    usunięcie niepotrzebnych wierszy zmiany akronimu tabeli
   {? _mapnew_blank.first
   || {! |?
         {? _mapnew_blank.WIERSZ*'MSK'
         || _mapnew_blank.cntx_psh();
            {? _mapnew_svn.find_tab('first','WIERSZ',,':*','TAB:'+spli_str(4-_mapnew_blank.WIERSZ,'.')[1])=0
               & _mapnew_blank.find_tab('first','WIERSZ',,':*','TAB:'+spli_str(4-_mapnew_blank.WIERSZ,'.')[1])
            || _mapnew_blank.del()
            ?};
            _mapnew_blank.cntx_pop()
         ?};
         _mapnew_blank.next()
      !}
   ?};
::   zapis nowego pliku .mapnew
   ferase(_mapnew_tran);
   {? _mapnew_blank.first()
   || _file:=fopen(_mapnew_tran,'Uw');
      {! |?
         fwrite(_file,_mapnew_blank.WIERSZ);
         _mapnew_blank.next()
      !};
      fclose(_file)
   ?}
|| return('OK. Brak pliku merit.mapnew w folderze defy')
?};
'OK'


\body_xml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca treść maila
::   WE: _a - xml z wynikami czynności
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_res:=exec('get_elem','%transfer',_a,'podsumowanie');
_naz:=exec('get_elem','%transfer',_a,'nazwa_instancji');
{? _res <> '' & _res*'OK'
|| {? exec('get_elem','%transfer',_a,'nazwa_instancji')<>''
   || _msg:='Proces uaktualniajacy system powiódł się na serwerze: <b>' + _naz + '</b>.\n\n'
   || _msg:='Proces uaktualniajacy system powiódł się na serwerze.\n\n'
   ?}
|| {? exec('get_elem','%transfer',_a,'nazwa_instancji')<>''
   || _msg:='Błąd podczas procesu uaktualniającego system na serwer: <b>' + _naz + '</b>.\n\n'
   || _msg:='Błąd podczas procesu uaktualniającego system.\n\n'
   ?}
?};
_add:="  {? _a <> ''
         || _a+'\n\n'
         || 'Brak informacji'+'\n\n'
         ?}";
_msg+='\t<b>1. Definicja systemu:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'definicja_systemu');
_msg+=_add(_elem);

_msg+='\t<b>2. Sprawdzenie, czy pth nie ulegną zmianie podczas aktualizacji svn:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'zgodność_katalogu_pth');
_msg+=_add(_elem);

_elem_b:=exec('get_elem','%transfer',_a,'aktualizacja_svn_pth');
{? _elem_b<>''
|| _msg+='\t<b>2a. Aktualizacja SVN (katalog pth):</b>\n';
   _msg+=_add(_elem_b)
?};

_msg+='\t<b>3. Sprawdzenie, czy zmiany w modified nie przykryją zmian w standardzie:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'zmiany_w_standardzie_przykryte_przez_modified');
_msg+=_add(_elem);

_msg+='\t<b>4. Aktualizacja SVN (katalog modified):</b>\n';
_elem:=exec('get_elem','%transfer',_a,'aktualizacja_svn_modified');
_msg+=_add(_elem);

_msg+='\t<b>5. Porównanie definicji przed transferem:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'transfer_możliwy');
_msg+=_add(_elem);

_msg+='\t<b>6. Aktualizacja SVN (katalog merit):</b>\n';
_elem:=exec('get_elem','%transfer',_a,'aktualizacja_svn_merit');
_msg+=_add(_elem);

_msg+='\t<b>7. Wynik transferu danych:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'transfer_danych');
_msg+=_add(_elem);

::_msg+='\t<b>Start webserwera:</b>\n';
::_elem:=exec('get_elem','%transfer',_a,'webserver_start');
::_msg+=_add(_elem);

gsub(_msg,'\r\n\r\n\r\n','\n\n');
return(_msg)


\body_xml_tw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [20.42]
:: OPIS: Zwraca treść maila dla TRAN_WER
::   WE: _a - xml z wynikami czynności
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_res:=exec('get_elem','%transfer',_a,'podsumowanie');
_naz:=exec('get_elem','%transfer',_a,'nazwa_instancji');
{? _res <> '' & _res*'OK'
|| {? exec('get_elem','%transfer',_a,'nazwa_instancji')<>''
   || _msg:='Proces podnoszący wersje powiódł się na serwerze: <b>' + _naz + '</b>.\n\n'
   || _msg:='Proces podnoszący wersje powiódł się na serwerze.\n\n'
   ?}
|| {? exec('get_elem','%transfer',_a,'nazwa_instancji')<>''
   || _msg:='Błąd podczas procesu podnoszącego wersje na serwerze: <b>' + _naz + '</b>.\n\n'
   || _msg:='Błąd podczas procesu podnoszącego wersje.\n\n'
   ?}
?};
_add:="  {? _a <> ''
         || _a+'\n\n'
         || 'Brak informacji'+'\n\n'
         ?}";
_msg+='\t<b>1. Definicja systemu:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'definicja_systemu');
_msg+=_add(_elem);

_msg+='\t<b>2. Sprawdzenie, czy pth nie ulegną zmianie podczas aktualizacji svn:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'zgodność_katalogu_pth');
_msg+=_add(_elem);

_msg+='\t<b>3. Sprawdzenie, czy zmiany w modified nie przykryją zmian w standardzie:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'zmiany_w_standardzie_przykryte_przez_modified');
_msg+=_add(_elem);

_msg+='\t<b>4. Aktualizacja SVN (katalog modified):</b>\n';
_elem:=exec('get_elem','%transfer',_a,'aktualizacja_svn_modified');
_msg+=_add(_elem);

_msg+='\t<b>5. Porównanie definicji przed transferem:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'transfer_możliwy');
_msg+=_add(_elem);

_msg+='\t<b>6. Przepięcie SVN:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'przepiecie_svn_merit');
_msg+=_add(_elem);

_msg+='\t<b>7. Backup:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'backup');
_msg+=_add(_elem);

_msg+='\t<b>8. Wynik transferu danych:</b>\n';
_elem:=exec('get_elem','%transfer',_a,'transfer_danych');
_msg+=_add(_elem);

::_msg+='\t<b>Start webserwera:</b>\n';
::_elem:=exec('get_elem','%transfer',_a,'webserver_start');
::_msg+=_add(_elem);

gsub(_msg,'\r\n\r\n\r\n','\n\n');
return(_msg)


\svn_up_merit_xml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [22.26]
:: OPIS: wywołanie svn_up_merit dla czynności "Aktualizacja svn". Zapisuje wynik transferu do xml i wywołuje formułę główną
::   WE: _a - json z konfiguracja procesu
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
{? exec('latest_proc','%transfer')
|| _svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));
   _merit_path:=exec('cfg_get_elem','%transfer',_a,'merit_path');
   {? var_pres('_merit_path')<>type_of('') | (var_pres('_merit_path')=type_of('') & _merit_path='')
   || _merit_path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
   ?};
   _wynik:=exec('result_blank','%transfer',_a);
   _war_wynik:=0
||
::   WE: _a,... - parametry procesu ZWS_TRAN czynności "Aktualizacja svn"
   _svn:=_a;
   _merit_path:=_b;
   {? var_press('_c')=type_of('') & _c<>''
   || _wynik:=exec('set_elem','%transfer',_d,'transfer_danych','OK')
   || _wynik:=_d
   ?};
   _war_wynik:={? var_press('_e')=type_of(1) || 1 || 0 ?}
?};

::zapis poprzednich kroków procesu do xml'a
{? _war_wynik
|| {? _e
   || _xml:=exec('set_elem','%transfer',_wynik,'transfer_danych','OK. Transfer niewymagany. \nKopiowanie defa zakończone powodzeniem.')
   || _xml:=exec('set_elem','%transfer',_wynik,'transfer_danych','BŁĄD. Błąd podczas kopiowania defa. \nTransfer niewymagany.')
   ?}
|| _xml:=_wynik
?};
::wywołanie głównej formułu czynności
_result:=exec('svn_up_merit','%transfer',_merit_path,_svn,,_xml);

:: ewentualne wywołanie dodatkowych czynności ze zdefiniowanej wtyczki
{? Plugin.runnable('ZWS_TRAN_AF_SVNUPD')
|| _result:=Plugin.run('ZWS_TRAN_AF_SVNUPD',_merit_path,_svn,,_xml,_result)
?};

_result


\after_transfer_xml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [22.26]
:: OPIS: wywołanie svn_up_merit dla czynności "Aktualizacja svn". Zapisuje wynik transferu do xml i wywołuje formułę główną
::   WE: _a - tablica nazwana z parametrami:
::          .p01 - xml z wynikiem transferu
::          .p02 - xml z wynikiem rep tran
::          .p03 - wartosc wyjsciowa z kopiowanie def2
::          .p04 - xml z wynikiem backup
::          .p05 - xml z wynikiem przepiecia svn
::          .p06 - xml z wynikiem Przywrocenia plikow uzytkownikow
::          .p07 - xml z wynikiem porownania def
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
{? exec('latest_proc','%transfer')
|| _tran:=_a.p01;
   _reptran:=_a.p02;
   _kopdef2:=_a.p03;
   _backup:=_a.p04;
   _switch:=_a.p05;
   _restore:=_a.p06;
   _xml:=_a.p07
||
::   WE: _a,... - parametry procesu ZWS_TRAN czynności "Aktualizacja svn"
   _tran:=_c;
   _reptran:=0;
   _kopdef2:=_e;
   _backup:=0;
   _switch:=0;
   _restore:=0;
   _xml:=_d
?};

::zapis poprzednich kroków procesu do xml'a
{? var_press('_tran')=type_of('') & _kopdef2<>''
|| _xml:=exec('set_elem','%transfer',_xml,'transfer_danych','OK')
|? var_press('_kopdef2')=type_of(1)
|| {? _kopdef2
   || _xml:=exec('set_elem','%transfer',_xml,'transfer_danych','OK. Transfer niewymagany. \nKopiowanie defa zakończone powodzeniem.')
   || _xml:=exec('set_elem','%transfer',_xml,'transfer_danych','BŁĄD. Błąd podczas kopiowania defa. \nTransfer niewymagany.')
   ?}
?};
_b_bf:={? var_press('_backup')=type_of('') & _backup<>'' || exec('get_elem','%transfer',_backup,'backup') || '' ?};
_b_af:={? var_press('_restore')=type_of('') & _restore<>'' || exec('get_elem','%transfer',_restore,'backup') || '' ?};
{? _b_bf<>'' | _b_af<>''
|| _xml:=exec('set_elem','%transfer',_xml,'backup',{? _b_bf<>'' || _b_bf+'\n' || ''?}+_b_af)
?};
{? var_press('_switch')=type_of('') & _switch<>''
|| _xml:=exec('set_elem','%transfer',_xml,'przepiecie_svn_merit',exec('get_elem','%transfer',_switch,'przepiecie_svn_merit'))
?};
{? var_press('_reptran')=type_of('') & _reptran<>''
|| _xml:=exec('set_elem','%transfer',_xml,'aktualizacja_svn_merit',exec('get_elem','%transfer',_reptran,'aktualizacja_svn_merit'))
?};
_xml


\result_blank
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [22.26]
:: OPIS: wzór xml z wynikami procesu aktualizującego
::   WE: _a [MEMO] - zawartosc konfiguracji
::   WY: [STRING] - xml
::----------------------------------------------------------------------------------------------------------------------
_blank:={? exec('latest_proc','%transfer') & exec('cfg_get_elem','%transfer',_a, 'zws_tran_wer')='T'
        ||  '<?xml version="1.0" encoding="UTF-8"?>
             <wynik>
                <nazwa_instancji></nazwa_instancji>
                <definicja_systemu></definicja_systemu>
                <zgodność_katalogu_pth></zgodność_katalogu_pth>
                <zmiany_w_standardzie_przykryte_przez_modified></zmiany_w_standardzie_przykryte_przez_modified>
                <aktualizacja_svn_modified></aktualizacja_svn_modified>
                <transfer_możliwy></transfer_możliwy>
                <przepiecie_svn_merit></przepiecie_svn_merit>
                <backup></backup>
                <transfer_danych></transfer_danych>
                <podsumowanie>BŁĄD</podsumowanie>
             </wynik>'
        ||  '<?xml version="1.0" encoding="UTF-8"?>
             <wynik>
                <nazwa_instancji></nazwa_instancji>
                <definicja_systemu></definicja_systemu>
                <zgodność_katalogu_pth></zgodność_katalogu_pth>
                <zmiany_w_standardzie_przykryte_przez_modified></zmiany_w_standardzie_przykryte_przez_modified>
                <aktualizacja_svn_pth></aktualizacja_svn_pth>
                <aktualizacja_svn_merit></aktualizacja_svn_merit>
                <aktualizacja_svn_modified></aktualizacja_svn_modified>
                <transfer_możliwy></transfer_możliwy>
                <transfer_danych></transfer_danych>
                <podsumowanie>BŁĄD</podsumowanie>
             </wynik>'
        ?}


\get_elem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [22.26]
:: OPIS: wyszykuje i zwraca treść elementu xml
::   WE: _a - [STRING] xml z elementami
::       _b - [STRING] nazwa elementu
::   WY: [STRING] - wartość elementu xml
::----------------------------------------------------------------------------------------------------------------------
_wynik:='';
_tab:=xml_tparse(_a);
{? _tab.find_tab(,'NAME',,'=',_b,'TYPE',,'=','E')
|| {? _tab.VTRUNC='N'
   || _wynik:=_tab.VAL
   || _file:=fopen(_tab.BVAL,'ur');
      {? _file
      || {? (_wiersz:=fread(_file))<>'\n'
         || {! |? _wynik+=_wiersz;
               {? (_wiersz:=fread(_file))<>'\n'
               || _wynik+='\n';1
               || 0
               ?}
            !}
         ?};
         fclose(_file)
      ?}
   ?}
?};
_wynik


\set_elem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [22.26]
:: OPIS: modyfikuje treść elementu xml
::   WE: _a - [STRING] xml z elementami
::       _b - [STRING] nazwa elementu xml
::       _c - [STRING] nowa treść elementu xml
::   WY: [STRING] - xml po modyfikacji
::----------------------------------------------------------------------------------------------------------------------
_tab:=xml_tparse(_a);
{? _tab.find_tab(,'NAME',,'=',_b,'TYPE',,'=','E')
|| {? +_c<255
   || _tab.VAL:=xml_value(_c);
      _tab.put
   || _tab.VAL:=_c;
      _tab.VTRUNC:='T';
      _tab.put();
      _file:=fopen(_tab.BVAL,'w');
      _conv:=iconv('UTF-8');
      fwrite(_file,_conv.to(_c));
      _tab.bl_put('BVAL',_file,,,'value.txt');
      fclose(_file)
   ?}
?};
_tab.first();
_tab.xml_twrite(,,,'indentation=1')


\xml_view
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WHAN [22.26]
:: OPIS: Pokazuje xml w formie drzewka
::   WE: _a - [STRING] xml
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_tab:=xml_tparse(_a);
_tab.first;
exec('select','#table',_tab,1,,,'NAME[50],VAL[50]');
_tab.first();
_tab.xml_twrite()


\reptran
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [21.37]
:: OPIS: Wykonuje kompilacje raportow jesli jest taka potrzeba
::   WE: _a - parametr z dotychczasowym stanem wykonania procesu w postaci MEMO xml
::   WY: dotychczasowy stan wykonania procesu w postaci MEMO xml
::----------------------------------------------------------------------------------------------------------------------
_elem:=exec('get_elem','%transfer',_a,'aktualizacja_svn_merit');
_elem:=exec('get_elem','%transfer',_a,'aktualizacja_svn_modified');
_is_rpm:=_elem*'.rpm' | _elem*'.rpi';
{? _is_rpm
|| _wynik:=rep_tran('*')
?};
_a


\tran_mail_body
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [21.37]
:: OPIS: Formuła zwracająca treść maila technicznego dla konkretnego etapu w procesie ZWS_TRAN
::   WE: _a - [STRING] nazwa identyfikująca położenie w procesie
::       _b - parametry wejsciowe
::   WY: treść maila na podstawie parametrów wejściowych
::----------------------------------------------------------------------------------------------------------------------
_tran_wer:=0;
{? exec('latest_proc','%transfer')
|| _par:={? _a='transfer'
         || exec('set_elem','%transfer',_b.p03,'transfer_danych',_b.p02)
         |? _a='ok'
         || exec('set_elem','%transfer',_b.p02,'podsumowanie','OK')
         |? _a='check_mod' & exec('spr_wyn_weryfikacji','%transfer',2,_b.p02)=1
         || exec('set_elem','%transfer',_b.p02,'podsumowanie','Na liscie ToDO zalozono zadanie')
         || _b.p02
         ?};
   _tran_wer:=exec('cfg_get_elem','%transfer',_b.p01,'zws_tran_wer')='T'
|| _par:={? _a='check_pth_mail'
         || {? type_of(_b.p05)=type_of('') & _b.p05<>'' || _b.p05 || _b.p06 ?}
         |? _a='transfer'
         || exec('set_elem','%transfer',_b.p06,'transfer_danych',_b.p05)
         |? _a='ok'
         || exec('set_elem','%transfer',_b.p04,'podsumowanie','OK')
         || _b.p05
         ?}
?};
{? _tran_wer
|| exec('body_xml_tw','%transfer',_par)
|| exec('body_xml','%transfer',_par)
?}


\tech_mail
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [21.37]
:: OPIS: Formuła do technicznej wysyłki maili z procesów transferujących, niezależnie od normalnego trybu wysyłki
::       poczty
::   WE: _a - [STRING] oznaczenie procesu
::       _b - [STRING] oznaczenie położenia w procesie
::       _c - [STRING] nazwa szablonu do użycia w wiadomości
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
exec('MAIL','#object');
_args:=exec('add_email_a','#mailbox');
{? exec('latest_proc','%transfer')
|| _json:=exec('cfg_get_elem','%transfer',params_get().in.p01,'smtp');
   _mails:=gsub(exec('cfg_get_elem','%transfer',params_get().in.p01,'mail_address'),';',',');
   _from:=exec('cfg_get_elem','%transfer',params_get().in.p01,'s_mail_address');
   _sub:=exec('cfg_get_elem','%transfer',params_get().in.p01,'name');
   {? _b='wyn_wer'
   || _b:=exec('wyn_wer_sub','%transfer',params_get().in.p02)
   ?}
|| _json:=params_get().in.p01;
   _mails:=gsub(params_get().in.p02,';',',');
   _from:=params_get().in.p03;
   _sub:=params_get().in.p04
?};
{? _mails*','
|| _tmp:=spli_str(_mails,',');
   _tab_rcv:=tab_tmp(,'ADDRESS','STRING[255]','Adres email');
   {! _i:=1..obj_len(_tmp)
   |! _tab_rcv.ADDRESS:=_tmp[_i];
      _tab_rcv.add()
   !};
   _args.RCV:=_tab_rcv
|| _args.RCV:=_mails
?};
_args.FROM:=_from;
{? _args.FROM=''
|| _args.FROM:=exec('get','#params',700002,2)
?};
_args.SUB:=$exec(_b+'_sub','%transfer',_sub);
_args.BODYT:=exec(_a+'_mail_body','%transfer',_b,params_get().in);
_args.TEMPLATE:=_c;
:: Generowany mail "techniczny"
_args.TRYB:='X';
{? var_pres('SUB_PREFIX',_args) = type_of(0)
|| _args.SUB_PREFIX:={? _sub='' || 1 || 0 ?}
?};
{? exec('add_email','#mailbox',_args)
|| {? _json<>'' || _server:=json_parse(_json) ?};
   {? var_pres('_server')<>exec('type_of_array','#var') | var_press('ADDRESS',_server)<>type_of('') | _server.ADDRESS=''
   || _res:=exec('em_send_one','#mailbox',_args.REFERENCE)
   || _res:=exec('em_send_one','#mailbox',_args.REFERENCE,,,_server)
   ?}
?};
_res


\can_upg_be_done
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Sprawdzenie czy można podnieść wersję
::   WE: _a - parametr określający czy jest dostepna nowa wersja
::       _b - parametr zawierający ścieżkę do nowego svn
::      [_c]- rekord z poswiadzczeniami svn w tabeli POCZTAM, jesli nie podany domyslnie szukany 'svn'
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _a<>'T'
|| '[N] Nie zostala udostepniona nowa wersja.'
|| _sep:=exec('sep','#file',1);
   _m_path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit';
   _svn:=exec('get_svn_data','%transfer',{? _c<>'' || _c || 'svn' ?});
   _svn_info:=exec('parse_svn_info','%transfer',_m_path,_svn).URL;
   {? _svn_info<>'' & _svn_info<>_b+'/merit'
   || '[T]'
   || '[N] Obecne powiazanie z svn wskazuje ze jest zainstalowana najnowsza wersja.'
   ?}
?}


\read_upg_cfg_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Rozczytanie pliku conf dla podnoszenia wersji
::   WE: _a - json z konfiguracja procesu
::       _b - poszukiwany element konfiguracji
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::_upg_cfg_file:=exec('cfg_get_elem','%transfer',_a,'upg_cfg_file');
_upg_cfg_file:=_a;

_plik:={? _upg_cfg_file<>''
       || fopen(_upg_cfg_file,'ur',0,1,1)
       || fopen(exec('cfg_file_name','%transfer','autotranwer.cfg'),'Ur',1,1,1)
       ?};
{? _plik.is_open
|| _par_val:=($("json_parse(_a)."+_b))(_plik)
|| _par_val:=''
?};
fclose(_plik);
_par_val


\cfg_get_elem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca wartosc konkretnego elementu konfiguracji
::   WE: _a - memo string zawierajacy jsona z konfiguracja
::       _b - string nazwa poszukiwanego elementu
::   WY: wartosc poszukiwanego elementu konfiguracji
::----------------------------------------------------------------------------------------------------------------------
_wynik:='';
_cfg:=json_parse(_a);
{? type_of(_cfg)>100
|| {! _i:=1..obj_len(_cfg)
   |! {? _cfg[_i].NAME=_b
      || _wynik:=_cfg[_i].VALUE;
         _i:=obj_len(_cfg)
      ?}
   !}
?};
_wynik


\upg_backup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Robi backup wersji i zapamiętuje pliku użytkowników
::   WE: _a - json z parametryzacja procesu
::       _b - xml z wynikiem procesu
::   WY: Czy powodzenie i treść dla ewentualnego powiadomienia o problemie
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_workdir:=fmkdir(exec('workdir','%transfer'),'backup');
_itg_file:='systems.itg';
_dest_file:=_workdir+_sep+'backup_upg.zip';
_cfg_dir:=exec('cfg_get_elem','%transfer',_a,'macro_cfg_linux');
_bck_res:=exec('backup','zws',_itg_file,_dest_file,_cfg_dir,1);
_result:='Backup calej wersji - '+{? _bck_res.STATUS || 'OK' || 'BLAD' ?}+'\n';
_result+=_bck_res.TEXT+'\n';
_merit_path:=(exec('cfg_get_elem','%transfer',_a,'merit_path'));
{? var_pres('_merit_path')<>type_of('') | (var_pres('_merit_path')=type_of('') & _merit_path='')
|| _merit_path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
?};

_work_dir:=(_merit_path-5)+'work';

_result+='\n';

_dir_bck:="'Backup '+_d+'work'+_d+_a+_d+_b+' - '+
           {? exec('dir','#file',_e+_d+_a+_d+_b).first()
           ||  {? fpack_add(_c+_d+_b+_a+'.zip',_e+_d+_a+_d+_b)
               || 'OK\n'
               || 'BLAD\n'
               ?}
           || 'OK - brak plików do spakowania\n'
           ?}";

_system_bck:="'Backup '+_d+'work'+_d+_a+_d+_b+' - '+
           {? exec('dir','#file',_e+_d+_a+_d+_b).first()
           ||
:: zakladam katalog firmy i listuje katalog work\f00x\system
               fmkdir(_c+_d,_b+_a);
               _tabdir:=fdir(_e+_d+_a+_d+_b,1,1);
               {? _tabdir.first()
               || _licznik:=0;
                  {!
                  |? {? _tabdir.TYPE='d'
                     ||
:: jeżeli fdir zwrocił katalog, to zakładam katalog lub podkatalog usera
                        fmkdir(_c+_d+_b+_a,_tabdir.NAME)
                     |? _tabdir.TYPE='f' & _tabdir.NAME+4<>'.log'
:: jeżeli fdir zwrócił coś innego niż log, to kopiuję go. Katalog docelowy otrzymam poprzez zamianę
                     || _licznik+=fcopy(_tabdir.DIR+_d+_tabdir.NAME,gsub(_tabdir.DIR,_e+_d+_a+_d+_b,_c+_d+_b+_a)+_d+_tabdir.NAME)
                     ?};
                     _tabdir.next()
                  !};
:: pakowanie katalogu work/f00x/system bez plikow
                  {? _licznik
                  || {? fpack_add(_c+_d+_b+_a+'.zip',_c+_d+_b+_a)
                     || exec('del_catal','%transfer',_c+_d+_b+_a);
                        'OK\n'
                     || 'BLAD\n'
                     ?}
                  || 'OK - brak plików do spakowania\n'
                  ?}
               || 'OK - brak plików do spakowania\n'
               ?}
           || 'OK - brak plików do spakowania\n'
           ?}";

_result+=_system_bck('f000','system',_workdir,_sep,_work_dir);
_result+=_dir_bck('f000','dsku',_workdir,_sep,_work_dir);
_result+=_system_bck('f001','system',_workdir,_sep,_work_dir);
_result+=_dir_bck('f001','dsku',_workdir,_sep,_work_dir);
_result+=_system_bck('f002','system',_workdir,_sep,_work_dir);
_result+=_dir_bck('f002','dsku',_workdir,_sep,_work_dir);
_result+=_system_bck('f003','system',_workdir,_sep,_work_dir);
_result+=_dir_bck('f003','dsku',_workdir,_sep,_work_dir);

_result:=exec('set_elem','%transfer',_b,'backup',_result)


\svn_switch_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Przepięcie svnów
::   WE: _a - json z konfiguracja procesu
::       _b - parametr z sygnalu procesu ZWS_TRAN_WER zawierajacy wynik svn switch dla katalogu pth
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_merit_path:=exec('cfg_get_elem','%transfer',_a,'merit_path');
{? var_pres('_merit_path')<>type_of('') | (var_pres('_merit_path')=type_of('') & _merit_path='')
|| _merit_path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
?};
_modified_path:=exec('cfg_get_elem','%transfer',_a,'modified_path');
{? var_pres('_modified_path')<>type_of('') | (var_pres('_modified_path')=type_of('') & _modified_path='')
|| _modified_path:=''
?};
_def_path:=exec('cfg_get_elem','%transfer',_a,'new_def');
{? _def_path*(_sep+'merit.def') || _def_path:=_def_path-(+(_sep+'merit.def')) ?};
{? var_pres('_def_path')<>type_of('') | (var_pres('_def_path')=type_of('') & _def_path='')
|| _def_path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'defy'
?};

_new_svn_url:=exec('cfg_get_elem','%transfer',_a,'svn_url_new');
_svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));

_result:='';
_result+=_b;
:: w razie problemow z svnswitch usunmy dodatkowy katalog z plikami fml ktorego w 22.26 nie bylo
_fml_dir_scr:=pth_dir('zws.fml');
_fml_dir_dst:=gsub(pth_dir('zws.fml'),'lib','');
{? (_fml_dir_dst+2)=('//') | (_fml_dir_dst+2)=('\\\\')
|| _fml_dir_dst:=(_fml_dir_dst-2)+_sep
|? (_fml_dir_dst+1)=('/') | (_fml_dir_dst+1)=('\\')
|| _fml_dir_dst:=(_fml_dir_dst-1)+_sep
|| _fml_dir_dst:=_fml_dir_dst+_sep
?};
_fml_dir_dst+='upgrade';
_plk:=fdir(_fml_dir_dst);
_loop:=_plk.first();
{!
|? _loop
|! {? _plk.TYPE='f'
	|| ferase(_plk.DIR+_sep+_plk.NAME)
	?};
   _loop:=_plk.next()
!};
:: koniec obejscia
_result+=exec('svn_switch','%transfer',_merit_path,_svn,,_new_svn_url+'/merit');
_result+=exec('svn_switch','%transfer',_def_path,_svn,,_new_svn_url+'/defy');
{? _modified_path<>''
|| _result+=exec('svn_switch','%transfer',_modified_path,_svn,,_new_svn_url+'/modified')
?};
_result:=exec('set_elem','%transfer',exec('result_blank','%transfer',_a),'przepiecie_svn_merit',_result)


\svn_switch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Uruchamia przepiecie SVN
::   WE: [_a] - ścieżka (domyślnie katalog główny aplikacji)
::       [_b] - POCZTAM.ref - wskazanie na dane logowania do svn
::       [_c] - ścieżka do loga.
::       [_d] - url nowego svn
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_path:='';
_username:='';
_password:='';
_sep:=exec('sep','#file',1);
_workdir:=exec('workdir','%transfer');
_errlog:=pth_dir('svnuperr.log')+_sep+'svnuperr.log';
_new_url:=_d;
{? var_pres('_a')=type_of('') & _a<>''
|| _path:=_a
|| _path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()
?};
POCZTAM.cntx_psh();
POCZTAM.prefix();
{? var_pres('_b')=type_of(null()) & POCZTAM.seek(_b)
|| _username:=POCZTAM.USER;
   _password:=POCZTAM.PASS
?};
POCZTAM.cntx_pop();
{? var_pres('_c')=type_of('')
|| _log_path:=_c
|| _log_path:=_workdir+_sep+'svn'+$SYSLOG.tm_stamp()+'.log'
?};
_log_cl_path:=_workdir+_sep+'svn_cl_'+$SYSLOG.tm_stamp()+'.log';
{? var_pres('_a')=type_of('') & _a*'modified'
|| _local_log_path:=_workdir+_sep+'svn_switch_modified'+$SYSLOG.tm_stamp()+'.log'
|? var_pres('_a')=type_of('') & _a*'pth'
|| _local_log_path:=_workdir+_sep+'svn_switch_pth'+$SYSLOG.tm_stamp()+'.log'
|? var_pres('_a')=type_of('') & _a*'defy'
|| _local_log_path:=_workdir+_sep+'svn_switch_def'+$SYSLOG.tm_stamp()+'.log'
|? var_pres('_a')=type_of('') & _a*'merit'
|| _local_log_path:=_workdir+_sep+'svn_switch_merit'+$SYSLOG.tm_stamp()+'.log'
|| _local_log_path:=_workdir+_sep+'svn_switch'+$SYSLOG.tm_stamp()+'.log'
?};

:: revert
{? _path<>''
||
   _path:=gsub(_path,'\\\\','\\');

   _result:=0;
   {? sys_name(1)='U_LINUX'
   || {? _username<>''
      ||
         _command:='svn revert %1 --recursive --username %2 --password %3 --non-interactive --trust-server-cert '
                   '--no-auth-cache > %4'
                   [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_cl_path]
      || _command:='svn revert %1 --recursive --non-interactive --trust-server-cert > %2'[_path,_log_cl_path]
      ?}
   || {? _username<>''
      ||
         _command:='svn revert "%1" --recursive --username %2 --password %3 --non-interactive --trust-server-cert '
                   '--no-auth-cache > "%4"'
                   [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_cl_path]
      || _command:='svn revert "%1" --recursive --non-interactive --trust-server-cert > "%2"'[_path,_log_cl_path]
      ?}
   ?};
   {? sys_name(1)='U_LINUX'
   || _sys_res:=system('sh -c \"' + _command +'\"',1)
   || _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1)
   ?};
   ferase(_log_cl_path);
:: cleanup
   {? sys_name(1)='U_LINUX'
   || {? _username<>''
      ||
         _command:='svn cleanup %1 --username %2 --password %3 --non-interactive --trust-server-cert '
                   '--no-auth-cache > %4'
                   [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_cl_path]
      || _command:='svn cleanup %1 --non-interactive --trust-server-cert > %2'[_path,_log_cl_path]
      ?}
   || {? _username<>''
      ||
         _command:='svn cleanup "%1" --username %2 --password %3 --non-interactive --trust-server-cert '
                   '--no-auth-cache > "%4"'
                   [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1),_log_cl_path]
      || _command:='svn cleanup "%1" --non-interactive --trust-server-cert > "%2"'[_path,_log_cl_path]
      ?}
   ?};
   {? sys_name(1)='U_LINUX'
   || _sys_res:=system('sh -c \"' + _command +'\"',1)
   || _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1)
   ?};
   ferase(_log_cl_path);
   {? sys_name(1)='U_LINUX'
   || {? _username<>''
      ||
         _command:='svn switch %6 %1 --username %2 --password %3 --accept theirs-full --non-interactive --trust-server-cert '
                   '--no-auth-cache --ignore-ancestry --force > %4 2> %5'
                   [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1)
                   ,_local_log_path,_errlog,_new_url]
      || _command:='svn switch %4 %1 --accept theirs-full --non-interactive --trust-server-cert '
                   ' --ignore-ancestry --force > %2 2> %3'[_path,_local_log_path,_errlog,_new_url]
      ?};
      _command2:='cat %1 >> %2'[_local_log_path,_log_path]
   || {? _username<>''
      ||
         _command:='svn switch %6 "%1" --username %2 --password %3 --accept theirs-full --non-interactive --trust-server-cert '
                   '--no-auth-cache --ignore-ancestry --force > "%4" 2> "%5"'
                   [_path,_username,exec('pwd_decode','#string',_password,exec('encode_key','#mailbox'),1)
                   ,_local_log_path,_errlog,_new_url]
      || _command:='svn switch %4 "%1" --accept theirs-full --non-interactive --trust-server-cert '
                   '--ignore-ancestry --force > "%2" 2> "%3"'[_path,_local_log_path,_errlog,_new_url]
      ?};
      _command2:='type "%1" >> "%2"'[_local_log_path,_log_path]
   ?};
   {? sys_name(1)='U_LINUX'
   || _sys_res:=system('sh -c \"' + _command +'\"',1);
      _sys_res:=system('sh -c \"' + _command2 +'\"',1)
   || _sys_res:=system(envget('COMSPEC')+' /c ' + _command,1);
      _sys_res:=system(envget('COMSPEC')+' /c ' + _command2,1)
   ?};
   ferase(_local_log_path)
?};
:: przetwarzamy wynik
_result:='';
_updated:=0;
_conflicts:=0;
_skipped:='';
_flog:=fopen(_log_path,'ur',0);
{? _flog
|| {!
   |? (_wiersz:=fread(_flog))<>'\n'
   |!
      {? _wiersz*'At revision'>0 | _wiersz*'Updated to revision'>0
         | _wiersz*'W wersji'>0 | _wiersz*'Uaktualniono do wersji'>0 | _wiersz*'Checked out revision'>0
      || _updated:=1
      ?};
      {? _wiersz*'Summary of conflicts'>0 | _wiersz*'Podsumowanie konfliktów'>0
      || _conflicts:=1
      ?};
      {? _wiersz*'Skipped'>0 & _wiersz*'Skipped paths:'=0
      || _skipped+=(_wiersz*'Skipped'+(+'Skipped')-1-_wiersz)
      ?};
      {? _wiersz*'Pominięto'>0 & _wiersz*'Pominięte ścieżki:'=0
      || _skipped+=(_wiersz*'Pominięto'+(+'Pominięto')-1-_wiersz)
      ?};
      _result+=_wiersz+'\n'
   !};
   fclose(_flog)
?};
{? _conflicts
|| {? +_skipped
   || _result:='BŁĄD.\nPominięte lokalizacje:\n'+_skipped+'\nPełny wynik:\n'+_result
   || _result:='OK, ale wystąpiły konflikty.\n'+_result
   ?}
|? _updated
|| _result:='OK.\n'+_result
|| _result:='BŁĄD.\n'+_result
?};
{? var_pres('_c')<>type_of('')
|| ferase(_log_path,0)
?};
_result


\wynik_weryfikacji
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zebranie rownoleglych weryfikacji przed transferowych
::   WE: _a - xml z wynikiem weryfikacji defa
::       _b - xml z wynikiem weryfikacji formul modified
::       _c - xml z wynikiem weryfikacji pth
::       _d - xml z wynikiem update pth
::   WY: zbiorczy xml z wynikiem
::----------------------------------------------------------------------------------------------------------------------
:: do wyniku z galezi weryfikacji defa dodajemy reszte gdy w tym wyniku mamy prawidlowa strukture w zaleznosci od tego
:: czy jest to proces ZWS_TRAN_WER czy nie
_result:=exec('set_elem','%transfer',_a,'zmiany_w_standardzie_przykryte_przez_modified',exec('get_elem','%transfer',_b,'zmiany_w_standardzie_przykryte_przez_modified'));
_result:=exec('set_elem','%transfer',_result,'aktualizacja_svn_modified',exec('get_elem','%transfer',_b,'aktualizacja_svn_modified'));
_result:=exec('set_elem','%transfer',_result,'zgodność_katalogu_pth',exec('get_elem','%transfer',_c,'zgodność_katalogu_pth'));
{? type_of(_d)<>type_of(~~) & _d<>~~
|| _result:=exec('set_elem','%transfer',_result,'aktualizacja_svn_pth',exec('get_elem','%transfer',_d,'aktualizacja_svn_pth'))
?};
_result


\spr_wyn_weryfikacji
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Sprawdza poziom problemow wstepnej weryfikacji
::   WE: _a - poziom sprawdzenia: 1 - czy byl problem 2 - czy wymagane sa akcje reczne 3 - czy problem blokujacy
::       _b - xml z wynikiem
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? _a=1
|| _result:=exec('get_elem','%transfer',_b,'definicja_systemu')*'BŁĄD'=1 |
            exec('get_elem','%transfer',_b,'zgodność_katalogu_pth')*'BŁĄD'=1 |
            exec('get_elem','%transfer',_b,'zmiany_w_standardzie_przykryte_przez_modified')*'BŁĄD'=1
|? _a=2
|| _result:=exec('get_elem','%transfer',_b,'zgodność_katalogu_pth')*'BŁĄD'=1 |
            exec('get_elem','%transfer',_b,'zmiany_w_standardzie_przykryte_przez_modified')*'BŁĄD'=1
|? _a=3
|| _result:=exec('get_elem','%transfer',_b,'definicja_systemu')*'BŁĄD'=1
?};
_result


\svn_tasks_res
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca wynik procesu w zaleznosci od podazanej sciezki wykonania
::   WE: _a - xml z wynikiem procesu ze sciezki dla ZWS_TRAN
::       _b - xml z wynikiem procesu ze sciezki dla ZWS_TRAN_WER
::   WY: xml z wynikiem procesu
::----------------------------------------------------------------------------------------------------------------------
{? type_of(_b)=type_of(~~) & _b=~~
|| _a
|| _b
?}


\user_par_rebuild
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Przywrocenie zapamietanych plikow z ustawieniami uzytkownikow
::   WE: _a - json z konfiguracja procesu
::   WY: xml z wynikiem procesu
::----------------------------------------------------------------------------------------------------------------------
_sep:=exec('sep','#file',1);
_workdir:=exec('workdir','%transfer')+_sep+'backup';
_merit_path:=exec('cfg_get_elem','%transfer',_a,'merit_path');
{? var_pres('_merit_path')<>type_of('') | (var_pres('_merit_path')=type_of('') & _merit_path='')
|| _merit_path:=((pth_dir()*(_sep+'pth'))-1)+pth_dir()+_sep+'merit'
?};
_work_dir:=(_merit_path-5)+'work';
_result:='';

_dir_bck:="'Przywrócenie Backup '+_d+'work'+_d+_a+_d+_b+' - '+
           {? fexists(_c+_d+_b+_a+'.zip')
           || {? funpack('zip',_c+_d+_b+_a+'.zip',_e+_d+_a+_d+_b)
              || 'OK\n'
              || 'BLAD\n'
              ?}
           || 'Nie znaleziono pliku .zip\n'
           ?}";

_result+=_dir_bck('f000','system',_workdir,_sep,_work_dir);
_result+=_dir_bck('f000','dsku',_workdir,_sep,_work_dir);
_result+=_dir_bck('f001','system',_workdir,_sep,_work_dir);
_result+=_dir_bck('f001','dsku',_workdir,_sep,_work_dir);
_result+=_dir_bck('f002','system',_workdir,_sep,_work_dir);
_result+=_dir_bck('f002','dsku',_workdir,_sep,_work_dir);
_result+=_dir_bck('f003','system',_workdir,_sep,_work_dir);
_result+=_dir_bck('f003','dsku',_workdir,_sep,_work_dir);

_result:=exec('set_elem','%transfer',exec('result_blank','%transfer',_a),'backup',_result)


\latest_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Funkcja sprawdza czy aktywowana i używana jest ostatnia wersja procesu ZWS_TRAN oraz czy pracujemy w kontekscie
::       procesu ZWS_TRAN lub ZWS_TRAN_WER
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
B_PROC.cntx_psh();
B_PREL.cntx_psh();
B_PREL.clear();
{? B_PREL.seek(#__proenv.STOS_ALL.topPrel())
|| {? B_PREL.B_PROC().SYMBOL='ZWS_TRAN_WER'
   || _result:=1
   |? B_PREL.B_PROC().SYMBOL='ZWS_TRAN'
   || _ver:=B_PREL.B_PROC().VER;
      {? _ver='23.25' | #(4+(gsub(_ver,'.','')))>2137
      || _result:=1
      ?}
   ?}
?};
B_PREL.cntx_pop();
B_PROC.cntx_pop();
_result


\manual_tasks
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS:
::   WE: _a - json z konfiguracja procesu
::       _b - xml z wynikiem svn update modified
::       _c - xml z wynikiem weryfikacji pth
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_svn:=exec('get_svn_data','%transfer',exec('cfg_get_elem','%transfer',_a,'svn_record_id'));
_res_mod:=exec('get_elem','%transfer',_b,'zmiany_w_standardzie_przykryte_przez_modified');
params_exec('sprawdzenie_warstwy_m','%transfer',_a,1,_svn);

_pth:=exec('get_elem','%transfer',_c,'zgodność_katalogu_pth');
{? _pth*'BŁĄD'=1
|| FUN.info(_pth+'\n\nNalezy uzgodnic pliki pth'@)
?};

{? FUN.ask('Czy dokonano weryfikacji/uzgodnienia plikow modified oraz pth?'@)
|| _res_mod:=gsub(_res_mod,'BŁĄD','OK');
   _res_mod+='\nEwentualne konflikty na plikach modified zostaly zweryfikowane i potwierdzone recznie.';
   _pth:=gsub(_pth,'BŁĄD','OK');
   _pth+='\nZgodnosc plikow pth zostala zweryfikowana i potwierdzona recznie.';
   _result:=exec('set_elem','%transfer',_c,'zgodność_katalogu_pth',_pth);
   _result:=exec('set_elem','%transfer',_result,'zmiany_w_standardzie_przykryte_przez_modified',_res_mod)
||
   _result:='Nie zakonczono zadania'
?};
_result


\manual_tasks_main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
{? var_pres('_a')=type_of('') & _a='Nie zakonczono zadania'
|| _mp.keep();
   0
|| 1
?}


\upg_imposible_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca temat maila dla niemozliwego do wykonania ZWS_TRAN_WER
::   WE: _a - string z nazwa instancji
::   WY: string z trescia
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Podniesieni wersji nie jest mozliwe na serwerze: ' + _a + '.')
|| return('[BLAD] Podniesieni wersji nie jest mozliwe na serwerze.')
?}


\tran_wer_mail_body
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca temat i treść maila dla niemozliwego do wykonania ZWS_TRAN_WER
::   WE: _a - string okreslajacy polozenie w procesie
::       _b - obiekt z wartoscia wyniku sprawdzenia czy mozna dokonac upgradu
::   WY: string z trescia
::----------------------------------------------------------------------------------------------------------------------
_txt:='Podniesienie wersji nie jest możliwe do wykonania przez proces na serwerze.';
{? var_pres('_b')<>type_of(~~) & var_pres('p02',_b)=type_of('') & _b.p02<>''
|| return(_txt+'\n'+(4-_b.p02))
|| return(_txt)
?}


\cfg_file_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Sprawdza czy istnieje zmodyfikowana wersja pliku. Zakladamy 3 znakowe rozszerzenie pliku
::   WE: _a - nazwa pliku
::   WY: nazwa docelowego pliku
::----------------------------------------------------------------------------------------------------------------------
{? fexists((_a-4)+'.m.'+(_a+3),1)
|| (_a-4)+'.m.'+(_a+3)
|| _a
?}


\svn_switch_pth
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Przepięcie svn dla katalogu pth dla ZWS_TRAN_WER
::   WE: _a - json z konfiguracja procesu ZWS_TRAN_WER
::       _b - url nowego svn
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_zws_tr_cfg_file:=exec('read_upg_cfg_file','%transfer',_a,'zws_tran_cfg_file');
_tmp:=params_get();
_tmp.in.p01:=_zws_tr_cfg_file;
params_set(_tmp);
_pth_path:=exec('parse_config_file','%transfer','pth_path');
_sep:=exec('sep','#file',1);
{? var_pres('_pth_path')=type_of('') & _pth_path=''
|| _pth_path:=((pth_dir()*(_sep+'pth'))+3)+pth_dir()
?};

_new_svn_url:=_b;
_svn:=exec('get_svn_data','%transfer',exec('parse_config_file','%transfer','svn_record_id'));

_result:='';
_result+=exec('svn_switch','%transfer',_pth_path,_svn,,_new_svn_url+'/pth');
:: obejscie problemu z przejscia wersji 22.26->23.25 i zmiany polozenia niektorych plikow fml do katalogu upgrade
_fml_dir_scr:=pth_dir('zws.fml');
_fml_dir_dst:=gsub(_fml_dir_scr,'lib','');
{? (_fml_dir_dst+2)=('//') | (_fml_dir_dst+2)=('\\\\')
|| _fml_dir_dst:=(_fml_dir_dst-2)+_sep
|? (_fml_dir_dst+1)=('/') | (_fml_dir_dst+1)=('\\')
|| _fml_dir_dst:=(_fml_dir_dst-1)+_sep
|| _fml_dir_dst:=_fml_dir_dst+_sep
?};
fmkdir(_fml_dir_dst,'upgrade');
_fml_dir_dst+='upgrade';
_fml_list:=fdir(_fml_dir_scr);
_ndx:=_fml_list.ndx_tmp(,1,'TYPE',,,'NAME',,);
_fml_list.index(_ndx);
_fml_list.prefix('f');
_loop:=_fml_list.first();
{!
|? _loop
|! {? _fml_list.NAME*'upgrade' | _fml_list.NAME*'tran_' | _fml_list.NAME*'transfer'
   || fcopy(_fml_dir_scr+_sep+_fml_list.NAME,_fml_dir_dst+_sep+_fml_list.NAME)
   ?};
   _loop:=_fml_list.next()
!};
_result


\can_proceed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Formula warunku dla kontynuacji procesu ZWS_TRAN_WER po przepieciu svn dla katalogu pth i przejscia do
::       do ZWS_TRAN (puszczamy dopiero gdy wykona sie restart serwera, bo zalezy nam by byly podczytane nowe pliki pth)
::   WE: _a - data uruchomienia servera przed tym krokiem
::   WY:
::----------------------------------------------------------------------------------------------------------------------
server_start_idtime()<>_a


\tran_wer_pow
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Formula do obslugi powiadomien z procesu ZWS_TRAN_WER
::   WE: _a - json z konfiguracja procesu ZWS_TRAN_WER
::       _b - oznaczenie położenia w procesie
::       _c - Uszczegolowiony tekst wiadomosci
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_tmp:=obj_new('in');
_tmp.in:=obj_new('p01','p02','p03','p04');
params_set(_tmp);
_tmp.in.p01:=exec('parse_config_file','%transfer',exec('read_upg_cfg_file','%transfer',_a,'zws_tran_cfg_file'),1);
{? var_pres('_c')=type_of('') & _c<>''
|| _tmp.in.p02:=_c
?};
params_set(_tmp);
exec('tech_mail','%transfer','tran_wer',_b,'template_error.htm')


\pth_sw_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca temat maila dla nieudanego pth svn switch
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Nieudane przepiecie svn dla katalogu pth na serwerze: ' + _a + '.')
|| return('[BLAD] Nieudane przepiecie svn dla katalogu pth.')
?}


\svn_sw_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca temat maila dla nieudanego svn switch katalogow merit,modified,defy
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Nieudane przepiecie svn dla katalogow merit, modified, defy na serwerze: ' + _a + '.')
|| return('[BLAD] Nieudane przepiecie svn dla katalogow merit, modified, defy.')
?}


\backup_sub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Zwraca temat maila dla nieudanego backupu podczas ZWS_TRAN_WER
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & _a <> ''
|| return('[BLAD] Nieudalo sie poprawenie zrobic backupu plikow ' + _a + '.')
|| return('[BLAD] Nieudalo sie poprawenie zrobic backupu.')
?}

:Sign Version 2.0 jowisz:1045 2023/10/03 13:59:27 45abb517d62330033fe19be06babe21c99e07b05a9b52741c8c75ccea291dd166984987471d647e4a7cd35a561070be98535c9df2b768ccb071e9a225a624fa8be575f61055403a0fea33b5b69f794ae71fd42a848a01d02fc4c82a99adb511d03bdc5860ecaaf2c8f23f2ef980ba3a95b63743f116bbb8eda5744d670b9fdd7
