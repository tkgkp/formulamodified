:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: %logger.fml
:: Utworzony: 20.09.2016
:: Autor: RWR
::======================================================================================================================
:: Zawartość: Plik zawiera formuły przydatne przy tworzeniu plików z informacjami o stanie przetwarzania danych,
::            np. w środowisku webTerm-a czyli bez możliwości uruchamiana debugera.
::======================================================================================================================


\_const
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła zwraca tablicę ze stałymi.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_CONST:=obj_new(
   'tVOID','tNUMBER','tSTRING','tRULE','tDATE','tTIME','tREFERENCE',
   'TREAL','TDATE','TINTEGER','THEADER','TMEMO','T_','TSTRING','TTIME','TREFERENCE',
   'TTREE_REF','TBLOBRAW','TSYS_MEMO','TBLOBIMAGE','TIDTIME','TIDADD','TIDPUT',
   'tMETH','tARRAY','tTABLE','tFILE',
   'CLASS',
   'EOL',
   'fSign',
   'width'
);

:: Typy proste (wartości na podstawie opisu funckji type_of()).
_CONST.tVOID:=0;
_CONST.tNUMBER:=1;
_CONST.tSTRING:=2;
_CONST.tRULE:=3;
_CONST.tDATE:=4;
_CONST.tTIME:=5;
_CONST.tREFERENCE:=7;
:: Typy związane z tabelami / zmiennymi (wartości na podstawie opisu funkcji var_pres()).
_CONST.TREAL:=20;
_CONST.TDATE:=21;
_CONST.TINTEGER:=22;
_CONST.THEADER:=24;
_CONST.TMEMO:=25;
_CONST.T_:=26;
_CONST.TSTRING:=27;
_CONST.TTIME:=29;
_CONST.TREFERENCE:=30;
_CONST.TTREE_REF:=32;
_CONST.TBLOBRAW:=33;
_CONST.TSYS_MEMO:=36;
_CONST.TBLOBIMAGE:=37;
_CONST.TIDTIME:=38;
_CONST.TIDADD:=39;
_CONST.TIDPUT:=40;
:: Pozostałe (wartości obliczane lub określone doświadczalnie).
_CONST.tMETH:=115;
_CONST.tARRAY:=type_of(obj_new(1));
_CONST.tTABLE:=type_of(@.CLASS.DBF_T);
_CONST.tFILE:=type_of(@.CLASS.FILE_T);

_CONST.CLASS:=tab_tmp(1,
   'ID','INTEGER','Identyfikator klasy (typ)',
   'NAME','STRING[39]','Nazwa klasy',
   'LP','INTEGER','Numer wewnętrzny klasy'
);
{! _lp:=1 .. obj_len(@.CLASS)
|! _vp:=var_pres('[%1]' [$_lp],@.CLASS);
   {? _vp>0
   || _CONST.CLASS.blank();
      _CONST.CLASS.ID:=_vp;
      _CONST.CLASS.NAME:=!@.CLASS[_lp];
      _CONST.CLASS.LP:=_lp;
      _CONST.CLASS.add()
   ?}
!};

:: Znak końca linii.
_CONST.EOL:=%13+%10;

:: Funkcja
::  _a  [STRING] - Napis wprowadzający (doklejany na początku każdej linii).
:: [_b] [STRING] - Rozszerzenie napisu wprowadzającego (doklejany tylko w pierwszej linii)
::  _c  [STRING] - Tekst źródłowy.
_CONST.fSign:=$("
   _sign:=_a;
   _t1:={? var_pres('_b')="+$_CONST.tSTRING+" || _b || '' ?};
   {? _t1<>'' & _t1+1<>' '
   || _t1+=' '
   ?};
   _tx:=(+_t1)*' ';
   _eol:='"+_CONST.EOL+"';
   _text:=gsub(_c,_eol,'\n');
   _ret:='';
   _la:=spli_str(_text,'\n');
   {! _lp:=1 .. obj_len(_la)
   |! _ret+=_sign+{? _lp=1 || _t1 || _tx ?}+_la[_lp]+_eol
   !};
   _ret-(+_eol)
");

_CONST


\_cfg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła tworzy i zwraca tablicę nazwaną z parametrami / środowiskiem działania.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_env:=obj_new('CONST','fn','mode','sign','width','fl','ll','head');

:: Stałe.
_env.CONST:=exec('_const','%logger');

:: Domyślna nazwa i tryb otwarcia pliku. Tryb nie powinien być zmieniany!
_env.fn:='log.txt';
_env.mode:='ua!';

:: Znacznik czasowy poprzedzający każdą zapisywaną linię. Znacznik ustalany jest na początku przetwarzania i jest
:: informacją o czasie rozpoczęcia zapisu. W trakcie pracy współbieżnej może się zdarzyć, że zapis do pliku odbywa się
:: w tym samym czasie z więcej niż jednego procesu. Wówczas znacznik ma również wskazywać "autora".
:: Zmienna musi być typu napisowego, może być jednak napisem pustym.
_env.sign:=tm_form(SYSLOG.tm_stamp())+' ';

:: Szerokość separatorów.
_env.width:=120-(+_env.sign);

:: Pierwsza i ostatnia linia w sesji. Są zapisywane jeżeli są typu napisowego.
_env.fl:=_env.width*'{';
_env.ll:=_env.width*'}';

:: Treść nagłówka umieszczanego po pierwszej linii każdej sesji. Jest zapisywany, jeżeli jest typu napisowego.
:: Dla zgodności z formatem zapisu pierwsza linia nagłówka NIE rozpoczyna się _env.sign (zostanie dodany na etapie
:: zapisywania) a ostatnia linia nie kończy się _env.CONST.EOL (zostanie dodany na etapie zapisywania).
 _webTerm:=app_info('web_sesid')<>'';
_env.head:=
   {? _webTerm
   || ' TCID: [%1]' [app_info('web_tcid')]+
      ' MBID: [%1]' [app_info('web_mbid')]+
      ' SesID: [%1]' [app_info('web_sesid')]+
      ' TabID: [%1]' [app_info('web_tabid')]+
      ' ParentTabID: [%1]' [app_info('web_parent_tabid')]
   || _ses:=SYSLOG.ses_id(1);
      ' Id. sesji: [%1]' [_ses]+
      ' Aktywna: %1' [{? SYSLOG.ses_info(_ses,'exist') || 'T' || 'N' ?}]+
      ' Początek: %1 %2' [SYSLOG.ses_info(_ses,'log_date')$1,SYSLOG.ses_info(_ses,'log_time')$3]+
      ' Terminal: [%1]' [SYSLOG.ses_info(_ses,'log_tty')]+
      ' Nr połączenia: [%1]' [$SYSLOG.ses_info(_ses,'log_num')]
   ?}+_env.CONST.EOL+
   _env.sign+
   ' web_user: %1' [app_info('web_user')]+
   ' app_user: %1' [app_info('app_user')];
_env


\type_of
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.14]
:: OPIS: Rozwinięcie funkcji type_of() - zwraca tablicę nazwaną z numerem i nazwą typu.
::   WE: [_a] [ANY]   - Wartość [domyślnie: ~~].
::       [_b] [ARRAY] - Tablica stałych. Parametr techniczny.
::   WY: Tablica nazwana z numerem i nazwą typu.
::----------------------------------------------------------------------------------------------------------------------
_var:={? _<1 || ~~ || _a ?};
_CONST:={? _>1 || _b || exec('_const','%logger') ?};

_type:=obj_new('nr','name','clp');
_type.clp:=0;
_type.nr:=type_of(_var);
_type.name:=
   {? _type.nr=_CONST.tVOID
   || 'VOID'
   |? _type.nr=_CONST.tNUMBER
   || 'NUMBER'
   |? _type.nr=_CONST.tSTRING
   || 'STRING'
   |? _type.nr=_CONST.tRULE
   || 'RULE'
   |? _type.nr=_CONST.tDATE
   || 'DATE'
   |? _type.nr=_CONST.tTIME
   || 'TIME'
   |? _type.nr=_CONST.tREFERENCE
   || 'REFERENCE'
   |? _type.nr=_CONST.tMETH
   || 'obj_meth()'
   |? _type.nr=_CONST.tARRAY
   || 'ARRAY'
   |? _type.nr=_CONST.tTABLE
   || 'TABLE'
   |? _CONST.CLASS.find_key(_type.nr)
   || _type.clp:=_CONST.CLASS.LP;
      _CONST.CLASS.NAME
   || '#'+$_type.nr+'#'
   ?};

_type


\fld_type
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.14]
:: OPIS: Formuła zwraca tablicę nazwaną z numerem i nazwą typu przekazanego pola tabeli.
::   WE:  _a  [STRING] - Akronim pola [domyślnie: ''].
::        _b  [TABLE]  - Uchwyt tabeli  [domyślnie: @]
::       [_c] [NUMBER] - Numer pola w strukturze tabeli. Wartość wykorzystywana tylko dla pól złączeniowych.
::       [_d] [ARRAY]  - Tablica stałych. Parametr techniczny.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_CONST:={? _>3 || _d || exec('_const','%logger') ?};

_type:=obj_new('nr','name');
_type.nr:=-1;
_type.name:='';

{? var_pres('_a')=_CONST.tSTRING
|| _fld:=_a
|| return(_type)
?};
{? var_pres('_b')=_CONST.tTABLE
|| _TAB:=_b
|| return(_type)
?};

_type.nr:=var_pres(_fld,_TAB,'diff_blob');
_type.name:=
   {? _type.nr=_CONST.TREAL
   || 'REAL'
   |? _type.nr=_CONST.TDATE
   || 'DATE'
   |? _type.nr=_CONST.TINTEGER
   || 'INTEGER'
   |? _type.nr=_CONST.THEADER
   || 'HEADER'
   |? _type.nr=_CONST.TMEMO
   || 'MEMO'
   |? _type.nr=_CONST.T_
   || '_'+ {? var_pres('_c')=_CONST.tNUMBER & _c || _TAB.fld_join(_c) || '' ?}
   |? _type.nr=_CONST.TSTRING
   || 'STRING[%1]' [$($('_val:=_a.%1; _a.%1:=256*\'a\'; _ret:=+_a.%1; _a.%1:=_val; _ret' [_fld]))(_TAB)]
   |? _type.nr=_CONST.TTIME
   || 'TIME'
   |? _type.nr=_CONST.TREFERENCE
   || 'REFERENCE'
   |? _type.nr=_CONST.TTREE_REF
   || 'TREE_REF'
   |? _type.nr=_CONST.TBLOBRAW
   || 'BLOBRAW'
   |? _type.nr=_CONST.TSYS_MEMO
   || 'SYS_MEMO'
   |? _type.nr=_CONST.TBLOBIMAGE
   || 'BLOBIMAGE'
   |? _type.nr=_CONST.TIDTIME
   || 'IDTIME'
   |? _type.nr=_CONST.TIDADD
   || 'IDADD'
   |? _type.nr=_CONST.TIDPUT
   || 'IDPUT'
   || '#'+$_type.nr+'#'
   ?};

_type


\to_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła zwraca znakową reprezentację przekazanego parametru. Podstawowa formuła zajmująca się konwersją na typ
::       napisowy.
::   WE:  _a  [ANY]    - Dowolna wartość.
::       [_b] [NUMBER] - Czy umieszczać informacje o typie wartości?
::                       0 - Nie [domyślnie];
::                       1 - Tak.
::       [_c] [STRING] - Napis wprowadzający. Parametr techniczny.
::       [_d] [NUMBER] - Poziom. Parametr techniczny.
::       [_e] [ARRAY]  - Tablica stałych. Parametr techniczny.
::   WY: Znakowa reprezentacja przekazanego parametru wraz z jego typem.
::----------------------------------------------------------------------------------------------------------------------
_CONST:={? _>4 || _e || exec('_const','%logger') ?};

{? _<1 || _a:=~~ ?};

_type:=exec('type_of','%logger',_a,_CONST);
_st:=var_pres('_b')=_CONST.tNUMBER & _b;
_sign:={? var_pres('_c')=_CONST.tSTRING || _c || '' ?};
_level:={? var_pres('_d')=_CONST.tNUMBER || _d || 0 ?};

_tab:="_a*3*' '";

_ret:='';

{? _=0
|| ~~

|? _type.nr=_CONST.tVOID
|| _ret+=_sign+'~~'+{? _st || ' [%1]' [_type.name] || '' ?}

|? _type.nr=_CONST.tNUMBER
|| _ret+=_sign+$_a+{? _st || ' [%1]' [_type.name] || '' ?}

|? _type.nr=_CONST.tSTRING
|| _ret+=_CONST.fSign(_sign,,_a)+{? _st || ' [%1]' [_type.name] || '' ?}

|? _type.nr=_CONST.tRULE
|| _ret+=_CONST.fSign(_sign,,$_a)+{? _st || ' [%1]' [_type.name] || '' ?}

|? _type.nr=_CONST.tDATE
|| _ret+=_sign+_a$1+{? _st || ' [%1]' [_type.name] || '' ?}

|? _type.nr=_CONST.tTIME
|| _ret+=_sign+_a$3+{? _st || ' [%1]' [_type.name] || '' ?}

|? _type.nr=_CONST.tREFERENCE
|| _ret+=_sign+{? _a=null() || 'null()' || $_a ?}+{? _st || ' [%1]' [_type.name] || '' ?}

|? _type.nr=_CONST.tTABLE
:: Tabela / Zmienna.
|| _ret+=_sign+_tab(_level)+'Akronim: %1 | Zbiór: %2 | Maska: %3' [form(2-!_a,8),_a.name(0),_a.name(1)]+_CONST.EOL;
   {? MS.table(_a) & _a<>SYSMEMO
   || _ret+=_sign+_tab(_level)+'Ineks: %1 | Prefix: %2 | Rozmiar: %3' [_a.index('?'),_a.cur_prfx(),$_a.size()]+
         _CONST.EOL
   ?};
   {! _lp:=1 .. _a.fld_num()
   |! _acr:=_a.fld_acr(_lp);
      _title:=_tab(_level)+form(_acr,8)+' = ';
      _ftype:=exec('fld_type','%logger',_acr,_a,_lp,_CONST);
      _ret+=
         {? _ftype.nr=_CONST.TREAL | _ftype.nr=_CONST.TINTEGER |
            _ftype.nr=_CONST.TREFERENCE | _ftype.nr=_CONST.TTREE_REF |
            _ftype.nr=_CONST.TBLOBRAW | _ftype.nr=_CONST.TBLOBIMAGE
         || _sign+_title+$_a[_lp]+{? _st || ' [%1]' [_ftype.name] || '' ?}
         |? _ftype.nr=_CONST.TDATE
         || _sign+_title+_a[_lp]$1+{? _st || ' [%1]' [_ftype.name] || '' ?}
         |? _ftype.nr=_CONST.THEADER
         || _sign+_title+'~~'+{? _st || ' [%1]' [_ftype.name] || '' ?}
::         |? _ftype.nr=_CONST.TMEMO
::         || Nawet nie ma tego jak przetestować ...
         |? _ftype.nr=_CONST.T_
         || _sign+_title+{? _a[_lp]=null() || 'null()' || $_a[_lp] ?}+{? _st || ' [_%1]' [_a.fld_join(_lp)] || '' ?}
         |? _ftype.nr=_CONST.TSTRING | _ftype.nr=_CONST.TIDTIME | _ftype.nr=_CONST.TIDADD | _ftype.nr=_CONST.TIDPUT
         || _sign+_title+_a[_lp]+{? _st || ' [%1]' [_ftype.name] || '' ?}
         |? _ftype.nr=_CONST.TTIME
         || _sign+_title+_a[_lp]$3+{? _st || ' [%1]' [_ftype.name] || '' ?}
         |? _ftype.nr=_CONST.TSYS_MEMO
         || _CONST.fSign(_sign,_title,exec('to_string','%logger',_a.memo_txt(0,1,_acr),_st,,_level+1,_CONST))+
            {? _st || ' [%1]' [_ftype.name] || '' ?}
         || _sign+_title+'[#'+$_ftype.nr+'#]'
         ?}+_CONST.EOL;
         obj_del(_ftype)
   !};
   _ret:=_ret-(+_CONST.EOL)

|? obj_ntab(_a)
:: Tablica z elementami nazwanymi.
|| _ret+=_sign+_tab(_level)+'['+_CONST.EOL;
   _level+=1;
   _an:=obj_ntab_names(_a);
   {! _lp:=1 .. obj_len(_an)
   |! _title:=_tab(_level)+_an[_lp]+' = ';
      _ret+=_CONST.fSign(_sign,_title,exec('to_string','%logger',_a[_lp],_st,,_level+1,_CONST))+_CONST.EOL
   !};
   _level-=1;
   _ret+=_sign+_tab(_level)+']'

|? _type.nr=_CONST.tARRAY
:: Tablica.
|| _ret+=_sign+_tab(_level)+'['+_CONST.EOL;
   _level+=1;
   {! _lp:=1 .. obj_len(_a)
   |! _title:=_tab(_level)+'['+$_lp+']=';
      _ret+=
         {? var_pres('['+$_lp+']',_a)<0
         || _sign+_title+'[undefined]'
         || _CONST.fSign(_sign,_title,exec('to_string','%logger',_a[_lp],_st,,_level+1,_CONST))
         ?}+_CONST.EOL
   !};
   _level-=1;
   _ret+=_sign+_tab(_level)+']'

|? _type.nr=_CONST.tFILE
:: Plik (rozsądnie pobrany początek).
|| _ret+=_CONST.fSign(_sign,,exec('bin2txt','#file',_a,400000))+{? _st || ' [%1]' [_type.name] || '' ?}

|? 7+_type.name='@.CLASS'
:: Obiekt.
|| _zm:={? !_a='' || '_a' || 2-!_a ?};
   _ret+=_sign+_tab(_level)+_zm+'= ['+_CONST.EOL;
   _level+=1;
   _dlo:=+(!_a)+1;
   _dlc:=+_type.name+1;
   _len:=obj_len(_a);
   {! _mem:=1 .. _len
   |! _acr:=_dlo-!_a[_mem];
      {? _acr=''
      || _acr:=_dlc-!@.CLASS[_type.clp][_mem]
      ?};
      {? _acr<>''
      || _tacr:=exec('type_of','%logger',_a[_mem],_CONST);
         {? _tacr.name<>_type.name
::          Obsługa wskazania na samego siebie (.this).
         || _title:=_tab(_level)+_acr+'=';
            _ret+=_CONST.fSign(_sign,_title,exec('to_string','%logger',_a[_mem],_st,,_level+1,_CONST))+_CONST.EOL
         ?};
         obj_del(_tacr)
      ?}
   !};
   _level-=1;
   _ret+=_sign+_tab(_level)+'] ['+_type.name+']'

|| _ret+=_sign+'['+$_type.name+']'
?};

_ret


\write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła zapisująca do pliku wartości przekazanych zmiennych.
::       Uwaga: parametrami mogą być kody mające specjalne znaczenie:
::                #stack   - w pliku umieszczany jest cały stos wywołania.
::   WE: [_a] [STRING] - Nazwa pliku [domyślnie: określona w _cfg].
::        _b  [ANY]    - Parametr dowolnego typu, którego wartość będzie dopisana do pliku.
::       [_c] [ANY]    - Parametr dowolnego typu, którego wartość będzie dopisana do pliku.
::       [_d] [ANY]    - Parametr dowolnego typu, którego wartość będzie dopisana do pliku.
::       [_e] [ANY]    - Parametr dowolnego typu, którego wartość będzie dopisana do pliku.
::       [_f] [ANY]    - Parametr dowolnego typu, którego wartość będzie dopisana do pliku.
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_env:=exec('_cfg','%logger');
_CONST:=_env.CONST;

_fn:={? var_pres('_a')=_CONST.tSTRING || _a || _env.fn ?};
_fh:=fopen(_fn,_env.mode,1,1,1);
{? _fh.is_open()
|| {? type_of(_env.fl)=_CONST.tSTRING
::    First Line
   || _fh.fwrite(_env.sign+_env.fl+_CONST.EOL)
   ?};
   {? type_of(_env.head)=_CONST.tSTRING
::    Header
   || _fh.fwrite(_env.sign+_env.head+_CONST.EOL)
   ?};
   {! _lp:=2 .. _
::    Elements
   |! {? type_of(_[_lp])=_CONST.tSTRING
      || {? _[_lp]='#stack'
         || _sep:=_env.sign+('%1+%2' [6*'-',(2+31+1+31+4)*'-'])+_env.CONST.EOL;
            _fh.fwrite(_sep);
            _fh.fwrite(_env.CONST.fSign(_env.sign,,(exec('stack','%logger',3,_env.sign,_env.CONST)-1))+_env.CONST.EOL);
            _fh.fwrite(_sep)
         || _fh.fwrite(_CONST.fSign(_env.sign,,_[_lp])+_CONST.EOL)
         ?}
      || _fh.fwrite(exec('to_string','%logger',_[_lp],1,_env.sign,,_CONST)+_CONST.EOL)
      ?}
   !};
   {? type_of(_env.ll)=_CONST.tSTRING
::    Last Line
   || _fh.fwrite(_env.sign+_env.ll+_CONST.EOL)
   ?};
   _fh.fclose()
?};
~~


\mp_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Informacja o bieżącej czynności. Formuła napisana z przeznaczeniem do wywołania w funkcji main dowolnej
::       czynności. Identyfikuje bieżącą czynność, jej stan i parametry.
::   WE: [_a] [STRING] - Tryb pracy
::                      'W' - Wyświetlenie okna redagowania (wartość domyślna dla jTerma).
::                      'F' - Zapis do pliku (wartość domyślna dla webTerma).
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_par:=params_get(0);
{? ~obj_ntab(_par)
|| return(0)
?};

B_ACTION.cntx_psh();
B_ACTION.prefix();
B_ACTION.blank();
_INFO:=tab_tmp(1,
:: Czynność
   'UID','STRING[%1]'[$MS.fld_len(B_ACTION,'UID')],MS.name(B_ACTION,'UID'),
   'NAME','STRING[%1]'[$MS.fld_len(B_ACTION,'NAME')],MS.name(B_ACTION,'NAME'),
   'B_CAN','STRING[%1]'[$MS.fld_len(B_ACTION,'B_CAN')],MS.name(B_ACTION,'B_CAN'),
   'FMMAIN','STRING[%1]'[$MS.fld_len(B_ACTION,'FMMAIN')],MS.name(B_ACTION,'FMMAIN'),
   'FMTODO','STRING[%1]'[$MS.fld_len(B_ACTION,'FMTODO')],MS.name(B_ACTION,'FMTODO'),
   'FMACCESS','STRING[%1]'[$MS.fld_len(B_ACTION,'FMACCESS')],MS.name(B_ACTION,'FMACCESS'),
   'FPARSES','STRING[%1]'[$MS.fld_len(B_ACTION,'FPARSES')],MS.name(B_ACTION,'FPARSES'),
   'ICON','STRING[%1]'[$MS.fld_len(B_ACTION,'ICON')],MS.name(B_ACTION,'ICON'),
   'USER','STRING[%1]'[$MS.fld_len(B_ACTION,'USER')],MS.name(B_ACTION,'USER'),
   'CSERVICE','STRING[%1]'[$MS.fld_len(B_ACTION,'SERVICE')],MS.name(B_ACTION,'SERVICE'),
   'LOOP','STRING[%1]'[$MS.fld_len(B_ACTION,'LOOP')],MS.name(B_ACTION,'LOOP'),
   'SEND','STRING[%1]'[$MS.fld_len(B_ACTION,'SEND')],MS.name(B_ACTION,'SEND'),
   'IN','SYS_MEMO','Parametry wejściowe',
   'OUT','SYS_MEMO','Parametry wyjściowe',
   'INT','SYS_MEMO','Parametry wewnętrzne',
   'CONTEXT','SYS_MEMO','Kontekst',
   'KEYS','SYS_MEMO','Kluczowe rekordy',
:: Instancja
   'AKCJA','STRING[255]','Akcja',
   'AUTORUN','INTEGER','AutoRun',
   'BINEW','INTEGER','BiNew',
   'GROUP','INTEGER','Group',
   'MICRO','INTEGER','Micro',
   'ISERVICE','INTEGER','Service',
   'LOOPX','INTEGER','Obsługa pętli',
   'GRPKEYS','SYS_MEMO','Lista kluczy',
   'PATH','STRING[10]','Path',
   'PATHAREA','INTEGER','pathArea',
   'PATHPROC','INTEGER','pathProc',
   'PATHTODO','INTEGER','pathTodo',
::
   'B_PROC','STRING[16]','Proces',
   'B_PREL','STRING[16]','Element w procesie',
   'B_WORKER','STRING[16]','Kolejka robocza usuługi',
   'BI_PROC','STRING[16]','Instancja procesu',
   'BI_PREL','STRING[16]','Instancja elementu w procesie'
);
B_ACTION.cntx_pop();

_INFO.blank();
{? var_pres('mp',_par)=type_of(@.CLASS.cProMan)
|| _mp:=_par.mp;
:: Czynność
   _INFO.UID:=_mp.buf_act.UID;
   _INFO.NAME:=_mp.buf_act.NAME;
   _INFO.B_CAN:=_mp.buf_act.B_CAN;
   _INFO.FMMAIN:=_mp.buf_act.FMMAIN;
   _INFO.FMTODO:=_mp.buf_act.FMTODO;
   _INFO.FMACCESS:=_mp.buf_act.FMACCESS;
   _INFO.FPARSES:=_mp.buf_act.FPARSES;
   _INFO.ICON:=_mp.buf_act.ICON;
   _INFO.USER:=_mp.buf_act.USER;
   _INFO.CSERVICE:=_mp.buf_act.SERVICE;
   _INFO.LOOP:=_mp.buf_act.LOOP;
   _INFO.SEND:=_mp.buf_act.SEND;
   _INFO.memo_set(exec('to_string','%logger',_mp.getRefs()),'KEYS');
:: Instancja
   _INFO.AKCJA:=_mp.akcja();
   _INFO.AUTORUN:=_mp.isAutoRun();
   _INFO.BINEW:=_mp.isBiNew();
   _INFO.GROUP:=_mp.isGroup();
   _INFO.MICRO:=_mp.isMicro();
   _INFO.ISERVICE:=_mp.isService();
   _INFO.LOOPX:=_mp.loop();
   {? _mp.GRPKEY=''
   || _txt:='Brak informacji o kluczu grupującym.'
   || _txt:='';
      _GRPKEYS:=_mp.grpkeyGetAll();
      {? _GRPKEYS.first()
      || {!
         |? _txt+=_GRPKEYS.ITEM+'\n';
            _GRPKEYS.next()
         !}
      ?};
      obj_del(_GRPKEYS)
   ?};
   _INFO.memo_set(_txt,'GRPKEYS');
   _INFO.PATH:=_mp.path();
   _INFO.PATHAREA:=_mp.pathArea();
   _INFO.PATHPROC:=_mp.pathProc();
   _INFO.PATHTODO:=_mp.pathTodo();
::
   _INFO.B_PROC:=$_mp.b_proc;
   _INFO.B_PREL:=$_mp.b_prel;
   _INFO.B_WORKER:=$_mp.b_worker;
   _INFO.BI_PROC:=$_mp.bi_proc;
   _INFO.BI_PREL:=$_mp.bi_prel;
   ~~
?};
_INFO.add();
{? var_pres('in',_par)>=0
|| _INFO.memo_set(exec('to_string','%logger',_par.in),'IN');
   _INFO.memo_put(,'IN')
?};
{? var_pres('out',_par)>=0
|| _INFO.memo_set(exec('to_string','%logger',_par.out),'OUT');
   _INFO.memo_put(,'OUT')
?};
{? var_pres('int',_par)>=0
|| _INFO.memo_set(exec('to_string','%logger',_par.int),'INT');
   _INFO.memo_put(,'INT')
?};
{? var_pres('context',_par)>=0
|| _INFO.memo_set(exec('to_string','%logger',_par.context),'CONTEXT');
   _INFO.memo_put(,'CONTEXT')
?};
_INFO.memo_put(,'KEYS');
_INFO.memo_put(,'GRPKEYS');

_wt:=app_info('web_sesid')<>'';
_tryb:=
   {? _wt
   || 'F'
   |? var_pres('_a')=type_of('') & (_a*'W' | _a*'F')
   || _a
   || 'W'
   ?};

{? _tryb*'F'
|| exec('write','%logger',,' - = Menedżer procesu = -',_INFO)
?};

{? _tryb*'W'
|| _we:=_INFO.mk_edit();

   _szer:=40;
   _INFO.win_etab(_we,'Czynność'@);
   _INFO.win_esep(_we,'Dane podstawowe'@);
   _INFO.win_efld(_we,,'UID',,,_szer);
   _INFO.win_efld(_we,,'NAME',,,_szer);
   _INFO.win_efld(_we,,'B_CAN',,,_szer);
   _INFO.win_efld(_we,,'FMMAIN',,,_szer);
   _INFO.win_efld(_we,,'FMTODO',,,_szer);
   _INFO.win_efld(_we,,'FMACCESS',,,_szer);
   _INFO.win_efld(_we,,'FPARSES',,,_szer);
   _INFO.win_efld(_we,,'ICON',,,_szer);
   _INFO.win_efml(_we,,'ICON',,'ICON_BEFORE',"params_get().INFO.ICON");
   _INFO.win_efld(_we,,'USER',,,,,,,,,'check-box',,"'T'","'N'");
   _INFO.win_efld(_we,,'CSERVICE',,,,,,,,,'check-box',,"'T'","'N'");
   _INFO.win_efld(_we,,'LOOP',,,,,,,,,'check-box',,"'T'","'N'");
   _INFO.win_efld(_we,,'SEND',,,,,,,,,'check-box',,"'T'","'N'");

   _szer:=16;
   _INFO.win_etab(_we,'Instancja'@);
   _INFO.win_esep(_we,'Dane podstawowe'@);
   _INFO.win_efld(_we,,'AKCJA',,,_szer);
   _INFO.win_efld(_we,,'AUTORUN',,,,,,,,,'check-box',,"1","0");
   _INFO.win_efld(_we,,'BINEW',,,,,,,,,'check-box',,"1","0");
   _INFO.win_efld(_we,,'GROUP',,,,,,,,,'check-box',,"1","0");
   _INFO.win_efld(_we,,'MICRO',,,,,,,,,'check-box',,"1","0");
   _INFO.win_efld(_we,,'ISERVICE',,,,,,,,,'check-box',,"1","0");
   _INFO.win_efld(_we,,'LOOPX',,,,,,,,,'check-box',,"1","0");
   _INFO.win_efld(_we,,'PATH',,,_szer);
   _INFO.win_efld(_we,,'PATHAREA',,,,,,,,,'check-box',,"1","0");
   _INFO.win_efld(_we,,'PATHPROC',,,,,,,,,'check-box',,"1","0");
   _INFO.win_efld(_we,,'PATHTODO',,,,,,,,,'check-box',,"1","0");
   _INFO.win_ecol(_we);
   _INFO.win_esep(_we,'Dane rozszerzone'@);
   _INFO.win_efld(_we,,'B_PROC',,,_szer);
   _INFO.win_efld(_we,,'B_PREL',,,_szer);
   _INFO.win_efld(_we,,'B_WORKER',,,_szer);
   _INFO.win_efld(_we,,'BI_PROC',,,_szer);
   _INFO.win_efld(_we,,'BI_PREL',,,_szer);

   _szer:=80;

   _INFO.win_etab(_we,'IN'@);
   _INFO.win_esep(_we,'Parametry wejściowe'@);
   _INFO.win_efld(_we,,'IN',,,_szer,-12,,,1);

   _INFO.win_etab(_we,'OUT'@);
   _INFO.win_esep(_we,'Parametry wyjściowe'@);
   _INFO.win_efld(_we,,'OUT',,,_szer,-12,,,1);

   _INFO.win_etab(_we,'INT'@);
   _INFO.win_esep(_we,'Parametry wewnętrzne'@);
   _INFO.win_efld(_we,,'INT',,,_szer,-12,,,1);

   _INFO.win_etab(_we,'CONTEXT'@);
   _INFO.win_esep(_we,'Kontekst'@);
   _INFO.win_efld(_we,,'CONTEXT',,,_szer,-12,,,1);

   _INFO.win_etab(_we,'refs'@);
   _INFO.win_esep(_we,'Kluczowe rekordy'@);
   _INFO.win_efld(_we,,'KEYS',,,_szer,-12,,,1);

   _INFO.win_etab(_we,'grpkeys'@);
   _INFO.win_esep(_we,'Lista pozycji klucza grupującego'@);
   _INFO.win_efld(_we,,'GRPKEYS',,,_szer,-12,,,1);

   _INFO.win_edit(_we);

   params_set('INFO',_INFO);
   _INFO.display()
?};
~~


\write_variables
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła zapisuje do pliku wszystkie zmienne globalne.
::   WE: [_a] [STRING] - Nazwa pliku [domyślnie: określona w _cfg].
::       [_b] [STRING] - Komentarz [domyślnie: ''].
::       [_c] [STRING] - Lista zmiennych globalnych (rozdzielona przecinkami), które nie będą zapisywane
::                       [domyślnie: ''].
::   WY: Liczba zapisanych zmiennych lub -1 w przypadku błędu.
::----------------------------------------------------------------------------------------------------------------------
_env:=exec('_cfg','%logger');
_CONST:=_env.CONST;

_fn:={? var_pres('_a')=_CONST.tSTRING || _a || _env.fn ?};
_pomin:=','+{? var_pres('_c')=_CONST.tSTRING || gsub(_c,' ','') || '' ?}+',';

_count:=-1;
_fh:=fopen(_fn,_env.mode,1,1,1);
{? _fh.is_open()
|| _count:=0;
   _on:=0;
   {! _lp:=1 .. obj_len(@)
   |! _type:=var_pres('[%1]' [$_lp],@);
      {? _on & ((_type>0 & _type<10 ) | _type=_CONST.tARRAY | _CONST.CLASS.find_key(_type))
      || _name:=2-!@[_lp];
         {? _pomin=',,' | _pomin*(',%1,' [_name])=0
         || {? _count=0
            || {? type_of(_env.fl)=_CONST.tSTRING
               || _fh.fwrite(_env.sign+_env.fl+_CONST.EOL)
               ?};
               {? type_of(_env.head)=_CONST.tSTRING
               || _fh.fwrite(_env.sign+_env.head+_CONST.EOL)
               ?};
               {? var_pres('_b')=_CONST.tSTRING
               || _fh.fwrite(_CONST.fSign(_env.sign,,_b)+_CONST.EOL)
               ?}
            ?};
            _count+=1;
            {? _type=_CONST.CLASS.ID
            || _fh.fwrite(_env.sign+_name+' ['+_CONST.CLASS.NAME+']'+_CONST.EOL)
            || _fh.fwrite(_CONST.fSign(_env.sign,_name+' = ',exec('to_string','%logger',@[_lp],1,,,_CONST))+_CONST.EOL)
            ?}
         ?}
      ?};
      {? _type=_CONST.tARRAY & !@[_lp]='@.DEFINE'
      || _on:=1
      ?}
   !};
   {? _count
   || {? type_of(_env.ll)=_CONST.tSTRING
      || _fh.fwrite(_env.sign+_env.ll+_CONST.EOL)
      ?}
   ?};
   _fh.fclose()
?};
_count


\write_records
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła zapisuje do pliku rekordy wskazanej tabeli.
::   WE: [_a] [STRING] - Nazwa pliku [domyślnie: określona w _cfg].
::       [_b] [STRING] - Komentarz [domyślnie: ''].
::       [_c] [STRING] - Sposób prezentacji danych:
::                       'f0' - formatka ('okno redagowania') [domyślnie].
::                       't0' - tabelka.
::        _d  [TABLE]  - Uchwyt tabeli.
::       [_e] [STRING] - Akronim indeksu [domyślnie: bieżący].
::       [_f] [STRING] - Lista akronimów pól do logowania [domyślnie: ''].
::       [_g] [ANY]    - Kolejne pole wchodzące do prefiksu.
::       [_h] [ANY]    - Kolejne pole wchodzące do prefiksu.
::       [_i] [ANY]    - Kolejne pole wchodzące do prefiksu.
::       [_j] [ANY]    - Kolejne pole wchodzące do prefiksu.
::       [_k] [ANY]    - Kolejne pole wchodzące do prefiksu.
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_env:=exec('_cfg','%logger');
_CONST:=_env.CONST;

_fn:={? var_pres('_a')=_CONST.tSTRING || _a || _env.fn ?};

_fh:=fopen(_fn,_env.mode,1,1,1);
{? _fh.is_open()
|| {? type_of(_env.fl)=_CONST.tSTRING
   || _fh.fwrite(_env.sign+_env.fl+_CONST.EOL)
   ?};
   {? type_of(_env.head)=_CONST.tSTRING
   || _fh.fwrite(_env.sign+_env.head+_CONST.EOL)
   ?};
   {? var_pres('_b')=_CONST.tSTRING
   || _fh.fwrite(_CONST.fSign(_env.sign,,_b)+_CONST.EOL)
   ?};
   {? var_pres('_d')=_CONST.tTABLE
   || _TAB:=_d;
      _TAB.cntx_psh();
      {? var_pres('_e')=_CONST.tSTRING
      || _TAB.index(_e)
      ?};
      {? _>6
      || _prfx:='';
         _par:=obj_new(_);
         {! _lp:=7 .. _
         |! _par[_lp]:=_[_lp];
            _prfx+={? type_of(_[_lp])=_CONST.tVOID || ',' || ',_b['+$_lp+']' ?}
         !};
         ($('_a.prefix('+(1-_prfx)+')'))(_TAB,_par)
      || _TAB.prefix()
      ?};
      _fh.fwrite(
         _env.sign+
         'Akronim: %1 | Zbiór: %2 | Maska: %3' [form(2-!_TAB,8),_TAB.name(0),_TAB.name(1)]+
         _CONST.EOL
      );
      {? MS.table(_TAB)
      || _fh.fwrite(
            _env.sign+
            'Ineks: %1 | Prefix: %2 | Rozmiar: %3' [_TAB.index('?'),_TAB.cur_prfx(),$_TAB.size()]+
            _CONST.EOL
         )
      ?};
      {? _TAB.first()
      || _view:={? var_pres('_c')=_CONST.tSTRING & (_c='f0' | _c='t0') || _c || 'f0' ?};
         _pola:={? var_pres('_f')=_CONST.tSTRING || ','+gsub(_f,' ','')+',' || '*' ?};
         {? _pola=',,'
         || _pola:='*'
         ?};
         {? _view='f0'
::          Sposób prezentacji danych: formatka ('okno redagowania').  -------------------------------------------------
         || _fwrite:=
               "_fh:=_a;\n"+
               "_TAB:=_b;\n"+
               "_CONST:=_c;\n"+
               "_fh.fwrite('"+_env.sign+"'+"+$_env.width+"*'-'+_CONST.EOL);\n"+
               "_fh.fwrite('"+_env.sign+form('REF',8)+' = '+"'+"+
                  "form(#_TAB.ref(),6,0,'99')+' | SQL-ref = '+$_TAB.ref()+_CONST.EOL);\n";
            {! _lp:=1 .. _TAB.fld_num()
            |! _acr:=_TAB.fld_acr(_lp);
               {? _pola='*' | _pola*(','+_acr+',')
               || _title:=form(_acr,8)+' = ';
                  _vp:=var_pres(_acr,_TAB,'diff_blob');
                  _fwrite+=
                     "_fh.fwrite("+
                     {? _vp=_CONST.TREAL | _vp=_CONST.TINTEGER | _vp=_CONST.TSTRING |
                        _vp=_CONST.TDATE | _vp=_CONST.TTIME | _vp=_CONST.T_ | _vp=_CONST.TREFERENCE
::                      Typy proste.
                     || "_CONST.fSign('"+_env.sign+"','"+_title+"',exec('to_string','%logger',_TAB."+_acr+",1))"
                     |? _vp=_CONST.TTREE_REF
                     || "'"+_env.sign+_title+"'+$_TAB."+_acr+"+' [TREE_REF]'"
                     |? _vp=_CONST.TBLOBRAW
                     || "'"+_env.sign+_title+"'+$_TAB."+_acr+"+' [BLOBRAW]'"
                     |? _vp=_CONST.TSYS_MEMO
                     || "_CONST.fSign('"+_env.sign+"','"+_title+"',"+
                           "exec('to_string','%logger',_TAB.memo_txt(0,1,'"+_acr+"')+' [SYS_MEMO]',0))"
                     |? _vp=_CONST.TBLOBIMAGE
                     || "'"+_env.sign+_title+"'+$_TAB."+_acr+"+' [BLOBIMAGE]'"
                     |? _vp=_CONST.TIDTIME
                     || "'"+_env.sign+_title+"'+_TAB."+_acr+"+' [IDTIME]'"
                     |? _vp=_CONST.TIDADD
                     || "'"+_env.sign+_title+"'+_TAB."+_acr+"+' [IDADD]'"
                     |? _vp=_CONST.TIDPUT
                     || "'"+_env.sign+_title+"'+_TAB."+_acr+"+' [IDPUT]'"
                     || "'"+_env.sign+_title+"[$"+$_vp+"$]'"
                     ?}+
                     "+_CONST.EOL"+
                     ");\n"
               ?}
            !};
            _fwrite+="~~";
            {!
            |? ($_fwrite)(_fh,_TAB,_CONST);
               _TAB.next()
            !}
         |? _view='t0'
::          Sposób prezentacji danych: tabelka.  -----------------------------------------------------------------------
         || exec(,'_string');
            exec(,'_print');
            exec(,'_misc');
            _MS:=obj_new(@.CLASS.MISC);
            params_set('TAB',_TAB);
            _prn:=obj_new(@.CLASS.PRINT,_TAB.fld_num()+3);
            _prn.s_frame();
            _dh:=1+int(log10(_TAB.size()));
            {? _dh<5
            || _dh:=5
            ?};
            _prn.add("#params_get().TAB.ref()",&_dh,'REF',1,,,,,',0,\'99\'' );
            _brak:='';
            {! _lp:=1 .. _TAB.fld_num()
            |! _acr:=_TAB.fld_acr(_lp);
               {? _pola='*' | _pola*(','+_acr+',')
               || _vp:=var_pres(_acr,_TAB,'diff_blob');
                  {? _vp=_CONST.TREAL | _vp=_CONST.TINTEGER | _vp=_CONST.TTREE_REF
                  || _prn.add($("exec('to_string','%logger',params_get().TAB."+_acr+")"),18,_acr,1)
                  |? _vp=_CONST.TDATE
                  || _prn.add($("exec('to_string','%logger',params_get().TAB."+_acr+")"),10,_acr)
                  |? _vp=_CONST.T_
                  || _prn.add($("exec('to_string','%logger',params_get().TAB."+_acr+")"),16,_acr)
                  |? _vp=_CONST.TTIME
                  || _prn.add($("exec('to_string','%logger',params_get().TAB."+_acr+")"),8,_acr)
                  |? _vp=_CONST.TSTRING
                  || _len:=_MS.fld_len(_TAB,_acr);
                     {? _len<+_acr
                     || _len:=+_acr
                     ?};
                     _prn.add($("params_get().TAB."+_acr),_len,_acr)
                  |? _vp=_CONST.TBLOBRAW
                  || _prn.add($("exec('to_string','%logger',params_get().TAB."+_acr+")"),16,_acr)
                  |? _vp=_CONST.TSYS_MEMO
                  || _prn.add($("gsub(params_get().TAB.memo_txt(0,1,'"+_acr+"'),'\n',' ')"),60,_acr)
                  |? _vp=_CONST.TBLOBIMAGE
                  || _prn.add($("exec('to_string','%logger',params_get().TAB."+_acr+")"),16,_acr)
                  |? _vp=_CONST.TIDTIME | _vp=_CONST.TIDADD | _vp=_CONST.TIDPUT
                  || _prn.add($("params_get().TAB."+_acr),31,_acr)
                  || _brak+=_acr+','
                  ?}
               ?}
            !};
            _prn.ini_head();
            _fh.fwrite(_env.sign+_prn.hbar()+_CONST.EOL);
            {!
            |? _prn.h_next()
            |! _fh.fwrite(_env.sign+_prn.h_line()+_CONST.EOL)
            !};
            _fh.fwrite(_env.sign+_prn.bar()+_CONST.EOL);
            {!
            |? _prn.ini_line();
               {!
               |? _prn.next()
               |! _fh.fwrite(_env.sign+_prn.line()+_CONST.EOL)
               !};
               _TAB.next()
            !};
            _fh.fwrite(_env.sign+_prn.lbar()+_CONST.EOL);
            {? _brak<>''
            || _brak:='Lista kolum, które nie zostały umieszczone w tabelce: %1.' [_brak-1];
               _fh.fwrite(_env.sign+_brak+_CONST.EOL)
            ?}

         ?}
      ?};
      _TAB.cntx_pop()
   || _fh.fwrite('Nieprawidłowy typ parametru TABLE.'+_CONST.EOL)
   ?};
   {? type_of(_env.ll)=_CONST.tSTRING
   || _fh.fwrite(_env.sign+_env.ll+_CONST.EOL)
   ?};
   _fh.fclose()
?};
~~


\write_ndx_tmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła zapisuje do pliku nazwy/akronimy tabel, które mają zdefiniowane indeksy tymczasowe.
::   WE: [_a] [STRING] - Nazwa pliku [domyślnie: określona w _cfg].
::       [_b] [STRING] - Komentarz [domyślnie: ''].
::       [_c] [STRING] - Lista akronimów tabel lub nazw zmiennych przechowujących tabele tymczasowe (rozdzielona
::                       przecinkami), które nie będą zapisywane [domyślnie: ''].
::                       Tabela SYSMEMO, ze względów technologicznych, jest pomijana zawsze.
::   WY: Liczba usuniętych indeksów lub -1 w przypadku błędu.
::----------------------------------------------------------------------------------------------------------------------
_env:=exec('_cfg','%logger');
_CONST:=_env.CONST;

_fn:={? var_pres('_a')=_CONST.tSTRING || _a || _env.fn ?};
_pomin:=','+{? var_pres('_c')=_CONST.tSTRING || gsub(_c,' ','') || '' ?}+',SYSMEMO,';

_count:=-1;
_fh:=fopen(_fn,_env.mode,1,1,1);
{? _fh.is_open()
|| _TAB:=tab_tmp(1,'ACR','STRING[8]','Akronim','TYPE','STRING[1]','Typ');
   {! _lp:=1 .. tab_num()
   |! _TAB.ACR:=tab_acr(_lp);
      _TAB.TYPE:={? tab_real(_lp) || 'T' || 'Z' ?};
      _TAB.add()
   !};

   _count:=0;
   {! _lp:=1 .. obj_len(@)
   |! {? var_pres('[%1]' [$_lp],@)=_CONST.tTABLE &
         _pomin*(',%1,' [_acr:=2-!@[_lp]])=0 &
         {? _TAB.find_key(_acr,) || _TAB.TYPE='T' || 1 ?}
      || _tmp:=@[_lp].tab_info('ndx_tmp_cnt');
         {? _tmp>0
         || {? _count=0
            || {? type_of(_env.fl)=_CONST.tSTRING
               || _fh.fwrite(_env.sign+_env.fl+_CONST.EOL)
               ?};
               {? type_of(_env.head)=_CONST.tSTRING
               || _fh.fwrite(_env.sign+_env.head+_CONST.EOL)
               ?};
               {? var_pres('_b')=_CONST.tSTRING
               || _fh.fwrite(_CONST.fSign(_env.sign,,_b)+_CONST.EOL)
               ?}
            ?};
            _count+=1;
            _fh.fwrite(_env.sign+'Tabela: %1 | Indeksów tymczasowych: %2'
               [form(_acr,31),form(_tmp,2,0,'99')]+_CONST.EOL
            )
         ?}
      ?}
   !};
   {? _count
   || {? type_of(_env.ll)=_CONST.tSTRING
      || _fh.fwrite(_env.sign+_env.ll+_CONST.EOL)
      ?}
   ?};
   _fh.fclose()
?};
_count


\stack
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Formuła zwraca sformatowaną informację o stosie wywołań.
::   WE: [_a] [NUMBER] - Numer początkowy prezentowanego poziomu wywołań. Pozwala pominąć informacje o "początkowych"
::                       formułach [domyślnie: 1].
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_start:={? var_pres('_a')=type_of(0) & _a>0 || _a || 1 ?};

_array:=form_stack(-1);
_ret:='';
{! _lp:=_start .. obj_len(_array)
|! _name:=_array[_lp].name;
   _file:=_array[_lp].file;
   {? _array[_lp].type
   || _mb:='T';
     _fml:=_name+' (MacroBUILDER)'
   || _mb:='N';
      {? _name<>'' & _file<>''
      || _fml:='\\%1/%2.fml' [_name,_file]
      |? _name<>''
      || _fml:=_name+' (metoda)'
      || _fml:='$'
      ?}
   ?};
   _ret+='%1 | %2\n' [form(_lp-_start+1,5,0,'9.'),_fml]
!};
_ret

:Sign Version 2.0 jowisz:1045 2022/06/12 17:09:47 6141c6140d922b271613bf84bbb08ef2cc5f850d225df86ff521768c8ea194fb0e73c51b3bce42c8af6de7b59d441cb4ad1a973dd26d90d2f32a2d53d2a90a3281e9d67373954ee3e127593a7c4a340cb064025f6b328b93091a993a1f4e0f2897a5dde896a6ced121e1076f01e416233f457127eec1b4ca2ce0728e9c92090b
