:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: %portal.fml
:: Utworzony: 06.02.2020
:: Autor: RWR
::======================================================================================================================
:: Zawartość: Formuły wspomagające obsługę testów portalu.
::            Formuły pomocnicze do procesów obsługujących komunikację z portalem.
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Główna formuła startowa.
::----------------------------------------------------------------------------------------------------------------------
on_error(0);

_szer:=60;

_TAB:=tab_tmp(1
   ,'LP','INTEGER','Lp.'
   ,'NAME','STRING[%1]' [$_szer],'Nazwa'
   ,'HELP','STRING[60]','Podpowiedź'
   ,'FORMULA','STRING[255]','Formuła do wykonania'
   ,'TMMOD','STRING[19]','Ostatnie uruchomienie'
   ,'RUNTIME','TIME','Czas wykonania'
);
_TAB.fld_fml('RUNTIME','DISPLAY_FORMAT',"'empty=%1'[$(cur_tab(1,1).RUNTIME=time(0,0,0))]");
_add:="
   _a.blank();
   _a.LP:=_a.size()+1;
   {? var_pres('_d')=3
   || _a.FORMULA:=$_d
   ?};
   _a.NAME:=
      {? _a.FORMULA=''
      || '[ %1 ]' [_b]
      || _b
      ?};
   _a.HELP:={? var_pres('_c')=type_of('') || _c || _a.NAME ?};
   _a.add()
";
_lic_seo:=exec('lic','#b_domain','SEO');

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_add(_TAB,'Parametry portalu'@,'Redagowanie parametrów portalu'@);
_add(_TAB,'Dostęp do portalu'@,'Parametry dostępu do portalu'@,"exec('params','portal_engine','access')");
_add(_TAB,'Parametry działania'@,'Parametry działania portalu'@,"exec('params','portal_engine','oper')");
_add(_TAB,'Zakres prezentacji danych'@,'Parametry ustawiające zakres prezentacji danych'@,
   "exec('params','portal_engine','scope')"
);
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_add(_TAB,'Zasilanie (krok po kroku)'@);
_add(_TAB,'Inicjowanie systemu — zadania wspólne'@,'Inicjowanie systemu po zmianie istancji danych'@,
   "exec('clear','portal_engine',0)"
);
_add(_TAB,'Inicjowanie systemu — zadania dla bieżącej firmy'@,'Inicjowanie systemu po zmianie istancji danych'@,
   "exec('clear','portal_engine',1)"
);
_add(_TAB,'Zewnętrzne identyfikatory rekordów'@,'Aktualizacja definicji zewnętrznych identyfikatorów rekordów'@,"
   _ret:=exec('init','sync_id');
   {? _ret.RESULT
   || FUN.info('Operacja zakończona sukcesem.'@)
   || FUN.info('Operacja nie powiodła się [%1].'@ [_ret.ARGS.KOD])
   ?}"
);
_add(_TAB,'Usuwanie zapisów z rejestru zdarzeń'@,'Usuwanie zapisów z rejestru zdarzeń klienta MacroWebAPI'@,
   "exec('mwac_log_clear','zui')"
);
_add(_TAB,'Identyfikator bazy danych'@,'Identyfikator bazy danych'@,"exec('base_id_manage','#system')");
_add(_TAB,'Licencje'@,'Licencje portalowe'@,"exec('portall_select','portal_engine')");
_add(_TAB,'Zasilanie: PORTAL_CFG'@,,"exec('test_start','sync_mwa','PORTAL_CFG')");
_add(_TAB,'Zasilanie: PORTAL_HR_CFG'@,,"exec('test_start','sync_mwa','PORTAL_HR_CFG')");
{? _lic_seo
|| _add(_TAB,'Zasilanie: PORTAL_SEOD_CFG'@,,"exec('test_start','sync_mwa','PORTAL_SEOD_CFG')")
?};
_add(_TAB,'Zasilanie: PORTAL'@,,"exec('test_start','sync_mwa','PORTAL')");
_add(_TAB,'Testuj odbieranie: PORTAL_HR_CFG'@,,"exec('test_receive','sync_mwa','PORTAL_HR_CFG')");
_add(_TAB,'Testuj odbieranie: PORTAL_CFG'@,,"exec('test_receive','sync_mwa','PORTAL_CFG')");
_add(_TAB,'Zasilanie: PORTAL'@,,"exec('test_start','sync_mwa','PORTAL')");
_add(_TAB,'Zarządzanie uprawnieniami'@,'Zarządzania uprawnieniami do elementów portalu'@,
   "exec('portalu_select','portal_engine')"
);
_add(_TAB,'Zasilanie: PORTAL_WNIOSKI'@,,"exec('test_start','sync_mwa','PORTAL_WNIOSKI')");
{? _lic_seo
|| _add(_TAB,'Zasilanie: PORTAL_SEOD'@,,"exec('test_start','sync_mwa','PORTAL_SEOD')")
?};
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_add(_TAB,'Na skróty'@);
_add(_TAB,'CAS'@,'Konfiguracja Centralnego Serwera Autentykacji'@,"exec(,'__sysusr').XPass.setupWebCas()");
_add(_TAB,'Token OAuth'@,'Pobiera token dla aktualnego dzierżawcy'@,
   "exec('czytaj','#stalesys',,XINFO);exec('get_token','sl_api','Portal',exec('token_id','portal_engine'))"
);

_add(_TAB,'Wymiana danych'@,'Wymiana danych z innymi systemami'@,"exec('sync_def_sel','synchro')");
_add(_TAB,'Identyfikatory rekordów'@,'Wertowanie identyfikatorów'@,"exec('def','#sync_id','ZWS')");
_add(_TAB,'Definicje tabel i pól dodatkowych'@,'Definicje tabel i pól dodatkowych na portalu'@,
   "exec('portalk_select','portal_engine')"
);
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_add(_TAB,'Narzędzia'@);
_add(_TAB,'Aktualizuj firmy'@,'Aktualizuje w portalu dane firm dzierżawcy'@,"exec('firmy_act','portal_engine')");
_add(_TAB,'Rekordy do przetworzenia'@,'Wertowanie identyfikatorów rekordów do przetworzenia'@,
   "exec('new_sync','%portal')"
);
_add(_TAB,'Opóźniona aktualizacja'@,'Przeglądanie zapisów oczekujacych na aktualizacje w firmach'@,
   "exec('select','portaloa')"
);
_add(_TAB,'Master serwis'@,'Pobranie zbiorczej informacji o danych do pobrania przez API'@,
   "exec('GetDataAboutEntitiesToSync','%portal')"
);
_add(_TAB,'Rejestr zdarzeń'@,'Przeglądanie rejestru zdarzeń klienta MacroWebAPI'@,"exec('logviewer','#mwac')");
_add(_TAB,'Analiza rejestru zdarzeń'@,'Analiza rejestru zdarzeń klienta MacroWebAPI'@,"exec('rejestr','%portal')");
_add(_TAB,'Wysłanie logów'@,'Wysłanie raportów do chmury',"exec('SENDALLERRORSTOCLOUD','portal_engine')");
_add(_TAB,'put()-y dla tabel'@,'',"exec('tables_idput','sync_mwa')");
_add(_TAB,'Wzorzec funkcji praw'@,'Prezentacja wzorca funkcji praw',"exec('portalu_w','%portal')");
{? exec('interm','#system')<>1
|| _add(_TAB,'Porównanie funkcji praw dla wersji'@,'',"exec('permissions_list','%portal')")
?};
_add(_TAB,'Weryfikacja synchronizacji danych'@,'',"exec('test_sync','%portal')");
_add(_TAB,'Usuwanie danych z encji'@,'',"exec('data_delete','portal_engine')");
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_add(_TAB,'Postman'@);
_add(_TAB,'Kolekcja'@,'Przygotowanie pliku z kolekcją dla Postmana-a'@,"exec('postman_kolekcja','%portal')");
_add(_TAB,'Środowisko'@,'Przygotowanie pliku ze środowiskiem dla Postmana-a'@,"exec('postman_env','%portal')");
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_add(_TAB,'MWAC'@);
_add(_TAB,'Menadżer'@,'Menadżer - klient MacroWebAPI'@,"exec('manager','portal_engine')");
_add(_TAB,'Metody'@,'Prezentacja wszystkich dostępnych metod'@,"exec('methods','%portal')");
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_add(_TAB,'Dokumenty w obiegu'@);
_add(_TAB,'Wnioski, delegacje i faktury - widok techniczny'@,,"exec('select','%portal')");
_add(_TAB,'Usuwanie wniosków'@,'Usuwanie wniosków w obiegu'@,"exec('del_edok_oper','%portal')");
_add(_TAB,'Usuwanie instancji procesów'@,'Usuwanie instancji (w tym archiwalnych)'@,"exec('del_proc_oper','%portal')");
_add(_TAB,'Usuwanie atrybutów'@,'Usuwanie niepowiązanych atrybutów (TAT)'@,"exec('del_tat_not_conected','%portal')");
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_add(_TAB,'Dodatkowa parametryzacja/kastomizacja po zasileniu portalu'@);
_add(_TAB,'Wykonanie dodatkowej parametryzacji/kastomizacji'@,'Dodatkowa parametryzacja/kastomizacja',
   "exec('param_custom','%portal')"
);

_dh:=_TAB.size()+1;
{? _dh<5
|| _dh:=5
|? _dh>30
|| _dh:=30
?};
_ws:=_TAB.mk_sel(,'N',,'#hrportalfpom',,,_dh,,'U');
_TAB.win_fld(_ws,,'NAME');
_TAB.win_fld(_ws,,'TMMOD',,,-20);
_TAB.win_fld(_ws,,'RUNTIME',,,8);
_TAB.win_act(_ws,,'Formuła','Uruchom'@,,
   ," _TAB:=cur_tab(1,1);
      _TAB.TMMOD:=tm_form(tm_stamp);
      _ts:=time();
      ($_TAB.FORMULA)();
      _TAB.RUNTIME:=time()-_ts;
      _TAB.put()
   "
   ,,1,,,,'U'
);
_TAB.win_act(_ws,,'Formuła','Informacja'@,,,"FUN.info(cur_tab(1,1).HELP)",,,,,,'I');
_TAB.win_act(_ws,,'Formuła','Zeruj'@,,
   ," _TAB:=cur_tab(1,1);
      _t0:=time(0,0,0);
      {? _TAB.TMMOD<>'' | _TAB.RUNTIME<>_t0
      || _TAB.TMMOD:='';
         _TAB.RUNTIME:=_t0;
         _TAB.put()
      ?}
   "
   ,,,1,,,'Z'
);
_TAB.win_act(_ws,,'Rekord',,,,"
   _par:=params_get();
   _TAB:=_par.TAB;
   echo(_TAB.HELP);
   {? _TAB.FORMULA=''
   || _ag:='UI';
      _color:=1
   || _ag:='';
      _color:=0
   ?};
   {? _a
   || _TAB.actions_grayed(_par.ws,_ag)
   ?};
   _color
   ");

_grp:=_TAB.grp_make('Portal HR i SEOD — funkcje pomocnicze'@,,'#grp',,
   ,$("FUN.ask('"+
      'Czy na pewno chcesz opuścić menu funkcji pomocniczych?'@+'\n'+
      '(znaczniki i czasy uruchomienia funkcji zostaną wyzerowane)'@+
      "')"),
   ,'normal'
);
_TAB.grp_sel(_grp,,_ws,,,,,,,,,,'maximized');
_TAB.win_sel(_grp);
params_set(
   'TAB',_TAB,
   'ws',_ws,
   'szer',_szer
);
_TAB.select();

~~


\_json
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Funkcja tworzy tablicę elementów nazwanych służących do tworzenia struktur / plików w formacie JSON.
::   WE: [_a] [STRING] - Tytuł okna wertowania.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_title:={? var_pres('_a')=type_of('') || _a || 'JSON' ?};

_TAB:=json_tparse('{}');
_NDX:=obj_new('INDEX');
_NDX.INDEX:=_TAB.index('?');

_ws:=_TAB.mk_sel(_title,'N',,,,,,1,);
_TAB.win_fld(_ws,,'NAME',,,40);
_TAB.win_fld(_ws,,'INDEX',,,-4);
_TAB.win_fld(_ws,,'NTRUNC',,,-3,,,,,,2,,"'T'","'N'");
_TAB.win_fld(_ws,,'TYPE',,,-3);
_TAB.win_fld(_ws,,'VAL',,,80);
_TAB.win_fld(_ws,,'VTRUNC',,,-3,,,,,,2,,"'T'","'N'");
_TAB.win_fld(_ws,,'BVAL',,,20);
_TAB.win_act(_ws,,'Formuła','Plik'@@,,,"
    _TAB:=cur_tab(1,1);
    {? _TAB.BVAL<>null() || exec('bl_view','#blob',_TAB,'BVAL') ?}",,,,,,'P');
_TAB.win_act(_ws,,'Formuła','Dalej'@@,,,"sel_exit()",,1,,,,'D');
_TAB.win_btn(_ws,'text=%1,icon=xwin16.png:23,panel=bottom,align=end' ['Dalej'@],'menu:D');
_TAB.win_act(_ws,,'Szukaj');
_TAB.win_act(_ws,,'Kolejność');
_TAB.win_act(_ws,,'Rekord',,,,"
   {? _a
   || _TAB:=cur_tab(1,1);
      _ws:=cur_win(1,1);
      _ha:={? _TAB.BVAL=null() || 'P' || '' ?};
      _TAB.actions_grayed(_ws,_ha)
   ?}"
);
_TAB.win_sel(_ws);

_JSON:=obj_new('TAB','NDX','ws','add');
_JSON.TAB:=_TAB;
_JSON.NDX:=_NDX;
_JSON.ws:=_ws;
_JSON.add:="
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Metoda dodaje rekord do tabeli .TAB (jako ostatnie dziecko wskazanego rodzica).
::   WE:  _a  [NUMBER] - Numer rekordu rodzica.
::        _b  [STRING] - Nazwa elementu.
::        _c  [STRING] - Typ elementu:
::                      O - obiekt,
::                      A - tablica,
::                      L - wartość logiczna (true lub false),
::                      N - liczba,
::                      S - napis,
::                      V - wartość null.
::       [_d] [STRING] - Wartość elementu [domyślnie: ''].
::   WY: Numer dodanego rekordu.
::----------------------------------------------------------------------------------------------------------------------
   _parent:={? var_pres('_a')=type_of(0) || _a |? var_pres('_a')=type_of(null()) || #_a || 0 ?};
   _name:={? var_pres('_b')=type_of('') || _b || '' ?};
   _type:=_c;
   _val:={? var_pres('_d')=type_of('') || _d || '' ?};

   _ret:=0;
:: Najpierw ustalmy INDEX.
   .TAB.cntx_psh();
   .TAB.index(.NDX.INDEX);
   .TAB.prefix(_parent);
   _index:={? .TAB.last() || .TAB.INDEX ?}+1;

   .TAB.blank();
   .TAB.TREE:=_parent;
   .TAB.NAME:=_name;
   .TAB.NTRUNC:={? .TAB.NAME=_name || 'N' || 'T' ?};
   .TAB.TYPE:=_type;
   .TAB.VAL:=_val;
   .TAB.VTRUNC:={? .TAB.VAL=_val || 'N' || 'T' ?};
   .TAB.INDEX:=_index;
   {? .TAB.add()
   || _ret:=#.TAB.ref();
      {? .TAB.VTRUNC='T'
      || _fh:=fopen(null(),'Uw!',,,1);
         {? _fh.is_open()
         || _fh.fwrite(_val);
            .TAB.bl_put('BVAL',_fh,,,'value.txt');
            _fh.fclose()
         ?}
      ?}
   ?};
   .TAB.cntx_pop();
   _ret
";

_JSON


\postman_kolekcja
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Funkcja tworząca plik (w wersji 2.1.0) z kolekcją dla Postman-a.
::       Zakłada się, że w Postman-ie są zdefiniowane zmienne środowiskowe:
::          * TenantIdentifier
::          * User
::          * Password
::          * SERVER
::          * DBC
::   WE:
::   WY: Plik z kolekcją został utworzony i zapisany na dysku lokalnym [0/1].
:: ~OST: INFOPEN
::----------------------------------------------------------------------------------------------------------------------
{? ~FUN.ask('Formuła przygotowuje plik kolekcji dla Postman-a.\nCzy na pewno chcesz kontynuować?'@)
|| return(0)
?};

_client:=exec('client','__mwac','portal.mwac');
{? ~_client.Valid
|| FUN.info('Inicjalizacja modułu obsługi klienta MacroWebApi nie powiodła się.'@);
   return(0)
?};

_JSON:=exec('_json','%portal','Struktura kolekcji dla Postman-a'@);
{? exec('_postman_kolekcja_info','%portal',_client,_JSON) &
   exec('_postman_kolekcja_item','%portal',_client,_JSON) &
   exec('_postman_kolekcja_auth','%portal',_client,_JSON) &
   exec('_postman_kolekcja_event','%portal',_client,_JSON) &
   exec('_postman_kolekcja_protocol','%portal',_client,_JSON)
|| _save:=1;
::   {!
::   |? _save:=0;
::      {? _JSON.TAB.select()
::      || _save:=1;
::         0
::      || ~FUN.ask('Czy na pewno rezygnujesz z utworzenia pliku kolekcji dla Postman-a?'@)
::      ?}
::   !};
   {? _save
   || _path:=exec('save_as','#file','postman.json',
         'develop.upf','HR PORTAL','postman.json.dir','postman.json.file'
      );
      {? _path<>''
      || _fh:=fopen('@'+_path,'Uw',0,1,1);
         _JSON.TAB.index(_JSON.NDX.INDEX);
         _JSON.TAB.prefix();
         {? _fh.is_open() & _JSON.TAB.first()
         || _JSON.TAB.json_twrite(_fh);
            _fh.fclose();
            1
         ?}
      ?}
   ?}
?}


\_postman_kolekcja_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Funkcja dodaje sekcję 'info' do struktury pliku kolekcji dla Postman'a.
::   WE: _a [OBJ]   - Obiekt klienta (MWAC_CLIENT).
::       _b [ARRAY] - Tablica elementów nazwanych (patrz \_json).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_client:=_a;
_JSON:=_b;

_blank:='HR Portal (%1 %2)' [date()$1,time()$3];
_name:=exec('edit_string','#edit',_blank,'Nazwa kolekcji'@,
   $("__CHK.record2(cur_tab(1,1),'VAL','"+'Nazwa kolekcji'@+"')")
);
{? _name=~~
|| return(0)
?};

_ret:=0;
_JSON.TAB.cntx_psh();
_JSON.TAB.index(_JSON.NDX.INDEX);
_JSON.TAB.prefix();
{? _JSON.TAB.first()
|| _gen:="~exec('gen_id','#id',_a)";
   _ref:=_JSON.TAB.ref();
   _info:=_JSON.add(_ref,'info','O');
      _JSON.add(_info,'_postman_id','S','%1-%2-%3-%4-%5' [_gen(8),_gen(4),_gen(4),_gen(4),_gen(8)]);
      _JSON.add(_info,'name','S',_name);
      _JSON.add(_info,'schema','S','https://schema.getpostman.com/json/collection/v2.1.0/collection.json');
   _ret:=1
?};
_JSON.TAB.cntx_pop();
_ret


\_postman_kolekcja_item
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Funkcja dodaje sekcję 'item' do struktury pliku kolekcji dla Postman'a.
::   WE: _a [OBJ]   - Obiekt klienta (MWAC_CLIENT).
::       _b [ARRAY] - Tablica elementów nazwanych (patrz \_json).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_client:=_a;
_JSON:=_b;

:: Tabela tymczasowa do obsługi katalogów grupujących metody obsługujące tę samą tabelę. W tabeli zapamiętywane są:
::    - nazwa katalogu;
::    - numer rekordu w tworzonej tabeli, zawierający element "item" w katalogu;
::    - liczba metod w elemencie "item".
_DIR:=tab_tmp(1,
   'NAME','STRING[255]','Nazwa',
   'ITEM1','INTEGER','Rekord "item1"',
   'LP','INTEGER','Liczba pozycji'
);

:: Automatyzacja metod typu "Get".
_gpatt:=obj_new(3);
_grepl:=obj_new(3);

_gpatt[1]:='"__OrderCount":<int|null>';
_gpatt[2]:='"__id_cloud":<long|null>';
_gpatt[3]:='"__ModifiedDate_cloud":<dateTime|null>';

_grepl[1]:='"__OrderCount": null';
_grepl[2]:='"__id_cloud": null';
_grepl[3]:='"__ModifiedDate_cloud": "1970-01-01T00:00:00"';

:: Zamiana "nieoczekiwanych" znaczników "<>" na napisy.
_ppatt:=spli_str('<,>',',');
_prepl:=spli_str('"<,>"',',');

_ret:=0;
_JSON.TAB.cntx_psh();
_JSON.TAB.index(_JSON.NDX.INDEX);
_JSON.TAB.prefix();
{? _JSON.TAB.first()
|| _ref:=_JSON.TAB.ref();
   _item0:=_JSON.add(_ref,'item','A');

   _ok:=1;

:: _TOOLS
::    -1 - HELP
::     0 - WADL
   {! _im:=-1 .. obj_len(_client.Methods)

   |? _ok
   |! {? _im=-1
      || _name:='HELP';
         _meth_name:='';
         _ometh:=obj_new(1);
         _base:='_TOOLS';
         _dir_descr:='Katalog narzędzi';
         _restmeth:='GET'
      |? _im=0
      || _name:='WADL';
         _meth_name:='';
         _ometh:=obj_new(1);
         _base:='_TOOLS';
         _dir_descr:='Katalog narzędzi';
         _restmeth:='GET'

      |? _im>0
      || _name:=_client.Methods[_im].NAME;
         _meth_name:=_name;
         _ometh:=_client.getMethod(_meth_name);
         {? ~(_ok:=_ometh.Valid)
         || FUN.info(
               'Powołanie obiektu klasy MWAC_METHOD dla metody %1 nie powiodło się. Definicja nie jest kompletna!'@
               [_meth_name]
            )
         ?};

         _base:=_meth_name-
            {? _meth_name+6='Modify' || 6
            |? _meth_name+3='Get' || 3
            |? _meth_name+6='Delete' || 6
            ?};
         _dir_descr:='Metody obsługi tabeli %1' [_base];

         _restmeth:=_client.Methods[_im].RESTMETH

      ?};

::    Przygotowanie / znalezienie katalogu grupującego metody obsługujące tę samą tabelę.
      {? _DIR.find_key(_base,)
      || _item1:=_DIR.ITEM1;
         _DIR.LP+=1;
         _DIR.put()
      || _dir:=_JSON.add(_item0,'[%1]' [$(_DIR.size()+1)],'O');
         _JSON.add(_dir,'name','S',_base);
         _item1:=_JSON.add(_dir,'item','A');
         _JSON.add(_dir,'description','S',_dir_descr);
         _JSON.add(_dir,'protocolProfileBehavior','O');
         _DIR.NAME:=_base;
         _DIR.ITEM1:=_item1;
         _DIR.LP:=1;
         _DIR.add()
      ?};

::    Przygotowanie treści żądania.
      {? _im=-1
      || _jq:='&help';
         _key:='help';
         _value:=~~
      |? _im=0
      || _jq:='&wadl';
         _key:='wadl';
         _value:=~~
      |? _im>0
      || _jq:=_ometh.getRequestTemplate();
         {? _restmeth='GET'
         || _jq:=gsub(_jq,_gpatt,_grepl);
            _key:='json';
            _value:=_jq
         ?}
      ?};
      {? _restmeth='GET'
      || _raw:={? type_of(_value)=type_of('') & _value<>'' || '&%1=%2' [_key,_value] || '&%1' [_key] ?}
      ?};

::    Tworzenie elementu - metody.
      _el:=_JSON.add(_item1,'[%1]' [$_DIR.LP],'O');
         _JSON.add(_el,'name','S',_name);
         _req:=_JSON.add(_el,'request','O');
            _JSON.add(_req,'method','S',_restmeth);

            _header:=_JSON.add(_req,'header','A');
               _ht:=_JSON.add(_header,'[1]','O');
                  _JSON.add(_ht,'key','S','TenantIdentifier');
                  _JSON.add(_ht,'value','S','{{TenantIdentifier}}');
                  _JSON.add(_ht,'type','S','text');
               _hb:=_JSON.add(_header,'[2]','O');
                  _JSON.add(_hb,'key','S','X-SL-ID');
                  _JSON.add(_hb,'value','S','{{BASE_ID}}');
                  _JSON.add(_hb,'type','S','text');
               _he:=_JSON.add(_header,'[3]','O');
                  _JSON.add(_he,'key','S','Encoding');
                  _JSON.add(_he,'value','S','UTF-8');
                  _JSON.add(_he,'type','S','text');

               {? _restmeth='POST'
               || _body:=_JSON.add(_req,'body','O');
                     _JSON.add(_body,'mode','S','raw');
                     _JSON.add(_body,'raw','S',gsub(_jq,_ppatt,_prepl));
                     _opt:=_JSON.add(_body,'options','O');
                        _raw:=_JSON.add(_opt,'raw','O');
                           _JSON.add(_raw,'language','S','json')
               ?};

            _url:=_JSON.add(_req,'url','O');
               _JSON.add(_url,'raw','S',
                  '{{Server}}/%1?DBC={{DBC}}' [_meth_name]+
                  {? _restmeth='GET'
                  || _raw
                  || ''
                  ?}
               );
               _host:=_JSON.add(_url,'host','A');
                  _JSON.add(_host,'[1]','S','{{Server}}');
               _path:=_JSON.add(_url,'path','A');
                  _JSON.add(_path,'[1]','S',_meth_name);
               _query:=_JSON.add(_url,'query','A');
                  _q1:=_JSON.add(_query,'[1]','O');
                     _JSON.add(_q1,'key','S','dbc');
                     _JSON.add(_q1,'value','S','{{DBC}}');
                  {? _restmeth='GET'
                  || _q2:=_JSON.add(_query,'[2]','O');
                        _JSON.add(_q2,'key','S',_key);
                        {? type_of(_value)=type_of('')
                        || _JSON.add(_q2,'value','S',_value)
                        ?}
                  ?};

::         _JSON.add(_el,'response','A');

         obj_del(_ometh)

   !};
   _ret:=1
?};
_JSON.TAB.cntx_pop();
_ret


\_postman_kolekcja_auth
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Funkcja dodaje sekcję 'auth' do struktury pliku kolekcji dla Postman'a.
::   WE: _a [OBJ]   - Obiekt klienta (MWAC_CLIENT).
::       _b [ARRAY] - Tablica elementów nazwanych (patrz \_json).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_client:=_a;
_JSON:=_b;

_ret:=0;
_JSON.TAB.cntx_psh();
_JSON.TAB.index(_JSON.NDX.INDEX);
_JSON.TAB.prefix();
{? _JSON.TAB.first()
|| _gen:="~exec('gen_id','#id',_a)";
   _ref:=_JSON.TAB.ref();
   _auth:=_JSON.add(_ref,'auth','O');
      _JSON.add(_auth,'type','S','oauth2');
      _oauth2:=_JSON.add(_auth,'oauth2','A');
         _parent:=_JSON.add(_oauth2,'[1]','O');
            _JSON.add(_parent,'key','S','accessToken');
            _JSON.add(_parent,'value','S','{{TokenValue}}');
            _JSON.add(_parent,'type','S','string');
         _parent:=_JSON.add(_oauth2,'[2]','O');
            _JSON.add(_parent,'key','S','tokenType');
            _JSON.add(_parent,'value','S','bearer');
            _JSON.add(_parent,'type','S','string');
         _parent:=_JSON.add(_oauth2,'[2]','O');
            _JSON.add(_parent,'key','S','addTokenTo');
            _JSON.add(_parent,'value','S','header');
            _JSON.add(_parent,'type','S','string');
   _ret:=1
?};
_JSON.TAB.cntx_pop();
_ret


\_postman_kolekcja_prerequest
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła zwraca treść skryptu.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
$"// Usunięcie ciasteczek
const jar = pm.cookies.jar();
var server = pm.environment.get('Server');
jar.clear(server, function (error) {
   if(error)
      throw new Error(error.message);
});

// Znacznik czasowy tokena i czas życia
var tokenDate = new Date(2010, 1, 1);
var tokenTimeStamp = pm.environment.get('TokenTimeStamp');
if (tokenTimeStamp) {
   tokenDate = Date.parse(tokenTimeStamp)
}
var expiresInTime = pm.environment.get('TokenExpiresInTime');
if (!expiresInTime) {
   expiresInTime = 300000; // Set default expiration time to 5 minutes
}

if ((new Date() - tokenDate) >= expiresInTime) {
   // Użytkownik i hasło
   var user = pm.environment.get('User');
   var password = pm.environment.get('Password');
   var basic = btoa(user + ':' + password);
   var accessTokenURL = pm.variables.get('AccessTokenURL');

   pm.sendRequest({
      url: accessTokenURL,
      method: 'POST',
      header: {
         'Content-Type': 'application/x-www-form-urlencoded',
         'Authorization': 'Basic ' + basic,
         'Accept-Encoding': 'gzip, deflate, br'
      },
      body: 'grant_type=client_credentials&scope=USERAPI'
   }, function (err, res) {
      pm.environment.set('TokenValue', res.json().access_token);
      pm.environment.set('TokenTimeStamp', new Date());

      // Set the ExpiresInTime variable to the time given in the response if it exists
      if (res.json().expires_in) {
         expiresInTime = res.json().expires_in * 1000;
         pm.environment.set('ExpiresInTime', expiresInTime);
      }
   });
}"


\_postman_kolekcja_event
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Funkcja dodaje sekcję 'event' do struktury pliku kolekcji dla Postman'a.
::   WE: _a [OBJ]   - Obiekt klienta (MWAC_CLIENT).
::       _b [ARRAY] - Tablica elementów nazwanych (patrz \_json).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_client:=_a;
_JSON:=_b;

_ret:=0;
_JSON.TAB.cntx_psh();
_JSON.TAB.index(_JSON.NDX.INDEX);
_JSON.TAB.prefix();
{? _JSON.TAB.first()
|| _gen:="~exec('gen_id','#id',_a)";
   _ref:=_JSON.TAB.ref();
      _parent:=_JSON.add(_ref,'event','A');
         _e1:=_JSON.add(_parent,'[1]','O');
            _JSON.add(_e1,'listen','S','prerequest');
            _script:=_JSON.add(_e1,'script','O');
               _JSON.add(_script,'id','S','%1-%2-%3-%4-%5' [_gen(8),_gen(4),_gen(4),_gen(4),_gen(12)]);
               _JSON.add(_script,'type','S','text/javascript');
               _exec:=_JSON.add(_script,'exec','A');
                  _body:=spli_str(exec('_postman_kolekcja_prerequest','%portal'),'\r\n');
                  {! _lp:=1 .. obj_len(_body)
                  |! _JSON.add(_exec,'[%1]' [$_lp],'S',_body[_lp])
                  !};
   _ret:=1
?};
_JSON.TAB.cntx_pop();
_ret


\_postman_kolekcja_protocol
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Funkcja dodaje sekcję 'protocolProfileBehavior' do struktury pliku kolekcji dla Postman'a.
::   WE: _a [OBJ]   - Obiekt klienta (MWAC_CLIENT).
::       _b [ARRAY] - Tablica elementów nazwanych (patrz \_json).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_client:=_a;
_JSON:=_b;

_ret:=0;
_JSON.TAB.cntx_psh();
_JSON.TAB.index(_JSON.NDX.INDEX);
_JSON.TAB.prefix();
{? _JSON.TAB.first()
|| _ref:=_JSON.TAB.ref();
      _JSON.add(_ref,'protocolProfileBehavior','O');
   _ret:=1
?};
_JSON.TAB.cntx_pop();
_ret


\postman_env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Formuła na podstawie pliku konfiguracyjnego dzierżawcy tworzy plik ze środowiskiem dla Postmana'a.
::   WE:
::   WY:
:: ~OST: INFILECHOOSER, INFOPEN
::----------------------------------------------------------------------------------------------------------------------
_choice:=FUN.choice(
   'Plik z definicją środowiska dla Postman-a może być utworzony na podstawie\n'
   'pliku konfiguracyjnego pobranego z manegement-u lub\n'
   'parametrów dostępu do portalu zapisanych w systemie.\n'
   'Twój wybór:'@
   ,,'Plik &konfiguracyjny'@,'Parametry dostępu'@
);
{? _choice=0
|| return()
?};

_profile:='develop.upf';
_section:='HR PORTAL';

{? _choice=1
|| _envdir:='dir.env';
   _dir:=exec('get','#profile',_profile,_section,_envdir);

   _envfile:=exec('filechooser','#file',,0,'xml','Pliki XML',0,,,_dir);
   {? _envfile=''
   || return()
   ?};
   _ap:=spli_str(_envfile,exec('sep','#file'));
   _dir:=_envfile-(+_ap[obj_len(_ap)]+1);

   exec('set','#profile',_profile,_section,_envdir,_dir);

   _fh:=fopen('@'+_envfile,'ur',0,1,1,1);
   {? ~_fh.is_open()
   || return()
   ?};
   _XML:=xml_tparse(_fh);
   _fh.fclose();
   obj_del(_fh);

   _env:=json_parse(_XML.xml_tconvert())

|| exec('czytaj','#stalesys',,XINFO);
   _get:={? XINFO.POR_CONF='J' || "_a" || "_b" ?};

   _env:=exec('obj_ntab_set','#array',
      ,'Tenant', exec('obj_ntab_set','#array',
         ,'Name',_get(XINFO.POR_NAME,XINFO.POR0NAME)
         ,'APIUsers',exec('obj_ntab_set','#array',
            ,'APIUser',exec('obj_ntab_set','#array',
               ,'Login',_get(XINFO.POR_USR,XINFO.POR0USR)
               ,'Password',_get(XINFO.POR_PASS,XINFO.POR0PASS)
            )
         )
         ,'Identifier',_get(XINFO.POR_TNNT,XINFO.POR0TNNT)
      )
      ,'Urls', exec('obj_ntab_set','#array',
         ,'API_OAUTH_Url',_get(XINFO.POR_OURL,XINFO.POR0OURL)
         ,'API_REST_Url',_get(XINFO.POR_RURL,XINFO.POR0RURL)
      )
   )
?};

_name:=gsub(_env.Tenant.Name,' ','_');

_blank:='%1 (%2 %3)' [_name,date()$1,time()$3];
_envname:=exec('edit_string','#edit',_blank,'Nazwa środowiska'@,
   $("__CHK.record2(cur_tab(1,1),'VAL','"+'Nazwa środowiska'@+"')")
);

{? _envname=~~
|| return(0)
?};

_JSON:=exec('_json','%portal','Struktura środowiska dla Postman-a'@);

{? ~_JSON.TAB.first()
|| return()
?};

_root:=_JSON.TAB.ref();
_gen:="~exec('gen_id','#id',_a)";
_JSON.add(_root,'id','S','%1-%2-%3-%4-%5' [_gen(8),_gen(4),_gen(4),_gen(4),_gen(12)]);
_JSON.add(_root,'name','S',_envname);
_values:=_JSON.add(_root,'values','A');
   _parent:=_JSON.add(_values,'[1]','O');
      _JSON.add(_parent,'key','S','AccessTokenURL');
      _JSON.add(_parent,'value','S',_env.Urls.API_OAUTH_Url);
      _JSON.add(_parent,'enabled','L','true');

   {? type_of(_env.Tenant.APIUsers.APIUser[1])<100
::    Jeden użytkownik w pliku.
   || _user:=_env.Tenant.APIUsers.APIUser
   || _user:=_env.Tenant.APIUsers.APIUser[1]
   ?};
   _parent:=_JSON.add(_values,'[2]','O');
      _JSON.add(_parent,'key','S','User');
      _JSON.add(_parent,'value','S',_user.Login);
      _JSON.add(_parent,'enabled','L','true');
   _parent:=_JSON.add(_values,'[3]','O');
      _JSON.add(_parent,'key','S','Password');
      _JSON.add(_parent,'value','S',_user.Password);
      _JSON.add(_parent,'enabled','L','true');

   _parent:=_JSON.add(_values,'[4]','O');
      _JSON.add(_parent,'key','S','TenantIdentifier');
      _JSON.add(_parent,'value','S',_env.Tenant.Identifier);
      _JSON.add(_parent,'enabled','L','true');

   _parent:=_JSON.add(_values,'[5]','O');
      _JSON.add(_parent,'key','S','Server');
      _JSON.add(_parent,'value','S',(_env.Urls.API_REST_Url*'?'-1)+_env.Urls.API_REST_Url);
      _JSON.add(_parent,'enabled','L','true');

   _params:=spli_str((_env.Urls.API_REST_Url*'?')-_env.Urls.API_REST_Url,'&');
   {! _lp:=1 .. obj_len(_params)
   |? {? 4+_params[_lp]='DBC='
      || _parent:=_JSON.add(_values,'[6]','O');
            _JSON.add(_parent,'key','S','DBC');
            _JSON.add(_parent,'value','S',4-_params[_lp]);
            _JSON.add(_parent,'enabled','L','true');
         0
      || 1
      ?}
   !};

   _base_id:=XINFO.BASE_ID;
   exec('czytaj','#stalesys',,XINFO,'BASE_ID');
   _base_id==XINFO.BASE_ID;
   _parent:=_JSON.add(_values,'[7]','O');
      _JSON.add(_parent,'key','S','BASE_ID');
      _JSON.add(_parent,'value','S',_base_id);
      _JSON.add(_parent,'enabled','L','true');

_JSON.add(_root,'_postman_variable_scope','S','environment');
_JSON.add(_root,'_postman_exported_at','S',iso_datetime_value());
_JSON.add(_root,'_postman_exported_using','S','Postman 7.19.1');

_save:=1;
::{!
::|? _save:=0;
::   {? _JSON.TAB.select()
::   || _save:=1;
::      0
::   || ~FUN.ask('Czy na pewno rezygnujesz z utworzenia pliku środowiska dla Postman-a?'@)
::   ?}
::!};
{? _save
|| _path:=exec('save_as','#file',_name+'.postman_environment.json',
      _profile,_section,'postman.env.json.dir','postman.env.json.file'
   );
   {? _path<>''
   || _fh:=fopen('@'+_path,'uw',0,1,1);
      _JSON.TAB.index(_JSON.NDX.INDEX);
      _JSON.TAB.prefix();
      {? _fh.is_open() & _JSON.TAB.first()
      || _JSON.TAB.json_twrite(_fh);
         _fh.fclose();
         1
      ?}
   ?}
?};

~~


\methods
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Formuła prezentuje listę wszystkich dostępnych metod.
::   WE:
::   WY:
:: ~OST: INFEXISTS, INTMPDIR, INWEBBROWSER, INCLIEXEC
::----------------------------------------------------------------------------------------------------------------------
_html:=tmp_dir()+exec('sep','#file',0)+'PortalCloud_HELP.html';
{? fexists('@'+_html)
|| _help:=''
|| _help:=exec('get_help','%portal','@'+_html,2);
   {? _help<>''
   || FUN.emsg('Dostęp do pomocy nie będzie możliwy.'@+'\n'+_help)
   ?}
?};

_client:=exec('client','__mwac','portal.mwac');
{? ~_client.Valid
|| FUN.info('Inicjalizacja modułu obsługi klienta MacroWebApi nie powiodła się.'@);
   return(0)
?};
exec('portaljson_decl','portal_engine');

_TAB:=tab_tmp(1,
   'METHOD','STRING[50]','Metoda'@,
   'BASE','STRING[50]','Obsługiwana tabela'@,
   'RESTMETH','STRING[10]','Metoda'@,
   'FJ','INTEGER','Szablon uzupełniony?'@,
   'JSON','SYS_MEMO','Szablon żądania'@,
   'FF','INTEGER','Szablon uzupełniony?'@,
   'FML','SYS_MEMO','Szablon kodu'@,
   'COLOR','STRING[11]','Kolor'@
);
{! _it:=1 .. obj_len(_client.Methods)
|! _TAB.blank();
   _TAB.METHOD:=_client.Methods[_it].NAME;
   _TAB.RESTMETH:=_client.Methods[_it].RESTMETH;
   _TAB.BASE:=
      {? _TAB.METHOD+6='Modify'
      || _TAB.METHOD-6
      |? _TAB.METHOD+3='Get'
      || _TAB.METHOD-3
      |? _TAB.METHOD+6='Delete'
      || _TAB.METHOD-6
      || _TAB.METHOD
      ?};
   {? +_TAB.BASE+12>31
   || _TAB.COLOR:='255:0:0'
   ?};
   {? _client.Methods[_it].NAME+6<>'Modify'
   || _TAB.FF:=-1
   ?};
   _TAB.add()
!};

_fj:="
   _TAB:=cur_tab(1,1);
   _par:=params_get();
   _eol:=_par.eol;
   {? _TAB.FJ
   || _TAB.memo_get(,'JSON')
   || _ometh:=_par.client.getMethod(_TAB.METHOD);
      {? _ometh.Valid
      || _templ:=gsub(_ometh.getRequestTemplate(),spli_str('{;,',';'),spli_str('{%1;,%1' [_eol],';'));
         _TAB.memo_set(_templ,'JSON');
         _TAB.FJ:=1;
         _TAB.put();
         _TAB.memo_put(,'JSON')
      ?}
   ?};
";

_ws:=_TAB.mk_sel('Metody'@,,,'methods',,,,,'U');
_TAB.win_fld(_ws,,'METHOD',,,,,,'Nazwa'@,,'Nazwa metody'@);
_TAB.win_act(_ws,,'Formuła','JSON'@@,,'Prezentacja szablonu żądania'@,$(_fj+"_TAB.memo_view(,'JSON')"),,,,,,'J');
_TAB.win_act(_ws,,'Formuła','FML'@@,,'Prezentacja szablonu kodu'@,$(_fj+"
   {? _TAB.FF
   || _TAB.memo_get(,'FML')
   || _obj:=_par.obj;
      _obj.init(_TAB.memo_txt(0,1,'JSON'));
      _FLDS:=_obj.getFlds('LP');
      {? _FLDS.first()
      || _fml:='_obj.create();'+(2*_eol);
         {!
         |? {? 7+_FLDS.NAME<>'__exf__'
            || {? ',__ModifiedDate_cloud,PersonId,'*(',%1' [_FLDS.NAME])
               || _fml+='::'
               ?};
               _val:=
                  {? _FLDS.NAME='__id_cloud'
                  || '{? _id || _id || ~~ ?}'
                  |? _FLDS.NAME='__id_erp'
                  || 'QQQ.uidref()'
                  |? _FLDS.NAME='__ModifiedDate_erp'
                  || 'QQQ.idput_value()'
                  |? _FLDS.NAME='PersonId__id_Erp'
                  || 'P.uidref()'
                  || ''
                  ?};
               _fml+='_obj.set(\\'%1\\',%2);%3' [_FLDS.NAME,_val,_eol]
            ?};
            _FLDS.next()
         !};
         _fml+='%1_obj.save();' [_eol];
         _TAB.memo_set(_fml,'FML');
         _TAB.FF:=1;
         _TAB.put();
         _TAB.memo_put(,'FML')
      ?}
   ?};
   _TAB.memo_view(,'FML')
   "),,,,,,
   'F'
);
_TAB.win_act(_ws,,'Formuła','Pomoc'@@,,'Strona z opisem metody'@,"
   _html:=params_get().html;
   {? _html=''
   || return()
   ?};
   _TAB:=cur_tab(1,1);

   params_set(
      'html',_html,
      'tag',_TAB.METHOD+_TAB.RESTMETH
   );

   _wc:=SYSLOG.mk_ctr('Dokumentacja do WebSerwisu'@,'ctrl_webbrowser',,,,,'maximized');
   SYSLOG.win_ctr(_wc);
   SYSLOG.win_cctr(_wc, 'ctr_id','@webbrowser');
   SYSLOG.control(,,""
      _par:=params_get();
      ctr_set(,'ctr_id','setButtonBarVisible','false');
      ctr_set(,'ctr_id','setLocationBarVisible','false');
      ctr_set(,'ctr_id','setStatusBarVisible','false');
      ctr_set(,'ctr_id','closeAfterEscape','true');
      ctr_set(,'ctr_id','navigate','file:///%1#%2' [_par.html,_par.tag])
   "")

::   _lnk:='file:///%1#%2%3'[_html,_TAB.METHOD,_TAB.RESTMETH];
::   cli_exec(_lnk,'open',1)
");
_TAB.win_act(_ws,,'Szukaj');
_TAB.win_act(_ws,,'Kolejność');
_TAB.win_act(_ws,,'Rekord',,,,"
   _TAB:=cur_tab(1,1);
   _html:=params_get().html;
   {? _a
   || _ws:=cur_win(1,1);
      _pomoc:={? _html='' || 'P' || '' ?};
      _TAB.actions_grayed(_ws,_pomoc+{? _TAB.FF=-1 || 'F:' || ':' ?});
      _TAB.actions(_ws,,{? _TAB.FF=-1 || 'J' || 'F' ?},1)
   ?};
   _TAB.COLOR
");
_TAB.win_btn(_ws,'text=%1' ['JSON'@],'menu:J');
_TAB.win_btn(_ws,'text=%1' ['FML'@],'menu:F');
_TAB.win_btn(_ws,'text=%1' ['Pomoc'@],'menu:P');
_TAB.win_sel(_ws);

params_set(
   'client',_client,
   'obj',obj_new(@.CLASS.PortalJSON),
   'html',{? _help='' || gsub(_html,'\\','/') || '' ?},
   'eol',%10
);
_TAB.select()


\new_sync_show
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Wyświetla rekordy do przetworzenia (zależnie od kontekstu wywołania)
::   WE: _a - przeznaczenie danych
::       [_b] - akronim tabeli (jeżeli nie podano, to wszystkie z przeznaczenia danych)
::----------------------------------------------------------------------------------------------------------------------
_pd:=_a;
_acr_tab:={? var_pres('_b')=type_of('') || _b || '' ?};

progress(,'Proszę czekać ...'@,'Przygotowywanie danych'@,1);
_ile:=exec('edit_number','#edit',1000,'Liczba pobieranych rekordów'@,0,0);
{? type_of(_ile)=0 || _ile:=1000 ?};
_TAB:=proc_exec('new_sync@synchro',_pd,0,_acr_tab,_ile);
prgs_clr();
_TAB.index(_TAB.ndx_tmp(,,'R_IDPUT',,));
_dh:=_TAB.size()+1;
{? _dh<5
|| _dh:=5
|? _dh>30
|| _dh:=30
?};
_ws:=_TAB.mk_sel('Rekordy do zmiany'@,,,'#idsync',,,_dh,,'U');
_TAB.win_fld(_ws,,'LP');
_TAB.win_fld(_ws,,'FIRMA');
_TAB.win_fld(_ws,,'ACR');
_TAB.win_fld(_ws,,'REF');
_TAB.win_fld(_ws,,'RODZ');
_TAB.win_fld(_ws,,'IDSYNC');
_TAB.win_act(_ws,,'Szukaj');
_TAB.win_act(_ws,,'Kolejność');
_TAB.win_sel(_ws);
_TAB.select();
_TAB.ndx_drop();
~~


\new_sync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Formuła pokazuje identyfikatory rekordów oczekujących na przetworzenie.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_pd:=exec('pd_select','sync_mwa','PORTAL');
{? _pd=''
|| return()
?};

SYNC_DEF.cntx_psh();
SYNC_DEF.prefix();
SYNC_DEF.f_set('ACR_TAB','join SYNC_PD','"SYNC_PD"."SYM"=\':_a\' and "SYNC_DEF"."ACR_TAB"<>\'\'',_pd);
_dh:=SYNC_DEF.f_size()+1;
{? _dh<5
|| _dh:=5
|? _dh>30
|| _dh:=30
?};

_ws:=SYNC_DEF.mk_sel('Definicje'@,'P',,'#sync_def',,,_dh,,'U');
SYNC_DEF.win_fld(_ws,,'ACR_TAB',,,20,,,'Tabela'@);
SYNC_DEF.win_act(_ws,,'Formuła','Usuń'@@,,,$("
   _pd:='"+_pd+"';
   {? SYNC_DEF.sel_size() | exec('del_ask','#table')
   || progress(,
         'Usuwanie informacji o konieczności przetworzenia rekordów [%1].'@ [SYNC_DEF.ACR_TAB]+'\n'
         'Proszę czekać ...'@,'Przetwarzanie danych'@,1
      );
      SYNC_DEF.cntx_psh();
      _TAB:=proc_exec('new_sync@synchro',_pd,0,SYNC_DEF.ACR_TAB,100000);
      SYNC_DEF.cntx_pop();
      {? _TAB.first()
      || proc_exec('new_sync_id_del@synchro',_pd,0,SYNC_DEF.ACR_TAB,,_TAB.IDSYNC)
      ?};
      prgs_clr()
   ?}
   "),,,
   1,
   "exec('del_ask','#table')",,
   'U'
);
SYNC_DEF.win_act(_ws,,'Formuła','Pokaż'@@,,,
   "exec('new_sync_show','%portal',SYNC_DEF.SYNC_PD().SYM,SYNC_DEF.ACR_TAB)",,1,,,,'P'
);
SYNC_DEF.win_act(_ws,,'Formuła','Pokaż &wszystkie'@@,,,
   "exec('new_sync_show','%portal',SYNC_DEF.SYNC_PD().SYM)",,0,,,,'W'
);
SYNC_DEF.win_act(_ws,,'Kolejność');
SYNC_DEF.win_btn(_ws,'text=%1,panel=right,align=begin'['Pokaż'@],'menu:P');
SYNC_DEF.win_btn(_ws,'text=%1,panel=bottom,align=begin'['Pokaż &wszystkie'@],'menu:W');
SYNC_DEF.win_sel(_ws);
SYNC_DEF.select();
SYNC_DEF.f_clear();
SYNC_DEF.cntx_pop();

~~


\methods_to_sync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Dla wskazanego przeznaczenia danych zwraca listę metod 'Get' (oddzielonych przecinkami) dla encji,
::       które zawierają dane do odebrania.
::       Formuła do użycia w procesie odberania danych z portalu w celu zmniejszenia liczby komunikatów 'Get'
::       wysyłanych do poszczególnych encji.
::   WE: _a - przeznaczenie danych (kod lub lista kodów oddzielonych przecinkami)
::       [_b] - token notyfikacyjny / ''
::----------------------------------------------------------------------------------------------------------------------
_result:='';

{? var_pres('_b')=type_of('') || SL_api.set_notify_token(_b) ?};
_tab:=exec('GetDataAboutEntitiesToSync','portal_engine',_a,0);
SL_api.set_notify_token('');

{? var_pres('_tab')>100
|| {? _tab.first()
   || {!
      |? _result+='%1Get,'[_tab.ENTITY];
         _tab.next()
      !}
   ?}
?};
_result


\all_methods_to_sync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [22.26]
:: OPIS: Dla wszystkich biznesowych przeznaczeń danych zwraca listę metod 'Get' (oddzielonych przecinkami) dla encji,
::       które zawierają dane do odebrania.
::       Formuła do użycia w procesie odberania danych z portalu w celu zmniejszenia liczby komunikatów 'Get'
::       wysyłanych do poszczególnych encji.
::   WE: [_a] - token notyfikacyjny / ''
::----------------------------------------------------------------------------------------------------------------------
_token:={? var_pres('_a')=type_of('') || _a || '' ?};
exec('methods_to_sync','%portal',
   'PORTAL_CFG,PORTAL,PORTAL_WNIOSKI,PORTAL_CUSTOM,PORTAL_HR_CFG,PORTAL_SEOD,PORTAL_SEOD_CFG',
   _token
)
:: Do testów:
::'chr_AdsImprovementGet,chr_AdsImprovementPersonGet,chr_AdsImprovementVoteGet,chr_KnowledgeBaseItemGet,chr_PersonAbsenceRequestGet,chr_PersonReplacementGet,chr_PersonReplacementGet,chr_PersonRequestGet,chr_QuestionGet,chr_QuestionDetailGet,rgt_OprGrupyTenantGet'


\del_edok_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [12.51]
:: OPIS: Wybór operacji usuwania wniosków jaką chcemy przeprowadzić.
::----------------------------------------------------------------------------------------------------------------------
_szer:=70;
_TAB:=tab_tmp(1,
   'LP','INTEGER','Lp.',
   'NAME','STRING[%1]' [$_szer],'Nazwa',
   'FORMULA','STRING[255]','Formuła do wykonania'
);
_add:="
   _a.blank();
   _a.LP:=_a.size()+1;
   {? var_pres('_c')=3
   || _a.FORMULA:=$_c
   ?};
   _a.NAME:=
      {? _a.FORMULA=''
      || '[ %1 ]' [_b]
      || _b
      ?};
   _a.add()
";
_options:=obj_new('opt1','opt2');
_options.opt1:='Usuwanie wniosków dla pracownika na podstawie wybranego typu'@;
_options.opt2:='Usuwanie wszystkich wniosków dla pracownika bez względu na typ'@;
_form:=
   "_rodz:=exec('edok_type','%portal');
    {? _rodz<>''
    || exec('del_edok','%portal',1,exec('edok_mask','%portal',_rodz),_rodz)
    ?}
   ";
_add(_TAB,_options.opt1,_form);
_add(_TAB,_options.opt2,_form);
_ws:=_TAB.mk_sel('Usuwanie wniosków HR Portal'@,'N',,'#hrportaluswn',,,,,'U');
_TAB.win_fld(_ws,,'NAME',,,,,,,1);
_TAB.win_act(_ws,,'Formuła','Uruchom'@,,,"($cur_tab(1,1).FORMULA)()",,1,,,,'U');
_TAB.win_sel(_ws);
params_set(
   'TAB',_TAB,
   'ws',_ws,
   'szer',_szer
);
_TAB.select();
~~


\edok_type
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Komunikat z wyborem rodzaju wniosków, dla którego wykonać operację usuwania.
::   WE:
::   WY: Znacznik dla wybranego typu, np. 'T', 'P', 'X'...
::----------------------------------------------------------------------------------------------------------------------
_choices:=obj_new('portal','paperless','absences');
_choices.portal:='&Portal HR'@;
_choices.paperless:='Paperless &HR'@;
_choices.absences:='Wnioski &urlopowe'@;
_title:='Rodzaj wywołania'@;

_type:=exec('types','portal_wnioski');

_result:='';

{? exec('lic','#b_domain','PEP')
|| _choice:=FUN.choice(_title,1,_choices.portal,_choices.paperless,_choices.absences);
   {? _choice=1
   || _result:=_type.portal
   |? _choice=2
   || _result:=_type.paperless
   |? _choice=3
   || _result:=_type.absence
   ?}
|| _choice:=FUN.choice(_title,1,_choices.portal,_choices.absences);
   {? _choice=1
   || _result:=_type.portal
   |? _choice=2
   || _result:=_type.absence
   ?}
?};

_result


\edok_mask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [12.51]
:: OPIS: Wybór maski wniosków zaakceptowanych.
::----------------------------------------------------------------------------------------------------------------------
_types:=exec('types','portal_wnioski');
_rodz:={? var_pres('_a')=type_of('')
       || {? _a=_types.paperless
          || '\'%1\''[_types.paperless]
          |? _a=_types.absence
          || '\'%1\''[_types.absence]
          || '\'%1\''[_types.portal]
          ?}
       ?};
_mask:='';
_width:=60;
_NAMES:=EDOKUM.names();
_TABN:=tab_tmp(1,
   'MASK','STRING[10]','Maska',
   'NAME','STRING[50]','Grupa wniosków',
   'LW'  ,'INTEGER'   ,'Liczba wniosków (%1)'[{? _rodz*'P' || 'Paperless' || 'Portal HR' ?}]
);
_loop:=_NAMES.first();
_nwuMask:=exec('nwu_edokum_mask','portal_method_chr');
{!
|? _loop
|!
   {? _NAMES.NAME<>'skid_v__' & {? _a=_types.absence || _NAMES.NAME=_nwuMask || _NAMES.NAME<>_nwuMask ?}
   ||
      _TABN.blank();
      _TABN.MASK:=_NAMES.NAME;
      _TABN.NAME:=exec('edok_name','%portal',_NAMES.NAME);
      EDOKUM.cntx_psh();
      EDOKUM.use(_TABN.MASK);
      EDOKUM.prefix();
      {? var_pres('_LW')>100 || obj_del(_LW) ?};
      _LW:=sql(
         'select count(*) as LW from EDOKUM join ETYPY using(EDOKUM.TYP,ETYPY.REFERENCE) where ETYPY.W_PORTAL=:_a',
         _rodz
      );
      EDOKUM.cntx_pop();
      _TABN.LW:=_LW.LW;
      _TABN.add(1)
   ?};
   _loop:=_NAMES.next()
!};
_win:=_TABN.mk_sel('Wybór grupy wniosków'@,,0,'#edoktype',,,,,'U');
_TABN.win_fld(_win,,'NAME',,,_width);
_TABN.win_fld(_win,,'LW',,,30);
_TABN.win_act(_win,,'Formuła','Wybierz'@,,,"sel_exit()",,1,0,,,'W');
_TABN.win_sel(_win);
{? _TABN.select()
|| _mask:=_TABN.MASK
|| FUN.info('Nie wybrano rodzaju wniosków.'@);
   return(0)
?};
_mask


\edok_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Zwraca nazwę rodzaju wniosków odpowiednią dla przekazanej maski.
::   WE: _a [STRING] - nazwa maski tabeli EDOKUM
::   WY: nazwa do wyświetlenia dla danej maski
::----------------------------------------------------------------------------------------------------------------------
_name:='';
_mask:={? var_pres('_a')=type_of('') & _a<>'' || _a || return(_name) ?};
{? #(_year:=(_mask+2))>0
|| _name:='Wnioski na rok 20%1'[_year]
|? _mask='skid_v_1'
|| _name:='Wnioski niezaakceptowane'
|? _mask=exec('nwu_edokum_mask','portal_method_chr')
|| _name:='Wnioski urlopowe'
?};
_name


\del_edok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol & TMR [20.42]
:: OPIS: Czyści powiązane z pracownikiem wnioski tak, aby można było usunąć definicję wniosku
::   WE:
::   WY: 1 - sukces, 0 - porażka
::----------------------------------------------------------------------------------------------------------------------
_types:=exec('types','portal_wnioski');
_all:={? var_pres('_a')=type_of(0) & _a || _a || 0 ?};
_mask:={? var_pres('_b')=type_of('') & _b<>'' || _b |? var_pres('_b')=type_of(0) || return(0) || 'skid_v_1' ?};
_rodz:={? var_pres('_c')=type_of('') & _c<>'' || _c || _types.portal ?};
EDOKUM.cntx_psh();
EDOKUM.use(_mask);
:: wybór pracownika
_args:=exec('wybierz_args','pracownik');
_args.DOMAIN:='POR';
_args.WIELU:=0;
_args.F_ZATR:='';
_args.VIEW:='';
_args.UD_SCH:=exec('domyslny','schemat','PODZORG');
_args.UD_SKL:=__PARSES.getVal('JednostkaOrganizacyjna').REF;
_args.SQL_FROM:='join OSOBA using(P.OSOBA,OSOBA.reference)';
_args.SQL_WHERE:='OSOBA.PESEL in (select OSOBA.PESEL from EDOKUM '
   'join OSOBA using(EDOKUM.DOSTAWCA,OSOBA.reference) where EDOKUM.OSOBAWWW<>\'\')';
_wyb:=exec('wybierz','pracownik',_args);
:: jeżeli nie wybrano to wracamy
{? _wyb.P.size()=0
|| EDOKUM.cntx_pop();
   return(0)
?};
_wyb.P.first();
_refP:=_wyb.P.SQL;
_refObieg:=exec('FindInSet','#table','TYPOBIEG','UNIK','Obieg wniosków',,,,,null);
{? _refObieg=null || FUN.info('Nie znaleziony ref TYPOBIEG'@); EDOKUM.cntx_pop(); return(0) ?};
_refEtyp:=null();
{? ~_all
|| ETYPY.cntx_psh();
   ETYPY.index('UNIK_WP');
   ETYPY.prefix(_refObieg,_rodz);
   ETYPY.win_sel('SLO_WYBP');
   {? ETYPY.select()
   || _refEtyp:=ETYPY.ref()
   ?};
   ETYPY.cntx_pop()
?};
{? ~_all & _refEtyp=null || FUN.info('Nie wybrano typu wniosku'@); EDOKUM.cntx_pop(); return(0) ?};
_ndx:={? _all
      || EDOKUM.ndx_tmp(,1,'TYP','W_PORTAL',,'OSOBAWWW',,)
      || EDOKUM.ndx_tmp(,1,'TYP','W_PORTAL',,'OSOBAWWW',,,'TYP',,)
      ?};
EDOKUM.index(_ndx);
{? _all || EDOKUM.prefix(_rodz,_refP) || EDOKUM.prefix(_rodz,_refP,_refEtyp) ?};
_ret:=0;
_retModified:=0;
_size:=EDOKUM.size();
_mainLoop:=_fa:=EDOKUM.first();
{? _mainLoop
|| _link:=EDOKUM.testlink(,EDOKUM.count);
   {! _mainLoop
   |?
::    zalozenie transakcji
      _mydo:=do_state()=0;
      {? _mydo || do() ?};

      _order:='EDOKOS|EDOKPAR|EDOKUMZ|EDOK_ATK|EDOK_ATR|EDOKLOG|R_NADG|R_ODN|R_WO|';
      {!
      |? +_order
      |!
         _wsk:=_order*'|'; _tab:=(_wsk-1)+_order; _order:=_wsk-_order;
         _Tab:=($_tab)();
         _link.prefix(_tab);
         _loop:=_link.first();
         {!
         |? _loop
         |!
            _link.first();
            _Tab.cntx_psh();
            {!
            |?
               _Tab.use(_link.MASKA);
               _Tab.cntx_psh();
               _Tab.prefix();
               {? _Tab.seek(_link.REF,_link.MASKA)
               || {? _tab='EDOKUMZ'
                  || EDOKUMZS.cntx_psh();
                     EDOKUMZS.use('skids_'+(ref_name(_Tab.ref())+2));
                     EDOKUMZS.prefix();
                     exec('del_ndx','#table',EDOKUMZS,'EDOKUMZ',_Tab.ref());
                     EDOKUMZS.cntx_pop()
                  |? _tab='R_ODN'
                  ||  R_ODP.cntx_psh();
                      R_ODP.index('NAG');
                      R_ODP.prefix(R_ODN.ref());
                      {? R_ODP.first()
                      || {! |? R_ODP.del(1) !}
                      ?};
                      R_ODP.cntx_pop()
                  |? _tab='R_WO'
                  || R_WYK.cntx_psh();
                     R_WYK.use('r_wyk');
                     R_WYK.index('R_WYKWO');
                     R_WYK.prefix(R_WO.ref());
                     {? R_WYK.first()
                      || {! |? R_WYK.del(1) !}
                      ?};
                     R_WYK.cntx_pop()
                  ?};
                  _Tab.del()
               ?};
               _Tab.cntx_pop();
               _link.next()
            !};
            _Tab.cntx_pop();
            _loop:=_link.next()
         !};
         obj_del(_Tab)
      !};
      _op:=EDOKUM.del(,1);
      {? _mydo || end() ?};
      _mainLoop:={? _op
                 || _ret+=1; _retModified+=1;
                    {? _op=2 || 1 || 0 ?}
                 || EDOKUM.next()
                 ?};
      {? _mainLoop || obj_del(_link); _link:=EDOKUM.testlink(); 1 ?}
   !}
?};
EDOKUM.ndx_drop(_ndx);
EDOKUM.cntx_pop();
{? (~_ret & ~_fa)
|| FUN.info('Brak w systemie istniejących wniosków dla wskazanego pracownika'@)
|? (_ret & (_retModified=_size) & _fa)
|| FUN.info('Wnioski wybranego pracownika zostały usunięte'@)
|? (~_ret & ~_retModified & _fa)
|| FUN.info('Brak w systemie istniejących wniosków danego typu dla wskazanego pracownika'@)
|? (_ret & (_retModified<>_size) & _fa)
|| FUN.emsg('Wnioski wybranego pracownika nie zostały usunięte ze względu na istniejące powiązania'@)
|| FUN.emsg('Wnioski wybranego pracownika nie zostały usunięte'@)
?};
return(_ret)


\EDOKUM_sel_paperless
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [21.14]
:: OPIS: Wyśletla okno z wnioskami w obiegu Paperless - widok techniczny
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_rok:=exec('edit_string','#edit','21','Rok maski EDOKUM');
exec('EDOKUM_sel','portal_wnioski',_rok,'P')


\del_proc_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Wybór operacji usuwania procesów jaką chcemy przeprowadzić.
::----------------------------------------------------------------------------------------------------------------------
_szer:=70;
_TAB:=tab_tmp(1,
   'LP','INTEGER','Lp.',
   'NAME','STRING[%1]' [$_szer],'Nazwa',
   'FORMULA','STRING[255]','Formuła do wykonania'
);
_add:="
   _a.blank();
   _a.LP:=_a.size()+1;
   {? var_pres('_c')=3
   || _a.FORMULA:=$_c
   ?};
   _a.NAME:=
      {? _a.FORMULA=''
      || '[ %1 ]' [_b]
      || _b
      ?};
   _a.add()
";
_options:=obj_new('opt1','opt2');
_options.opt1:='Usuwanie instancji wybranych procesów portalowych'@;
_options.opt2:='Usuwanie instancji wszystkich procesów portalowych'@;
_add(_TAB,_options.opt1,"exec('del_proc','%portal',0)");
_add(_TAB,_options.opt2,"exec('del_proc','%portal',1)");
_ws:=_TAB.mk_sel('Usuwanie procesów Portal HR'@,'N',,'#hrportaluspr',,,,,'U');
_TAB.win_fld(_ws,,'NAME',,,,,,,1);
_TAB.win_act(_ws,,'Formuła','Uruchom'@,,,"($cur_tab(1,1).FORMULA)()",,1,,,,'U');
_TAB.win_sel(_ws);
params_set(
   'TAB',_TAB,
   'ws',_ws,
   'szer',_szer
);
_TAB.select();
~~


\del_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol & TMR [20.42]
:: OPIS: Usuwa instancje procesu
::       !!!UWAGA!!! - wszystkie instancje procesu, dla których powstały instancje z podanego dnia w argumencie _b
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

_all:={? var_pres('_a')=type_of(0) & _a || _a || 0 ?};

B_PROC.cntx_psh();
_ndx1:=B_PROC.ndx_tmp('',1,'FIRMA',,0, 'ACTIVE',,0, 'ACCEPTED',,0, 'SYMBOL',,0);
B_PROC.index(_ndx1);
:: prefiksujemy się tylko na procesach portalowych zaakceptowanych
B_PROC.prefix(exec('ref_firma','ustawienia'),'T','T','POR');

{? ~_all
||
   _ws:=B_PROC.mk_sel('Procesy'@,'P',,'#proc_def',,,15,,'U');
   B_PROC.win_fld(_ws,,'SYMBOL',,,20,,,'Symbol'@);
   B_PROC.win_fld(_ws,,'NAME',,,30,,,'Nazwa'@);
   B_PROC.win_fld(_ws,,'VER',,,10,,,'Wersja'@);
   B_PROC.win_fld(_ws,,'ACTIVE',,,5,,,'Aktywny'@,,,2,,"'T'","'N'");
   B_PROC.win_fld(_ws,,'ACCEPTED',,,5,,,'Zaakceptowany'@,,,2,,"'T'","'N'");
   B_PROC.win_act(_ws,,'Formuła','Wybierz'@@,,,"sel_exit()",,1,,,,'W');
   B_PROC.win_sel(_ws);
   _refProc:={? B_PROC.select() || B_PROC.ref() || null() ?};
   {? _refProc=null
   || FUN.info('Nie wybrano procesu.'@);
      B_PROC.cntx_pop();
      B_PROC.ndx_drop(_ndx1);
      return(_result)
   ?}
||
   {? B_PROC.first()
   || _refProc:=B_PROC.ref
   || FUN.info('W systemie nie odnaleziono żadnego procesu portalowego'@);
      B_PROC.cntx_pop();
      B_PROC.ndx_drop(_ndx1);
      return(_result)
   ?}
?};

BI_PROC.cntx_psh();
_ndx:=BI_PROC.ndx_tmp(,1,'B_PROC',,);
BI_PROC.index(_ndx);

_loop:=obj_new('main','instances','link');
_loop.main:=1;

_fa:=0;
_del:=1;

do();
{!
|? _loop.main
|!
   BI_PROC.prefix(_refProc);
   _loop.instances:=BI_PROC.first();
   {? ~_fa & _loop.instances || _fa:=1 ?};
   {? _loop.instances
   || _link:=BI_PROC.testlink(,BI_PROC.count);
      {!
      |? _loop.instances
      |!
         _order:='BI_MSG|BI_CONN|BI_PORT|BI_PREL|BI_TODO|B_KEYREF|';
         {!
         |? +_order
         |!
            _wsk:=_order*'|'; _tab:=(_wsk-1)+_order; _order:=_wsk-_order;
            _Tab:=($_tab)();
            _link.prefix(_tab);
            _loop.link:=_link.first();
            {!
            |? _loop.link
            |!
               _link.first();
               _Tab.cntx_psh();
               {!
               |?
                  _Tab.use(_link.MASKA);
                  _Tab.cntx_psh();
                  _Tab.prefix();
                  {? _Tab.seek(_link.REF,_link.MASKA)
                  ||
                     {? _tab='BI_PREL'
                     || _Tab.BI_PROC:=null;
                        _Tab.put()
                     || _Tab.del()
                     ?}
                  ?};
                  _Tab.cntx_pop();
                  _link.next()
               !};
               _Tab.cntx_pop();
               _loop.link:=_link.next()
            !};
            obj_del(_Tab)
         !};
         _loop.instances:=
            {? BI_PROC.del(,1)>0
            || _result+=1;
               1
            || _del*=0;
               0
            ?};
         {? _loop.instances
         || obj_del(_link);
            _loop.instances:=BI_PROC.next();
            {? _loop.instances
            || _link:=BI_PROC.testlink(,BI_PROC.count)
            ?}
         ?}
      !}
   ?};
   _next:=B_PROC.next();
   _loop.main:={? _all & _del & _next
               || _refProc:=B_PROC.ref();
                  1
               ?}
!};
{? ~_loop.main & _next
|| undo();
   _result*=0
?};
end();
BI_PROC.ndx_drop(_ndx);
BI_PROC.cntx_pop();

:: kasowanie archiwum całego

{? _result
||
::    powrot w przypadku zerwanej transakcji
   {? do_state()=2
   || B_PROC.cntx_pop();
      B_PROC.ndx_drop(_ndx1);
      return(0)
   ?};

::    zalozenie transakcji
   _mydo:=do_state()=0;
   {? _mydo || do() ?};

   _can_continue:=1;
   {? _all & B_PROC.first()
   || _refProc:=B_PROC.ref
   ?};
   BI_ARCH.cntx_psh();
   BI_ARCH.index('B_PROC');
   {? _refProc
   || _loopAll:=1;
      {!
      |? _loopAll
      |!
         {! _ind:=1..2
         |! BI_ARCH.prefix(exec('ref_firma','ustawienia'),{? _ind=1 || 'N' || 'T' ?},_refProc);
            {? BI_ARCH.first()
            || {!
               |? _num_proc:=BI_ARCH.NUM_PROC;
                  _num_act:=BI_ARCH.NUM_ACT;
                  BI_ARCH.cntx_psh();
                  BI_ARCH.prefix();
                  {? BI_ARCH.seek(BI_ARCH.TREE,)
                  || BI_ARCH.NUM_PROC-=_num_proc;
                     BI_ARCH.NUM_ACT-=_num_act;
                     {? BI_ARCH.NUM_PROC<0 || BI_ARCH.NUM_PROC:=0 ?};
                     {? BI_ARCH.NUM_ACT<0 || BI_ARCH.NUM_ACT:=0 ?};
                     {? ~BI_ARCH.put(1) || _can_continue:=0; undo() ?}
                  ?};
                  BI_ARCH.cntx_pop();
                  _del:=BI_ARCH.del(,1);
                  {? ~_del
                  || _can_continue:=0;
                     _result:=0
                  ?};
                  _can_continue & BI_ARCH.first()
               !}
            ?}
         !};
         _loopAll:=
            {? _all & B_PROC.next
            || _refProc:=B_PROC.ref()
            ?}
      !}
   ?};
   BI_ARCH.cntx_pop();
   {? _mydo || end() ?}
?};

{?  _result & _fa
|| {? _all
   || FUN.info('Instancje procesów powiązanych z Portal HR zostały usunięte.'@)
   || FUN.info('Instancje wybranego procesu zostały usunięte.'@)
   ?}
|? ~_result & ~_fa
|| FUN.info('Brak instancji procesów portalowych do usunięcia.'@)
|| FUN.info('Wystąpił błąd podczas próby usunięcia instancji %1.'@[{? _all || 'procesów' || 'wybranego procesu' ?}])
?};
B_PROC.cntx_pop();
B_PROC.ndx_drop(_ndx1);

_result


\del_tat_not_conected
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [20.42]
:: OPIS: Usuwa nie powiązane rekordy tabeli TAT
::----------------------------------------------------------------------------------------------------------------------
no_msg(1);
TAT.cntx_psh();
TAT.index('ID_WP');
TAT.prefix();
_before:=TAT.size();
TAT.for_each("{? TAT.count()=0 || TAT.del() ?}",1);
_after:=TAT.size();
TAT.cntx_pop();
no_msg(0);
FUN.info('Usunięto: %1 typów atrybutów'[$(_before-_after)])


\GetDataAboutEntitiesToSync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Funkcja pobierze informację o danych do pobrania dla aktywnych metod.
::----------------------------------------------------------------------------------------------------------------------
_choice:=FUN.choice(
   'Funkcja pobierze informację o danych do pobrania dla aktywnych metod\n'
   '"Get" typu "Odbieranie" ze wskazanego przeznaczenia danych.\n\n'
   'Wybierz przeznaczenie danych:'@,,
   '&PORTAL'@,'PORTAL_&WNIOSKI'@,'PORTAL_&CFG'@
);
{? _choice=1
|| exec('GetDataAboutEntitiesToSync','portal_engine','PORTAL',1)
|? _choice=2
|| exec('GetDataAboutEntitiesToSync','portal_engine','PORTAL_WNIOSKI',1)
|? _choice=3
|| exec('GetDataAboutEntitiesToSync','portal_engine','PORTAL_CFG',1)
?};
~~


\process_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Przetworzenie startowej wysyłki wszystkich danych na portal
::   WE: [_a] - czy wyświetlać progress [0]/1
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0)
|| _progress:=_a
|| _progress:=0
?};

exec('process_start','sync_mwa','PORTAL_CFG',-1,1,_progress);
exec('process_start','sync_mwa','PORTAL_HR_CFG',-1,1,_progress);
exec('process_start','sync_mwa','PORTAL',-1,1,_progress);
exec('process_start','sync_mwa','PORTAL_WNIOSKI',-1,1,_progress);
~~


\step_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Formuła obsługująca krok startowy kreatora
::----------------------------------------------------------------------------------------------------------------------
_ask:=FUN.ask(
   'Czy rozpocząć instalację i konfigurację współpracy z Portalem HR?\n\n'
   'Przed rozpoczęciem pracy zalecane jest uruchomienie obszarów roboczych:\n'
   '- Administracja\n'
   '- Ustawienia i parametryzacja\n'
   '- Użytkownicy i uprawnienia\n'
   '- Obsługa procesów\n'
   '- Usługi integracyjne - klient\n'
   ''@
);
_ask


\step_tenant
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Formuła obsługująca krok konfiguracji dzierżawcy
::----------------------------------------------------------------------------------------------------------------------
_ask:=FUN.ask(
   'Aby skonfigurować dzierżawcę należy wybrać w obszarze roboczym \'Ustawienia i parametryzacja\':\n'
   'Portal HR -> Parametry portalu.\n\n'
   'Następnie należy zaimportować dostarczony plik konfiguracyjny (xml), albo użyć przycisku Autokonfiguracja.\n\n'
   'Czy skonfigurowano dzierżawcę?'@
);
_ask


\step_xlsx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Formuła obsługująca krok importu danych parametryzacyjnych z arkuszy xlsx
::----------------------------------------------------------------------------------------------------------------------
_ask:=FUN.ask('Czy wykonano import danych parametryzacyjnych z arkuszy xlsx i zweryfikowano dane?'@);
_ask


\step_license
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Formuła obsługująca krok konfiguracji licencji
::----------------------------------------------------------------------------------------------------------------------
_ask:=FUN.ask(
   'W obszarze roboczym \'Administracja\' w zakładce \'Portal HR\' znajduje się przycisk \'Licencje\'.\n\n'
   'Należy zweryfikować, czy liczba zakupionych dostępów jest zgodna z wyświetlaną.\n\n'
   'Jeżeli liczba zakupionych dostępów jest zerowa (albo brak wpisu o licencjach),\n'
   'to nie będzie można używać funkcjonalności portalu HR.\n\n'
   'Następnie należy skonfigurować (zdarzenie czasowe i zdarzenie wysłania) oraz zaakceptować proces ZUI_POR_LIC.\n\n'
   'Czy skonfigurowano obsługę licencji?'@
);
_ask


\step_senddata
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Formuła obsługująca krok wysłania danych na portal w kreatorze
::----------------------------------------------------------------------------------------------------------------------
_choice:=FUN.choice(
   'Inicjowanie danych można wykonać w tle (serwisowo)\n'
   'albo z poziomu obszaru roboczego KlientWebAPI - przycisk \'Zasilenie\'.\n\n'
   'Czy wysłać dane na portal?'@,,
   '&Wysłać w tle'@,'Wykonane &ręcznie'@
);
_choice


\is_active
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Formuła dla bramy na początku procesów obsługujących wymianę danych z portalem
::       Zabezpiecza przypadek, gdy współpraca z portalem nie jest skonfigurowana
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
exec('czytaj_conf','portal_engine');
exec('is_active','portal_engine')


\rejestr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [21.14]
:: OPIS: Formuła wyświetla błędy z rejestru zdarzeń.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=S01;

_NAMES:=_TAB.names();
{? ~_NAMES.first()
|| return()
?};

exec('__CHK','#object');
exec('FUN','#object');

_option:="
   _tryb:={? var_pres('_a')=type_of('') & (_a='1' | _a='*') || _a || '1' ?};
   {? var_pres('_b')=type_of(SYSLOG)
   || _TAB:=_b
   |? _tryb='1'
   || _TAB:=cur_tab(1,1)
   || return(0)
   ?};
   {? var_pres('_c')=type_of('')
   || _we:=_c
   |? _tryb='1'
   || _we:=cur_win(1,1)
   || return(0)
   ?};
   {? var_pres('_d')=type_of('')
   || _fld:=_d
   |? _tryb='1'
   || _fld:=cur_afld()
   || _fld:=''
   ?};

   {? _fld='' | _fld='ALL'
   || _sval:=$(~_TAB.ALL);
      _TAB.efld_opt(_we,'enable=%1,mark=%1' [_sval],,'ODD');
      _TAB.efld_opt(_we,'enable=%1' [_sval],,'ODT');
      _TAB.efld_opt(_we,'enable=%1,mark=%1' [_sval],,'DOD');
      _TAB.efld_opt(_we,'enable=%1' [_sval],,'DOT')
   ?}
";

_ZAKRES:=tab_tmp(,
   'ALL','INTEGER','Zakres analizy'@,
   'ODD','DATE','Data'@,
   'ODT','TIME','Godzina'@,
   'DOD','DATE','Data'@,
   'DOT','TIME','Godzina'@
);
_ZAKRES.fld_fml('ALL','AFTER_EDIT',_option);

_we:=_ZAKRES.mk_edit('Parametry analizy'@,,'#arz');
_ZAKRES.win_esep(_we,'Dane podstawowe'@);
_ZAKRES.win_efld(_we,,'ALL',,,,,,,,,'radio-buttons',,
   'Wszystkie zapisy'@,"1",
   'Wybrany okres'@,"0"
);
_ZAKRES.win_esep(_we,'Początek analizowanego okresu'@);
_ZAKRES.win_efld(_we,,'ODD');
_ZAKRES.win_efld(_we,,'ODT',,,8);
_ZAKRES.win_esep(_we,'Koniec analizowanego okresu'@);
_ZAKRES.win_efld(_we,,'DOD');
_ZAKRES.win_efld(_we,,'DOT',,,8);
exec('ok_esc','#window',_ZAKRES,_we);
_ZAKRES.win_edit(_we);

_ZAKRES.blank();
_ZAKRES.ODD:=_ZAKRES.DOD:=date();
_ZAKRES.DOT:=time(23,59,59);
_option('*',_ZAKRES,_we);
{? _ZAKRES.edit("
      _ZAKRES:=cur_tab(1,1);
      {? _ZAKRES.ALL
      || return('')
      |? (_chk:=__CHK.record2(_ZAKRES,
            'ODD','Data [Początek analizowanego okresu]',
            'DOD','Data [Koniec analizowanego okresu]'))<>''
      || return(_chk)
      |? iso_datetime_value(_ZAKRES.ODD,_ZAKRES.ODT)>iso_datetime_value(_ZAKRES.DOD,_ZAKRES.DOT)
      || FUN.emsg('[Początek analizowanego okresu] musi być przed [Końcem analizowanego okresu].'@);
         0
      || ''
      ?}
")=0
|| return()
?};

_RESULT:=tab_tmp(1,
   'DATETIME','STRING[24]','Czas zdarzenia'@,
   'ELAPSED','REAL','Czas trwania'@,
   'STATUS','STRING[8]','Status'@,
   'HTTPSTAT','INTEGER','HTTP',
   'HTTPTYPE','STRING[8]','Typ'@,
   'METHOD','STRING[64]','Metoda'@,
   'APP_STAT','STRING[128]','Status biznesowy'@,
   'APP_TEXT','SYS_MEMO','Opis biznesowy'@,
   'REQ_TEXT','SYS_MEMO','Żądanie'@,
   'RES_TEXT','SYS_MEMO','Odpowiedź'@,
:: Pola techniczna
   'MASKA','STRING[8]','Maska'@,
   'OK','STRING[1]','Poprawiony?'@,
   'COUNT','INTEGER','Powtórzeń'@,
   'APP_HASH','STRING[40]','APP hash',
   'REQ_HASH','STRING[40]','REQ hash',
   'RES_HASH','STRING[40]','RES hash'
);
_NDX:=obj_new('VIEW','APP_STAT');
_NDX.VIEW:=_RESULT.ndx_tmp(,,'MASKA',,,'APP_STAT',,,'DATETIME',,);
_NDX.APP_STAT:=_RESULT.ndx_tmp(,,'METHOD',,,'HTTPSTAT',,,'APP_STAT',,);
_RESULT.index(_NDX.APP_STAT);
_RESULT.prefix();

_cmp:='';
_set:='';
_add:='';
{! _lp:=1 .. _TAB.fld_num()
|! _acr:=_TAB.fld_acr(_lp);
:: Jeżeli pole z _TAB istnieje również w _RESULT ...
   _typ:=var_pres(_acr,_RESULT);
   {? _typ=20 | _typ=22 | _typ=27
   || _set+='_a.%1:=_b.%1; ' [_acr]
   |? _typ=36
   || _set+='_a.%3HASH:=hash(_%1:=_b.memo_get(\'r\',\'%2\',0)); ' [~_acr,_acr,4+_acr];
      _add+='_a.memo_put(_%1,\'%2\'); obj_del(_%1); ' [~_acr,_acr];
      _cmp+='_a.%1HASH=hash(_b.memo_get(\'r\',\'%2\',0)) & ' [4+_acr,_acr]
   ?}
!};
_set:=$(_set+'_a.add()'+{? +_add || '; %1' [_add-2] || '' ?});
_cmp:={? +_cmp || $(_cmp-3) || "1" ?};

:: Faza I - znalezienie błędów.
_where:='APP_STAT like \'%|R:0|\'';
{? ~_ZAKRES.ALL
|| _where+=
      ' and DATETIME between \'%1 %2.000\' and \'%3 %4.999\''
      [_ZAKRES.ODD$1,_ZAKRES.ODT$3,_ZAKRES.DOD$1,_ZAKRES.DOT$3]
?};
{!
|? _TAB.use(_NAMES.NAME);
   _TAB.prefix();
   _TAB.f_set('DATETIME',,_where);
   {? _TAB.f_first()
   || {!
      |? _add:=0;
         _RESULT.prefix(_TAB.METHOD,_TAB.HTTPSTAT,_TAB.APP_STAT,);
         {? _RESULT.first()
         || {!
            |? {? _cmp(_RESULT,_TAB)
               || _RESULT.COUNT+=1;
                  _RESULT.put();
                  0
               || _RESULT.next()
               ?}
            !}
         || _add:=1
         ?};
         {? _add
         || _uid:=(_TAB.APP_STAT-5)+51;
            _maska:={? 4+_uid='|U::' || form((_uid-8)+8) || '' ?};
            _RESULT.blank();
            _RESULT.MASKA:=_maska;
            _RESULT.OK:='N';
            _RESULT.COUNT:=1;
            _set(_RESULT,_TAB)
         ?};
         _RESULT.prefix();
         _TAB.f_next()
      !}
   ?};
   _TAB.f_clear();
   _NAMES.next()
!};

:: Faza II - analiza błędów.
{? _NAMES.first()
|| {!
   |? _TAB.use(_NAMES.NAME);
      _ndx:=_TAB.ndx_tmp(,,'APP_STAT',,,'DATETIME',,);
      _TAB.index(_ndx);
      {? _RESULT.first()
      || {!
         |? _TAB.prefix('%1|R:|' [_RESULT.APP_STAT-5],);
            {? _TAB.last() & _RESULT.DATETIME<_TAB.DATETIME
            || _RESULT.OK:='T';
               _RESULT.put()
            ?};
            _RESULT.next()
         !}
      ?};
      _TAB.ndx_drop(_ndx);
      _NAMES.next()
   !}
?};

_RESULT.index(_NDX.VIEW);
_ws:=_RESULT.mk_sel('Analiza błędów'@,'T',,'s01error',,,,,'U');
_RESULT.win_fld(_ws,,'DATETIME');
_RESULT.win_fld(_ws,,'ELAPSED',,,7,3);
_RESULT.win_fld(_ws,,'STATUS',,,-7);
_RESULT.win_fld(_ws,,'HTTPSTAT',,,-4);
_RESULT.win_fld(_ws,,'HTTPTYPE',,,6);
_RESULT.win_fld(_ws,,'METHOD',,,36);
_RESULT.win_fld(_ws,,'APP_STAT',,,64);
_RESULT.win_fld(_ws,,'MASKA');
_RESULT.win_fld(_ws,,'OK',,,-3,,,,,,2,,"'T'","'N'");
_RESULT.win_fld(_ws,,'COUNT');
_RESULT.win_act(_ws,,'Szukaj');
_RESULT.win_act(_ws,,'Kolejność');
_RESULT.win_sel(_ws);
_we:=_RESULT.mk_edit('Błąd'@);
_RESULT.win_efld(_we,,'APP_TEXT',,,80,-7);
_RESULT.win_efld(_we,,'REQ_TEXT',,,80,-7);
_RESULT.win_efld(_we,,'RES_TEXT',,,80,-7);
_RESULT.win_edit(_we);
_RESULT.select();
~~


\param_custom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Wybór operacji dodatkowej parametryzacji/kastomizacji portalu.
::----------------------------------------------------------------------------------------------------------------------
_szer:=60;
_TAB:=tab_tmp(1,
   'LP','INTEGER','Lp.',
   'NAME','STRING[%1]' [$_szer],'Nazwa',
   'FORMULA','STRING[255]','Formuła do wykonania'
);
_add:="
   _a.blank();
   _a.LP:=_a.size()+1;
   {? var_pres('_c')=3
   || _a.FORMULA:=$_c
   ?};
   _a.NAME:=
      {? _a.FORMULA=''
      || '[ %1 ]' [_b]
      || _b
      ?};
   _a.add()
";
:: Podmiana komponentu "Historia zmian" na "Ścieżka akceptacji"
_add(_TAB,'Kastomizacja dashboardu wniosków kadrowych'@,"exec('TenantGenericDashItems','portal_engine')");
_ws:=_TAB.mk_sel('Dodatkowa parametryzacja/kastomizacja Portalu HR'@,'N',,'#hrportalpc',,,,,'U');
_TAB.win_fld(_ws,,'NAME',,,,,,,1);
_TAB.win_act(_ws,,'Formuła','Uruchom'@,,,"($cur_tab(1,1).FORMULA)()",,1,,,,'U');
_TAB.win_sel(_ws);
params_set(
   'TAB',_TAB,
   'ws',_ws,
   'szer',_szer
);
_TAB.select();
~~


\get_help
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.37]
:: OPIS: Pobiera stronę pomocy
::   WE:  _a  [STRING] - Pełna ścieżka dostępu do pliku, w którym ma być zapisana strona z pomocą.
::       [_b] [NUMBER] - Zapis do rejestru zdarzeń:
::                       0 - Brak zapisu do rejestru zdarzeń.
::                       1 - Zapis do rejestru zdarzeń, ale bez treści odpowiedzi [domyślnie].
::   WY: Przyczyna niepowodzenia lub '' w przypadku sukcesu.
::----------------------------------------------------------------------------------------------------------------------
_fn:=_a;
_mode:={? var_pres('_b')=type_of(0) & 0<=_b & _b<=1 || _b || 1 ?};
_url:=exec('help_url','portal_engine');
_token:=SL_api.token('Portal',exec('token_id','portal_engine'));

_ret:='';
_inet:=inet_get(_url);
{? type_of(_inet)>100
|| _fh:=fopen(_a,'bw',0,1,1);
   {? _fh.is_open()
   || _inet.set_opt('SSL_VERIFYPEER',0);
      _inet.append_header('Authorization: Bearer %1'[_token]);
      _utc_start:=utc_get();
      _status:=_inet.http_get(_fh);
      _utc_stop:=utc_get();
      _fh.fclose();
      {? _status<>200
      || _ret:='Błąd komunikacji (%1).'@ [$_status]
      ?};
      {? _mode>0
::       Zapis do rejestru zdarzeń
      || _mwac_log_ref:=exec('mwac_log','zui',
            'HELP',
            _inet.get_url(),
            'GET',
            _inet.get_status(),
            _utc_start,
            _utc_stop,
            '',
            '',
            _inet.get_header(1),
            _inet.get_header(0)
         );
         exec('mwac_log_app','zui',_mwac_log_ref,'|HELP|','')
      ?}
   || _ret:='Brak dostępu do pliku: %1'@ [_a]
   ?}
|| _ret:='Powołanie obiektu INET nie powiodło się.'@
?};
_ret


\abc_notify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [22.26]
:: OPIS: Warunek zdarzenia startowego - czy jest notyfikacja o zmianach w encjach Portal HR.
::       Opcjonalnie, po przekroczeniu limitu czasu zdarzenie wyzwalane jest bezwarunkowo.
::       Limit czasu resetowany jest po każdym odebraniu notyfikacji.
::   WE: [_a] - limit czasu (w minutach - domyślnie 15)
::   WY: obj('STATUS','TOKEN')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _limit:=_a || _limit:=15 ?};

_interval_on:=1;

_result:=0;
_reset:=0;
_token:='';

_abc:=exec('abc_notify','#notify');

_tm:=_abc.param_get(__Firma,'POR_TMSNC');

exec('czytaj','#stalesys',,XINFO,'POR_CONF','POR_TNNT','PO0TNNT');
_tenant:=exec('tenant','portal_engine');
{? _tenant<>''
|| _token:=_abc.notify_get(_tenant);
   _result:=(_token<>'')
?};

{? _result=0
|| {? _interval_on
   || {? _tm=''
      || _result:=1;
         _reset:=1
      || _sync_utc:=iso_datetime_parse_utc(_tm).utc;
         {? _sync_utc+_limit*60<utc_get()
         || _result:=1;
            _reset:=1
         ?}
      ?}
   ?}
|| _reset:=1
?};

{? _reset
|| _abc.param_set(__Firma,'POR_TMSNC',iso_datetime_value())
?};

_res:=obj_new('STATUS','TOKEN');
_res.STATUS:=_result;
_res.TOKEN:=_token;
_res


\permissions_list
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Formuła zbiera uprawnienia wykorzystywane w formułach czynności odnoszących się do portalu (pliki !*.fml
::       zawierające w sobie tag #portal oraz następujące po nim wymienione kolejno uprawnienia, do których
::       dany użytkownik uzyskuje uprawnienia po przypisaniu mu konkretnej czynności), a następnie
::   WE:
::   WY:
:: ~OST: INWINBTN
::----------------------------------------------------------------------------------------------------------------------
_progress:=obj_new('args','size','global_step');
_stages:=exec('permissions_stages','%portal');
_progress.args:=exec('init','#progress');
_progress.args.TITLE:='Wczytywanie funkcji praw'@;
_progress.args.gl_smode('|');
_progress.args.add_progress(_stages.csvImport,1);
_progress.args.add_progress(_stages.actionsFilesSearch,1);
_progress.args.add_progress(_stages.actionsSearch,1);
_progress.args.add_progress(_stages.fileSystemComparison,1);
_progress.args.add_progress(_stages.reverseComparison,1);
_progress.args.HEIGHT:=20;
_progress.size:=obj_len(_stages);
_progress.global_step:=1;

_permissions:=obj_new('list','fromSource','inUse','imported');
_permissions.list:=tab_tmp(1,
   'NAME'   ,'STRING[255]'                               ,'Nazwa funkcji praw'@,
   'DESC'   ,'STRING[255]'                               ,'Opis funkcji praw'@,
   'GROUP'  ,'STRING[255]'                               ,'Grupa funkcji praw'@,
   'ACTION' ,'STRING[%1]'[$MS.fld_len('B_ACTION','UID')] ,'Identyfikator czynności'@,
   'IMPL'   ,'STRING[1]'                                 ,'Status'@
);

_permissions.fromSource:=exec('permissions_from_source','%portal',_progress);
{? ~_permissions.fromSource.size()
|| return()
?};
_permissions.inUse:=exec('permissions_in_use','%portal',_progress);
{? ~_permissions.inUse.size()
|| FUN.error('Nie powiodło się wyznaczenie funkcji praw używanych w systemie.'@);
   return()
?};
_permissions.imported:=exec('permissions_imported','%portal',_progress);

_ok:=1;
_status:=exec('permissions_statuses','%portal');

{? _loop:=_permissions.fromSource.first()
||
   _progress.args.next_phase();
   _size:=_permissions.fromSource.size;
   _progress_step:=(1/{? _size || _size || 1 ?});

   {!
   |? _loop
   |!
      _ok*=exec('next_step','#progress',_progress.args,_progress.global_step,_progress_step);
      _progress.args.global_step(_progress_step/_progress.size);

      _permissions.list.blank();
      _permissions.inUse.clear();
      _permissions.list.NAME:=_permissions.fromSource.PNAME;
      _permissions.list.DESC:=_permissions.fromSource.PDESC;
      _permissions.list.GROUP:=_permissions.fromSource.GDESC;
      _permissions.inUse.prefix(_permissions.fromSource.PNAME,);
      {? _permissions.inUse.first()
      ||
         {!
         |?
            _permissions.list.ACTION:=_permissions.inUse.ACTION;
            _permissions.imported.prefix(_permissions.list.ACTION,);
            {? _permissions.imported.find_key(_permissions.list.NAME,)
            || _permissions.list.IMPL:=_status.implemented.code
            || _permissions.list.IMPL:=_status.unimported.code
            ?};

            _del:=_permissions.inUse.del(,1);
            _ok*=(_del>0);
            _del<>1
         !}
      || _permissions.list.ACTION:='';
         _permissions.list.IMPL:=_status.missing.code
      ?};

      {? ~_permissions.list.find_rec()
      || _permissions.list.add()
      ?};

      _loop:=(_ok & _permissions.fromSource.next())
   !};

   _progress.args.ph_sname(,'Zakończono: %1'@[_progress.args.ph_sname()]);
   _progress.args.next_phase();

   _permissions.inUse.clear();
   _size:=_permissions.inUse.size;
   _progress_step:=(1/{? _size || _size || 1 ?});

   _permissions.list.cntx_psh();
   {? _loop:=_permissions.inUse.first()
   || {!
      |? _loop
      |!
         _ok*=exec('next_step','#progress',_progress.args,_progress.global_step,_progress_step);
         _progress.args.global_step(_progress_step/_progress.size);

         _permissions.list.clear();
         _permissions.list.prefix(_permissions.inUse.NAME,);
         {? _permissions.list.first()
         || {? _permissions.list.IMPL<>_status.unimported.code
            || _permissions.list.IMPL:=_status.nonexistent.code;
               _ok*=_permissions.list.put(1)
            ?}
         || _permissions.list.blank();
            _permissions.list.NAME:=_permissions.inUse.NAME;
            _permissions.list.ACTION:=_permissions.inUse.ACTION;
            _permissions.list.IMPL:=_status.nonexistent.code;
            _ok*=_permissions.list.add(1)
         ?};

         _loop:=_permissions.inUse.next()
      !}
   ?};
   _permissions.list.cntx_pop();

   _progress.args.ph_sname(,'Zakończono: %1'@[_progress.args.ph_sname()]);

   {? _ok
   ||
      _progress.args.ctr_stop();

      _view:="""
         _act:='""+_a+""';

         _par:=params_get();
         _list:=_par.list;
         _ws:=_par.ws;
         _status:=_par.status;

         _where:='IMPL=\\\\'%1\\\\''[_act];
         _grayed:='W(%1):W(%1)'[_act];
         _desc:='';
         _all:=0;

         {! _index:=1..obj_len(_status)-2
         |! {? _act=_status[_index].code
            || _desc:=_status[_index].desc;
               {? _status[_index].code=_status.all.code || _all:=1 ?}
            ?}
         !};

         _hdr:={? _all || _where:=''; '%1 funkcje'@[_desc] || 'funkcje %1'@[_desc] ?};

         _list.f_set('NAME',,_where);
         _list.actions_grayed(_ws,_grayed);
         _list.hdr_sel();
         _tyt:=' - %1'[_hdr];
         _list.hdr_sel(_tyt);
         ~~
      """;

      _ws:=_permissions.list.mk_sel('Lista funkcji praw'@,,0,'#funkpraw',,,,,'U',,,,,'normal',,,'lumen');
      _permissions.list.win_fld(_ws,,'NAME',,,'50,32,64',,,,,'Nazwa funkcji praw na Portal HR'@);
      _permissions.list.win_fld(_ws,,'DESC',,,'20,16,128');
      _permissions.list.win_fld(_ws,,'GROUP',,,'32,20,64');
      _permissions.list.win_fld(_ws,,'ACTION',,,'12,12,12');
      _permissions.list.win_fld(_ws,,'IMPL',,,'3,1,3',,,,,("
            _status:={? var_pres('_a')>100 || _a || return('') ?};

            _desc:=obj_new('statuses','info');
            _desc.statuses:='';
            _desc.info:='';
            {! _index:=1..obj_len(_status)-3
            |! _desc.statuses+='%1/'[_status[_index].code];
                  _desc.info+='%1/'[_status[_index].desc]
            !};
            _desc.statuses-=1;
            _desc.info-=1;

            'Status funkcji [%1 - %2]'@[_desc.statuses,_desc.info]
         ")(_status)
      );
      _permissions.list.win_act(_ws,0,'Rekord',,,,
         "_par:=params_get();
          _par.status.getColorFor(_par.list.IMPL)
         "
      );
      _permissions.list.win_act(_ws,0,'Formuła','Legenda'@@,,'Opis znaczenia kolorów wierszy'@,,
            "exec('legenda','color','@funkpraw#01#01','@funkpraw#01#02')",,,,,'L',,'target=window'
      );
      {! _empty:=0..1
      |! _permissions.list.win_act(_ws,_empty,'Menu','Widok'@@,,,,,,,,,'W');
         _permissions.list.win_act(_ws,_empty,'Formuła','Pokaż %1'@@[_status.implemented.action],'Widok'@,,
            $_view(_status.implemented.code),,,,,,_status.implemented.code
         );
         _permissions.list.win_act(_ws,_empty,'Formuła','Pokaż %1'@@[_status.missing.action],'Widok'@,,
            $_view(_status.missing.code),,,,,,_status.missing.code
         );
         _permissions.list.win_act(_ws,_empty,'Formuła','Pokaż %1'@@[_status.unimported.action],'Widok'@,,
            $_view(_status.unimported.code),,,,,,_status.unimported.code
         );
         _permissions.list.win_act(_ws,_empty,'Formuła','Pokaż %1'@@[_status.nonexistent.action],'Widok'@,,
            $_view(_status.nonexistent.code),,,,,,_status.nonexistent.code
         );
         _permissions.list.win_act(_ws,_empty,'Formuła','Pokaż %1'@@[_status.all.action],'Widok'@,,
            $_view(_status.all.code),,,,,,_status.all.code
         )
      !};
      _permissions.list.win_btn(_ws,'text=%1'['Pokaż %1'@[_status.implemented.action]],
         'menu:W%1'[_status.implemented.code]);
      _permissions.list.win_btn(_ws,'text=%1'['Pokaż %1'@[_status.missing.action]],
         'menu:W%1'[_status.missing.code]);
      _permissions.list.win_btn(_ws,'text=%1'['Pokaż %1'@[_status.unimported.action]],
         'menu:W%1'[_status.unimported.code]);
      _permissions.list.win_btn(_ws,'text=%1'['Pokaż %1'@[_status.nonexistent.action]],
         'menu:W%1'[_status.nonexistent.code]);
      _permissions.list.win_btn(_ws,'text=%1'['Pokaż %1'@[_status.all.action]],
         'menu:W%1'[_status.all.code]);
      _permissions.list.win_sel(_ws);

      params_set(
         'list',_permissions.list,
         'ws',_ws,
         'status',_status
      );

      ($_view(_status.missing.code))();

      _permissions.list.select()
   ?}
?};

{? ~_ok
|| _progress.args.ctr_stop()
?};
~~


\permissions_stages
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Zwraca obiekt tymczasowy z nazwami kolejnych etapów dla obiektu mprogress.
::   WE:
::   WY: Obiekt tymczasowy z informacjami dla mprogress
::----------------------------------------------------------------------------------------------------------------------
_stages:=obj_new('csvImport','actionsFilesSearch','actionsSearch','fileSystemComparison','reverseComparison');

_stages.csvImport:='Import funkcji praw z pliku CSV'@;
_stages.actionsFilesSearch:='Import funkcji praw z plików czynności'@;
_stages.actionsSearch:='Przeglądanie czynności systemu w poszukiwaniu funkcji praw'@;
_stages.fileSystemComparison:='Porównanie funkcji praw (Plik - System)'@;
_stages.reverseComparison:='Porównanie funkcji praw (System - Plik)'@;

_stages


\permissions_from_source
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Formuła importuje uprawnienia pochodzące z pliku z uprawnieniami dostępnymi na Portal HR (pobierany z adresu
::       na confluence.assecobs.pl - dostęp tylko dla pracowników ABS).
::       Pobrany plik powinien o ile nie jest w formacie .csv powinien uprzednio w takim zostać zapisany na dysku.
::   WE: _a [OBJECT] - obiekt multiprogress prezentujący postęp wczytywania funkcji praw
::   WY: Tabela zawierająca zbiór uprawnień pochodzących z odpowiedniego pliku .csv z uprawnieniami
:: ~OST: INFILECHOOSER
::----------------------------------------------------------------------------------------------------------------------
_LIST:=tab_tmp(1,
   'PNAME'  ,'STRING[255]' ,'Funkcja praw'@,
   'PDESC'  ,'STRING[255]' ,'Opis funkcji praw'@,
   'GDESC'  ,'STRING[255]' ,'Opis grupy'@
);

{? exec('interm','#system')=1 | var_pres('_a')<100 || return(_LIST) ?};
_progress:=_a;

_title:='Wybór pliku CSV z funkcjami praw na Portal HR'@;
_filename:=exec('filechooser','#file',_title,0,'csv','%1 %2'@['Pliki'@,'*.csv']);

{? _filename=''
|| FUN.info('Nie wybrano pliku.'@);
   return(_LIST)
|? ~fexists(_filename)
|| FUN.error('Brak dostępu do pliku.'@);
   return(_LIST)
?};

exec('start','#progress',_progress.args);
_progress.args.next_phase();

_result:=_LIST.import(_filename,,0,,'UTF-8,nopth,header',,
   'PNAME',,3,,
   'PDESC',,4,,
   'GDESC',,2,
);

{? ~_result
|| FUN.error('Błędna struktura pliku.'@)
|| {? ~exec('next_step','#progress',_progress.args,1)
   || _progress.args.ctr_stop();
      _LIST.erase()
   || _progress.args.ph_sname(,'Zakończono: %1'@[_progress.args.ph_sname()]);
      _progress.global_step+=1;
      _progress.args.global_step(1/_progress.size)
   ?}
?};

_LIST


\permissions_in_use
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Formuła zwraca tabelę zawierającą zbiór używanych w plikach czynności w obecnej wersji uprawnień portalowych.
::   WE: _a [OBJECT] - obiekt multiprogress prezentujący postęp wczytywania funkcji praw
::   WY: Tabela zawierająca zbiór uprawnień na podstawie plików czynności
::----------------------------------------------------------------------------------------------------------------------
_LIST:=tab_tmp(1,
   'NAME'   ,'STRING[255]'                               ,'Nazwa funkcji praw'@,
   'ACTION' ,'STRING[%1]'[$MS.fld_len('B_ACTION','UID')] ,'Nazwa czynności'@
);
_progress:={? var_pres('_a')>100 || _a || return(_LIST) ?};

_progress.args.next_phase();
:: Informacje o zdefiniowanych czynnościach
_task:=app_info('task');

_size:=_task.size;
_progress_step:=(1/{? _size || _size || 1 ?});
_can_continue:=1;

{? _loop:=_task.first()
||
   {!
   |? _loop
   |!
      _can_continue*=exec('next_step','#progress',_progress.args,_progress.global_step,_progress_step);
      _progress.args.global_step(_progress_step/_progress.size);

      _filename:=(-~('!'+_task.SYMBOL));
      _permissionsString:=exec('string_fun','#file',_filename,'main','::# portal=',,'^','::#');

      {? var_pres('_split')>100 || obj_del(_split) ?};
      _split:=spli_str(_permissionsString,'\n');

      {? obj_len(_split)>0
      ||
         {? var_pres('_index')>100 || obj_del(_index) ?};
         _index:=obj_new('main','permission');
         {! _index.main:=1..obj_len(_split)
         |!
            _row:=gsub(gsub(_split[_index.main],' ',''),'\n','');

            {? _row<>'\n' & _row<>''
            ||
               {? var_pres('_splittedRow')>100 || obj_del(_splittedRow) ?};
               _splittedRow:=spli_str(_row,';');

               {! _index.permission:=1..obj_len(_splittedRow)
               |!
                  _permission:=gsub(gsub(_splittedRow[_index.permission],' ',''),'\n','');

                  {? _permission<>''
                  ||
                  _LIST.blank();
                  _LIST.NAME:=_permission;
                  _LIST.ACTION:=_task.SYMBOL;
                  _LIST.add()
                  ?}
               !}
            ?}
         !}
      ?};
      _loop:=(_can_continue & _task.next())
   !}
?};

{? ~_can_continue
|| _progress.args.ctr_stop();
   _LIST.erase()
|| _progress.global_step+=1;
   _progress.args.ph_sname(,'Zakończono: %1'@[_progress.args.ph_sname()])
?};

_LIST


\permissions_imported
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Formuła zwraca tabelę zawierającą zbiór używanych czynnościach w obecnej wersji uprawnień portalowych.
::   WE: _a [OBJECT] - obiekt multiprogress prezentujący postęp wczytywania funkcji praw
::   WY: Tabela zawierająca zbiór uprawnień na podstawie czynności (zapisów B_ACTION)
::----------------------------------------------------------------------------------------------------------------------
_LIST:=tab_tmp(2,
   'ACTION' ,'STRING[%1]'[$MS.fld_len('B_ACTION','UID')] ,'Nazwa czynności'@,
   'NAME'   ,'STRING[255]'                               ,'Nazwa funkcji praw'@
);
_progress:={? var_pres('_a')>100 || _a || return(_LIST) ?};

_progress.args.next_phase();

B_ACTION.cntx_psh();
B_ACTION.index('PORTAL');
B_ACTION.prefix('T',);

_progress_step:=(1/B_ACTION.size);
_can_continue:=1;

{? _loop:=B_ACTION.first()
|| {!
   |? _loop
   |!
      _can_continue*=exec('next_step','#progress',_progress.args,_progress.global_step,_progress_step);
      _progress.args.global_step(_progress_step/_progress.size);

      _LIST.blank();
      _LIST.ACTION:=B_ACTION.UID;

      {? B_ACTION.memo_get(,'PORT_OPR')
      || _memo:=B_ACTION.memo_txt(,,'PORT_OPR');
         {? _memo<>''
         ||
            {? var_pres('_permissions')>100 || obj_del(_permissions) ?};
            _permissions:=spli_str(_memo,'\n');

            {? obj_len(_permissions)>0
            || {! _index:=1..obj_len(_permissions)
               |!
                  _permission:=gsub(gsub(gsub(gsub(_permissions[_index],' ',''),'\n',''),'^',''),',','');

                  {? _permission<>'\n' & _permission<>''
                  ||
                     _LIST.blank();
                     _LIST.ACTION:=B_ACTION.UID;
                     _LIST.NAME:=_permission;
                     _LIST.add()
                  ?}
               !}
            ?}
         ?}
      ?};
      _loop:=(_can_continue & B_ACTION.next())
   !}
?};
B_ACTION.cntx_pop();

{? ~_can_continue
|| _progress.args.ctr_stop()
|| _progress.global_step+=1;
   _progress.args.ph_sname(,'Zakończono: %1'@[_progress.args.ph_sname()])
?};

_LIST


\permissions_statuses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Zwraca tymczasowy obiekt z informacjami o dostępnych statusach funkcji praw na potrzeby prezentacji.
::   WE:
::   WY: Obiekt tymczasowy z informacjami o statusach
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new(
:: Zaimplementowane oraz zaimportowane
   'implemented',
:: Brakujące (są w pliku z funkcjami praw, nie ma w plikach czynności systemu)
   'missing',
:: Są zawarte w plikach czynności, ale nie zostały zaimportowane do systemu (nie odbyła się aktualizacja czynności)
   'unimported',
:: Nie istnieją w pobranym pliku
   'nonexistent',
:: Wszystkie - jeden znak ozanczający status 'wszystkie' dla okien wertowania
   'all',
:: Mapa status - kolor
   'map',
:: Zwraca kolor dla przekazanego statusu
   'getColorFor'
);

_init:=
   "_element:=obj_new('code','desc','action');
    _element.code:={? var_pres('_a')=type_of('') & +_a=1 || _a || '' ?};
    _element.desc:={? var_pres('_b')=type_of('') || _b || '' ?};
    _element.action:={? var_pres('_c')=type_of('') || _c || '' ?};
    _element
   ";

_obj.implemented:=_init('Z','zaimplementowane'@,'&zaimplementowane'@);
_obj.missing:=_init('B','brakujące'@,'&brakujące'@);
_obj.unimported:=_init('I','niezaimportowane'@,'nieza&importowane'@);
_obj.nonexistent:=_init('N','nieistniejące'@,'&nieistniejące'@);
_obj.all:=_init('W','wszystkie'@,'&wszystkie'@);

_obj.map:=tab_tmp(1,
   'STATUS','STRING[1]' ,'Status',
   'COLOR' ,'STRING[11]','Kolor'
);

{! _index:=1..obj_len(_obj)-2
|!
   _status:=_obj[_index].code;
   _obj.map.blank();
   _obj.map.STATUS:=_status;
   _obj.map.COLOR:=
      {? _status=_obj.missing.code | _status=_obj.nonexistent.code
      || {? var_pres('Color')>100 || Color.fnd_kol('funkpraw#01#01') || '188:26:34' ?}
      |? _status=_obj.unimported.code
      || {? var_pres('Color')>100 || Color.fnd_kol('funkpraw#01#02') || '131:143:160' ?}
      || '0:0:0'
      ?};
   _obj.map.add()
!};

_obj.getColorFor:=
   "_result:='0:0:0';
    _status:={? var_pres('_a')=type_of('') & _a<>'' || _a || return(_result) ?};
    {? .map.find_key(_status,)
    || _result:=.map.COLOR
    ?};
    _result
   ";

_obj


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [23.25]
:: OPIS: Formuła wyświetlająca widoki techniczne: wniosków, faktur i delegacji na portalu HR i SEOD
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new(
   'TAB','win','MASKA',
   'add','select','setMask'
);
_obj.MASKA:=$(date~1)+2;
_obj.TAB:=tab_tmp(1,
   'NAME','STRING[255]','Nazwa',
   'F1','STRING[255]','Formuła 1',
   'F2','STRING[255]','Formuła 2'
);
_tab:=_obj.TAB;
_wer:=_tab.mk_sel('Widok danych portalu HR i SEOD','P',,'#wnfdsel',,,,,'U');
_tab.win_fld(_wer,,'NAME',,,40);
_tab.win_act(_wer,,'Formuła','Wybierz',,,"($cur_tab().F2)(params_get().obj.MASKA)",,1);
_tab.win_act(_wer,,'Formuła','Techniczna',,,"($cur_tab().F1)()");
_tab.win_act(_wer,,'Formuła','Zmień rok',,,"params_get().obj.setMask()");
_tab.win_act(_wer,,'Rekord',,,,"
   _tab:=cur_tab();
   _win:=_tab.win_sel('?');
   _gray:='';
   {? _tab.F1='' || _gray+='T' ?};
   {? _tab.F2='' || _gray+='B' ?};
   _tab.actions_grayed(_win,_gray);
   ~~
");
_tab.win_btn(_wer,'text=%1,btn_label_align=center,panel=right,align=begin'['&Wybierz'@],'menu:W');
_tab.win_btn(_wer,'text=%1,btn_label_align=center,panel=right,align=begin'['&Techniczna'@],'menu:T');
_tab.win_sel(_wer);

_obj.add:="
   _name:=_a;
   _f1:={? var_pres('_b')=type_of('') || _b || '' ?};
   _f2:={? var_pres('_c')=type_of('') || _c || '' ?};
   _tab:=.TAB;
   _tab.blank(1);
   _tab.NAME:=_a;
   _tab.F1:=_f1;
   _tab.F2:=_f2;
   _tab.add()
";

_obj.select:="
   params_set('obj',.);
   .setMask(0);
   _tab:=.TAB;
   _tab.select()
";

_obj.setMask:="
   _edit:={? var_pres('_a')=type_of(1) || _a || 1 ?};
   {? _edit
   || undefine();
      define('MASKA',.MASKA,'Rok: 20',,2,5);
      {? def_edit(\"
            {? +DEFINE.MASKA<>2
            || FUN.info('Wymagana długość to 2 znaki.');
               'MASKA'
            |? #DEFINE.MASKA=0 & DEFINE.MASKA<>'00'
            || FUN.info('Wymagana liczba.');
               'MASKA'
            || ~~
            ?}
         \",'Rok')
      || .MASKA:=DEFINE.MASKA
      ?};
      undefine()
   ?};
   _tab:=.TAB;
   _tab.hdr_sel('');
   _tab.hdr_sel(' - rok 20'+.MASKA)
";

_obj.add('Wnioski kadrowe',
   $"exec('EDOKUM_sel','portal_wnioski','_1')",
   $"exec('EDOKUM_sel','portal_wnioski',_a)"
);
_obj.add('Wnioski urlopowe',
   $"exec('EDOKUM_sel','portal_wnioski','_1','X')",
   $"exec('EDOKUM_sel','portal_wnioski','wu','X')"
);
_obj.add('Wnioski paperless',
   $"exec('EDOKUM_sel','portal_wnioski','_1','P')",
   $"exec('EDOKUM_sel','portal_wnioski',_a,'P')"
);
_obj.add('Wnioski pozostałe',
   $"exec('EDOKUM_sel','portal_wnioski','_1','s')",
   $"exec('EDOKUM_sel','portal_wnioski',_a,'s')"
);
_obj.add('Faktury',
   ,
   $"exec('EDOKUM_sel','portal_seod',_a,'S')"
);
_obj.add('Delegacje',

   ,$"exec('EDOKUM_sel','portal_wnioski',_a,'D','D')"
);
_obj.add('Wnioski inTerm',
   ,
   $"exec('EDOKUM_sel','portal_wnioski',_a,'n')"
);
_obj.select()


\test_sync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.51]
:: OPIS: Testowanie, czy dana tabela z przeznaczenia danych ma wszytkie rekordy zsynchronizowane.
::       Wymuszenie wysyłki rekordów poprzez podbicie ich IDPUT.
::   WE: [_a] - SYNC_PD.SYM - domyślnie PORTAL
::       [_b] - czy uruchomienie z wyborem tabel ([1]/0) - w trybie bez wyboru obrabiane są wszystkie tabele
::              wybranego przeznaczenia danych
::----------------------------------------------------------------------------------------------------------------------
_pd_sym:={? var_pres('_a')=type_of('') || _a || 'PORTAL' ?};
_dialog:={? var_pres('_b')=type_of(0) || _b || 1 ?};

_msg:=
   'Funkcja wyświetla uidref() rekordów tabel, które są przeznaczone do wysłania na Portal HR w ramach wybranego\n'
   'przeznaczenia danych (np. PORTAL).\n'
   'Kryterium wysłania określone jest w definicji wymiany danych - z reguły dotyczy ograniczenia do bieżącej firmy.\n\n'
   'Dla każdego rekordu sprawdzane jest, czy pobrany został przez API identyfikator rekordu z portalu.\n'
   'Jeżeli identyfikator nie został pobrany, to uznaje się, że rekord nie został jeszcze zsynchronizowany.\n\n'
   'Funkcja WYMUŚ WYSŁANIE spowoduje podbicie IDADD wskazanych rekordów, dzięki czemu zostanie wymuszona ponowna\n'
   'wysyłka ich na portal.\n\n'
   'Uwaga: nie wszystkie rekordy oznaczone jako niezsynchronizowane podlegają wysyłce, ponieważ oprócz reguł\n'
   'określonych w definicji wymiany danych wprowadzone są jeszcze reguły w ramach formuł przygotowujących dane\n'
   '(formuły \\*_args umieszczone w plikach portal_method_*.fml).\n\n'
   'Wybrane przeznaczenie danych: %1.'@
   [_pd_sym]+'\n'+
   {? _dialog
   || 'Uruchomiono w trybie z wyborem tabel.'@
   || 'Uruchomiono w trybie bez wyboru tabel (analizowane będą wszytkie tabele z wybranego przeznaczenia danych.'@
   ?}+'\n\n'+
   'Czy kontynuować?'@;

_ask:=FUN.ask(_msg);

{? _ask=0 || return() ?};

:: Tabela wynikowa do analizy
_komm:=tab_tmp(2
   ,'TAB_ACR','STRING[8]','Akronim tabeli'@
   ,'ID_CODE','STRING[30]','Identyfikator synchronizacji'@
   ,'SYNC','STRING[1]','Zsynchronizowany'@
   ,'DESC','STRING[100]','Opis'@
);

:: Przygotowanie indeksu tabeli SYNC_IDD (może być brak stałego w definicji systemu)
SYNC_IDD.cntx_psh();
_ndx:=SYNC_IDD.ndx_tmp(,,'SYSTEM',,,'TABELA',,);
SYNC_IDD.index(_ndx);

:: Pętla po tabelach wybranego przeznaczenia danych (opcjonalnie z możliwością wyboru)
SYNC_PD.cntx_psh();
SYNC_PD.index('SYM');
SYNC_PD.prefix(_pd_sym,);
{? SYNC_PD.first()
|| _tab_wyb:=sql('
      select distinct
         SYNC_MWA.TAB_ACR,
         case when SYNC_DEF.WAR_FORM=\'\' then \'1\' else SYNC_DEF.WAR_FORM end as WAR_FORM,
         \':_b\' as ACCESS
      from SYNC_MWA
      join SYNC_PD using(SYNC_MWA.SYNC_PD,SYNC_PD.REFERENCE)
      join SYNC_DEF using(SYNC_DEF.SYNC_PD,SYNC_PD.REFERENCE)
      where SYNC_MWA.SYNC_PD=:_a and SYNC_MWA.TAB_ACR<>\'\' and SYNC_MWA.TAB_ACR=SYNC_DEF.ACR_TAB
      order by TAB_ACR
   ',SYNC_PD.ref(),{? _dialog || 'N' || 'T' ?});
   _wer_wyb:=_tab_wyb.mk_sel('Wybierz tabele przeznaczenia %1'@[_pd_sym],'P',,'#wybtabtotest',,,20,,'U');
   _tab_wyb.win_fld(_wer_wyb,,'TAB_ACR',,,20,,,'Tabela'@);
   _tab_wyb.win_fld(_wer_wyb,,'WAR_FORM',,,50,,,'Warunek zapamiętywania'@);
   _formula:="
      _tab:=cur_tab(1,1);
      {? _tab.WAR_FORM='' || _tab.WAR_FORM:='1' ?};
      _tab.ACCESS:='T';
      _tab.put();
      sel_exit()
   ";
   _tab_wyb.win_act(_wer_wyb,,'Formuła','&Wybierz'@@,,,_formula,,1,1,,,'W');
   _tab_wyb.win_btn(_wer_wyb,'text=%1,btn_label_align=center,panel=bottom,align=end'['&Wybierz'@],'menu:W');
   _tab_wyb.win_btn(_wer_wyb,'text=%1,btn_label_align=center,panel=bottom,align=end'['&Anuluj'@],'key:Esc');
   _tab_wyb.win_sel(_wer_wyb);

   _time_start:='';
   {? ~_dialog | _tab_wyb.select()
   || {? _tab_wyb.first()
      || {!
         |? {? _tab_wyb.ACCESS='T'
            || _tab_acr:=_tab_wyb.TAB_ACR;

::             Pętla po definicjach identyfikatorów dla danej tabeli (może być kilka definicji, np. tabele H, EDOKUM)
               SYNC_IDD.prefix('PORTAL',_tab_acr,);
               {? SYNC_IDD.first()
               || {!
                  |?
                     _id_code:=SYNC_IDD.KOD;

                     SYNC_DEF.cntx_psh();
                     SYNC_DEF.index('PDNR');
                     SYNC_DEF.prefix(exec('FindInSet','#table','SYNC_PD','SYM',_pd_sym,,,1),_tab_acr,);
                     {? SYNC_DEF.first()
                     ||
                        _tab:=($_tab_acr)();
                        _names:=_tab.names();
                        {? _names.first()
                        || {!
                           |? _tab.use(_names.NAME);
                              _tab.cntx_psh();
                              _tab.prefix();
                              {? _tab.first()
                              || {!
                                 |?
::                                  Przetwarzane tylko rekordy spełniające warunek SYNC_DEF.WAR_FORM
                                    {? ($_tab_wyb.WAR_FORM)('put',3+REF.INFO,REF.FIRMA)
                                    || _id_tab:=exec('get_id','#sync_id',_id_code,_tab.uidref());
                                       _komm.blank();
                                       _komm.TAB_ACR:=_tab_acr;
                                       _komm.ID_CODE:=_id_code;
                                       {? type_of(_id_tab)>100 & _id_tab.first()
                                       || _komm.SYNC:='T'
                                       || _komm.SYNC:='N'
                                       ?};
                                       _komm.DESC:=_tab.uidref();
                                       _komm.add();
                                       {? type_of(_id_tab)>100 || obj_del(_id_tab) ?}
                                    ?};

                                    _tab.next()
                                 !}
                              ?};
                              _tab.cntx_pop();
                              _names.next()
                           !}
                        ?};
                        obj_del(_names);
                        obj_del(_tab);
                        ~~
                     ?};
                     SYNC_DEF.cntx_pop();

                     SYNC_IDD.next()
                  !}
               ?}
            ?};
            _tab_wyb.next()
         !}
      ?}
   ?}
?};
SYNC_PD.cntx_pop();

SYNC_IDD.ndx_drop();
SYNC_IDD.cntx_pop();

{? _komm.first()
|| _wer:=_komm.mk_sel('Dane do analizy'@,,,'danedoanal',,,,,'U');
   _komm.win_fld(_wer,,'TAB_ACR');
   _komm.win_fld(_wer,,'ID_CODE');
   _komm.win_fld(_wer,,'SYNC',,,-10,,,,,,2,,"'T'","'N'");
   _komm.win_fld(_wer,,'DESC');
   _formula:="
      _tab:=cur_tab(1,1);
      {? _tab.sel_size()>0 | FUN.ask('Czy wymusić ponowną wysyłkę zaznaczonego rekordu?'@)
      || exec('FindAndGet','#table',_tab.TAB_ACR,_tab.DESC,,\"put(,1)\",~~)
      ?};
      ~~
   ";
   _fbg:="
      FUN.ask('Czy wymusić ponowną wysyłkę zaznaczonych rekordów?'@)
   ";
   _komm.win_act(_wer,,'Formuła','&Wymuś wysłanie'@@,,,_formula,,1,1,_fbg,,'W');
   _komm.win_sel(_wer);
   _komm.select()
|| FUN.info('Brak danych do analizy.'@)
?};
~~


\portalu_w
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Prezentacja wzorca funkcji praw.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=sql(
   'select PORTALU.OPR_NAME, PORTALU.OPR_DESC, PORTALU.PTH_NAME, PORTALU.PTH_DESC, '
          'lower(PORTALU.OPR_NAME) as "FIND", 0 as "COUNT", cast(\'\' as SYS_MEMO_TYPE) as "ACTIONS" '
   'from PORTALU '
   'where PORTALU.TYPE=\'W\' '
   'order by PORTALU.OPR_NAME '
);
_TAB.fld_attr('FIND',2);
_ndx:=obj_new('OPR_NAME','FIND');
_ndx.OPR_NAME:=_TAB.index('?');
_ndx.FIND:=_TAB.ndx_tmp(,1,'FIND',,);

B_ACTION.cntx_psh();
B_ACTION.index('PORTAL');
B_ACTION.prefix('T',);
{? B_ACTION.first()
|| KOMM.init(,,'Nieistniejące funkcje praw użyte w czynnościach'@);
   _TAB.index(_ndx.FIND);
   {!
   |? _fp:=spli_str(gsub(B_ACTION.memo_txt(,1,'PORT_OPR'),'\n',''),',');
      _size:=obj_len(_fp);
      {! _lp:=1 .. _size
      |! {? _fp[_lp]<>''
         || {? _TAB.find_key(-_fp[_lp],)
            || _txt:=form(_TAB.memo_txt(,1,'ACTIONS'));
               _txt+={? _txt='' || '' || ',' ?}+B_ACTION.UID;
               _TAB.memo_set(_txt,'ACTIONS');
               _TAB.memo_put(,'ACTIONS');
               _TAB.COUNT+=1;
               _TAB.put()
            || KOMM.add('%1 [%2]'[_fp[_lp],B_ACTION.UID])
            ?}
         ?}
      !};
      obj_del(_fp);
      B_ACTION.next()
   !};
   _TAB.index(_ndx.OPR_NAME);
   KOMM.select()
?};
B_ACTION.cntx_pop();

_ws:=_TAB.mk_sel('Funkcje praw'@,,,,,,,,'U');
_TAB.win_fld(_ws,,'OPR_NAME',,,40);
_TAB.win_fld(_ws,,'OPR_DESC',,,30);
_TAB.win_fld(_ws,,'PTH_NAME',,,50);
_TAB.win_fld(_ws,,'PTH_DESC',,,50);
_TAB.win_fld(_ws,,'COUNT',,,-5);
_TAB.win_fld(_ws,,'ACTIONS',,,30);
_TAB.win_act(_ws,,'Szukaj');
_TAB.win_act(_ws,,'Kolejność');
_TAB.win_sel(_ws);

_we:=_TAB.mk_edit('Funkcja praw'@);
_TAB.win_esep(_we,'Dane podstawowe'@);
_TAB.win_efld(_we,,'OPR_NAME');
_TAB.win_efld(_we,,'OPR_DESC');
_TAB.win_efld(_we,,'PTH_NAME');
_TAB.win_efld(_we,,'PTH_DESC');
_TAB.win_efld(_we,,'COUNT');
_TAB.win_efld(_we,,'ACTIONS',,,100,-3);
_TAB.win_edit(_we);
_TAB.select()

:Sign Version 2.0 jowisz:1045 2024/01/12 14:16:44 7a9e8e634bfca916f933a8d86b404956a8118d2c9fc7908ffa97cf19f39f6445bd387043cd09771650d1b33343dcb00bbfe3c5b153b2bd8ccd72c20094922cebc607fcd394d4eb16aceadab9926c649cd031981adda8df45388048559fa5a8406b128f984abe87cd00e0e99beeea13a899f9574d2d90f79421c7103483d2a292
