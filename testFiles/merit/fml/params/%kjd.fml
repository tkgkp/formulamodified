:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: %kjd.fml
:: Utworzony: 14.09.2021
:: Autor: RWR
::======================================================================================================================
:: Zawartość: Formuły obsługi kontroli jakości danych.
::
:: Testy dedykowane mogą być uruchamiane również wsadowo (patrz opis formuły \dedyki).
::======================================================================================================================


\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Formuła główna mechanizmu kontroli jakości danych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
popup(1,'Kontrola Jakości Danych'@
   ,'Testy dedykowane'@
   ,'Testy weryfikujące konkretne przypadki'@
   ,"exec('dedyki','%kjd')"

   ,'Testy zbiorowe'@
   ,'Testy techniczne wykonywane dla wszystkich tabel'@
   ,"exec('zbiorowki','%kjd')"
)


\dedyki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Formuła wywoływana w dwóch kontekstach:
::        * Obsługa menu testów dedykowanych.
::        * Wsadowe wykonanie wskazanego testu.
::   WE: [_a] [STRING] - Kod testu dedykowanego do uruchomienia.
::       [_b] [NUMBER] - Tryb wsadowy [0*/1]. Parametr ma znaczenie tylko dla _a<>''.
::   WY: Przyczyna niepowodzenia (napis) lub uchwyt tabeli tymczasowej z niepoprawnymi rekordami (dla _a<>'').
::----------------------------------------------------------------------------------------------------------------------
_kod:={? var_pres('_a')=type_of('') || _a || '' ?};
_wsad:=_kod<>'' & var_pres('_b')=type_of(0) & _b;

exec('xml_t_decl','#xml_t');

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:: Obsługa słownika tabel w systemie.
_TABLE:=obj_new('TAB','NDX','ws');

_TABLE.TAB:=tab_tmp(1
   ,'ACR','STRING[8]','Akronim'@
   ,'MASKA','STRING[8]','Maska'@
   ,'KOMENT','STRING[60]','Komentarz'@
);

_TABLE.NDX:=obj_new('ACR');
_TABLE.NDX.ACR:=_TABLE.TAB.index('?');

_TABLE.ws:=_TABLE.TAB.mk_sel('Tabele'@,,,'#kjd_tables',,,,,'U',,,,,'normal');
_TABLE.TAB.win_fld(_TABLE.ws,,'MASKA',,,,,,,,'Maska tabeli'@);
_TABLE.TAB.win_fld(_TABLE.ws,,'ACR',,,,,,,,'Akronim tabeli'@);
_TABLE.TAB.win_fld(_TABLE.ws,,'KOMENT',,,,,,,,'Koemtarz'@);
_TABLE.TAB.win_act(_TABLE.ws,,'Formuła','Wybierz'@@,,,"sel_exit()",,1,,,,'W');
_TABLE.TAB.win_sel(_TABLE.ws);

{! _lp:=1 .. tab_num()
|! {? tab_real(_lp)
   || _TABLE.TAB.blank();
      _TABLE.TAB.ACR:=tab_acr(_lp);
      _TABLE.TAB.MASKA:=($_TABLE.TAB.ACR)().name();
      _TABLE.TAB.KOMENT:=($_TABLE.TAB.ACR)().comment();
      _TABLE.TAB.add()
   ?}
!};

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:: Obsługa tabeli z wynikami testów.
_RES:=obj_new('TAB','NDX','add','ws','we','TFLD');

_RES.TAB:=tab_tmp(2
:: Pole TEST wystarczyłoby - KOD i TABELA są do filtrowania
   ,'KOD','STRING[31]','Kod'@
   ,'TABELA','STRING[8]','Tabela'@
   ,'UIDREF','STRING[48]','uidref'
   ,'ID','STRING[255]','Dziedzina'@
   ,'MSG','STRING[255]','Komunikat'@
   ,'DOD','SYS_MEMO','Dodatkowe informacje'@
   ,'TEST','STRING[16]','Wskazanie na test'@
);

_RES.NDX:=obj_new('UNIQUE');
_RES.NDX.UNIQUE:=_RES.TAB.index('?');

_RES.add:="
::  _a  [STRING] - Dziedzina.
::  _b  [STRING] - Komunikat.
:: [_c] [STRING] - Dodatkowe informacje.
   .TAB.blank();
   .TAB.ID:=_a;
   .TAB.MSG:=_b;
   {? .TAB.add()
   || {? var_pres('_c')=type_of('') & _c<>''
      || .TAB.memo_set(_c,'DOD');
         .TAB.memo_put(,'DOD')
      || 1
      ?}
   ?}
";

:: Obsługa prezentacji niepoprawnego rekordu.
_RES.TFLD:=obj_new('TAB','ws','we');
_RES.TFLD.TAB:=tab_tmp(1
   ,'LP','INTEGER','Lp.'@
   ,'ACR','STRING[8]','Akronim'@
   ,'NAME','STRING[60]','Nazwa'@
   ,'COMMENT','STRING[60]','Komentarz'@
   ,'TYPE','STRING[11]','Typ'@
:: Wartość (dla typów prostych) lub tekstowa reprezentacja wartości.
   ,'VALS','STRING[255]','Wartość'@
:: Pozostałe wartości.
   ,'VALM','SYS_MEMO','Wartość'@
   ,'VALBI','BLOBIMAGE','Wartość'@
   ,'VALBR','BLOBRAW','Wartość'@
:: Informacje o pliku.
   ,'SIZE','INTEGER','Rozmiar'@
   ,'CRT_DATE','DATE','Data utworzenia'@
   ,'CRT_TIME','TIME','Godzina utworzenia'@
   ,'MOD_DATE','DATE','Data modyfikacji'@
   ,'MOD_TIME','TIME','Godzina modyfikacji'@

);

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:: Obsługa testów dedykowanych.
_TEST:=obj_new('dro','interm','fn','FN','TAB','NDX','typ','ws','we','set_we','buf','eksportuj');
_TEST.dro:=exec('runtime_dro','#system');
_TEST.interm:=cli_ver()='interm';
:: Kolejność pól w tablicy fn jest istotna!
_TEST.fn:=obj_new('s','w');
_TEST.fn.s:='std_kjd.dfg';
_TEST.fn.w:='wdr_kjd.dfg';
_TEST.FN:=tab_tmp(1
   ,'S','STRING[255]','Systemowa'@
   ,'W','STRING[255]','Wdrożeniowa'@
);

_sep:=exec('sep','#file',1);
_TEST.FN.blank();
_TEST.FN.S:='%1%2%3'[pth_dir(_TEST.fn.s),_sep,_TEST.fn.s];
_TEST.FN.W:='%1%2%3'[pth_dir(_TEST.fn.w),_sep,_TEST.fn.w];
_TEST.FN.add();

_we:=_TEST.FN.mk_edit('Pliki z definicjami'@,,'#kjd_dedykfn');
_TEST.FN.win_esep(_we,'Ścieżki dostępu'@);
_TEST.FN.win_efld(_we,,'S',,,60,,,,,'Ścieżka dostępu do pliku z definicjami systemowymi'@);
_TEST.FN.win_efld(_we,,'W',,,60,,,,,'Ścieżka dostępu do pliku z definicjami wdrożeniowymi'@);
_TEST.FN.win_edit(_we);
:: Flaga poprawności eksportu / dostępności akcji Eksportuj.
_TEST.eksportuj:=0;
:: "Metoda" ustawiająca okno redagowania i formułę na wartość poczzątkową pola _TEST.TYP.
_TEST.set_we:="
   .typ:=_a;
   {? .typ='FML'
   || .TAB.win_edit(.we.FML)
   |? .typ='SQL'
   || .TAB.win_edit(.we.SQL)
   || .typ:='';
      .TAB.win_edit('')
   ?};
   .TAB.fld_fml('TYP','BLANK',$('\\''+.typ+'\\''));
   .typ<>''
";

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

params_set(
   'TEST',_TEST
   ,'TABLE',_TABLE
   ,'RES',_RES
);

{? ~exec('_dedyk_tab','%kjd')
|| _msg:='Utworzenie interfejsu testów dedykowanych nie powiodła się.'@;
   {? ~_wsad
   || FUN.info(_msg)
   ?};
   return(_msg)
?};

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:: Definiowanie okien
{? _kod=''
|| exec('_dedyk_res_wnd','%kjd');
   exec('_dedyk_res_tfld_wnd','%kjd');
   exec('_dedyk_test_wnd','%kjd')
?};

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

{? _kod=''
|| _TEST.TAB.select();
   {? _TEST.eksportuj
   || exec('_dedyk_test_export','%kjd')
   ?};
   ''
|? _TEST.TAB.find_key(_kod,)
|| exec('_dedyk_test_run_b','%kjd',1)
|| 'Nieznaleziono definicji testu o kodzie %1.'@ [_kod]
?}


\_dedyk_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Tworzenie głównej tabeli prezentującej testy dedykowane.
::   WE:
::   WY: Dołączenie do tabeli tymczasowej na serwerze (lub jej utworzenie) powiodło się: 0/1.
::----------------------------------------------------------------------------------------------------------------------
params_set(_par:=params_get());
_TEST:=_par.TEST;

{? OSOBA.lock(1,,1)
|| _ident:='KJD_TestyDedykowane';
   _STLIST:=st_list(_ident,0);
   _TEST.TAB:={? _STLIST.first() || st_open(_STLIST.IDENT) || ~~ ?};
   {? type_of(_TEST.TAB)=type_of(~~)
::    Brak tabeli tymczasowej na serwerze - tworzymy ją.
   || _TEST.TAB:=st_create(1
         ,'KOD','STRING[31]','Kod'@
         ,'SYSTEM','STRING[1]','System'@
         ,'TYP','STRING[3]','Typ'@
         ,'TABELA','STRING[8]','Tabela'@
         ,'OPIS','SYS_MEMO','Opis'@
         ,'KLUCZE','STRING[255]','Klucze'@
         ,'PROLOG','SYS_MEMO','Prolog'@
         ,'TEST','SYS_MEMO','Test'@
         ,'EPILOG','SYS_MEMO','Epilog'@
         ,'INFO','SYS_MEMO','Szczegóły'@
      );
      _TEST.TAB.st_id_make(OSOBA.name(0),_ident,300)
   ?};

:: Formuły dla pól.
   {? _TEST.dro
   || _TEST.TAB.fld_fml('KOD','PATTERN',"'Uu!'");
      _TEST.TAB.fld_fml('SYSTEM','BLANK',"'T'");
      _TEST.TAB.fld_fml('SYSTEM','AFTER_EDIT',"params_exec('_dedyk_test_system_ae','%kjd')")
   || _TEST.TAB.fld_fml('KOD','PATTERN',"'Qu!'");
      _TEST.TAB.fld_fml('SYSTEM','BLANK',"'N'");
      _TEST.TAB.fld_fml('SYSTEM','BEFORE_EDIT',"0")
   ?};

   _TEST.TAB.fld_fml('TABELA','PATTERN',"'Uu!'");
   _TEST.TAB.fld_fml('TABELA','F3',"params_exec('_dedyk_test_tabela_f3','%kjd')");
   _TEST.TAB.fld_fml('TABELA','AFTER_EDIT',"params_exec('_dedyk_test_tabela_ae','%kjd')");
   _TEST.TAB.fld_fml('KLUCZE','PATTERN',"'u!'");

:: Wyzwalacze.
   _ref:=form(_TEST.TAB.name(),8)+'00000001';
   _TEST.TAB.trig_b('put',$("exec('_dedyk_test_putb','%kjd',ref_tab('"+_ref+"'))"));
   _TEST.TAB.trig_b('add',$("exec('_dedyk_test_addb','%kjd',ref_tab('"+_ref+"'))"));
   _TEST.TAB.trig_b('memo_put',$("exec('_dedyk_test_memo_putb','%kjd',ref_tab('"+_ref+"'),_a)"));

:: Indeksy.
   _TEST.NDX:=obj_new('UNIQUE');
   _TEST.NDX.UNIQUE:=_TEST.TAB.index('?');

:: Import danych.
   {? ~_TEST.TAB.first()
   || exec('_dedyk_test_import','%kjd')
   ?};

   OSOBA.unlock();
   1

?}


\_dedyk_res_wnd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Definiowanie okien dla tabeli tymczasowej na wyniki przetwarzania.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_par:=params_get();
_TEST:=_par.TEST;
_RES:=_par.RES;

_RES.ws:=_RES.TAB.mk_sel('Niepoprawne rekordy'@,'P',,'#kjd_dedresws',,,,,'U');
_RES.TAB.win_fld(_RES.ws,,'KOD',,,25,,,,,'Kod identyfikujący test'@);
_RES.TAB.win_fld(_RES.ws,,'TABELA',,,-9,,,,,'Akronim tabeli, której dotyczy test'@);
_RES.TAB.win_fld(_RES.ws,,'UIDREF',,,15,,,,,'uidref rekordu'@);
_RES.TAB.win_fld(_RES.ws,,'ID',,,20,,,,,'Informacja identyfikująca rekord'@);
_RES.TAB.win_fld(_RES.ws,,'MSG',,,20,,,,,'Przyczyna uznania rekordu za niepoprawny'@);
_RES.TAB.win_fld(_RES.ws,,'DOD',,,20,,,,,'Dodatkowe informacje'@);
_RES.TAB.win_act(_RES.ws,,'Formuła','Pokaż &rekord'@@,,'Pokazanie wszystkich pól rekordu'@
   ,"params_exec('_dedyk_res_tfld_wer','%kjd')",
   ,1,,,
   ,'R'
);
_RES.TAB.win_act(_RES.ws,,'Wyświetl',,,,"
   _par:=params_get();
   _RES:=_par.RES;
   _TEST:=_par.TEST;
   _TEST.TAB.cntx_psh();
   _TEST.TAB.prefix();
   {? _TEST.TAB.seek(_RES.TAB.TEST,)
   || _TEST.TAB.memo_get(,'OPIS');
      _RES.TAB.display()
   ?};
   _TEST.TAB.cntx_pop();
   ~~
");
_RES.TAB.win_sel(_RES.ws);

_RES.we:=_RES.TAB.mk_edit('Niepoprawny rekord'@,,'#kjd_dedreswe',,,{? _TEST.interm || 'html_maximized' || 'normal' ?});
_RES.TAB.win_esep(_RES.we,'Test'@);
_RES.TAB.win_efld(_RES.we,,'KOD',,,,,,,,'Kod identyfikujący test'@);
_RES.TAB.win_efld(_RES.we,,'TABELA',,,,,,,,'Akronim tabeli, której dotyczy test'@);
_RES.TAB.win_efld(_RES.we,_TEST.TAB,'OPIS',,,120,-3,,,,'Opis działania / zakresu testu'@);
_RES.TAB.win_esep(_RES.we,'Dane o zapisie'@);
_RES.TAB.win_efld(_RES.we,,'UIDREF',,,,,,,,'uidref rekordu'@);
_RES.TAB.win_efld(_RES.we,,'ID',,,120,,,,,'Informacja identyfikująca rekord'@);
_RES.TAB.win_efld(_RES.we,,'MSG',,,120,,,,,'Przyczyna uznania rekordu za niepoprawny'@);
_RES.TAB.win_esep(_RES.we,'Dodatkowe informacje'@);
_RES.TAB.win_efld(_RES.we,,'DOD',,,120,-5,,,1,'Dodatkowe informacje'@);
_RES.TAB.win_edit(_RES.we);

~~


\_dedyk_res_tfld_wnd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Definiowanie interfejsu prezentacji niepoprawnego rekordu.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_par:=params_get();
_RES:=_par.RES;

_RES.TFLD.ws:=_RES.TFLD.TAB.mk_sel('Pola rekordu'@,,,'#kjd_res_tfld',,,,,'U');
_RES.TFLD.TAB.win_fld(_RES.TFLD.ws,,'LP',,,-4,,,,,'Liczba porządkowa'@);
_RES.TFLD.TAB.win_fld(_RES.TFLD.ws,,'ACR',,,-9,,,,,'Akronim pola'@);
_RES.TFLD.TAB.win_fld(_RES.TFLD.ws,,'NAME',,,40,,,,,'Nazwa pola'@);
_RES.TFLD.TAB.win_fld(_RES.TFLD.ws,,'TYPE',,,-12,,,,,'Typ pola'@);
_RES.TFLD.TAB.win_fld(_RES.TFLD.ws,,'VALS',,,50,,,,,'Wartość pola'@);
_RES.TFLD.TAB.win_act(_RES.TFLD.ws,,'Wyświetl',,,,"
   _RES:=params_get().RES;
   _type:=_RES.TFLD.TAB.TYPE;
   _we:='';
   {? _type='SYS_MEMO'
   || _we:=_RES.TFLD.we.m
   |? _type='BLOBIMAGE' | (_type='BLOBRAW' & _RES.TFLD.TAB.VALBI)
   || _we:=_RES.TFLD.we.bi
   |? _type='BLOBRAW'
   || _we:=_RES.TFLD.we.br
   || _we:=_RES.TFLD.we.s
   ?};
   {? _we<>''
   || _RES.TFLD.TAB.win_edit(_we);
      _RES.TFLD.TAB.display()
   ?};
   ~~
");
_RES.TFLD.TAB.win_sel(_RES.TFLD.ws);

:: Dedykowane okna redagowania (w zależności od typu pola).
_RES.TFLD.we:=obj_new('s','m','bi','br');
{! _lp:=1 .. obj_len(_RES.TFLD.we)
|! _szer:=60;
   _RES.TFLD.we[_lp]:=_RES.TFLD.TAB.mk_edit('Pole'@,,'#kjd_res_tfld');
   _RES.TFLD.TAB.win_esep(_RES.TFLD.we[_lp],'Dane podstawowe'@);
   _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'LP',,,,,,,,'Liczba porządkowa'@);
   _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'ACR',,,_szer,,,,,'Akronim pola'@);
   _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'NAME',,,_szer,,,,,'Nazwa pola'@);
   _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'COMMENT',,,_szer,,,,,'Komentarz'@);
   _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'TYPE',,,_szer,,,,,'Typ pola'@);
   {? _lp<>2
   || _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'VALS',,,_szer,,,,,'Tekstowa reprezentacja wartości'@)
   |? _lp=2
   || _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'VALM',,,_szer,-5,,,,'Wartość pola'@)
   ?};
   {? _lp=3 | _lp=4
   || _RES.TFLD.TAB.win_esep(_RES.TFLD.we[_lp],'Informacje o pliku'@);
      _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'VALBR',,,_szer,,,'Nazwa'@,,'Wartość pola'@);
      _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'SIZE',,,10,,,,,'Rozmianr pliku'@);
      _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'CRT_DATE',,,,,,,,'Data utworzenia pliku'@);
      _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'CRT_TIME',,,10,,,,,'Godzina utworzenia pliku'@,,'F3_button=0');
      _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'MOD_DATE',,,,,,,,'Data modyfikacji pliku'@);
      _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'MOD_TIME',,,10,,,,,'Godzina modyfikacji pliku'@)
   ?};
::    Wyłączamy prezentację BLOBIMAGE
::   {? _lp=3
::   || _RES.TFLD.TAB.win_ecol(_RES.TFLD.we[_lp]);
::      _RES.TFLD.TAB.win_efld(_RES.TFLD.we[_lp],,'VALBI',,,,17,,,0,'Wartość pola'@)
::   ?};
   ~~
!};

~~


\_dedyk_res_tfld_wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa (w oknie wertowania) prezentacji niepoprawnego rekordu.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
params_set(_par:=params_get());
_RES:=_par.RES;

_TAB:=($_RES.TAB.TABELA)();
_TAB.cntx_psh();
_wm:=ref_name(_RES.TAB.UIDREF);
{? _TAB.name()<>_wm
|| _TAB.use(_wm)
?};
_TAB.prefix();
{? _TAB.seek(_RES.TAB.UIDREF)
|| _RES.TFLD.TAB.erase();
   _val:="($('_a.%1'[_b]))(_a)";
   {! _lp:=1 .. _TAB.fld_num()
   |! _acr:=_TAB.fld_acr(_lp);
      _RES.TFLD.TAB.blank();
      _RES.TFLD.TAB.memo_set(,'VALM');
      _RES.TFLD.TAB.bl_file('VALBI',1);
      _RES.TFLD.TAB.bl_file('VALBR',1);
      _RES.TFLD.TAB.LP:=_lp;
      _RES.TFLD.TAB.ACR:=_acr;
      _RES.TFLD.TAB.NAME:=_TAB.fld_name(_lp);
      _RES.TFLD.TAB.COMMENT:=_TAB.fld_comm(_lp);
      _val:=($('_a.%1'[_acr]))(_TAB);
      _vals:='!!!';
      _vp:=var_pres(_acr,_TAB,'diff_blob');
      _type:='!!!';
      {? _vp=20
      || _type:='REAL';
         _vals:=$_val
      |? _vp=21
      || _type:='DATE';
         _vals:=_val$1
      |? _vp=22
      || _type:='INTEGER';
         _vals:=$_val
      |? _vp=24
      || _type:='HEADER';
         _vals:=''
      |? _vp=25
      || _type:='MEMO'
      |? _vp=26
      || _type:='_%1'[_TAB.fld_join(_lp)];
         _vals:=$_val
      |? _vp=27
      || _type:='STRING[%1]' [$($('_val:=_a.%1; _a.%1:=256*\'a\'; _ret:=+_a.%1; _a.%1:=_val; _ret'[_acr]))(_TAB)];
         _vals:=_val
      |? _vp=29
      || _type:='TIME';
         _vals:=_val$3
      |? _vp=30
      || _type:='REFERENCE';
         _vals:=$_val
      |? _vp=32
      || _type:='TREE_REF';
         _vals:=$_val
      |? _vp=33
      || _type:='BLOBRAW';
         _vals:=$_val;
         _RES.TFLD.TAB.VALBR:=_val;
         {? _TAB.bl_info(_acr,'IMAGE')
         || _RES.TFLD.TAB.VALBI:=_val
         ?}
      |? _vp=36
      || _type:='SYS_MEMO';
         _vals:=_TAB.memo_txt(,1,_acr)
      |? _vp=37
      || _type:='BLOBIMAGE';
         _vals:=$_val;
         _RES.TFLD.TAB.VALBR:=_val;
         _RES.TFLD.TAB.VALBI:=_val
      |? _vp=38
      || _type:='IDTIME';
         _vals:=_val
      |? _vp=39
      || _type:='IDADD';
         _vals:=_val
      |? _vp=40
      || _type:='IDTPUT';
         _vals:=_val
      ?};
      _RES.TFLD.TAB.TYPE:=_type;
      _RES.TFLD.TAB.VALS:=_vals;
      {? _type='BLOBIMAGE' | _type='BLOBRAW'
      || _RES.TFLD.TAB.SIZE:=_TAB.bl_info(_acr,'SIZE');
         _RES.TFLD.TAB.CRT_DATE:=_TAB.bl_info(_acr,'CREAT_DATE');
         _RES.TFLD.TAB.CRT_TIME:=_TAB.bl_info(_acr,'CREAT_TIME');
         _RES.TFLD.TAB.MOD_DATE:=_TAB.bl_info(_acr,'MODIFY_DATE');
         _RES.TFLD.TAB.MOD_TIME:=_TAB.bl_info(_acr,'MODIFY_TIME')
      ?};
      _RES.TFLD.TAB.add();
      {? _type='SYS_MEMO'
      || _RES.TFLD.TAB.memo_put(_TAB.memo_get('r',_acr,0),'VALM')
      ?}
   !};
   _RES.TFLD.TAB.select()
|| FUN.info('Odnalezienie niepoprawnego rekordu nie powiodło się.'@)
?};
_TAB.cntx_pop();

~~


\_dedyk_test_wnd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Definiowanie interfejsu testów dedykowanych.
::   WE:
::   WY:
:: ~OST: INWEBBROWSER
::----------------------------------------------------------------------------------------------------------------------
_par:=params_get();
_TEST:=_par.TEST;

:: Okno wertowania + akcje (przyciski).
_TEST.ws:=_TEST.TAB.mk_sel('Testy dedykowane'@,,,'#kjd_dedyk',,,,,'U');
_TEST.TAB.win_fld(_TEST.ws,,'SYSTEM',,,,,,,,'Zapis systemowy [T/N]'@,2,,"'T'","'N'");
_TEST.TAB.win_fld(_TEST.ws,,'TYP',,,-4,,,,,'Typ przetwarzania'@);
_TEST.TAB.win_fld(_TEST.ws,,'KOD',,,,,,,,'Kod identyfikujący test'@);
_TEST.TAB.win_fld(_TEST.ws,,'OPIS',,,60,,,,,'Opis działania / zakresu testu'@);
_TEST.TAB.win_fld(_TEST.ws,,'KLUCZE',,,60,,,,,'Klucze grupujące (zestawy)'@);
{! _empty:=0 .. 1
|! _TEST.TAB.win_act(_TEST.ws,_empty,'Menu','Dołącz'@@,,,,,,,,,'D');
   _TEST.TAB.win_act(_TEST.ws,_empty,'Dołącz','Formuła'@@,'#D','Dołączenie testu w postaci formuły'@
      ,"params_get().TEST.set_we('FML')"
      ,"params_exec('_dedyk_test_export','%kjd',params_get().TEST.TAB.SYSTEM)",,,,
      ,'F'
   );
   _TEST.TAB.win_act(_TEST.ws,_empty,'Dołącz','Zapytanie'@@,'#D','Dołączenie testu w postaci zypytania SQL'@
      ,"params_get().TEST.set_we('SQL')","params_exec('_dedyk_test_export','%kjd')",,,,
      ,'Z'
   )
!};
_dbtn:=_TEST.TAB.win_btn(_TEST.ws,'text=%1,icon=xwin16.png:190' ['Dołącz'@],'Menu');
_TEST.TAB.btn_menu(_TEST.ws,_dbtn,'menu:DF');
_TEST.TAB.btn_menu(_TEST.ws,_dbtn,'menu:DZ');
_TEST.TAB.win_act(_TEST.ws,,'Popraw',,,
   ,"params_exec('_dedyk_test_akcje','%kjd').popraw"
   ,"params_exec('_dedyk_test_export','%kjd',params_get().TEST.TAB.SYSTEM)"
);
_TEST.TAB.win_btn(_TEST.ws,'text=%1' ['Popraw'@],'menu:P');
_TEST.TAB.win_act(_TEST.ws,,'Usuń',,,
   ," _TEST:=params_get().TEST;
      _TEST.buf:=_TEST.TAB.SYSTEM;
      params_exec('_dedyk_test_akcje','%kjd').usun
   "
   ,"{? params_get().TEST.TAB.sel_size()=0 || params_exec('_dedyk_test_export','%kjd',params_get().TEST.buf) ?}"
   ,,1,
   ,"params_exec('_dedyk_test_export','%kjd')"
);
_TEST.TAB.win_btn(_TEST.ws,'text=%1' ['Usuń'@],'menu:U');
_TEST.TAB.win_act(_TEST.ws,,'Formuła','U&ruchom'@@,,'Uruchomienie testu'@
   ,"params_exec('_dedyk_test_run_b','%kjd')",
   ,1,1
   ,"params_exec('_dedyk_test_run_bg','%kjd')","params_exec('_dedyk_test_run_ag','%kjd')"
   ,'R'
);
_TEST.TAB.win_btn(_TEST.ws,'text=%1' ['U&ruchom'@],'menu:R');
_TEST.TAB.win_act(_TEST.ws,,'Formuła','De&finicje'@@,,'Prezentacja ścieżek dostępu do plików z definicjami'@
   ,"params_get().TEST.FN.display()",,,,,
   ,'F'
);
_TEST.TAB.win_act(_TEST.ws,,'Kolejność');
_TEST.TAB.win_act(_TEST.ws,,'Formuła','Eksportuj'@@,,'Zapis definicji testów dedykowanych w plikach'@
   ,"params_exec('_dedyk_test_akcje','%kjd').eksportuj"
   ,"params_exec('_dedyk_test_export','%kjd')",,,,
   ,'E'
);
{! _empty:=0 .. 1
|! _TEST.TAB.win_act(_TEST.ws,_empty,'Rekord',,,
      ,"params_exec('_dedyk_test_bd','%kjd',1)"
      ,"params_exec('_dedyk_test_ae','%kjd')"
   )
!};
_TEST.TAB.win_sel(_TEST.ws);

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:: Okna redagowania.
_memo_wys:=-4;
_mode:={? _TEST.interm || 'html_maximized' || 'normal' ?};
_TEST.we:=obj_new('FML','SQL');
{! _lp:=1 .. 2
|! _TEST.we[_lp]:=_TEST.TAB.mk_edit('Test dedykowany'@,,'#kjd_dedyk%1'[$_lp],,,_mode);
   _TEST.TAB.win_esep(_TEST.we[_lp],'Dane podstawowe'@);
   {? _TEST.dro
   || _TEST.TAB.win_efld(_TEST.we[_lp],,'SYSTEM',,,,,,,,'Zapis systemowy'@
         ,'check-box','check_label="%1"' ['Tak, zapis systemowy (zablokowana modyfikacja)'@],"'T'","'N'"
      )
   ?};
   _TEST.TAB.win_efld(_TEST.we[_lp],,'TYP',,,4,,1,,,'Kod identyfikujący test'@);
   _TEST.TAB.win_efld(_TEST.we[_lp],,'KOD',,,,,,,,'Kod identyfikujący test'@);
   _TEST.TAB.efld_opt(_TEST.we[_lp],'mark=1',,'KOD');
   {? _lp=1
   || _TEST.TAB.win_efld(_TEST.we[_lp],,'TABELA',,,,,,,,'Akronim tabeli, której dotyczy test'@,,'F3_button=1');
      _TEST.TAB.efld_opt(_TEST.we[_lp],'mark=1',,'TABELA')
   ?};
   _TEST.TAB.win_efld(_TEST.we[_lp],,'OPIS',,,120,_memo_wys,,,,'Opis działania / zakresu testu'@);
   _TEST.TAB.efld_opt(_TEST.we[_lp],'mark=1',,'OPIS');
   _TEST.TAB.win_efld(_TEST.we[_lp],,'KLUCZE',,,120,,,,,'Klucze grupujące (zestawy)'@);
   _TEST.TAB.win_esep(_TEST.we[_lp],'Definicja'@);
   {? _lp=2
   || _TEST.TAB.win_efld(_TEST.we[_lp],,'TEST',,,120,_memo_wys,,,
         ,'Zapytanie SQL zwracające tabelę z polem REF, które zawiera SQL-refa niepoprawnych rekordów'@
      );
      _TEST.TAB.efld_opt(_TEST.we[_lp],'mark=1',,'TEST')
   ?};
   _TEST.TAB.win_efld(_TEST.we[_lp],,'PROLOG',,,120,_memo_wys,,,
      ,'Formuła przygotowująca środowisko, wykonywana na początku przetwarzania każdej maski'@
   );
   {? _lp=1
   || _TEST.TAB.win_efld(_TEST.we[_lp],,'TEST',,,120,_memo_wys,,,
         ,'Formuła testująca, wykonywana dla każdego rekordu w dziedzinie'@
      );
      _TEST.TAB.efld_opt(_TEST.we[_lp],'mark=1',,'TEST')
   || _TEST.TAB.win_efld(_TEST.we[_lp],,'INFO',,,120,_memo_wys,,,
         ,'Formuła uzupełniająca informacje szczegółowe dla niepoprawnego rekordu'@
      );
      _TEST.TAB.efld_opt(_TEST.we[_lp],'mark=1',,'INFO')
   ?};
   _TEST.TAB.win_efld(_TEST.we[_lp],,'EPILOG',,,120,_memo_wys,,,
      ,'Formuła przywracająca środowisko, wykonywana na końcu przetwarzania każdej maski'@
   );
   _TEST.TAB.win_ebtn(_TEST.we[_lp],'text=%1,align=begin' ['Wskazówki'@],"params_exec('_dedyk_test_help','%kjd')");
   exec('ok_esc','#window',_TEST.TAB,_TEST.we[_lp]);
   ~~
!};

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:: Kontrolka do wyświetlania wskazówek.
_wctr:=_TEST.TAB.mk_ctr('Test dedykowany - wskazówki'@,'#kjd_help',4,3,,,'');
_TEST.TAB.win_ctr(_wctr);
:: Co prawda kontrolka @webframe działa również dla jTerma, ale w starszych wersjach silnika jej nie ma. Używajmy zatem
:: kontrolki @webbrowser.
{? _TEST.interm
|| _TEST.TAB.win_cctr(_wctr,'ctr_help','@webframe')
|| _TEST.TAB.win_cctr(_wctr,'ctr_help','@webbrowser',1)
?};

~~


\_dedyk_test_addb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Wyzwalacz "Dołącz - przed" dla tabeli _TEST.
::   WE: _a [TABLE] - Uchwyt tabeli _TEST.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('_dedyk_test_chk','%kjd',_a,0)


\_dedyk_test_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Wyzwalacz "Popraw - przed" dla tabeli _TEST.
::   WE: _a [TABLE] - Uchwyt tabeli _TEST.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('_dedyk_test_chk','%kjd',_a,1)


\_dedyk_test_memo_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Wyzwalacz "memo_put - przed" dla tabeli _TEST.
::   WE: _a [TABLE]  - Uchwyt tabeli _TEST.
::       _b [STRING] - Akronim zapisywanego pola.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=_a;
_acr:=_b;

{? _acr='OPIS'
:: Zawartość pola OPIS jest dowolna - nie weryfikujemy jej.
|| return(1)
?};

{? _acr='PROLOG'
|| _name:='Prolog'@;
   _check:=1
|? _acr='TEST'
|| _name:='Test'@;
   _check:=_TAB.TYP='FML'
|? _acr='EPILOG'
|| _name:='Epilog'@;
   _check:=1
|? _acr='INFO'
|| _name:='Szczegóły'@;
   _check:=1
|| return(0)
?};

_fml:=_TAB.memo_txt(0,0,_acr);
{? _fml=''
|| 1

|? +_fml<>+_TAB.memo_txt(1,0,_acr)+1
:: Zawartość notatki musi się dać zapisać do zmiennej - tekst nie może być za długi.
|| FUN.emsg('Przekroczono dopuszczalną liczbę znaków w polu "%1"'@ [_name]);
   0

|? _check & (_ERR:=form_chk($_fml)).first()
:: Weryfikacja poprawności składni.
|| FUN.emsg(
      'Formuła w polu "%1" ma nieprawidłową składnię.\n\n'
      'Linia: %2\nKolumna: %3\n%4\n\n'
      'Należy poprawić treść formuły.'@ [_name,$_ERR.ERR_LINE,$_ERR.ERR_COL,_ERR.ERR_DESC]
   );
   0

: Wszystko OK.
|| 1
?}


\_dedyk_test_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Sprawdza wypełnienie wymaganych pól w tabeli _TEST.
::       Wykorzystywana w wyzwalaczach "Dołącz - przed" i "Popraw - przed" oraz akcji "Rekord - po".
::   WE:  _a  [TABLE]  - Uchwyt tabeli _TEST.
::       [_b] [NUMBER] - Specyfikacja testu:
::             0 - Dołącz [domyślnie];
::             1 - Popraw.
::----------------------------------------------------------------------------------------------------------------------
_TAB:=_a;
_put:=var_pres('_b')=type_of(0) & _b;

__CHK.validate(_TAB
   ,"_a.record(_b,,'SYSTEM','TYP','KOD')"
   ,"_a.in_set(_b,'SYSTEM',,'T','N')"
   ,"_a.in_set(_b,'TYP',,'FML','SQL')"
:: KOD jest uzupełniony, ale czy ma odpowiednią budowę.
   ,$(
     "{? _b.SYSTEM='T'
      || {? 1+_b.KOD='Q'
         || _a.err_fld(_b,'KOD',1,'"+'Kod nie może rozpoczynać się od litery Q.'@+"')
         |? ~exec('valid_acronim','#string',_b.KOD)
         || _a.err_fld(_b,'KOD',1,'"+
               'Kod musi rozpoczynać się od wielkiej litery.\n'
               'Może zawierać jedynie wielkie litery, cyfry i znaki podkreślenia.'@+"'
            )
         || ''
         ?}
      || {? 1+_b.KOD<>'Q'
         || _a.err_fld(_b,'KOD',1,'"+'Kod musi rozpoczynać się od litery Q.'@+"')
         |? _b.KOD='Q'
         ||  _a.err_fld(_b,'KOD',1,'"+'Kod nie może być jednoliterowy.'@+"')
         |? ~exec('valid_acronim','#string',_b.KOD)
         || _a.err_fld(_b,'KOD',1,'"+'Kod może zawierać jedynie wielkie litery, cyfry i znaki podkreślenia.'@+"')
         || ''
         ?}
      ?}
   ")
   ," {? _b.TYP='FML'
      || {? (_chk:=_a.record(_b,,'TABELA','OPIS','TEST'))<>''
         || return(_chk)
         |? var_pres(_b.TABELA)<>type_of(_b)
         || _a.err_fld(_b,'TABELA',1)
         || ''
         ?}
      || _a.record(_b,,'OPIS','TEST','INFO')
      ?}
   "
:: Unikalność po polu KOD.
   ,$(
     "_kod:=_b.KOD;
      _ref:={? "+$_put+" || _b.ref() || null() ?};
      _b.cntx_psh();
      _b.index(_ndx:=_b.ndx_tmp(,,'KOD',,));
      _b.prefix(_kod,);
      _dubel:=_b.first() & _b.ref()<>_ref;
      _b.cntx_pop();
      _b.ndx_drop(_ndx);
      {? _dubel
      || _msg:=
         {? "+$_put+"
         || '"+'Poprawienie zapisu nie jest możliwe.'@+'\n'+'Znaleziono rekord o podanym kluczu.'@+"'
         || '"+'Dołączenie zapisu nie jest możliwe.'@+'\n'+'Znaleziono rekord o podanym kluczu.'@+"'
         ?};
         _a.err_msg('"+'Kod:'@+"'+_kod+'\n'+_msg);
         0
      || 1
      ?}
   ")
)


\_dedyk_test_akcje
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Funkcja dla bieżącego rekordu tabeli params_get().tzalacz.ZALACZ.TAB określa dostępność akcji w oknie
::       wertowania.
::   WE: [_a] [NUMBER] - Uwzględniać obsługę grupową? [0*/1]
::                       Wyjaśnienie: akcja "Usuń nie jest wyszarzana po zaznaczeniu kilku rekordów, ale w trybie
::                       wdrożeniowym nie powinna zostać uruchomiona dla rekordu systemowego.
::   WY: Tablica z elementami nazwanymi.
::----------------------------------------------------------------------------------------------------------------------
_grp:=var_pres('_a')=type_of(0) & _a;


_TEST:=params_get().TEST;

_akcje:=obj_new('popraw','usun','eksportuj');
{! _lp:=1 .. obj_len(_akcje)
:: Domyślnie wszystkie akcje ustawiamy na dostępne.
|! _akcje[_lp]:=1
!};

{? ~_TEST.dro & _TEST.TAB.SYSTEM='T'
|| _akcje.popraw:=0;
   _akcje.usun:=_grp & _TEST.TAB.sel_size()
?};

_akcje.eksportuj:=_TEST.eksportuj;

_akcje


\_dedyk_test_system_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Po redagowaniu pola TABELA tabeli _TEST.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TEST:=params_get().TEST;
{? _TEST.TAB.SYSTEM='T'
|| {? 1+_TEST.TAB.KOD='Q'
   || _TEST.TAB.KOD:=1-_TEST.TAB.KOD
   ?}
|| {? 1+_TEST.TAB.KOD<>'Q'
   || _TEST.TAB.KOD:='Q'+_TEST.TAB.KOD
   ?}
?};
1


\_dedyk_test_tabela_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji F3 dla pola TABELA tabeli _TEST.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ret:=~~;
_fld:=fld();
_TABLE:=params_get().TABLE;
_TABLE.TAB.cntx_psh();
_TABLE.TAB.index(_TABLE.NDX.ACR);
_TABLE.TAB.prefix();
_TABLE.TAB.find_key(_fld) | _TABLE.TAB.first();
{? _TABLE.TAB.select(,1)
|| _ret:=_TABLE.TAB.ACR
?};
_TABLE.TAB.cntx_pop();
_ret


\_dedyk_test_tabela_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Po redagowaniu pola TABELA tabeli _TEST.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=fld();
{? _fld=''
|| 1
|| _ret:=0;
   _TABLE:=params_get().TABLE;
   _TABLE.TAB.cntx_psh();
   _TABLE.TAB.index(_TABLE.NDX.ACR);
   _TABLE.TAB.prefix();
   {? _TABLE.TAB.find_key(_fld)
   || fld(_TABLE.TAB.ACR);
      _ret:=1
   || FUN.emsg('Podano nieprawidłowy akronim tabeli.'@)
   ?};
   _TABLE.TAB.cntx_pop();
   _ret
?}


\_dedyk_test_import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Formuła importująca definicje testów z pliku.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_par:=params_get();
_TEST:=params_get().TEST;

_buf:=obj_new('txt');
_memo:="_a.memo_set(_b,_c)";
{! _lp:=1 .. 2
|! _fn:=_TEST.fn[_lp];
   {? fexists(_fn,1)=1
   || _fh:=fopen(_fn,'br',1,1,1,1);
      {? _fh.is_open()
      || _TEST.TAB.cntx_psh();
         _TEST.TAB.index(_TEST.NDX.UNIQUE);
         _TEST.TAB.prefix();
         params_set(
            'TEST',_TEST
            ,'buf',_buf
            ,'memo',_memo
            ,'system',{? _lp=1 || 'T' || 'N' ?}
         );
         {? ~xml_sax_parse(_fh
               ,,
::             Start element
               ," _par:=params_get();
                  _TEST:=_par.TEST;
                  _buf:=_par.buf;
                  _depth:=xml_path();
                  _path:='';
                  {! _lp:=1 .. _depth
                  |! _path+='<'+xml_path('name',_depth-_lp)+'>'
                  !};
                  {? _path='<KontrolaJakościDanych><Test>'
                  || _TEST.TAB.blank();
                     _TEST.TAB.SYSTEM:=_par.system;
                     _TEST.TAB.memo_set(,'OPIS');
                     _TEST.TAB.memo_set(,'PROLOG');
                     _TEST.TAB.memo_set(,'TEST');
                     _TEST.TAB.memo_set(,'EPILOG');
                     _TEST.TAB.memo_set(,'INFO')
                  ?};
                  _buf.txt:='';
                  1"
::             End element
               ," _par:=params_get();
                  _TEST:=_par.TEST;
                  _buf:=_par.buf;
                  _depth:=xml_path();
                  _path:='';
                  {! _lp:=1 .. _depth
                  |! _path+='<'+xml_path('name',_depth-_lp)+'>'
                  !};
                  {? _path='<KontrolaJakościDanych><Test><typ>'
                  || _TEST.TAB.TYP:=_buf.txt
                  |? _path='<KontrolaJakościDanych><Test><kod>'
                  || _TEST.TAB.KOD:=_buf.txt
                  |? _path='<KontrolaJakościDanych><Test><tabela>'
                  || _TEST.TAB.TABELA:=_buf.txt
                  |? _path='<KontrolaJakościDanych><Test><opis>'
                  || _par.memo(_TEST.TAB,_buf.txt,'OPIS')
                  |? _path='<KontrolaJakościDanych><Test><klucze>'
                  || _TEST.TAB.KLUCZE:=_buf.txt
                  |? _path='<KontrolaJakościDanych><Test><prolog>'
                  || _par.memo(_TEST.TAB,_buf.txt,'PROLOG')
                  |? _path='<KontrolaJakościDanych><Test><test>'
                  || _par.memo(_TEST.TAB,_buf.txt,'TEST')
                  |? _path='<KontrolaJakościDanych><Test><epilog>'
                  || _par.memo(_TEST.TAB,_buf.txt,'EPILOG')
                  |? _path='<KontrolaJakościDanych><Test><info>'
                  || _par.memo(_TEST.TAB,_buf.txt,'INFO')
                  |? _path='<KontrolaJakościDanych><Test>'
                  || do();
                     _TEST.TAB.add()
                     & _TEST.TAB.memo_put(,'OPIS')
                     & _TEST.TAB.memo_put(,'PROLOG')
                     & _TEST.TAB.memo_put(,'TEST')
                     & _TEST.TAB.memo_put(,'EPILOG')
                     & _TEST.TAB.memo_put(,'INFO');
                     end()
                  ?};
                  1
               "
::             Text
               ,"params_get().buf.txt+=_a"
            )
         || FUN.emsg('Import definicji testów nie powiódł się.'@)
         ?};
         _TEST.TAB.cntx_pop();
         _fh.fclose()
      ?};
      obj_del(_fh)
   ?}
!};
~~


\_dedyk_test_export
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Formuła eksportująca definicje testów do pliku.
::   WE: [_a] [STRING] - Zakres eksportu:
::             'T' - Eksport konfiguracji systemowej.
::             'N' - Eksport konfiguracji wdrożeniowj.
::             ''  - Eksport obu konfiguracji [domyślnie].
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TEST:=params_get().TEST;

{? var_pres('_a')=type_of('')
|| _system:={? _a='T' | _a='N' || _a || '' ?}
|| _system:={? _TEST.dro || '' || 'N' ?}
?};

_TEST.TAB.cntx_psh();
_TEST.TAB.index(_TEST.NDX.UNIQUE);
_TEST.TAB.prefix();
{? _TEST.TAB.first() & _TEST.TAB.lock(1,1)
|| _memo:="_a.memo_txt(0,1,_b)";
   _ok:=obj_new(2);
:: Kolejność pól w tablicy _xml jest istotna!
   _xml:=obj_new('s','w');
   _root:=obj_new('s','w');
   {! _lp:=1 .. 2
   |! {? _system='' | (_lp=1 & _system='T') | (_lp=2 & _system='N')
      || _xml[_lp]:=obj_new(@.CLASS.XML_T);
         _root[_lp]:=_xml[_lp].addElement('KontrolaJakościDanych',,,'')
      ?}
   !};
   {!
   |? _lp:={? _TEST.TAB.SYSTEM='T' || 1 || 2 ?};
      {? _system='' | (_lp=1 & _system='T') | (_lp=2 & _system='N')
      || _efml:=_xml[_lp].addElement('Test',,_root[_lp]);
            _xml[_lp].addElement('typ',_TEST.TAB.TYP,_efml);
            _xml[_lp].addElement('kod',_TEST.TAB.KOD,_efml);
            _xml[_lp].addElement('tabela',_TEST.TAB.TABELA,_efml);
            _xml[_lp].addElement('opis',_memo(_TEST.TAB,'OPIS'),_efml);
            _xml[_lp].addElement('klucze',_TEST.TAB.KLUCZE,_efml);
            _xml[_lp].addElement('prolog',_memo(_TEST.TAB,'PROLOG'),_efml);
            _xml[_lp].addElement('test',_memo(_TEST.TAB,'TEST'),_efml);
            _xml[_lp].addElement('epilog',_memo(_TEST.TAB,'EPILOG'),_efml);
            _xml[_lp].addElement('info',_memo(_TEST.TAB,'INFO'),_efml)
      ?};
      _TEST.TAB.next()
   !};
   {! _lp:=1 .. 2
   |! _ok[_lp]:=
         {? _system='' | (_lp=1 & _system='T') | (_lp=2 & _system='N')
         || _xml[_lp].write(_TEST.fn[_lp],1)
         || 1
         ?}
   !};
   _TEST.TAB.unlock();
   _TEST.eksportuj:=~(_ok[1] & _ok[2])
|| FUN.info('Eksport definicji testów dedykowanych nie był możliwy - należy go powtórzyć.'@);
   _TEST.eksportuj:=1
?};
_TEST.TAB.cntx_pop();
~~


\_dedyk_test_help
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji "Wskazówki" w oknie redagowania testów dedykowanych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TEST:=params_get().TEST;

_tr:=obj_new('patt','repl','run');
_tr.patt:=spli_str('\'| ','|');
_tr.repl:=spli_str('&apos;|&nbsp;','|');
_tr.run:="gsub(_a,.patt,.repl)+{? var_pres('_b')=type_of(0) & _b || '<br/>' || '' ?}";

_body:='';

{? _TEST.typ='FML'
|| _body+=
      '<h1>Zasadnicze działanie</h1>'

      '<p>Definiowanie testów typu FML zostało stworzone do obsługi przypadków, dla których testy typu SQL albo byłyby '
      'niezwykle skomplikowany, albo wręcz niemożliwy do napisania. Wynika z tego, że rekomendowanym typem jest SQL. '
      'Typ FML należy stosować w nadzwyczajnych sytuacjach.</p>'
      '<p>Dla testów typu FML scenariusz przetwarzania wygląda następująco:</p>'
      '<ol>'
         '<li>Odkładany jest kontekst przetwarzanej tabeli.</li>'
         '<li>Wykonywana jest pętla po wszystkich maskach przetwarzanej tabeli.</li>'
            '<ol>'
            '<li>Otwierana jest aktualnie przetwarzana maska.</li>'
            '<li>Wykonywana jest formuła <b>Prolog</b>. Jeżeli zwróci wartość 1, to rozpoczyna się przetwarzanie '
                'rekordów w bieżącej masce. Jeżeli dla przetwarzanej tabeli zdefiniowany jest filtr, to iteracja '
                'będzie się odbywała po rekordach filtra, w ustalonej w nim (parametr <i>sort</i>) kolejności. '
                'W przeciwnym wypadku (brak zdefiniowanego filtra) iteracja będzie się odbywała po wszystkich '
                'rekordach w dziedzinie w kolejności określonej przez bieżący indeks.'
            '</li>'
               '<ul>'
                  '<li>Dla każdego rekordu w dziedzinie wykonywana jest formuła <b>Test</b>.</li>'
               '</ul>'
            '<li>Wykonywana jest formuła <b>Epilog</b> '
               '(niezależnie od wyniku zwróonego przez formułę <b>Prolog</b>).</li>'
            '</ol>'
   '<li>Przywracany jest kontekst przetwrzanej tabeli.</li>'
      '</ol>'

      '<h1>Opis znaczenia i sposobu uzupełnienie wybranych pól</h1>'

      '<p>Uwaga</p>'
      '<p>Przykłady załączone poniżej mają za zadanie przede wszystkim pokazanie sposobu wypełnienie danego pola '
      'oraz zilustrowanie jego charakteru. Dodatkowo jednak stanowią komplet - są elementami prostej, ale poprawnej '
      'definicji testu. I nie ma znaczenia, że w rzeczywistości przykładowy test pewnie byłby zdefiniowany jako '
      '<b>SQL</b>.</p>'

      '<hr/>'

      '<h2>Prolog</h2>'
      '<p>Formuła wykonywana każdorazowo po otwarciu (kolejnej) maski przetwarzanej tabeli. Pozwala na ustawienie '
      'środowiska pracy. Dotyczy to zarówno przetwarzanej tabeli (indeks + prefix lub filtr) jak i wykorzystywanych '
      'tabel powiązanych (kontekst + maska + prefix).</p>'
      '<p>Jeżeli wynikiem formuły nie będzie <code>1</code>, to rekordy w tej masce NIE będą przetwarzane.</p>'
      '<h3>Przykład</h3>'
      '<p><code>'+
      _tr.run(''+"OSOBA.cntx_psh();",1)+
      _tr.run(''+"OSOBA.prefix();",1)+
      _tr.run(''+"P.cntx_psh();",1)+
      _tr.run(''+"P.prefix();",1)+
      _tr.run(''+"R.cntx_psh();",1)+
      _tr.run(''+"R.prefix();",1)+
      _tr.run(''+"1")+
      '</code></p>'
      '<hr/>'

      '<h2>Test</h2>'
      '<p>Najważniejsza część definicji testu dedykowanego. Formuła wykonywanego dla każdego rekordu w dziedzinie. '
      'Jeżeli rekord nie jest poprawny, to fakt ten należy zgłosić poprzez użycie metody <code>add</code> '
      'przekazywanego do formuły obiektu <code>_a</code>.</p>'
      '<p>Opis metody</p>'
      '<p><code>_a.add(identyf,info,[dod])</code>, gdzie:</p>'
      '<p><dl>'
      '<dt><code>STRING[255] identyf</code></dt><dd>Tekst jednoznacznie identyfikujący rekord.</dd>'
      '<dt><code>STRING[255] info</code></dt><dd>Opis znalezionej nieprawidłowości.</dd>'
      '<dt><code>SYS_MEMO dod</code></dt><dd>Dodatkowe informacje (parametr opcjonalny).</dd>'
      '</dl></p>'
      '</p>'
      '<h3>Przykład</h3>'
      '<p><code>'+
      _tr.run(''+"{? DS.R=0",1)+
      _tr.run(''+"|| {? DS.P().get()",1)+
      _tr.run(''+"   || {? P.OSOBA().get()",1)+
      _tr.run(''+"      || _os:='%1 %2 (PESEL:%3)'[OSOBA.NAZWISKO,OSOBA.PIERWSZE,OSOBA.PESEL]",1)+
      _tr.run(''+"      || _os:='Teczka: %1, IP: %2 (niewypełnione pole P.OSOBA)'[P.T,$P.IP]",1)+
      _tr.run(''+"      ?}",1)+
      _tr.run(''+"   || _os:='Niewypełnione pole DS.P'",1)+
      _tr.run(''+"   ?};",1)+
      _tr.run(''+"   _rubr:={? DS.NB().get() || '%1 - %2'[$R.RN,R.RT] || 'Niewypełnione pole DS.NB' ?};",1)+
      _tr.run(''+"   _a.add(_os,'Niewypełnione pole DS.R.',_rubr)",1)+
      _tr.run(''+"?}")+
      '</code></p>'
      '<hr/>'

      '<h2>Epilog</h2>'
      '<p>Formuła wykonywana jest po przetworzeniu wszystkich rekordów w danej masce. Pozwala na przywrócenie '
      'środowiska zmienionego w formule <code>Prolog</code>.</p>'
      '<h3>Przykład</h3>'
      '<p><code>'+
      _tr.run(''+"R.cntx_pop();",1)+
      _tr.run(''+"P.cntx_pop();",1)+
      _tr.run(''+"OSOBA.cntx_pop()")+
      '</code></p>'
      '<hr/>'

|? _TEST.typ='SQL'
|| _body+=
      '<h1>Zasadnicze działanie</h1>'

      '<p>Jeżeli znalezienie "niepoprawnych" rekordów możliwe jest za pomocą nieskomplikowanego zapytania SQL, '
      'to dedykowane testy typu SQL są znakomitym wyborem. Przeglądanie wszystkich rekordów (zapytaniem z pola '
      '<b>Test</b>) odbędzie się po stronie serwera (a więc szybko), a do końcówki przesłane zostaną jedynie '
      '"niepoprawne" rekordy. I tylko dla tych rekordów wykonane zostaną formuły z pól <b>Prolog</b>, <b>Szczegóły</b> '
      'i <b>Epilog</b>.</p>'

      '<h1>Opis znaczenia i sposobu uzupełnienie wybranych pól</h1>'

      '<p>Uwaga</p>'
      '<p>Przykłady załączone poniżej mają za zadanie przede wszystkim pokazanie sposobu wypełnienie danego pola '
      'oraz zilustrowanie jego charakteru. Dodatkowo jednak stanowią komplet - są elementami poprawnej definicji '
      'testu.</p>'

      '<hr/>'

      '<h2>Test</h2>'
      '<p>Najważniejsza część definicji testu dedykowanego. Zawiera treść zapytania SQL.</p>'
      '<p>W każdym zapytaniu dostępny jest parametr :_a zawierający ref-a bieżącej firmy.</p>'
      '<p>Wykonanie zapytania powinno zwrócić listę niepoprawnych rekordów, a dokładniej: tabelę tymczasową, w której '
      'schemacie znajduje się pole o akronimie <code>REFERENCE</code> typu <code>STRING[16]</code> zawierające '
      'ref-a niepoprawnego rekordu.</p>'


      '<h3>Przykład</h3>'
      '<p><code>'+_tr.run('select DS.REFERENCE from DS where DS.R=0')+'</code></p>'
      '<hr/>'

      '<h2>Szczegóły</h2>'
      '<p>Jeżeli w wyniku przeprowadzonego testu znalezione zostaną nieprawidłowe rekordy, to formuła ma za zadanie '
      'pomóc w ich jednoznacznej identyfikacji. Zadanie to należy wykonać poprzez użycie metody <code>add</code> '
      'przekazywanego do formuły obiektu <code>_a</code>.</p>'
      '<p>Opis metody</p>'
      '<p><code>_a.add(identyf,info,[dod])</code>, gdzie:</p>'
      '<p><dl>'
      '<dt><code>STRING[255] identyf</code></dt><dd>Tekst jednoznacznie identyfikujący rekord.</dd>'
      '<dt><code>STRING[255] info</code></dt><dd>Opis znalezionej nieprawidłowości.</dd>'
      '<dt><code>SYS_MEMO dod</code></dt><dd>Dodatkowe informacje (parametr opcjonalny).</dd>'
      '</dl></p>'
      '<h3>Przykład</h3>'
      '<p><code>'+
      _tr.run(''+"{? DS.P().get()",1)+
      _tr.run(''+"|| {? P.OSOBA().get()",1)+
      _tr.run(''+"   || _os:='%1 %2 (PESEL:%3)'[OSOBA.NAZWISKO,OSOBA.PIERWSZE,OSOBA.PESEL]",1)+
      _tr.run(''+"   || _os:='Teczka: %1, IP: %2 (niewypełnione pole P.OSOBA)'[P.T,$P.IP]",1)+
      _tr.run(''+"   ?}",1)+
      _tr.run(''+"|| _os:='Niewypełnione pole DS.P'",1)+
      _tr.run(''+"?};",1)+
      _tr.run(''+"_rubr:={? DS.NB().get() || '%1 - %2'[$R.RN,R.RT] || 'Niewypełnione pole DS.NB' ?};",1)+
      _tr.run(''+"_a.add(_os,'Niewypełnione pole DS.R.',_rubr)")+
      '</code></p>'
      '<hr/>'

      '<h2>Prolog</h2>'
      '<p>Znalezione rekordy mogą pochodzić z różnych masek. Formuła <code>Prolog</code> wykonywana jest po otwarciu '
      'każdej z nich i odpowiada za prawidłowe ustawienie środowiska (np. otwarcie odpowiednich masek tabel '
      'zrelacjonowanych).</p>'
      '<h3>Przykład</h3>'
      '<p><code>'+
      _tr.run(''+"OSOBA.cntx_psh();",1)+
      _tr.run(''+"OSOBA.prefix();",1)+
      _tr.run(''+"P.cntx_psh();",1)+
      _tr.run(''+"P.prefix();",1)+
      _tr.run(''+"R.cntx_psh();",1)+
      _tr.run(''+"R.prefix()")+
      '</code></p>'
      '<hr/>'

      '<h2>Epilog</h2>'
      '<p>Formuła <code>Epilog</code> wykonywana jest po zakończeniu przetwarzania rekordów w danej masce i odpowiada '
      'za prawidłowe przywrócenie środowiska zmienionego w ramach formuły <code>Prolog</code>.</p>'
      '<h3>Przykład</h3>'
      '<p><code>'+
      _tr.run(''+"R.cntx_pop();",1)+
      _tr.run(''+"P.cntx_pop();",1)+
      _tr.run(''+"OSOBA.cntx_pop()")+
      '</code></p>'
      '<hr/>'

?};

_html:=
   '<html>'
      '<head>'
         '<style>'
            'ol { counter-reset: item;}'
            'ol > li { counter-increment: item; }'
            'ol ol > li { display: block; }'
            'ol ol > li:before { content: counters(item, ".") ". "; margin-left: -20px; }'
         '</style>'
         '<meta charset="UTF-8">'
      '</head>'
      '<body>%1</body>'
   '</html>'[_body];
_TEST.TAB.hdr_ctr();
_tyt:=' (%1)'[_TEST.typ];
_TEST.TAB.hdr_ctr(_tyt);
_TEST.TAB.control(,,$(
   {? ~_TEST.interm
   || "ctr_set(,'ctr_help','setButtonBarVisible','false');
      ctr_set(,'ctr_help','setLocationBarVisible','false');
      ctr_set(,'ctr_help','setStatusBarVisible','false');
      ctr_set(,'ctr_help','closeAfterEscape','true');"
   || ""
   ?}+
   "ctr_set(,'ctr_help','setHTMLContent','"+_html+"')"
));

''


\_dedyk_test_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji "Rekord - przed" w oknie testów dedykowanych.
::   WE: _a [NUMBER] - Rekord bieżący? [0 - nie / 1 - tak]
::   WY:
::----------------------------------------------------------------------------------------------------------------------
params_set(_par:=params_get());
_TEST:=_par.TEST;
_TEST.set_we(_TEST.TAB.TYP);

{? _a
|| _akcje:=exec('_dedyk_test_akcje','%kjd',1);
   _ga:='';
   {? ~_akcje.popraw
   || _ga+='P'
   ?};
   {? ~_akcje.usun
   || _ga+='U'
   ?};
   {? ~_akcje.eksportuj
   || _ga+='E'
   ?};

   _TEST.TAB.actions_grayed(_TEST.ws,_ga)
?};

~~


\_dedyk_test_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji "Rekord - po" w oknie testów dedykowanych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TEST:=params_get().TEST;
_chk:=exec('_dedyk_test_chk','%kjd',_TEST.TAB,-menu_txt()='popraw');
{? (type_of(_chk)=type_of('') & _chk<>'') | (type_of(_chk)=type_of(0) & ~_chk)
|| return(_chk)
?};

:: Pola typu SYS_MEMO [36] nie są weryfikowane w wyzwalaczu _chk.
{! _lp:=1 .. _TEST.TAB.fld_num()
|! _acr:=_TEST.TAB.fld_acr(_lp);
   {? var_pres(_acr,_TEST.TAB)=36 & ~exec('_dedyk_test_memo_putb','%kjd',_TEST.TAB,_acr)
   || return(_acr)
   ?}
!};

''


\_dedyk_test_run_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji "Uruchom - grupa przed" w oknie testów dedykowanych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy na pewno chcesz uruchomić wszystkie zaznaczone testy?'@+'\n'+'(operacja może być bardzo czasochłonna)'@)
|| params_get().RES.TAB.erase();
   1
?}


\_dedyk_test_run_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Formuła wykonywana jest w dwóch kontekstach:
::        * Obsługa akcji "Uruchom - przed" w oknie testów dedykowanych
::        * Wsadowe wykonanie bieżącego testu.
::   WE: [_a] [NUMBER] - Tryb wsadowy.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_a')=type_of(0) & _a;

params_set(_par:=params_get());
_TEST:=_par.TEST;

_grp:=_TEST.TAB.sel_size();
{? _grp | _batch | FUN.ask('Czy na pewno chcesz uruchomić bieżący test?'@)
|| _err:='';
   {? _TEST.TAB.TYP='FML'
   || _TAB:=($_TEST.TAB.TABELA)();
      _TAB.cntx_psh();
      _NAMES:=_TAB.names();
      {? _NAMES.first()
      || _RES:=_par.RES;
         _RES.TAB.index(_RES.NDX.UNIQUE);
         _RES.TAB.prefix();
         {? ~_grp
         || _RES.TAB.erase()
         ?};
         _RES.TAB.fld_fml('KOD','BLANK',$("'"+$_TEST.TAB.KOD+"'"));
         _RES.TAB.fld_fml('TABELA','BLANK',$("'"+$_TEST.TAB.TABELA+"'"));
         _RES.TAB.fld_fml('TEST','BLANK',$("'"+$_TEST.TAB.ref()+"'"));
         _RES.TAB.fld_fml('UIDREF','BLANK',$'%1.uidref()' [_TEST.TAB.TABELA]);

         _prolog:=$_TEST.TAB.memo_txt(,1,'PROLOG');
         _test:=$_TEST.TAB.memo_txt(,1,'TEST');
         _epilog:=$_TEST.TAB.memo_txt(,1,'EPILOG');

         {!
         |? _TAB.use(_NAMES.NAME);
            _TAB.prefix();
            _ret:=_prolog();
            {? type_of(_ret)=type_of(0) & _ret
            || {? _TAB.f_active()
               || _first:=$'%1.f_first()' [_TEST.TAB.TABELA];
                  _next:=$'%1.f_next()' [_TEST.TAB.TABELA]
               || _first:=$'%1.first()' [_TEST.TAB.TABELA];
                  _next:=$'%1.next()' [_TEST.TAB.TABELA]
               ?};
               {? _first()
               || {!
                  |? _test(_RES);
                     _next()
                  !}
               ?}
            ?};
            _epilog();
            _NAMES.next()
         !}
      ?};
      _TAB.cntx_pop()

   |? _TEST.TAB.TYP='SQL'
   || _RES:=_par.RES;
      _RES.TAB.index(_RES.NDX.UNIQUE);
      _RES.TAB.prefix();
      {? ~_grp
      || _RES.TAB.erase()
      ?};

      _SQL:=sql(_TEST.TAB.memo_txt(,1,'TEST'),exec('ref_firma','ustawienia'));
      {? type_of(_SQL)=type_of(~~)
      || _err:='Zapytanie SQL nie zwróciło tabeli tymczasowej.'
      |? var_pres('REFERENCE',_SQL)<>27
      || _err:='Nieprawidłowa struktura - wynik nie zawiera pola REFERENCE.'
      |? _SQL.first()
      || _NAMES:=sql('select distinct trim(substr(REFERENC,1,8)) as NAME from :_a order by 1',_SQL);
         {? _NAMES.first()
         || _TAB:=ref_tab(_SQL.REFERENC);
            _tacr:=2-!_TAB;

            _prolog:=$_TEST.TAB.memo_txt(,1,'PROLOG');
            _info:=$_TEST.TAB.memo_txt(,1,'INFO');
            _epilog:=$_TEST.TAB.memo_txt(,1,'EPILOG');

            _obj:=obj_new('ID','MSG','DOD','add');
            _obj.add:="
               .ID:=_a;
               .MSG:=_b;
               .DOD:={? var_pres('_c')=type_of('') || _c || '' ?}
            ";
            _TAB.cntx_psh();
            {!
            |? _TAB.use(_NAMES.NAME);
               _TAB.prefix();
               _prolog();
               _SQL.f_set('REFERENC',,'REFERENC like \':_a%\'',_NAMES.NAME);
               {? _SQL.f_first()
               || {!
                  |? {? _TAB.seek(_SQL.REFERENC)
                     || _obj.ID:=_obj.MSG:=_obj.DOD:='';
                        _info(_obj);
                        _RES.TAB.blank();
                        _RES.TAB.KOD:=_TEST.TAB.KOD;
                        _RES.TAB.TABELA:=_tacr;
                        _RES.TAB.UIDREF:=_TAB.uidref();
                        _RES.TAB.ID:=_obj.ID;
                        _RES.TAB.MSG:=_obj.MSG;
                        _RES.TAB.TEST:=$_TEST.TAB.ref();
                        _RES.TAB.add();
                        {? _obj.DOD<>''
                        || _RES.TAB.memo_set(_obj.DOD,'DOD');
                           _RES.TAB.memo_put(,'DOD')
                        ?}
                     ?};
                     _SQL.f_next()
                  !}
               ?};
               _epilog();
               _NAMES.next()
            !};
            _TAB.cntx_pop()
         ?}
      ?}
   ?};


   {? +_err
   || {? _batch
      || return(_err)
      || FUN.info('%1\n%2'[_TEST.TAB.KOD,_err])
      ?}

   |? _batch
   || return(_RES.TAB)

   |? ~_grp
   || {? _RES.TAB.first()
      || _RES.TAB.select()
      || FUN.info('Procedura testowa nie znalazła niepoprawnych rekordów.'@)
      ?}
   ?};
   1
?}


\_dedyk_test_run_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji "Uruchom - grupa po" w oknie testów dedykowanych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
params_set(_par:=params_get());
_RES:=_par.RES;
{? _RES.TAB.first()
|| _RES.TAB.select()
|| FUN.info('Procedury testowe nie znalazły niepoprawnych rekordów.'@)
?}


\zbiorowki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa menu testów zbiorowych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
popup(1,'Kontrola Jakości Danych'@+' - '+'Testy zbiorowe'@
   ,'Walidacja procedurami wyzwalaczy "put przed"'@
   ,'Badanie poprawności rekordów procedurami walidacyjnymi (z wyzwalaczy "put przed")'@
   ,"exec('put_przed','%kjd')"

:   ,'Weryfikacja kolumn typu DATE (1800/01/01)'@
:   ,'Znalezienie rekordów z niepoprawnymi datami'@
:   ,"FUN.info('Do zrealizowania'@)"
)


\put_przed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Główna formuła testu zbiorowego wykorzystującego walidację w wyzwalaczach 'put - przed'.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
on_error(0);

FUN.emsg(
   'Mechanizm zakłada, że wyzwalacze "put - przed" mają za zadanie (m.in.)\n'
   'weryfikację poprawności danych w modyfikowanym rekordzie.\n'
   '\n'
   'Tak więc dla każdego rekordu w każdej masce wybranych tabel:\n'
   ' 1. Rozpoczynana jest transakcja;\n'
   ' 2. Wykonywany jest metoda put();\n'
   ' 3. Wycofywana jest transakcja.  \n'
   'Jeżeli w trakcie transakcji wystąpił błąd, '
   'to uznajemy, że zawartość rekordu nie jest prawidłowa.\n'
   '\n'
   'Uwaga\n'
   'Błędy, które pojawią się na ekranie (być może zamykające zakładkę)\n'
   'mogą być związane z kodem wyzwalacza, który nie działa bezkontekstowo.'@
);

_TABLE:=obj_new('TAB','NDX','ws');

_TABLE.TAB:=tab_tmp(1
   ,'ACR','STRING[8]','Akronim'@
   ,'NAME','STRING[8]','Nazwa'@
   ,'COMMENT','STRING[60]','Komentarz'@
   ,'TEST','STRING[1]','Dostępny test'@
:: Formuła podczytująca wartości pól typu SYS_MEMO.
   ,'MEMO','SYS_MEMO','Formuła'
);
_TABLE.NDX:=obj_new('ACR');
_TABLE.NDX.ACR:=_TABLE.TAB.index('?');

_TABLE.ws:=_TABLE.TAB.mk_sel('Kontrola Jakości Danych - "put przed"'@,,,'#kjd_putb',,,,,'U');
_TABLE.TAB.win_fld(_TABLE.ws,,'ACR',,,,,,,,'Akronim tabeli'@);
_TABLE.TAB.win_fld(_TABLE.ws,,'NAME',,,,,,,,'Nazwa tabeli'@);
_TABLE.TAB.win_fld(_TABLE.ws,,'COMMENT',,,,,,,,'Komentarz'@);
_TABLE.TAB.win_fld(_TABLE.ws,,'TEST',,,-3,,,,,'Czy dla tabeli dostępny jest test poprawności danych?'@+' [T/N]',2,,
   "'T'","'N'"
);
_TABLE.TAB.win_act(_TABLE.ws,,'Formuła','Testuj'@@,,'Sprawdzenie poprawności danych'@
   ,"params_exec('_put_przed_test_b','%kjd')"
   ,"params_exec('_put_przed_test_a','%kjd')"
   ,1
   ,1
   ,"params_exec('_put_przed_test_bg','%kjd')"
   ,"params_exec('_put_przed_test_ag','%kjd')"
   ,'T'
);
_TABLE.TAB.win_act(_TABLE.ws,,'Formuła','Wyzwalacze'@@,,'Przeglądanie zdefiniowanych wyzwalaczy'@,"
   _par:=params_get();
   _TABLE:=_par.TABLE;
   _TRIG:=_par.TRIG;
   _TRIG.TAB.cntx_psh();
   _TRIG.TAB.index(_TRIG.NDX.UNIQUE);
   _TRIG.TAB.prefix(_TABLE.TAB.ACR,);
   _TRIG.TAB.hdr_sel();
   _tyt:=' %1' [_TABLE.TAB.ACR];
   _TRIG.TAB.hdr_sel(_tyt);
   _TRIG.TAB.select();
   _TRIG.TAB.cntx_pop()
",,,,,,'W');
_TABLE.TAB.win_act(_TABLE.ws,,'Kolejność');
_TABLE.TAB.win_act(_TABLE.ws,,'Rekord',,,,"
   _TABLE:=params_get().TABLE;
   {? _a
   || _ga:={? _TABLE.TAB.sel_size() | _TABLE.TAB.TEST='T' || '' || 'T' ?};
      _TABLE.TAB.actions_grayed(_TABLE.ws,_ga)
   ?};
   {? _TABLE.TAB.TEST='N' || '217:217:217' || '' ?}
");
_TABLE.TAB.win_sel(_TABLE.ws);

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

_TRIG:=obj_new('TAB','NDX','ws','we');

_TRIG.TAB:=tab_tmp(3
   ,'TAB','STRING[8]','Akronim tabeli'@
   ,'TYPE','STRING[14]','Typ wyzwalacza'@
   ,'ORDER','INTEGER','Lp.'@
   ,'ID','STRING[15]','Nazwa wyzwalacza'@
   ,'MB','STRING[1]','MacroBUILDER'@
   ,'ACTIVE','STRING[1]','Aktywny'@
   ,'FORMULA','SYS_MEMO','Treść wyzwalacza'@
);
_TRIG.NDX:=obj_new('UNIQUE');
_TRIG.NDX.UNIQUE:=_TRIG.TAB.index('?');

_TRIG.ws:=_TRIG.TAB.mk_sel('Wyzwalacze tabeli'@,'P',,'#kjd_trig',,,,,'U');
_TRIG.TAB.win_fld(_TRIG.ws,,'TYPE');
_TRIG.TAB.win_fld(_TRIG.ws,,'ORDER',,,-3);
_TRIG.TAB.win_fld(_TRIG.ws,,'ID');
_TRIG.TAB.win_fld(_TRIG.ws,,'MB',,,,,,,,,2,,"'T'","'N'");
_TRIG.TAB.win_fld(_TRIG.ws,,'ACTIVE',,,,,,,,,2,,"'T'","'N'");
_TRIG.TAB.win_fld(_TRIG.ws,,'FORMULA',,,80);
_TRIG.TAB.win_act(_TRIG.ws,,'Kolejność');
_TRIG.TAB.win_act(_TRIG.ws,,'Wyświetl',,,,"
   _TAB:=cur_tab(1,1);
   _TAB.hdr_edit();
   _tyt:=' %1' [_TAB.TAB];
   _TAB.hdr_edit(_tyt);
   _TAB.display()
");
_TRIG.TAB.win_act(_TRIG.ws,,'Rekord',,,,"cur_tab(1,1).memo_get(,'FORMULA'); ~~");
_TRIG.TAB.win_sel(_TRIG.ws);

_TRIG.we:=_TRIG.TAB.mk_edit('Wyzwalacz tabeli'@,,'#kjd_trig');
_TRIG.TAB.win_esep(_TRIG.we,'Dane podstawowe'@);
_TRIG.TAB.win_efld(_TRIG.we,,'TYPE');
_TRIG.TAB.win_efld(_TRIG.we,,'ORDER');
_TRIG.TAB.win_efld(_TRIG.we,,'ID');
_TRIG.TAB.win_efld(_TRIG.we,,'MB',,,,,,,,
   ,'check-box','check_label="%1"' ['Tak, wyzwalacz zdefiniowany w MacroBUILDER-ze'@],"'T'","'N'"
);
_TRIG.TAB.win_efld(_TRIG.we,,'ACTIVE',,,,,,,,
   ,'check-box','check_label="%1"' ['Tak, wyzwalacz jest aktywny'@],"'T'","'N'"
);
_TRIG.TAB.win_efld(_TRIG.we,,'FORMULA',,,80,-5);
_TRIG.TAB.win_edit(_TRIG.we);

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

_RES:=obj_new('TAB','NDX','ws');

_RES.TAB:=tab_tmp(2
   ,'TACR','STRING[8]','Akronim tabeli'@
   ,'UIDREF','STRING[48]','uidref'
   ,'STRING','SYS_MEMO','Reprezentacja tekstowa'@
   ,'INFO','SYS_MEMO','Komunikat'@
);

_RES.NDX:=obj_new('UNIQUE');
_RES.NDX.UNIQUE:=_RES.TAB.index('?');

_RES.ws:=_RES.TAB.mk_sel('Niepoprawne rekordy'@,'P',,'#kjd_res',,,,,'U');
_RES.TAB.win_fld(_RES.ws,,'TACR');
_RES.TAB.win_fld(_RES.ws,,'UIDREF');
_RES.TAB.win_fld(_RES.ws,,'STRING',,,60);
_RES.TAB.win_fld(_RES.ws,,'INFO',,,60);
_RES.TAB.win_act(_RES.ws,,'Formuła','Test'@@,,,"
   _par:=params_get();
   _RES:=_par.RES;
   _TABLE:=_par.TABLE;
   _TABLE.TAB.cntx_psh();
   _TABLE.TAB.index(_TABLE.NDX.ACR);
   _TABLE.TAB.prefix(_RES.TAB.TACR,);
   {? _TABLE.TAB.first()
   || _TAB:=($_RES.TAB.TACR)();
      _TAB.cntx_psh();
      _TAB.use(ref_name(_RES.TAB.UIDREF));
      _TAB.prefix();
      {? _TAB.seek(_RES.TAB.UIDREF)
      || do();
         ($_TABLE.TAB.memo_txt(,,'MEMO'))();
         _TAB.put(1);
         undo();
         end()
      ?};
      _TAB.cntx_pop()
   ?};
   _TABLE.TAB.cntx_pop()",,1,,,,
   'T'
);
_RES.TAB.win_act(_RES.ws,,'Kolejność');
_RES.TAB.win_sel(_RES.ws);

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

{! _tlp:=1 .. tab_num()
|! {? tab_real(_tlp)
   || _tacr:=tab_acr(_tlp);
      _TAB1:=tab_alias(_tlp);

      _test:=0;
      _TRIG1:=_TAB1.triggers();
      _TRIG1.prefix('put przed',);
      {? _TRIG1.first()
      || {!
         |? {? _TRIG1.ID='synchro'
            || _TRIG1.next()
            || _test:=1;
               0
            ?}
         !}
      ?};
      _TRIG1.prefix();

      _memo:='';
      {! _flp:=1 .. _TAB1.fld_num()
      |! _fld:=_TAB1.fld_acr(_flp);
         {? var_pres(_fld,_TAB1)=36
         || _memo+='%1.memo_get(,\'%2\'); ' [_tacr,_fld]
         ?}
      !};
      {? _memo<>''
      || _memo+='~~'
      ?};

      _TABLE.TAB.blank();
      _TABLE.TAB.ACR:=_tacr;
      _TABLE.TAB.NAME:=_TAB1.name(1);
      _TABLE.TAB.COMMENT:=_TAB1.comment();
      _TABLE.TAB.TEST:={? _test || 'T' || 'N' ?};
      _TABLE.TAB.memo_set(_memo,'MEMO');
      _TABLE.TAB.add() & _TABLE.TAB.memo_put(,'MEMO');

      {? _TRIG1.first()
      || {!
         |? _TRIG.TAB.blank();
            _TRIG.TAB.TAB:=_TABLE.TAB.ACR;
            _TRIG.TAB.TYPE:=_TRIG1.TYPE;
            _TRIG.TAB.ORDER:=_TRIG1.ORDER;
            _TRIG.TAB.ID:=_TRIG1.ID;
            _TRIG.TAB.MB:=_TRIG1.MB;
            _TRIG.TAB.ACTIVE:=_TRIG1.ACTIVE;
            _TRIG.TAB.add() & _TRIG.TAB.memo_put(_TRIG1.memo_get('r','FORMULA'),'FORMULA');
            _TRIG1.next()
         !}
      ?};
      obj_del(_TRIG1);
      obj_del(_TAB1)
   ?}
!};

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

params_set(
   'TABLE',_TABLE
   ,'TRIG',_TRIG
   ,'RES',_RES
);
_TABLE.TAB.select()


\_put_przed_test_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji "Test - grupa przed" w oknie testu zbiorowego wykorzystującego walidację
::       w wyzwalaczach 'put - przed'.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
params_set(_par:=params_get());
_RES:=_par.RES;
_RES.TAB.cntx_psh();
_RES.TAB.index(_RES.NDX.UNIQUE);
_RES.TAB.prefix();
{? _RES.TAB.first()
|| {!
   |? _RES.TAB.del()
   !}
?};
_RES.TAB.cntx_pop();

FUN.ask(
   'Czy na pewno chcesz przetestować poprawność danych we wszystkich zaznaczonych tabelach?'@+'\n'
   '(operacja może być bardzo czasochłonna)'@
)


\_put_przed_test_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji "Test - przed" w oknie testu zbiorowego wykorzystującego walidację
::       w wyzwalaczach 'put - przed'.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_par:=params_get();
_TABLE:=_par.TABLE;
_RES:=_par.RES;


{? _TABLE.TAB.TEST<>'T'
|| return(1)

|? _TABLE.TAB.sel_size() | FUN.ask('Czy na pewno chcesz przetestować poprawność danych w tabeli %1?'@ [_TABLE.TAB.ACR])
|| _TAB:=($_TABLE.TAB.ACR)();
   _MASKI:=_TAB.names();
   {? _MASKI.first()
   || _RES.TAB.cntx_psh();
      _RES.TAB.index(_RES.NDX.UNIQUE);
      _RES.TAB.prefix(_TABLE.TAB.ACR,);
      {? _RES.TAB.first()
      || {!
         |? _RES.TAB.del()
         !}
      ?};
      _msg:=no_msg(1);
      on_error(3);
      {!
      |? _memo:=_TABLE.TAB.memo_txt(,1,'MEMO');
         echo(_TABLE.TAB.ACR+': '+_MASKI.NAME);
         _TAB.cntx_psh();
         _TAB.use(_MASKI.NAME);
         _TAB.prefix();
         {? _TAB.first()
         || {!
            |? _info:='';
               errno();
               in_error();
               do();
               ($_memo)();
               {? ~_TAB.put(1)
               || {? in_error()
                  || _info+='Wystąpił błąd składniowy.'@+'\n'
                  ?};
                  {? _ret:=errno()
                  || _info+='Wystąpił błąd %1.'@ [$_ret]
                  ?}
               ?};
               undo();
               end();
               {? _info<>''
               || _RES.TAB.blank();
                  _RES.TAB.TACR:=_TABLE.TAB.ACR;
                  _RES.TAB.UIDREF:=_TAB.uidref();
                  _RES.TAB.memo_set(exec('record','#to_string',_TAB.ref()),'STRING');
                  _RES.TAB.memo_set(_info,'INFO');
                  _RES.TAB.add() & _RES.TAB.memo_put(,'STRING') & _RES.TAB.memo_put(,'INFO')
               ?};
               _TAB.next()
            !}
         ?};
         _TAB.cntx_pop();
         _MASKI.next()
      !};
      on_error(0);
      no_msg(_msg);
      _RES.TAB.cntx_pop()
   ?}
?};
1


\_put_przed_test_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji "Test - po" w oknie testu zbiorowego wykorzystującego walidację
::       w wyzwalaczach 'put - przed'.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_par:=params_get();
_TABLE:=_par.TABLE;
{? _TABLE.TAB.sel_size()=0
|| params_set(_par);
   _RES:=_par.RES;
   _RES.TAB.cntx_psh();
   _RES.TAB.index(_RES.NDX.UNIQUE);
   _RES.TAB.prefix(_TABLE.TAB.ACR,);
   {? _RES.TAB.first()
   || _RES.TAB.select()
   || FUN.info('Procedury walidacyjne nie znalazły niepoprawnych rekordów.'@)
   ?};
   _RES.TAB.cntx_pop()
?}


\_put_przed_test_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Obsługa akcji "Test - grupa po" w oknie testu zbiorowego wykorzystującego walidację
::       w wyzwalaczach 'put - przed'.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
params_set(_par:=params_get());
_RES:=_par.RES;
_RES.TAB.cntx_psh();
_RES.TAB.index(_RES.NDX.UNIQUE);
_RES.TAB.prefix();
{? _RES.TAB.first()
|| _RES.TAB.select()
|| FUN.info('Procedury walidacyjne nie znalazły niepoprawnych rekordów.'@)
?};
_RES.TAB.cntx_pop();
~~

:Sign Version 2.0 jowisz:1048 2023/06/23 14:15:44 658fbaa2caaf7b79106d7d4adb1a59358c07c512e76e8c895e85b84299031fd6d6e76cc30a3e79e6bc12add99e62d0c856eac3eb37559a2117d876d2db41fb0c3c5fbda6ad67b8205380e05d54354119de4a81f4c8715936a9eb0ec023d44e23ed61c0294f15268b33a81992838fae16c25fdceba7f8046cbf13c0f7598d8564
