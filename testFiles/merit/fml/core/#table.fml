:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #table.fml [17.00]
:: Utworzony: 2014/12/17
:: Autor: jaws
::======================================================================================================================
:: Zawartość: Funkcje pomocnicze dla kartotek
::            Wykorzystywane w opisach pojęcie "uchwyt tabeli" oznacza akronim tabeli lub zmiennej strukturalnej podany
::            wprost np: P, OSOBA, a nie w postaci ciągu znaków (odpowiednio: 'P', 'OSOBA')
::            szukanie rekordów w tabeli
::======================================================================================================================


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2009]
:: OPIS: Dokonuje próby zapisu (dołączenie). W przypadku niepowodzenia wyświetla komunikat.
::   WE: _a - Alias do tabeli [domyślnie: tabela, której okienko jest aktualnie aktywne].
::   WY: 1 - Rekord został dodany.
::       0 - Rekordu nie udało się dodać.
::  OLD: \add/rubobj.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~{? var_pres('_a')=type_of(SYSLOG) || _a || cur_tab(1,1) ?}.add(1)
|| FUN.emsg('\n'+'Wystąpił błąd podczas próby dołączenia zapisu.'@+'\n');0
|| 1
?}


\put
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2009]
:: OPIS: Dokonuje próby zapisu (poprawienie). W przypadku niepowodzenia wyświetla komunikat.
::   WE: _a - Alias do tabeli [domyślnie: tabela, której okienko jest aktualnie aktywne].
::   WY: 1 - Rekord został zapisany.
::       0 - Rekordu nie udało się zapisać.
::  OLD: \put/rubobj.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~{? var_pres('_a')=type_of(SYSLOG) || _a || cur_tab(1,1) ?}.put(1)
|| FUN.emsg('\n'+'Wystąpił błąd podczas próby poprawienia zapisu.'@+'\n');0
|| 1
?}


\blk_lock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Blokuje podany rekord za pomocą tabeli BLK.
::   WE: _a - STRING - akronim tabeli, której rekord będzie blokowany
::       _b - TAB.ref() - rekord, który zablokować lub
::            STRING    - maska tabeli rekordu, który zablkować
::       [_c] - INTEGER - numer rekordu który zablokować (tylko jeśli _b to STRING)
::       [_d] - INTEGER - typ wyniku:  [1] - zwraca INTEGER 0/1 - czy udało się zablokować
::                                      2  - zwraca ses_id() sesji która blokuje
::       [_e] - STRING - preambuła komunikatu mówiącego o tym kto blokuje rekord np. 'Zlecenie o symbolu xxxx jest
::                       redagowane'. Do tej preambuły jest doklejane: ' przez użytkownika 'xxxx' na terminalu 'xxxx'.'
::                       Jeśli nie podane to komunikat się nie wyświetli
::       [_f] - FORMULA - formuła którą wykonać przed wyświetleniem komunikatu, o ile komunikat wyświetlany
::       [_g] - INTEGER - tryb komunikowania o tym kto blokuje: [0]- ekran, 1 - KOMM, 2 - VAR.MESSAGE
::   WY: w zależności od parametru _d:    INTEGER - 0/1 - wynik blokady lub
::                                        STRING  - SES_ID sesji blokującej rekord
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \blk_lock/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_msk:='';
_ref:=0;
{? var_pres('_b')=7 || _msk:=ref_name(_b); _ref:=#_b
|? var_pres('_b')=2 || _msk:=_b;           _ref:=_c
                    || return(-1)
?};
_wtr:={? var_pres('_d')=1 || _d || 1 ?};
_info:='';
{? var_pres('_e')=type_of('')
|| _info:=_e
?};
_fml:="";
{? var_pres('_f')=type_of("")
|| _fml:=_f
?};
_dialog_mode:=0;
{? var_pres('_g')=type_of(0)
|| _dialog_mode:=_g
?};

_ses_id:=SYSLOG.ses_id();

{? do_state()>0
|| FUN.wdrerror('Funkcja blk_lock\\#table nie może być używana w transakcji.'@);
   {? _wtr=2
   || return(_ses_id)
   || return(1)
   ?}
?};

{? BPMN.BLK_USER=''
|| BPMN.BLK_USER:=SYSLOG.ses_info(_ses_id,'log_name')
?};
{? BPMN.BLK_TERM=''
|| BPMN.BLK_TERM:=SYSLOG.ses_info(_ses_id,'log_tty')
?};

BLK.index('AMR');
BLK.prefix(_tab,_msk,_ref);
_ok:=1;
_atom_ok:=1;
_msg:=_info;
{? BLK.first()
|| {? BLK.SES_ID=_ses_id
   || _ok:=1
   || {? BLK.r_lock(1,1,1)
      || {? SYSLOG.ses_info(BLK.SES_ID,'exist')>0
         || _ok:=0;
            _ses_id:=BLK.SES_ID;
            {? _info<>''
            || _msg+=' '+translate(BLK.MESSAGE)
            ?}
         || BLK.SES_ID:=_ses_id;
            BLK.TM_STAMP:=SYSLOG.tm_stamp();
            BLK.MESSAGE:='przez użytkownika \'%1\' na terminalu: \'%2\' od: %3'@@[BPMN.BLK_USER,BPMN.BLK_TERM,19+tm_form(BLK.TM_STAMP)];
            _atom_ok:=BLK.put()
         ?};
         BLK.r_unlock()
      || _ok:=0;
         _ses_id:=BLK.SES_ID;
         {? _info<>''
         || _msg+=' '+translate(BLK.MESSAGE)
         ?}
      ?}
   ?}
|| BLK.blank(1);
   BLK.ACR:=_tab;
   BLK.MSK:=_msk;
   BLK.REF:=_ref;
   BLK.TM_STAMP:=SYSLOG.tm_stamp();
   BLK.MESSAGE:='przez użytkownika \'%1\' na terminalu: \'%2\' od: %3'@@
                [BPMN.BLK_USER,BPMN.BLK_TERM,19+tm_form(BLK.TM_STAMP)];
   BLK.SES_ID:=_ses_id;
   _atom_ok:=BLK.add(1)
?};
{? _atom_ok=0
|| _ses_id:='';
   _ok:=0
?};

:: Wyświetlam komunikat jeśli treść nie jest pusta i nie udało się zablokować
{? _ok=0 & _ses_id<>'' & _msg<>''
|| _fml();
   {? _dialog_mode=0
   || FUN.emsg(_msg)
   |? _dialog_mode=1
   || KOMM.add(_msg,2)
   |? _dialog_mode=2
   || VAR.MESSAGE:=_msg
   ?}
?};
{? _wtr=2
|| _ses_id
|| _ok
?}


\blk_unlock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Odblokowuje podany rekord w mechanizmie BLK
::   WE: _a - STRING - akronim tabeli
::       _b - TAB.ref() - rekord, który odblokować lub
::            STRING    - maska tabeli rekordu, który odblkować
::       [_c] - INTEGER - numer rekordu który odblokować (tylko jeśli _b to STRING)
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \blk_unlock/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_msk:='';
_ref:=0;
{? var_pres('_b')=7 || _msk:=ref_name(_b); _ref:=#_b
|? var_pres('_b')=2 || _msk:=_b;           _ref:=_c
                    || return(-1)
?};
_ses_id:=SYSLOG.ses_id();

BLK.index('AMR');
BLK.prefix(_tab,_msk,_ref);
_ok:=1;
{? BLK.first()
|| {? _ses_id=BLK.SES_ID
   || BLK.del()
   ?}
?};
~~


\last_mod_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.28]
:: OPIS: Procedura ustawia i zwraca znacznik czasowy ostatniej modyfikacji wskazanej tabeli / maski.
::   WE:  _a  [TABLE]  - Uchwyt tabeli.
::       [_b] [STRING] - Maska tabeli [domyślnie: bieżąca].
::   WY: Znacznik czasowy ostatniej modyfikacji tabeli lub 0 w przypadku błędnych parametrów wywołania.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(SYSLOG)
|| _TAB:=_a
|| return(0)
?};
_msk:={? var_pres('_b')=type_of('') || _b || _TAB.name(0) ?};

_acr:=2-!_TAB;
_id:=-1;

_ret:=_TAB.tm_stamp();
BLK.cntx_psh();
BLK.index('AMR');
BLK.prefix(_acr,_msk,_id);
{? BLK.first()
|| BLK.TM_STAMP:=_ret;
   BLK.put()
|| BLK.blank();
   BLK.ACR:=_acr;
   BLK.MSK:=_msk;
   BLK.REF:=_id;
   BLK.MESSAGE:='Znacznik ostatniej modyfikacji tabeli.';
   BLK.TM_STAMP:=_ret;
   BLK.add()
?};
BLK.cntx_pop();
_ret


\last_mod_get
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.28]
:: OPIS: Procedura zwraca znacznik czasowy ostatniej modyfikacji wskazanej tabeli / maski.
::   WE:  _a  [TABLE]  - Uchwyt tabeli.
::       [_b] [STRING] - Maska tabeli [domyślnie: bieżąca].
::   WY: Znacznik czasowy ostatniej modyfikacji tabeli lub 0 w przypadku błędnych parametrów wywołania.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(SYSLOG)
|| _TAB:=_a
|| return(0)
?};
_msk:={? var_pres('_b')=type_of('') || _b || _TAB.name(0) ?};

_acr:=2-!_TAB;
_id:=-1;

_ret:=0;
BLK.cntx_psh();
BLK.index('AMR');
BLK.prefix(_acr,_msk,_id);
_ret:=
   {? BLK.first()
   || BLK.TM_STAMP
   || exec('last_mod_set','#table',_TAB,_msk)
   ?};
BLK.cntx_pop();
_ret


\set_null
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Usuwa wykorzystanie wskazanego rekordu w polu tabeli.
::   WE: _a - alias do tabeli, w której będą modyfikowane dane
::       _b - akronim wykorzystanego pola
::       _c - wskazanie na powiązany rekord
::   WY: 1 jeśli powiązane rekordy zostały zmienione, 0 gdy zmiana nie powiodła się
::  OLD: \set_null/util.fml
:: UWAGA! Poprawność argumentów wywołania nie jest weryfikowana - użycie niezgodne ze specyfikacją może powodować błędy.
::----------------------------------------------------------------------------------------------------------------------
_release:=1;
_a.cntx_psh();
_a.clear();
_set:=$(!_a+'.'+_b+':=null;'+!_a+'.put');
_RS:=sql('select :_a.REFERENCE as REF from :_a where :_a.%1=:_b'[_b],_a,_c);
_loop:=_RS.first();
{!
|? _loop & _release
|! {? _a.seek(_RS.REF)
   || _release:=_set()
   || _release:=0
   ?};
   _loop:=_RS.next()
!};
_a.cntx_pop();
_release


\del_ndx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Usuwa zapisy powiązane z rekordem
::   WE:  _a  [TABLE]  - alias do tabeli, z której będą usuwane dane
::        _b  [STRING] - akronim wykorzystanego indeksu
::        _c  [ANY]    - wskazanie na powiązany rekord (wartość kolejnego pola w prefiksie)
::       [_d] [ANY]    - wskazanie na powiązany rekord (wartość kolejnego pola w prefiksie)
::       [_e] [ANY]    - wskazanie na powiązany rekord (wartość kolejnego pola w prefiksie)
::       [_f] [ANY]    - wskazanie na powiązany rekord (wartość kolejnego pola w prefiksie)
::       [_g] [ANY]    - wskazanie na powiązany rekord (wartość kolejnego pola w prefiksie)
::       [_h] [ANY]    - wskazanie na powiązany rekord (wartość kolejnego pola w prefiksie)
::       [_i] [ANY]    - wskazanie na powiązany rekord (wartość kolejnego pola w prefiksie)
::   WY: 1 jeśli powiązane rekordy zostały usunięte, 0 gdy usunięcie nie powiodło się
::  OLD: \del_ndx/util.fml
:: UWAGA! Poprawność argumentów wywołania nie jest weryfikowana - użycie niezgodne ze specyfikacją może powodować błędy.
::----------------------------------------------------------------------------------------------------------------------
_ret:=1;
_a.cntx_psh;
_a.index(_b);

{? _=3
|| _a.prefix(_c)
|| _prfx:='';
   _par:=obj_new(_);
   {! _lp:=3.._
   |! _par[_lp]:=_[_lp];
      _prfx+='_b['+$_lp+'],'
   !};
   {? type_of(_[_])<>type_of('') || _prfx:=_prfx-1 ?};
   ($('_a.prefix('+_prfx+')'))(_a,_par)
?};

{? _a.first
|| {!
   |? _state:=_a.del(,1);
      {? _state=0 || _ret:=0
      |? _state=1 || 0
      || 1
      ?}
   !}
?};

_a.cntx_pop;
_ret


\del_tmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Usuwa zapisy powiązane z rekordem
::   WE: _a [TABLE]  - alias do tabeli, z której będą usuwane dane
::       _b [STRING] - akronim pola
::       _c [REF]    - wskazanie na powiązany rekord
::   WY: 1 jeśli powiązane rekordy zostały usunięte, 0 gdy usunięcie nie powiodło się
::  OLD: \del_tmp/util.fml
:: UWAGA! Poprawność argumentów wywołania nie jest weryfikowana - użycie niezgodne ze specyfikacją może powodować błędy.
::----------------------------------------------------------------------------------------------------------------------
_ndx:=_a.ndx_tmp(,,_b,,);
_ret:=exec('del_ndx','#table',_a,_ndx,_c);
_a.ndx_drop(_ndx);
_ret


\del_ask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2009]
::       RWR [12.30]
:: OPIS: Wyświetla pytanie o usunięcie rekordu zgodne z systemowym pytaniem akcji "Usuń".
::   WE:  _a  [TABLE]  - Alias do tabeli, której rekord będzie usuwany - domyślnie tabela, której okienko jest aktualnie
::                       aktywne. Służy do ustalenia, czy akcja wykonywana jest dla grupy rekordów.
::       [_b] [STRING] - Dodatkowy komunikat (opcjonalnie).
::   WY: 1 - Użytkownik zaakceptował usunięcie rekordu(-ów).
::       0 - Użytkownik zrezygnował z usunięcia rekordu(-ów) lub usunięcie nie jest możliwe.
::  OLD: \del_ask/rubobj.fml
::----------------------------------------------------------------------------------------------------------------------
_ile:={? var_pres('_a')=type_of(SYSLOG) || _a || cur_tab(1,1) ?}.sel_size();
{? _ile=0
|| _txt:='Czy usunąć bieżący wiersz?'@
|? _ile=1
|| _txt:='Czy usunąć zaznaczony wiersz?'@
|| _txt:='Czy usunąć zaznaczone wiersze?'@
?};
{? var_pres('_b')=type_of('')
|| _txt+='\n'+_b
?};
FUN.ask(_txt)


\del_conf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Potwierdzenie operacji kaskadowego usunięcia rekordu.
::   WE: _a - Alias do tabeli, której rekord będzie usuwany - domyślnie tabela, której okienko jest aktualnie aktywne.
::            Służy do ustalenia, czy akcja wykonywana jest dla grupy rekordów.
::   WY: 1/0 zależnie od tego czy użytkownik potwierdził usunięcie rekordu
::  OLD: \del_conf/util.fml
::----------------------------------------------------------------------------------------------------------------------
_ile:={? var_pres('_a')=type_of(SYSLOG) || _a || cur_tab(1,1) ?}.sel_size();
{? _ile=0
|| _ask1:='Czy usunąć bieżący wiersz wraz z informacjami powiązanymi?'@;
   _ask2:='Czy na pewno usunąć bieżący wiersz i powiązane informacje?'@
|? _ile=1
|| _ask1:='Czy usunąć zaznaczony wiersz wraz z informacjami powiązanymi?'@;
   _ask2:='Czy na pewno usunąć zaznaczony wiersz i powiązane informacje?'@
|| _ask1:='Czy usunąć zaznaczone wiersze wraz z informacjami powiązanymi?'@;
   _ask2:='Czy na pewno usunąć zaznaczone wiersze i powiązane informacje?'@
?};

FUN.ask(_ask1) & FUN.ask('Operacja usunięcia informacji jest nieodwracalna.'@+'\n'+_ask2)


\del_warn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyświetla komunikat o niemożliwości usunięcia rekordu.
::  OLD: \del_warn/util.fml
::----------------------------------------------------------------------------------------------------------------------
FUN.emsg('Usunięcie informacji z kartoteki nie jest możliwe.\nZapis jest wykorzystywany.'@)


\czy_tab_glob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [12.10]
:: OPIS: Formula sprawdza czy tabela jest tabela globalna. W przypadku wersji jednofirmowej zwraca zawsze 0
::   WE: _a = (STRING) akronim tabeli lub (DICT) tabela, _b - jesli jest i = 1 to brak komunikatow
::   WY: 1- globalna, 0 - lokalna
::  OLD: \czy_tab_glob/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=1 || _b:=0 ?};
{? _=0 | (type_of(_a)<>2 & type_of(_a)<>118)
|| {? _b=0
   || FUN.emsg('Formuła tab_glob/#table.fml: błędny parametr wywołania lub brak parametru.'@)
   ?};
   return(-1)
?};
{? type_of(_a)=2
|| {? exec('test_acr','#table',_a)=0
   || {? _b=0
      || FUN.emsg('Formuła tab_glob/#table.fml: parametr <%1> nie jest tabelą.'@[_a])
      ?};
      return(-1)
   ?}
?};
_global:=0;
{? type_of(_a)=2 || _maska:=($(_a+'.name'))()
|? type_of(_a)=118 || _maska:=_a.name()
?};
_locp:=pth_dir(':ąąąąąąąą.mdb');
_path:=pth_dir(':'+_maska+'.mdb');
{? _path<>_locp || _global:=1 ?};
_global


\test_acr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [12.10]
:: OPIS: Test czy podany ciag znakow jest tabela
::   WE: _a = string z akronimem tabeli
::   WY: 1 - tabela, 0 - nie
::  OLD: \test_acr/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
var_pres(_a)=118 & ($(_a+'.name()'))()<>''


\rawtabmask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: wraca dla tabeli maske bez zapytajnikow
::   WE: _tab
::   WY: mask
::  OLD: \rawtabmask/libfml.fml
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_mask:=_tab.name(1);
_mpos:=_mask*'?';
{? _mpos
|| (_mpos+_mask)-1
|| _mask
?}


\FindAndGet
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: zwraca wartość formuły dla szukanego rekordu
::   WE: _a TABLE/STRING - tabela lub akronim tabeli
::       _b NUMBER/STRING/REFERENCE - 1. #ref    (NUMBER)
::                                    2. ref SQL (STRING)
::                                    3. uid REF (STRING)
::                                    4. ref     (REFERENCE)
::                                    5. idadd   (STRING)
::       [_c] STRING - ref_name(ref) - dotyczy tylko w przypadku parametru _b typu NUMBER
::       [_d] STRING/FORMULA - formuła do wykonania dla znalezionego rekordu (w konstrukcji wiążącej!)['.ref()']
::       [_e] ANY - domyślna wartość zwracana jeżeli nie znaleziony rekord [~~]
::       [_f] ARRAY - tablica parametrów do wykorzystania w formule jako parametr _b
::   WY: wynik formuły _d lub _e
::  OLD: \findandget/libfml.fml
::       \FindAndGet/libfml.fml
::       \FindAndGetQ/libfml.fml
::       \FindAndGetR/libfml.fml
::       \zwr_rsql/podstawy.fml
::       \zwr_wsql/podstawy.fml
::       \konw_hex/find_rad.fml
::       \wars/koszty.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
:: _tabela w ktorej szukamy rekordu podana bezposrednio uchwytem, albo jako akronim; gdy brak tabeli reszta nie ma sensu
_tab:={? _>0
      || {? type_of(_a)=type_of(SYSLOG) || _a
         |? type_of(_a)=type_of('')     || ($_a)()
                                        || FUN.wdrerror('Błędny parametr 1');
                                           return()
         ?}
      || return()
      ?};
:: czy wyszukiwanie z dwoma parametrami (domyslnie 0-nie)
_seek:=0;
:: numer rekordu do odszukania, bez numeru rekordu tez nie ma sensu reszta dzialania
{? _>1 & type_of(_b)=1
|| _seek:=1;
   _ref:=_b;
   _nam:={? _>2 & type_of(_c)=2 || _c || _tab.name() ?}
|? _>1 & type_of(_b)=7
|| _ref:=_b;
   _nam:=ref_name(_b)
|? _>1 & type_of(_b)=2 & ((+_b)%*16)=0
|| _ref:=_b;
   _nam:=form(8+(_b+16))
|? _>1 & type_of(_b)=2 & +_b=31
|| _nam:='';
   _ref:=0
|| FUN.wdrerror('Błędny parametr 2');
   return()
?};
:: formula do wykonania na znalezionym rekordzie
_fml:={? _>3 & (type_of(_d)=2 | type_of(_d)=3) || _d || 'ref()' ?};
:: ustalamy wartosc domyslna
_res:={? _>4 || _e || ~~ ?};
:: tablca parametrow do formuly
_arr:={? _>5 || _f || ~~ ?};

:: Kontrola skonczona wywolujemy formulke
:: kontekst tabeli zachowamy
_tab.cntx_psh();

:: inny sposób szukania dla przekazanego IDADD
{? type_of(_b)=2 & +_b=31
||
   _list_mask:=_tab.names();
   {? _list_mask.first()
   ||
      {!
      |?
         _tab.use(_list_mask[1]);
         _tab.prefix();
         _seek:=_tab.find_tab(1,_tab.idadd_acr,,'=',_b);
         {? _seek
         ||
            _tab.clear();
::          rekord znaleziony wiec wykonujemy formule
            _res:=($('_param:=_b;params_set(_c); {|_a|!'+_fml+'|}'))(_tab,_arr,params_get())
         ?};
         _seek=0 & _list_mask.next()
      !}
   ?}
||
:: sprawdzamy czy maska jest prawidlowa, jezeli nie, to zmieniamy
:: w danej masce mogl byc prefix
   _mask:=exec('rawtabmask','#table',_tab);

   {? _mask=(+_mask)+_nam
    & (_tab.name()=_nam | _tab.use(_nam))
    & (_tab.clear(); {? _seek || _tab.seek(_ref,) || _tab.seek(_ref) ?})
   ||
::    rekord znaleziony wiec wykonujemy formule
      _res:=($('_param:=_b;params_set(_c); {|_a|!'+_fml+'|}'))(_tab,_arr,params_get())
   ?}
?};
:: kontekst odkladamy
_tab.cntx_pop();
:: zwracamy wynik
_res


\FindInSet
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2008]
:: OPIS: zwraca ref lub wartość formuły dla danej tabeli i podanych wartości indeksu
::   WE: _a - akronim tabeli
::       _b - akronim indeksu
::       _c - wartosc szukana (w przypadku pola typu STRING wg poczatkowych znakow = nie dokladnie)
::       [_d] - wartosc prefiksu na pierwszym poziomie indeksu - domyslnie brak
::       [_e] - formula do wykonania dla znalezionego rekordu (w konstrukcji wiazacej!) domyslnie ref rekordu
::       [_f] - 1-wyszukiwanie dokładne 0-(domyślnie)-nie
::       [_g] - wartosc prefiksu na drugim poziomie indeksu - domyslnie brak
::       [_h] - domyślna wartość wyniku działania formuły,
::              inaczej wynik formuły
::              lub ~~ jeśli była formuła, która się nie uruchomiła - nie znaleziono rekordu
::   WY: wartość podanego pola lub jego wartość zerowa (null) jeśli niewypełnione - w zależności od typu
::  OLD: \zwr_ref/podstawy.fml
::       \zwr_war/podstawy.fml
::       \zwrcount/podstawy.fml
::       \zwr_dref/podstawy.fml
:: UWAGA. zamiana formuły "zwr_war" na formułę FindInSet przykłady:
::        exec('zwr_war','podstawy','B_ACTION','B_ELE','UID',B_PREL.B_ELE)
::        exec('FindInSet','#table','B_ACTION','B_ELE',B_PREL.B_ELE,,"B_ACTION.UID",,,'')
::
::        __War_f:="exec('zwr_war','podstawy',_a,_a,_b,_c,REF.FIRMA)"
::        __War_f:="exec('FindInSet','#table',_a,_a,_c,REF.FIRMA,$(_a+'.'+_b))"
:: UWAGA. zamiana formuły "zwrcount" na formułę FindInSet przykład:
::        exec('zwrcount','podstawy','M','M_ATR',M_ATR.ref(),'T')
::        exec('FindInSet','#table','M','M_ATR',M_ATR.ref(),'T',"M.prefix(\'T\',M_ATR.ref());M.size",,,0)
:: UWAGA. zamiana formuły "zwr_dref" na formułę FindInSet przykład:
::        exec('zwr_dref','podstawy','RVAT','SYM',_a,'SYM',REF.FIRMA,_a)
::        exec('FindInSet','#table','RVAT','SYM',_a,REF.FIRMA,,1)
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_tab:=($_a);
_ind:=$(_a+'.index('''+_b+''')');
_ref:=$(_a+'.ref');
_prf:={? _>=4 || _d || ~~ ?};
_dkl:={? var_pres('_f')=type_of(0) || _f || 0 ?};
_pr2:={? _>=7 || _g || ~~ ?};
:: formula do wykonania na znalezionym rekordzie
_fml:={? var_pres('_e')=3 || _e || _ref ?};
:: czy korzystamy z domyślnej wartości jeśli czegoś nie znajdziemy
_dom:=_>=8;
:: ustalamy typ danych zwracanych na podstawie ref-a lub domyślnej wartości
_typ:={? _dom || type_of(_h) |? var_pres('_e')=3 || 0 || type_of(_fml()) ?};
{| _tab()
|! cntx_psh;
   clear;
   _ind();
   {? _pr2<>~~ & _prf<>~~ || prefix(_prf,_pr2)
   |? _prf<>~~ || prefix(_prf)
   ?};
   {? {? _dkl || find_key(_c,) || find_key(_c) ?}
   || _wyn:=_fml()
   |? _dom
   || _wyn:=_h
   || {? _typ=0 &  var_pres('_e')=3 || _typ:=type_of(_fml()) ?};
      _wyn:={? _typ=1 || 0
            |? _typ=2 || ''
            |? _typ=4 || date(0,0,0)
            |? _typ=5 || time(0,0)
            |? _typ=7 || null
            || 0
            ?}
   ?};
   cntx_pop
|};
_wyn


\find_first_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca pozycje pierwszej tabeli w @
::   WY: pozycja  lub 0
::  OLD: \find_first_tab/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
{! _ff:=1..obj_len(@) |? var_pres('['+form(_ff,,,'99')+']',@)<>type_of(SYSLOG) !}; _ff


\tab_nr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca numer tabeli (jeżeli jest to tabela stała)
::   WE: TABLE _a - alias tabeli
::   WY: NUMBER - numer tabeli lub 0, gdy nie znaleziono
::  OLD: \tab_nr/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_nr:=0;
_tab_zero:=exec('find_first_tab','#table')-1;
{! _tt:=1..tab_num()
|? {? @[_tab_zero+_tt]=_table
   || _nr:=_tt;0
   || 1
   ?}
!};
_nr


\tab_acr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca akronim podanej tabeli (jeżeli jest to tabela stała)
::   WE: TABLE:  _a - alias tabeli
::       STRING: _a - maska tabeli TAB.name()
::   WY: STRING akronim lub pusty string, gdy nie znaleziono
::  OLD: \tab_acr/libfml.fml
::       \tab_acr/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
_res:='';
{? type_of(_a)=type_of(SYSLOG)
|| _table:=_a;
   _nr:=exec('tab_nr','#table',_table);
   {? _nr>0 || _res:=tab_acr(_nr) ?}
|? var_pres('_a')=type_of('') & form(_a)<>''
|| _mask:=form(_a);
   _ii:=1;
   _li:=tab_num();
   {!
   |? {? (_acr:=tab_acr(_ii))<>'MEMO' & tab_real(_ii) & ($(_acr+'.name()'))()=_mask
      || _res:=_acr;
         0
      || _ii+=1;
         _ii<=_li
      ?}
   !}
?};
_res


\mbFieldsType
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy i wypełnia tablicę nazwaną typów
::   WY: tablica nazwana (name, value)
::  OLD: \mbFieldsType/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__mb_ftypes')<100
||
   _type:=obj_new('name','value','default','size','numofrows');
   _type.numofrows:=255;
   _type.name:=obj_new(_type.numofrows);
   _type.value:=obj_new(_type.numofrows);
   _type.default:=obj_new(_type.numofrows);
   {! _tt:=1.._type.numofrows
   |! _type.name[_tt]:='?';
      _type.value[_tt]:="''";
      _type.default[_tt]:=~~
   !};

::_type.name[ 0]:='';          _type.value[ 0]:="'~~'";
   _type.name[ 1]:='NUMBER';    _type.value[ 1]:="form(_a,,,'9.')";                    _type.default[1]:=0;
   _type.name[ 2]:='STRING';    _type.value[ 2]:="''''+form(_a)+''''";                 _type.default[2]:='';
   _type.name[ 3]:='RULE';      _type.value[ 3]:="'\"'+form(_a)+'\"'";                 _type.default[3]:="";
   _type.name[ 4]:='DATE';      _type.value[ 4]:="'['+form(_a)+']'";                   _type.default[4]:=date(0,0,0);
   _type.name[ 5]:='TIME';      _type.value[ 5]:="'['+form(_a,,3)+']'";                _type.default[5]:=time(0,0,0);
   _type.name[ 7]:='REFERENCE'; _type.value[ 7]:="{? _a<>null() || $_a || 'null()' ?}";_type.default[7]:=null();

   _type.name[13]:='ERROR';     _type.value[13]:="'Wystąpił błąd'";                    _type.default[13]:='';

   _type.name[20]:='REAL';      _type.value[20]:="form(_a,,,'9.')";                    _type.default[20]:=0;
   _type.name[21]:='DATE';      _type.value[21]:="form(_a)";                           _type.default[21]:=date(0,0,0);
   _type.name[22]:='INTEGER';   _type.value[22]:="form(_a,,,'99')";                    _type.default[22]:=0;
   _type.name[24]:='HEADER';    _type.value[24]:="255*'.'";                            _type.default[24]:='';
   _type.name[25]:='MEMO';      _type.value[25]:="_b.memo_txt(,,_c)";                  _type.default[25]:='';
   _type.name[26]:='_';         _type.value[26]:="$_a";                                _type.default[26]:='';
   _type.name[27]:='STRING';    _type.value[27]:="_a";                                 _type.default[27]:='';
   _type.name[29]:='TIME';      _type.value[29]:="form(_a,8,3)";                       _type.default[29]:=time(0,0,0);
   _type.name[30]:='REFERENCE'; _type.value[30]:="{? _a<>null() || $_a || 'null()' ?}";_type.default[30]:=null();
   _type.name[32]:='TREE_REF';  _type.value[32]:="form(_a,,,'99')";                    _type.default[32]:=0;
   _type.name[33]:='BLOBRAW';   _type.value[33]:="'BLOBRAW'";                          _type.default[33]:=~~;
   _type.name[36]:='SYS_MEMO';  _type.value[36]:="_b.memo_txt(,,_c)";                  _type.default[36]:='';
   _type.name[37]:='BLOBIMAGE'; _type.value[37]:="'BLOBIMAGE'";                        _type.default[37]:=~~;
   _type.name[38]:='IDTIME';    _type.value[38]:="''''+form(_a)+''''";                 _type.default[38]:='';
   _type.name[39]:='IDADD';     _type.value[39]:="''''+form(_a)+''''";                 _type.default[39]:='';
   _type.name[40]:='IDPUT';     _type.value[40]:="''''+form(_a)+''''";                 _type.default[40]:='';
   _type;
   __mb_ftypes:=_type
?};
__mb_ftypes


\mbTabFields_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy i wypełnia tabelę struktury podanej tabeli
::   WE: _a - alias tabeli
::   WY: tabela ze strukturą
::  OLD: \mbTabFields_tab/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_Tab:=_a;
_TabAcr:={? var_pres('_b')=2 || _b || _TabAcr:=exec('tab_acr','#table',_a); {? _TabAcr<>'' || _TabAcr || '_a' ?} ?};
_tab:=tab_tmp(2
             ,'F_KIND'  ,'STRING[1]'  ,'Rodzaj'
             ,'FLD_POS' ,'INTEGER'    ,'Lp.'
             ,'FLD_NAME','STRING[60]' ,'Nazwa'
             ,'FLD_ACR' ,'STRING[8]'  ,'Akronim'
             ,'FLD_TYPE','STRING[11]' ,'Typ'
             ,'FLD_TRAW','STRING[11]' ,'Typ surowy [bez wielkości stringa]'
             ,'FLD_COMM','STRING[60]' ,'Komentarz'
             ,'FLD_VAL' ,'STRING[255]','Wartość'
             ,'F_COMMH' ,'STRING[255]','Komentarz dla bufora w nagłówku'
             ,'F_COMMO' ,'STRING[255]','Komentarz dla bufora w obiekcie'
             ,'M_BODY'  ,'SYS_MEMO'   ,'Treść metody'
             ,'MBUFSIZE','STRING[120]','Początek dla metody'
             ,'SIZE'    ,'INTEGER'    ,'Rozmiar bufora tabeli - narastajaco [bajty]'
             );
_Tab.cntx_psh();
_type:=exec('mbFieldsType','#table');
_Tab.blank(1);
_pp:=0;
_fld_num:=_Tab.fld_num();

{! _ff:=1.._fld_num
|!
   _str_len:=0;
   _tab.F_KIND:='F';
   _tab.FLD_POS:=_ff;
   _tab.FLD_ACR:=_Tab.fld_acr(_ff);
   _tab.FLD_NAME:=_Tab.fld_name(_ff);
   _tab.FLD_COMM:=_Tab.fld_comm(_ff);
   _tab.FLD_TYPE:=_Tab.fld_join(_ff);
   {? _tab.FLD_TYPE='SYSBLOB'
   || _tab.FLD_TYPE:=''
   ?};
   _type_of:=var_pres(_tab.FLD_ACR,_Tab,'diff_blob');
   _tab.FLD_VAL:=_type.value[_type_of](_Tab[_ff],_Tab,_tab.FLD_ACR);
   {? _tab.FLD_TYPE=''
   || _tab.FLD_TYPE:=_type.name[_type_of];
      _tab.FLD_TRAW:=_type.name[_type_of];
      {? _type_of=27
      || _str_len:=+(_Tab[_ff]:=9999*'#';_Tab[_ff]);
         _tab.FLD_TYPE+='['+form(_str_len)+']'
      ?}
   ||
      {? _tab.FLD_TYPE='MEMO' | _tab.FLD_TYPE='SYSMEMO'
      || _tab.FLD_TRAW:=_tab.FLD_TYPE
      || _tab.FLD_TRAW:='_'+_tab.FLD_TYPE
      ?};
      _tab.FLD_TYPE:='_'+_tab.FLD_TYPE
   ?};
   {? _pp%*4<>0
   || {? ',STRING,HEADER,SYS_MEMO,MEMO,'*(','+ _tab.FLD_TRAW+',')=0
      || _pp+=(4-_pp%*4)
      ?}
   ?};
   {? 'INTEGER,DATE,TIME'* _tab.FLD_TRAW<>0 |  _tab.FLD_TRAW='TREE_REF'
   || _pp+=4
   |? ('_'=1+_tab.FLD_TRAW)
   || _pp+=12
   |? 'BLOBRAW,BLOBIMAGE'*_tab.FLD_TRAW<>0
   || _pp+=12
   |? ('REFERENCE'*_tab.FLD_TRAW<>0)
   || _pp+=8
   |? 'REAL'=_tab.FLD_TRAW
   || _pp+=12
   |? 'STRING'=_tab.FLD_TRAW
   || _pp+=3*_str_len+1
   ?};
   {? _ff=_fld_num
   ||
::    Dla ostatniego pola zaokrąglam do czwórek
      {? _pp%*4<>0
      || _pp+=(4-_pp%*4)
      ?};

::    I dodaje jeszcze jedną czwórke
      _pp+=4
   ?};
   _tab.SIZE:=_pp;

::                ::   WY:
   _tab.F_COMMH:="::       "+(10+(_tab.FLD_ACR+(9*^8199)))+(12+(_tab.FLD_TYPE+(12*^8195)))+' - '+_tab.FLD_NAME+{? _tab.FLD_COMM<>'' || ' //'+_tab.FLD_COMM || '' ?};
   _tab.F_COMMO:='::  '+form(_tab.FLD_TYPE,12)+' '+_tab.FLD_NAME+{? _tab.FLD_COMM<>'' || ' //'+_tab.FLD_COMM || '' ?};
   _tab.add(1)
!};
_Tab.cntx_pop();
_tab


\tab_buffer_size
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca rozmiar fizycznego bufora tabeli. Rozmiar ten wpływa na maksymalną ilość
::       rekordów jaka może zmieścić się w jednej masce tabeli
::   WE: _a - alias tabeli np. TKTL
::   WY: INTEGER - rozmiar bufora tabeli w bajtach
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_result:=0;

_fields:=exec('mbTabFields_tab','#table',_tab);

{? var_pres('_fields')>100
||
   {? _fields.last()
   || _result:=_fields.SIZE
   ?}
?};
_result


\ref_table
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca uchwyt do tablicy nazwanej z tabelą przydatną do odkładania listy refów
::   WY: obiekt _arr
::UWAGA: Parametry bez [] sa wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \ref_table/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_arr:=obj_new(  'tab'
               ,'ndxNameRef'
               ,'ndxSql'
               ,'ndxRef'
               ,'ndxLp'
               ,'mk_win'
               ,'add'
               ,'r_add'
               ,'r_find'
               ,'r_del'
               ,'set_lp'
               ,'clean'
               ,'copy');
_arr.tab:=tab_tmp(2
                 ,'NAME','STRING[8]' ,'.name()'
                 ,'REF' ,'INTEGER'   ,'#.ref()'
                 ,'SQL' ,'STRING[16]','$.ref()'
                 ,'DESC','STRING[80]','opis'
                 ,'LP'  ,'REAL'      ,'Kolejność'
                 );
_arr.ndxNameRef:=_arr.tab.index('?');
_arr.ndxSql:=_arr.tab.ndx_tmp(,,'SQL',,);
_arr.ndxRef:=_arr.tab.ndx_tmp(,,'REF',,);
_arr.ndxLp:=_arr.tab.ndx_tmp(,,'LP',,);

:: tworzy okienka
_arr.mk_win:="
   _wer:=.tab.mk_sel('','P',1,,1,1);
   .tab.win_sel(_wer);
   .tab.win_act(_wer,,'Kolejność');
   .tab.win_edit(.tab.mk_edit('',1));
   ~~
";

:: dodaje ref'a do tabeli - sprawdza czy taki już istnieje i jeśli tak, to nie dodaje
_arr.add:="
   {? type_of(_a)=type_of(SYSLOG.ref())
   || _sql:=$_a
   |? type_of(_a)=type_of('')
   || _sql:=_a
   ?};

   _result:=1;

   .tab.cntx_psh();
   .tab.index(.ndxSql);
   .tab.prefix(_sql);
   {? .tab.size()=0
   || .tab.clear();
      _lp:=.tab.size()+1;
      {? var_pres('_b')=type_of(0)
      || _lp:=_b
      ?};
      .tab.NAME:=ref_name(_a);
      .tab.REF:=#_a;
      .tab.SQL:=_sql;
      .tab.LP:=_lp;
      _result:=.tab.add()
   ?};
   .tab.cntx_pop();
   _result
";

:: dodaje ref'a do tabeli - bez sprawdzania czy taki już istnieje
_arr.r_add:="
   _lp:=.tab.size()+1;
   {? var_pres('_b')=type_of(0)
   || _lp:=_b
   ?};
   .tab.NAME:=ref_name(_a);
   .tab.REF:=#_a;
   .tab.SQL:=$_a;
   .tab.LP:=_lp;
   .tab.add()
";

:: zwraca nr rekordu tabeli, który zawiera podany ref
_arr.r_find:="
   _tabref:=0;
   .tab.cntx_psh(); .tab.index(.ndxSql); .tab.prefix();
   {? .tab.find_key($_a,) || _tabref:=#.tab.ref() ?};
   .tab.cntx_pop();
   _tabref
";

:: kasuje rekord tabeli, który zawiera podany ref
_arr.r_del:="
   _result:=0;
   .tab.cntx_psh(); .tab.index(.ndxSql); .tab.prefix();
   {? .tab.find_key($_a,) || _result:=.tab.del(,1) ?};
   .tab.cntx_pop();
   _result
";

:: nadaje lp podanemu rekordowi tabeli
_arr.set_lp:="
   _result:=0;
   .tab.cntx_psh();
   .tab.index(.ndxSql);
   .tab.prefix();
   {? .tab.find_key($_a,)
   || .tab.LP:=_b;
      _result:=.tab.put()
   ?};
   .tab.cntx_pop();
   _result
";

_arr.clean:="
   .tab.cntx_psh();
   .tab.clear();
   {? .tab.first()
   || {!
      |? _can_continue:=.tab.del(,1);
         .tab.first() & _can_continue>0
      !}
   ?};
   .tab.cntx_pop();
   ~~
";

_arr.copy:="
   _dest:=_a;
   .tab.cntx_psh();
   .tab.clear();
   {? .tab.first()
   || {!
      |?
         _can_continue:=_dest.add(.tab.SQL);
         .tab.next() & _can_continue>0
      !}
   ?};
   .tab.cntx_pop();
   ~~
";

_arr


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy okienko dla podanej tabeli i wyświetla
::   WE:  _a  - wskazanie na tabelę / obiekt (tablica, tablica nazwana)
::       [_b] - drzewko? (dla tabeli domyślnie 0-nie, dla obiektu 1-tak)
::       [_c] - maska tabeli
::       [_d] - tytuł okienka
::       [_e] - lista kolumn (domyślnie wszystkie, które uda się dodać, dla obiektu predefiniowana lista)
::              użycie analogicznie jak w \select_action/#table.fml
::   WY: wybrany rekord
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \select/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
{? type_of(_a)=type_of(SYSLOG)
|| _tab:=_a;
   _tree:={? var_pres('_b')=1 || _b || 0 ?};
   _fields:={? var_pres('_e')=type_of('') || _fields:=_e || _fields:='' ?}
|? type_of(_a)>100
|| _tab:=json_tparse(json_obj(_a));
   _tree:={? var_pres('_b')=1 || _b || 1 ?};
   _fields:=
      {? var_pres('_e')=type_of('')
      || _fields:=_e
      || _fields:='NAME[50],NTRUNC[TN][-5],TYPE,VAL[50],VTRUNC[TN][-5],INDEX,BVAL'
      ?}
|| return('Błędna wartość parametru')
?};
_mask:={? var_pres('_c')=2 || _c || ~~ ?};
_title:={? var_pres('_d')=type_of('') || _d || '' ?};

_tab.cntx_psh();
{? _mask<>~~ || _tab.use(_mask) ?};
_ref:=null();
_win:={? _tree>0 || _tab.mk_sel(_tab.name()+ ' - ' +_title,'P',_fields='',form('#sellib'+_tab.name()),,,,1)
                 || _tab.mk_sel(_tab.name()+ ' - ' +_title,'P',_fields='',form('#sellib'+_tab.name()),,,,0,'U')
      ?};
{? _win<>''
||
:: nalezy tymczasowo wylaczyc formuly na wyswietl
   _fmle:=obj_new(_tab.fld_num());
   {! _fld:=1.._tab.fld_num()
   |! _fmle[_fld]:=_tab.fld_fml(_tab.fld_acr(_fld),'BEFORE_DISPLAY',"~~")
   !};

:: dodanie pól, gdy lista jest podana
   _column_width:=0;
   {? _fields<>''
   || _split:=spli_str(_fields,',');
      {! _it:=1..obj_len(_split)
      |!
         _fld_split:=_split[_it];
         _ciapek:=0;
         {? _fld_split*'[TN]'>0
         || _fld_split:=gsub(_fld_split,'[TN]','');
            _ciapek:=1
         ?};

         {? (_s1:=_fld_split*'[') & (_s2:=_fld_split*']')
         || _width:=#(_s1-((_s2-1)+_fld_split));
            {? _width=0
            || _width:=_column_width
            || _fld_split:=gsub(_fld_split,'['+$_width+']','')
            ?}
         || _width:=_column_width
         ?};

         {! _fld:=1.._tab.fld_num()
         |! _fld_acr:=_tab.fld_acr(_fld);
            {? _fld_acr=_fld_split
            || {? _ciapek>0
               || _tab.win_fld(_win,,_fld_acr,,,_width,,,,,,2,,"'T'","'N'")
               || _tab.win_fld(_win,,_fld_acr,,,_width)
               ?}
            ?}
         !}
      !}
   ?};

   {? _tab.fld_acr(1)='TABELA' & _tab.fld_acr(2)='MASKA' & _tab.fld_acr(3)='REF'
   || _tab.win_act(_win,,'Formuła','Select',,
                  ,"
                    exec('FindAndGet','#table'
                        ,($cur_tab(1,1).TABELA)()
                        ,cur_tab(1,1).REF
                        ,cur_tab(1,1).MASKA
                        ,\"
                          exec('select','#table',_a)
                         \"
                        )
                   "
                  ,
                  ,1,,,,'S'
                  );
      _tab.win_act(_win,,'Wyświetl',,,,"exec('display','#table',cur_tab(1,1).TABELA,cur_tab(1,1).REF,cur_tab(1,1).MASKA)");
      _tab.win_act(_win,,'Formuła','Testlink',,
                  ,"exec('select','#table'
                        ,exec('FindAndGet','#table'
                             ,($cur_tab(1,1).TABELA)()
                             ,cur_tab(1,1).REF
                             ,cur_tab(1,1).MASKA
                             ,'testlink()'
                             )
                        )
                   ",,,,,,'T'
                  );
      ~~

   || _tab.win_act(_win,,'Formuła','Wybór'@@,,,"sel_exit()",,1,,,,'W');
      _tab.win_act(_win,,'Wyświetl',,,,"exec('display','#table',cur_tab(1,1),cur_tab(1,1).ref())");
      _tab.win_act(_win,,'Formuła','Testlink',,,"exec('select','#table',cur_tab(1,1).testlink())",,,,,,'T');
      ~~
   ?};
   _tab.win_act(_win,,'Kolejność');
   _tab.win_sel(_win);
   {? _tab.select(,1,10)
   || _ref:=_tab.ref()
   ?};
:: teraz trzeba przywrocić poprzednią obsługę
   {! _fld:=1.._tab.fld_num()
   |! _tab.fld_fml(_tab.fld_acr(_fld),'BEFORE_DISPLAY',_fmle[_fld])
   !}
?};
_tab.cntx_pop();
_ref


\select_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Uniwersalna obudowa na wybieranie różnych rekordów z tabeli
::       Tabela musi mieć pole o akronimie SELECTED typu STRING[1]
::   WE: _a - TABLE - uchwyt do tabeli
::       [_b] - STRING - lista akronimów pól które dodawać do okna, separowana przecinkiem np 'SYMBOL,NAZWA'
::                       Jeżeli nie podane to dodawane są wszystkie. Pole SELECTED jest zawsze, nie trzeba go tu wymieniać
::                       jeżeli pole będzie miało w nazwie [TN] to będzie dodane jako ptaszek ze standardową
::                       obługą T/N. Przykład ACCEPTED[TN]
::                       Jeżeli pole ma w nazwie [liczba] np. POLE[5] oznacza to długość pola
::       [_c] - INTEGER - szerokości wszystkich kolejnych pól w oknie (oprócz pierwszego SELECTED). Domyślnie 20.
::       [_d] - STRING - tytuł okienka
::       [_e] - 1-klawisze po prawej strony wyboru, 0(domyślnie brak)
::       [_f] - STRING - niestandardowe akcje dodawane do okna (również jako przyciski) separowane znakiem ;
::                       np '&Podgląd procesu=exec(\'select4proc\',\'#b_design\',_a,0,,0);&Test=exec(\'test\',\'test\',_a)'
::                       parametr _a formuły zostanie zamieniony na cur_tab.REF jeżeli tabela ma takie pole, lub cur_tab().ref
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik zatwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_fields:='';
{? var_pres('_b')=type_of('')
|| _fields:=_b
?};

_column_width:=20;
{? var_pres('_c')=type_of(0)
|| _column_width:=_c
?};

_title:='Wybór rekordów'@;
{? var_pres('_d')=type_of('')
|| _title:=_d
?};

_selbtn:={? var_pres('_e')=type_of(0) || _e || 0 ?};
_actions:='';
{? var_pres('_f')=type_of('')
|| _actions:=_f
?};

_result:=0;

_sel:=_tab.mk_sel(_title,'P',,('#selact'+_tab.name()),,,,,'U');
_tab.win_fld(_sel,,'SELECTED',,,,,1,'Zaznaczony?'@,,'Czy wybrano rekord? (T/N)'@,2,,"'T'","'N'");

{? +_fields>0
||
   _split:=spli_str(_fields,',');
   {! _it:=1..obj_len(_split)
   |!
      _fld_split:=_split[_it];
      _ciapek:=0;
      {? _fld_split*'[TN]'>0
      || _fld_split:=gsub(_fld_split,'[TN]','');
         _ciapek:=1
      ?};

      {? (_s1:=_fld_split*'[') & (_s2:=_fld_split*']')
      || _width:=#(_s1-((_s2-1)+_fld_split));
         {? _width=0
         || _width:=_column_width
         || _fld_split:=gsub(_fld_split,'['+$_width+']','')
         ?}
      || _width:=_column_width
      ?};

      {! _fld:=1.._tab.fld_num()
      |! _fld_acr:=_tab.fld_acr(_fld);
         {? _fld_acr=_fld_split
         || {? _ciapek>0
            || _tab.win_fld(_sel,,_fld_acr,,,_width,,,,,,2,,"'T'","'N'")
            || _tab.win_fld(_sel,,_fld_acr,,,_width)
            ?}
         ?}
      !}
   !}
||
   {! _fld:=1.._tab.fld_num()
   |! _tab.win_fld(_sel,,_tab.fld_acr(_fld),,,_column_width)
   !}
?};

:: Zaznacz
_fb:="
   _tab:=cur_tab();
   _tab.SELECTED:='T';
   _tab.put();
   1
";
_gr1:="
   1
";
_gr2:="
   ~~
";
_tab.win_act(_sel,,'Formuła','&Zaznacz'@@,,'Zaznacz rekord'@,_fb,,,1,_gr1,_gr2,'Z');
{? _selbtn
|| _tab.win_btn(_sel,'text=%1,btn_label_align=center,panel=right,align=begin'['&Zaznacz'@],'menu:Z',,,,,,'noempty')
?};

:: Odznacz
_fb:="
   _tab:=cur_tab();
   _tab.SELECTED:='N';
   _tab.put()
";
_tab.win_act(_sel,,'Formuła','&Odznacz'@@,,'Odznacz rekord'@,_fb,,,1,,,'O');
{? _selbtn
|| _tab.win_btn(_sel,'text=%1,btn_label_align=center,panel=right,align=begin'['&Odznacz'@],'menu:O',,,,,,'noempty')
?};

:: Akceptuj
_fb:="
   sel_exit()
";
_tab.win_act(_sel,,'Formuła','&Akceptuj'@@,,,_fb,,,,,,'A');
_tab.win_btn(_sel,'text=%1,btn_label_align=center,panel=bottom,align=end'['&Akceptuj'@],'menu:A',,,,,,'noempty');
_tab.win_btn(_sel,'text=%1,btn_label_align=center,panel=bottom,align=end'['A&nuluj'@],'key:Esc');

{? _actions<>''
|| _act_split:=spli_str(_actions,';');
   {? obj_len(_act_split)>0
   || {! _it:=1..obj_len(_act_split)
      |! _act1:=_act_split[_it];
         {? var_pres('_act')>100
         || obj_del(_act)
         ?};
         _act:=spli_str(_act1,'=');
         {? obj_len(_act)>1
         || _act_name:=_act[1];
            _act_fml:=_act[2];

            {? _act_name<>'' & _act_fml<>''
            ||
               {? var_pres('REF',_tab)>0
               || _act_fml:=gsub(_act_fml,'_a','cur_tab.REF')
               || _act_fml:=gsub(_act_fml,'_a','cur_tab.ref()')
               ?};
               _marker:='';
               _amp_pos:=_act_name*'&';
               {? _amp_pos>0
               || _marker:=1+(_amp_pos-_act_name)
               || _marker:=1+_act_name
               ?};
               _marker:=~(-_marker);
               _tab.win_act(_sel,,'Formuła','%1'@@[_act_name],,,$_act_fml,,,,,,_marker);
               _tab.win_btn(_sel,'text=%1,btn_label_align=center,panel=right,align=begin'[_act_name],'menu:%1'[_marker],,,,,,'noempty')
            ?}
         ?}
      !}
   ?}
?};

:: Rekord
_fb:="
   _lastdraw:=1;
   {? var_pres('_a')=type_of(0)
   || _lastdraw:=_a
   ?};
   _grayed:='';
   _tab:=cur_tab();
   _sel:=cur_win();

   {? _lastdraw>0
   ||
      {? _tab.sel_size()=0
      ||
::       Pojedyncze zaznaczenie
         {? _tab.SELECTED='T'
         || _tab.actions(_sel,,'O',1);
            _grayed+='Z'
         |? _tab.SELECTED='N' | _tab.SELECTED=''
         || _tab.actions(_sel,,'Z',1);
            _grayed+='O'
         ?}
      ||
::       Zaznaczenie grupowe
         _tab.actions(_sel,,'Z',1)
      ?};

      _anyselected:=0;
      _current:=_tab.ref();
      _tab.first();
      {!
      |? _anyselected:=(_tab.SELECTED='T');
         _tab.next() & ~_anyselected
      !};
      _tab.seek(_current);
      _tab.actions_grayed(_sel,_grayed)

   ?}
";
_tab.win_act(_sel,,'Rekord',,,,_fb);

_tab.win_sel(_sel);
{? _tab.select()
|| _result:=1
?};
_result


\display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Tworzy okienko dla podanej tabeli i wyświetla rekord podany w parametrach
::   WE: _a - wskazanie na tabelę lub jej akronim
::       _b - tabela.ref() lub #ref
::       _c - maska
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \display/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:={? type_of(_a)=2 || ($_a)() || _a ?};
{? type_of(_b)=7
|| _ref:=#_b;
   _maska:=ref_name(_b)
|| _ref:=_b;
   _maska:={? var_pres('_c')=2 || _c || _tab.name() ?}
?};
_tab.cntx_psh();
_tab.win_edit('');
_tab.win_edit(_tab.mk_edit('',1));
_fmle:=obj_new(_tab.fld_num());
{! _fld:=1.._tab.fld_num()
|! _fmle[_fld]:=_tab.fld_fml(_tab.fld_acr(_fld),'BEFORE_DISPLAY',"~~")
!};
exec('FindAndGet','#table',_tab,_ref,_maska
    ,"
      _count:='$ref='''+($ref())+'''; count='+$count();
      {? win_edit('?')<>''
      || hdr_edit(_count); display()
      || FUN.info('Nie udało się utworzyć okienka, ale...\n%1'@[_count])
      ?}");
{! _fld:=1.._tab.fld_num()
|! _tab.fld_fml(_tab.fld_acr(_fld),'BEFORE_DISPLAY',_fmle[_fld])
!};
_tab.cntx_pop();
~~


\find_sql
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [2008]
:: OPIS: Procedura poszukujaca w tabeli na podstawie poniższych parametrów
::   WE: _a - tabela, w ktorej szukamy
::       _b - pola po ktorych szukamy (rozdzielone ;)
::          - oznacza pole tylko do okienka selekcji
::          *(S)oznacza pole dodatkowe (wolne pole)-okienko selekcji w nawiasie typ pola
::       _c - warunek wyszukiwania (w SQL-u)
::       _d - pole do ktorego przypisujemy
::       _e - szerokości kolumn (dodatkowo po @ mozna podac nazwe kolumny)
::       _f - okienko do wyswietlania
::       _g - formuly obliczeniowe dla wolnych pol
::            nazwa#plik; nazwa#plik;
::       _h - usuwanie pol zerowych wg typu
::            przyklad wywolania:
::            exec('find_sql','find_rad','M','KTM;N;*(R)IL','','BEER.M','20@KTM;30@Nazwa;12@Ilosc;','RED_T'
::               ,'obl_stan#find_rad','')
::       _j - 0/1 - włączenie działania funkcji
::  OLD: \find_sql/find_rad.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_j')<>type_of(0) | _j<>1 || return() ?};
{? var_pres('FUX')>100 || obj_del(FUX) ?};
_txt:=exec('gen_sql','#table',_a,_b);
_tab:=($_txt[1])();
_zap:='sql(\''+_txt[2]+{? _c<>'' || _txt[3]+' '+_c || _txt[3]-4 ?}+'\'';
_szer:=form(_e);
acrw:=form(_f);
acrt:=form(_a);
_g:=form(_g);
{| _tab
|! _ile:=fld_num();
   _win_edit:=mk_edit('Dane do filtrowania'@,0);
   win_esep(_win_edit,'Filtr'@);
   {! _i.._ile |! {? fld_name(_i)<>'' || win_efld(_win_edit,,fld_acr(_i),,,60,,,fld_name(_i),0,'',) ?} !};
   win_ebtn(_win_edit,'text=%1, btn_label_align=center, panel=bottom, align=end'['&Zapisz'@],"'key:F2'");
   win_ebtn(_win_edit,'text=%1, btn_label_align=center, panel=bottom, align=end'['&Anuluj'@],"'key:Esc'");
   win_edit(_win_edit);
   {? _ok:=edit()
   || add(1);
      {! _i.._ile |! _tab[_i]:=exec('strtosql','#string',_tab[_i]);put !};
      {! _i.._ile |! _zap+=',\''+(-form([_i]))+'\'' !};
      _zap+=')'
   ?};
   obj_del(_tab)
|};
{? _ok
|| FUX:=($_zap)();
   {| FUX
   |! _ile:=fld_num()-1;
      _win_sel:=mk_sel('Wynik wykonania akcji filtrowania'@,'P',,'find_sql',,,,,'U');
      {! _i:=3.._ile
      |! _nrs:=(_szer*';');
         _name:='';
         {? _nrs
         || _nr_op:=(_szer*'@');
            {? _nr_op=0
            ||
               _dlg:=#((_nrs-1)+_szer)
            ||
               _name:=_nr_op-((_nrs-1)+_szer);
               _dlg:=#((_nr_op-1)+((_nrs-1)+_szer))
            ?};
            _szer:=_nrs-_szer
         |? (~_nrs & +_szer)
         || _dlg:=#_szer; _szer:=''
         || _dlg:=10
         ?};
         {? _name='' || _name:=exec('fldLabel','#field',_a,fld_acr(_i)) ?};
         win_fld(_win_sel,,fld_acr(_i),,,_dlg,3,1,_name)
      !};
      win_act(_win_sel,,'Formuła','Wybierz'@@,,'Wybór bieżącego zapisu'@,,"sel_exit()",1);
      win_act(_win_sel,,'Szukaj');
      win_act(_win_sel,,'Wyświetl',,,,,"exec('disp_tab','#record',acrt,acrw,@.FUX.FUX)",0);
      win_act(_win_sel,,'Kolejność');
      ndx_drop();
      _acr:=ndx_tmp('',0,fld_acr(3),,{? type_of(($('FUX.'+fld_acr(3)))())=1 || 1 || 0 ?});
      index(_acr);
      prefix();
      win_sel(_win_sel);
      {? first()
      || {? _txt[4] & _g<>''
         || exec('uzupdane','#table',_g,_h)
         |? _g='' & _h<>''
         || exec('destroy','#table',_h)
         ?};
         {? select() || ($_d)():=exec('FindAndGet','#table',@.FUX.TFUX,@.FUX.FUX,,,null()) ?}
      ?}
   |};
   obj_del(FUX); &FUX
?};
obj_del(_txt);
&acrt; &acrw;
''


\uzupdane
::----------------------------------------------------------------------------------------------------------------------
::  UTW: rr [2006]
:: OPIS: uzupełnia wolne pola w tabelce wg podanych formuł (formuła pomocnicza dla funkcji find_sql)
::   WE: _a - formułki
::       _b - usuwa pola zerowe wg typu
::  OLD: \uzupdane/find_rad.fml
::----------------------------------------------------------------------------------------------------------------------
_ilf:='';
_ch1:=';';
_ch2:='#';
_buf:=_a;

_guf:=form(_b);
_ilu:=0;
{? _guf<>''
|| {!
   |? _ilu+=1;
      _nr:=(_guf*_ch1);  _guf:=_nr-_guf;
      _nr
   !};
   _guf:=form(_b);
   _pan:=obj_new(_ilu);
   _i  :=0;
   {!
   |? _i  +=1;
      _nr:=(_guf*_ch1);
      {? _nr || _pan[_i]:=(_nr-1)+_guf; _guf:=_nr-_guf || _pan[_i]:=_guf; _guf:='' ?};
      _nr
   !}
?};

_ilp:=FUX.fld_num();
{? _a*_ch2
|| _ilf:=1;
   {!
   |? _nr:=_buf*_ch1;
      _ilf+=(_nr<>0);
      _buf:=_nr-_buf;
      _nr
   !};
   _dan:=obj_new(_ilf);
   {! _i.._ilf |! _dan[_i]:=obj_new(3); _dan[_i][1]:=''; _dan[_i][2]:=''; _dan[_i][3]:=0 !};
   _buf:=_a; _i:=0; _k:=3;
   {!
   |? _nr:=_buf*_ch1;
      _nrf:={? _nr || (_nr-1)+_buf || _buf ?}*_ch2;
      _i  +=1;
      _dan[_i][1]:=form((_nrf-1)+_buf);
      _dan[_i][2]:=_nrf-{? _nr || ((_nr-1)+_buf) || _buf ?};
      {! |? {? _k<=_ilp & (FUX.fld_name(_k)+2)='__' || _dan[_i][3]:=_k; _k+=1; 0 || _k+=1; _k<=_ilp ?} !};
      _buf:=form(_nr-_buf);
      _nr & _buf<>''
   !};
   {| FUX
   |! {? first()
      || {!
         |? {! _i:=1.._ilf |! {? _dan[_i][3] || [_dan[_i][3]]:=exec('oblicz','#file',_dan[_i][1],_dan[_i][2]) ?} !};
            {? _ilu
            || _del:=_ilu;
               {! _j.._ilu
               |! _pol:=$('FUX.'+{? (1+_pan[_j])='*' || (1-_pan[_j])+'__' || _pan[_j] ?});
                  _war:=_pol();
                  _typ:=type_of(_war);
                  _del-=(_typ=1 & _war=0) | (_typ=2 & _war='')
                      | (_typ=4 & _war=date(0,0,0)) | (_typ=5 & _war=time(0,0,0))
               !};
               {? _del || put(1); next() || del() ?}
            || put(1); next()
            ?}
         !}
      ?}
   |}
?};
{? _ilu || obj_del(_pan) ?};
1


\destroy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: rr [2006]
:: OPIS: usunięcie pól zerowych (formuła pomocnicza dla funkcji find_sql)
::   WE: _a - schemat pól
::  OLD: \destroy/find_rad.fml
::----------------------------------------------------------------------------------------------------------------------
_ch:=';';
_buf:=form(_a);
_ilp:=0;
{? _buf<>''
|| {!
   |? _ilp+=1;
      _nr:=(_buf*_ch);  _buf:=_nr-_buf;
      _nr
   !};
   _buf:=form(_a);
   _dan:=obj_new(_ilp);
   _i  :=0;
   {!
   |? _i  +=1;
      _nr:=(_buf*_ch);
      {? _nr || _dan[_i]:=(_nr-1)+_buf; _buf:=_nr-_buf || _dan[_i]:=_buf; _buf:='' ?};
      _nr
   !};
   {| FUX
   |! {? first()
      || {!
         |? _del:=_ilp;
            {! _i.._ilp
            |! _pol:=$('FUX.'+{? (1+_dan[_i])='*' || (1-_dan[_i])+'__' || _dan[_i] ?});
               _war:=_pol();
               _typ:=type_of(_war);
               _del-=(_typ=1 & _war=0) | (_typ=2 & _war='')
                   | (_typ=4 & _war=date(0,0,0)) | (_typ=5 & _war=time(0,0,0))
            !};
            {? _del || next() || del() ?}
         !}
      ?}
   |};
   obj_del(_dan)
?}


\gen_sql
::----------------------------------------------------------------------------------------------------------------------
::  UTW: rr [2006]
:: OPIS: tworzy tabelę tymczasową z danymi
::   WE: _a - tabela
::       _b - pola
::   WY: _wyn - tabela danych string
::  OLD: \gen_sql/find_rad.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=obj_new(4);

:: 1-tabelka tymczasowa
:: 2-zapytanko SQL
:: 3-warunek zapytanka
:: 4-ilosc wolnych pol

_wyn[1] :='tab_tmp(';
_wyn[2] :='select \\\''+_a+'\\\' TFUX,'+_a+'.REFERENCE FUX, ';
_wyn[3] :=' where';
_wyn[4] :=0;
_ch  :=';';
_pola:=form(_b);
_i   :=0;
{!
|? _nr:=(_pola*_ch);
   {? _nr
   || _i+=1;
      _pol:=(_nr-1)+_pola; _pola:=(_nr-_pola);
      _dod:=1+_pol;
      {? _dod='*'
      || _pol:=1-_pol;
         _typ:={? (1+_pol)='('
               || _pol:=1-_pol;
                  _lit:=(1+_pol); _pol:=2-_pol;
                  {? _lit='S' || 'STRING[20]'
                  |? _lit='R' || 'REAL'
                  |? _lit='I' || 'INTEGER'
                  |? _lit='D' || 'DATE'
                  |? _lit='T' || 'TIME'
                  |? _lit='F' || ''
                  || 'STRING[20]'
                  ?}
               || 'STRING[20]'
               ?}
      |? _dod='-'
      || _pol:=1-_pol;
         _typ:=exec('ust_typ','#field',_a,_pol)
      || _typ:=exec('ust_typ','#field',_a,_pol)
      ?};
      _lit:=1+_typ;
      _wyn[1]+=',\''+_pol+'\',\''+_typ+'\',\''+{? ~('*-'*_dod) || exec('fldLabel','#field',_a,_pol) || '' ?}+'\'';
      {? ~('-*'*_dod)
      || _wyn[2]+=_a+'.'+_pol+' ,';
         _wyn[3]+=' (lower('+_a+'.'+_pol+') like \\\'%:_'+%(96+_i)+'%\\\' or \\\':_'+%(96+_i)+'\\\' = \\\'\\\') and'
      ||
         {? 'R'*_lit
         || _wyn[2]+=' CAST(0 AS REAL_TYPE) '+_pol+'__,'
         |? 'I' * _lit
         || _wyn[2]+=' CAST(0 AS INTEGER_TYPE) '+_pol+'__,'
         |? 'S' * _lit
         || _wyn[2]+='\\\'                    \\\' '+_pol+'__,'
         |? 'D' * _lit
         || _wyn[2]+=' CAST(0 AS DATE_TYPE) '+_pol+'__,'
         |? 'T' * _lit
         || _wyn[2]+=' CAST(0 AS TIME_TYPE) '+_pol+'__,'
         || _wyn[2]+='\\\'\\\' '+_pol+'__,'
         ?}
      ?};
      _wyn[4]+=(_dod='*');
      1
   || _i+=1;
      _pol:=_pola;
      _dod:=1+_pol;
      {? _dod='*'
      || _pol:=1-_pol;
         _typ:={? (1+_pol)='('
               || _pol:=1-_pol;
                  _lit:=(1+_pol); _pol:=2-_pol;
                  {? _lit='S' || 'STRING[20]'
                  |? _lit='R' || 'REAL'
                  |? _lit='I' || 'INTEGER'
                  |? _lit='D' || 'DATE'
                  |? _lit='T' || 'TIME'
                  || 'STRING[20]'
                  ?}
               || 'STRING[20]'
               ?}
      |? _dod='-'
      || _pol:=1-_pol;
         _typ:=exec('ust_typ','#field',_a,_pol)
      || _typ:=exec('ust_typ','#field',_a,_pol)
      ?};
      _lit:=1+_typ;
      _wyn[1]+=',\''+_pol+'\',\''+_typ+'\',\''+{? ~('*-'*_dod) || exec('fldLabel','#field',_a,_pol) || '' ?}+'\'';
      {? ~('-*'*_dod)
      || _wyn[2]+=_a+'.'+_pol+' ,';
         _wyn[3]+=' (lower('+_a+'.'+_pol+') like \\\'%:_'+%(96+_i)+'%\\\' or \\\':_'+%(96+_i)+'\\\' = \\\'\\\') and'
      ||
         {? 'R'*_lit
         || _wyn[2]+=' CAST(0 AS REAL_TYPE) '+_pol+'__,'
         |? 'I' * _lit
         || _wyn[2]+=' CAST(0 AS INTEGER_TYPE) '+_pol+'__,'
         |? 'S' * _lit
         || _wyn[2]+='\\\'                    \\\' '+_pol+'__,'
         |? 'D' * _lit
         || _wyn[2]+=' CAST(0 AS DATE_TYPE) '+_pol+'__,'
         |? 'T' * _lit
         || _wyn[2]+=' CAST(0 AS TIME_TYPE) '+_pol+'__,'
         || _wyn[2]+='\\\'\\\' '+_pol+'__,'
         ?}
      ?};
      _wyn[4]+=(_dod='*');
      0
   ?}
!};
_wyn[1]+=')';
_wyn[2]:=(_wyn[2]-1)+' from '+_a;
_wyn


\bufRec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2010]
:: OPIS: kopiuje do bufora rekord tabeli
::   WE: _a - akronim tabeli
::       _b - tabela danych
::  OLD: \buf_r/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
_n:=obj_len(_b); _m:=($(_a+'.fld_num()'))(); {? _m<_n || _n:=_m ?};
{! _i.._n |! _form:=$(_a+'['+$_i+']'); {? type_of(_form()) || _b[_i]:=_form() ?} !}


\unbufRec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2010]
:: OPIS: przepisanie rekordu z bufora
::   WE: _a - akronim tabeli
::       _b - tabela danych
::  OLD: \unbuf_r/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
_n:=obj_len(_b); _m:=($(_a+'.fld_num()'))(); {? _m<_n || _n:=_m ?};
{! _i.._n
|! _fld:='%1.fld_acr(%2)'[_a,$_i];
   {? var_pres(($_fld)(),($_a)())<>36
   || _form:=$(_a+'['+$_i+']'); {? type_of(_form()) || _form():=_b[_i] ?}
   ?}
!}


\reNrAdd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [8.40]
:: OPIS: renumeracja pola _b w bieżącej dziedzinie rekordów tabeli _a
::       wykonywana po dodaniu rekordu
::   WE: _a - akronim tabeli
::       _b - akronim pola
::   WY: 1 - renumeracja powiodła się, 0 - wpp
::  OLD: \reNrAdd/skid_lb0.fml
::----------------------------------------------------------------------------------------------------------------------
_return:=1;

_TAB:=_a;
_TABAKR:=$(_TAB+'.'+_b);
_cntxpsh:=$(_TAB+'.cntx_psh()');
_cntxpop:=$(_TAB+'.cntx_pop()');
_last:=$(_TAB+'.last()');
_prev:=$(_TAB+'.prev()');
_put:=$(_TAB+'.put()');
_nr:=_TABAKR();
_cntxpsh();
{? _last()
||
   {!
   |? {? _TABAKR()<_nr
      ||
         _loop:=0
      ||
         _TABAKR():=_TABAKR()+1;
         _return:=_put();
         _loop:=_prev()
      ?};
      _return & _loop
   !}
?};
_cntxpop();

_return


\reNrDel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [8.40]
:: OPIS: renumeracja pola _b w bieżącej dziedzinie rekordów tabeli _a
::       wykonywana po usunięciu rekordu
::   WE: _a - akronim tabeli
::       _b - akronim pola
::   WY: 1 - renumeracja powiodła się, 0 - wpp
::  OLD: \reNrDel/skid_lb0.fml
::----------------------------------------------------------------------------------------------------------------------
_return:=1;

_TAB:=_a;
_AKR:=_b;
_TABAKR:=$(_TAB+'.'+_AKR);
_cntxpsh:=$(_TAB+'.cntx_psh()');
_cntxpop:=$(_TAB+'.cntx_pop()');
_next:=$(_TAB+'.next()');
_ref:=$(_TAB+'.ref()');
_ref:=_ref();
_seek:=$(_TAB+'.seek(_a)');
_put:=$(_TAB+'.put()');
{!
|? _TABAKR():=_TABAKR()-1;
   _return:=_put();
   _return & _next()
!};
{? _return || _seek(_ref) ?};

_return


\ReNumAfterDel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JF [2008]
:: OPIS: przenumerowanie pól po usunięciu rekordu
::   WE: _a - akronim tabeli
::       _b - akronim pola
::       [_c] - formuła na ograniczenie dziedziny index + prefix
::  OLD: \poz_usun/defin.fml
::----------------------------------------------------------------------------------------------------------------------
:: formula do wykonania na prefix
_fml:={? _>2 & (type_of(_c)=2 | type_of(_c)=3) || _c || '' ?};

{| ($_a)()
|! cntx_psh();
   ($_fml)();
   _licz:=0;
   {? first()
   || {!
      |? _licz+=1;
         ($('@.'+_a+'.'+_b))():=_licz;
         put();
         next()
      !}
   ?};
   cntx_pop()
|}


\for_each_mask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: dla każdej maski maski podanej tabeli wykonuje podaną formułę
::   WE:  _a  - alias tabeli (przekazywany jako parametr _a do formuły _b)
::       [_b] - formuła
::       [_c] - maska od której zacząć iteracje
::       [_d] - maska na której skończyć iteracje
::       [_e] - parametr (przekazywany jako parametr _b do formuly _b)
::       [_f] - ANY - oczekiwana wartość która powinna zwrócić formuła _b - jeśli zwrócona wartość
::              bedzie inna to pętla po maskach jest przerywana i w wyniku będzie 0
::       [_g] - czy wyświetlać progress dla masek (tekst komunikatu)
::       [_h] - INTEGER - kierunek przetwarzania masek: [1] - do przodu, -1 - wstecz
::   WY: 0/1 - czy udało sie wykonać formułe _b z oczekiwaną wartoscią we wszystkich maskach
::  OLD: \for_each_mask/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(SYSLOG) || _a
      |? var_pres('_a')=2               || ($_a)()
      |? var_pres('_a')=3               || _a()
                                        || return(0)
      ?};

_fml:={? var_pres('_b')=2
       | var_pres('_b')=3 || $(''+_b)
      || "_a.sort(1)"
      ?};

_start:={? var_pres('_c')=type_of('')
        || _c
        || ''
        ?};

_stop:={? var_pres('_d')=type_of('')
       || _d
       || '~~~~~~~~'
       ?};

_params:={? var_pres('_e')>0 || _e || ~~ ?};

_expected:={? var_pres('_f')>0 || _f || ~~ ?};

{? var_pres('_g')=type_of('')
|| _progress:=1; _progress_txt:=_g
|? var_pres('_g')=type_of(0) & _g=1
|| _progress:=1; _progress_txt:='Przetwarzanie tabeli %1.'@[2-!_tab]
|| _progress:=0; _progress_txt:=''
?};
_dir:=1;
{? var_pres('_h')=type_of(0)
|| _dir:=_h
?};

_tab.cntx_psh();
_names:=_tab.names();
_size:=_names.size();
_it:=0;

_can_continue:=0;
_result:=1;

{? _start<>''
|| {? _dir>0
   || _can_continue:=_names.find_ge(_start)
   || _can_continue:=_names.find_le(_start)
   ?}
|| {? _dir>0
   || _can_continue:=_names.first()
   || _can_continue:=_names.last()
   ?}
?};
{? _can_continue>0
|| {!
   |? _it+=1;
      {? _progress || progress(_it/_size*100,_progress_txt+'\n'+'Maska: %1.'@[_names.NAME],FUN.TYT) ?};
      {? _names.SIZE<>0
      ||
         _tab.use(_names.NAME);
         _ret:=_fml(_tab,_params);
         {? type_of(_expected)>0
         || _can_continue:={? _ret=_expected
                           || 1
                           || 0
                           ?}
         ?}
      ?};
      {? _dir>0
      || _next:=_names.next()
      || _next:=_names.prev()
      ?};
      {? _dir>0
      || _names_cmp:=_names.NAME<=_stop
      || _names_cmp:=_names.NAME>=_stop
      ?};

      _next>0 & _can_continue>0 & _names_cmp
   !};
   {? _can_continue=0
   || _result:=0
   ?}
?};

_tab.cntx_pop();
{? _progress || prgs_clr() ?};
_result


\GetTabFromList
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [2011]
:: OPIS: Zwraca tabelę z listą ref'ów
::   WE: _a - tabela, gdzie szukać
::       _b - akronim pola, w którym jest szukana wartość
::       _c - lista wartości pola _b
::       [_d] - separator (domyslnie ' ')
::   WY: tabela lub tekst błędu
::  OLD: \GetTabFromList/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=tab_tmp(2
                ,'MASK'    ,'STRING[8]'  ,'TAB.name()'
                ,'REF'     ,'INTEGER'    ,'#TAB.ref()'
                ,'SQLREF'  ,'STRING[16]' ,'$TAB.ref()'
                ,'VALUE'   ,'STRING[255]','Wartość'
                );
   _tab:={?_>0 & type_of(_a)=type_of(SYSLOG) || _a
         |?_>0 & type_of(_a)=type_of('')     || ($_a)()
                                             || return('Brak lub błędny typ parametru 1')
         ?};
   _fld:={?_>1 & type_of(_b)=type_of('')     || _b
                                             || return('Brak lub błędny typ parametru 2')
         ?};

_values:={?_>2 & type_of(_c)=type_of('')     || _c
                                             || return('Brak lub błędny typ parametru 3')
         ?};

   _sep:={?_>3 & type_of(_d)=type_of('')     || _d
                                             || ' '
         ?};

{? _values<>''
|| _ndx:=_tab.ndx_tmp(''
                     ,1
                     ,_fld,,
                     ,_fld,,
                     );
   _tab.cntx_psh();
   _tab.clear();
   _tab.index(_ndx);

   {!
   |?
      _can_continue:=1;
      _pos:=_values*_sep;
      {? _pos>0
      ||
         _value:={? _pos>0
                 || (_pos-1)+_values
                 ?};
         _values:=_pos-_values;
         _can_continue:=+_value
      || _value:=_values;
         _can_continue:=0
      ?};
      {? _tab.find_key(_value,_value)
      || _result.blank();
         _result.VALUE:=_value;
         _result.REF:=#_tab.ref();
         _result.MASK:=_tab.name();
         _result.SQLREF:=$_tab.ref();
         _result.add()
      ?};
      _can_continue>0
   !};
   _tab.cntx_pop();
   _tab.ndx_drop(_ndx);
   ~~
?};
_result


\compare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Porównuje zawartość dwóch obiektów buforujących
::       Porównywane mogą być obiekty buforowe tej samej tabeli
::   WE: _a - obiekt buforujący
::       _b - obiekt buforujący
::       _c - czy porównywać wszystkie pola (1) czy tylko wybrane (0)
::       [_d, ...] - lista pól dołączanych/wyłączanych z porównania
::   WY: 1 (identyczna zawartość), 0 (są różnice)
::----------------------------------------------------------------------------------------------------------------------
_buffer1:=_a;
_buffer2:=_b;
_all:=_c;

{? ref_tab(_buffer1.ref())<>ref_tab(_buffer2.ref())
|| FUN.error('Porównanie buforów różnych tabel nie jest możliwe.'@);
   _res:=0
||
   _fields:=tab_tmp(1,'ACRONIM','STRING[8]','Akronim pola');
   {? var_pres('_d')=type_of('')
   || {! _it:=4.._
      |! {? var_pres('_['+$_it+']')=type_of('')
         || _fields.ACRONIM:=_[_it];
            _fields.add()
         ?}
      !}
   ?};
   _res:=1;
   _acronyms:=_buffer1.acronyms();
   {! _it:=1..obj_len(_acronyms)
   |! _fields.prefix(_acronyms[_it],);
      {? _all
      || {? _fields.first() || _compare:=0 || _compare:=1 ?}
      || {? _fields.first() || _compare:=1 || _compare:=0 ?}
      ?};
      {? _compare || _res*=($('_a.'+_acronyms[_it]+'=_b.'+_acronyms[_it]))(_buffer1,_buffer2) ?}
   !}
?};
_res


\empty_f_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2011]
:: OPIS: ustawienie pustej dziedziny f_set dla tabeli _a
::   WE: _a - tabela
::   WY: wynik f_set()
::  OLD: \empty_f_set/lib_prod.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_tab.fset('','','0=1')


\NewOrder
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [2008]
:: OPIS: nadaje pozycje a la order (musi byc ustawiony prawidłowy indeks i prefix)
::   WE:  _a - akronim tabeli
::        _b - akronim pola typu LP (order)
::        [_c] - akronim indeksu
::        [_d] - wartość prefiksu (1 pole indeksu)
::   WY: numer
::  OLD: \poz_bl/defin.fml
::       \bl_pozup/um2.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_tab:=($_a);
_fld:=($('@.'+_a+'.'+_b));
_wgi:=0;
_ind:={? _>2 & type_of(_c)=2 & form(_c)<>'' || _wgi:=1; $(_a+'.index('''+form(_c)+''')') || '' ?};
_prf:={? _>3 || _d || ~~ ?};

{| _tab()
|! cntx_psh;
   {? _wgi
   || _ind();
      {? _prf<>~~ || prefix(_prf) || prefix() ?}
   ?};
   _wyn:={? last() || _fld() || 0 ?}+1;
   cntx_pop
|};
_wyn


\has_idadd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy tabela zawiera pole typu IDADD
::   WE: _a - TABLE - uchwyt do tabeli
::   WY: 0 - tabela nie ma pola typu IDADD
::       1 - tabela ma pole typu IDADD
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_result:=0;

{? _tab.idadd_acr()<>''
|| _result:=1
?};
_result


\ref2uid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ustala unikalny identyfikator rekordu tabeli.
::   WE: _a [REFERENCE] - Wskazanie rekordu tabeli.
::   WY: uidref wskazanego rekordu lub tekst pusty jeśli nie udało się go ustalić.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) | _a=null()
|| return('')
?};

_TAB:=ref_tab(_a);
_TAB.cntx_psh();
_TAB.use(ref_name(_a));
_TAB.prefix();
_uid:={? _TAB.seek(_a) || _TAB.uidref() || '' ?};
_TAB.cntx_pop();
_uid


\dom_empty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Sprawdza, czy dziedzina tabeli jest pusta.
::   WE: _a - Alias do tabeli.
::   WY: 1 - Dziedzina tabeli jest pusta.
::       0 - Dziedzina tabeli nie jest pusta.
::----------------------------------------------------------------------------------------------------------------------
~(_a.sel_size() | {? _a.f_active() || _a.f_size() || _a.size() ?})


\tab_or_var
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy podany akronim jest tabelą czy zmienną zdefiniowaną w MacroBUILDER
::   WE: _a - STRING - akronim tabeli lub zmiennej
::   WY: 0 - wystąpił błąd
::       1 - podany akronim jest zmienną
::       2 - podany aronim jest tabelą
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_acr:=_a;

_result:=0;

{? _acr='_a'
|| _result:=2
||
   _name:=($(_acr+'.name()'))();
   _name1:=($(_acr+'.name(1)'))();

   {? _name=''
   ||
::    Zmienna lub tabela maskowalna
      {? _name1*'?'>0
      ||
::       Zawiera pytajniki więc tabela maskowalna
         _result:=2
      ||
::       Nie zawiera pytajników, więc zmienna
         _result:=1
      ?}
   ||
::    Jeżeli name jest niepusty to na bank mamy do czynienia z prawdziwą tabelą
      _result:=2
   ?}
?};
_result


\tab2tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2011]
:: OPIS: przepisanie danych z jednej tabeli do drugiej
::   WE: _a - wejsciowa tabela uchwyt (moze byc tymczasowka)
::       _b - wyjsciowa tabela (akronim albo uchwyt)
::       [_c] - bez usuwania starych danych 1-nie usuwac 0-usuwac (domyslnie)
::       [_d] - INTEGER - czy na tabeli _a wykonywać clear, czy pracować na aktualnej dziedzinie
:: UWAGA: nie jest kontrolowana struktura tabel
::  OLD: \tab2tab/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
{? _>=3 || {? type_of(_c)<>1 || _c:=0 ?} || _c:=0 ?};

{? var_pres('_b')=type_of('')
|| _tab2:=($(_b))()
|| _tab2:=_b
?};

_doclear:=1;
{? var_pres('_d')=type_of(0)
|| _doclear:=_d
?};
_mema:=tab_tmp(1,
   'ACR','STRING[8]','Nazwa pola 1');

{| _a
|! _tab2.cntx_psh();
   _tab2.clear();
   {? ~_c || _tab2.erase() ?};
   _ile:=fld_num();
   {? _doclear>0
   || clear()
   ?};
   {? first()
   || {!
      |? _tab2.blank();
         {! _i:=1.._ile
         |!
            _acr:=fld_acr(_i);
            {? var_pres(fld_acr(_i),_a)=36
            ||
::             Specjalna obsługa SYS_MEMO
               _mema.prefix(_acr);
               {? _mema.first()=0
               ||
::                Zbieram akronimy SYS_MEMów
                  _mema.blank();
                  _mema.ACR:=_acr;
                  _mema.add()
               ?};
               _txt:=memo_txt(,1,_acr);
               _tab2.memo_set(_txt,_acr)
            || _tab2[_i]:=[_i]
            ?}
         !};
         _tab2.add(1);

::       Specjalna obsługa SYS_MEMO
         _mema.prefix();
         {? _mema.first()
         || {!
            |? _tab2.memo_put(,_mema.ACR);
               _mema.next()
            !}
         ?};
         next()
      !}
   ?};
   _tab2.cntx_pop()
|}


\bufAndgetRec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: podczytuję zawartośc buforu, podczytuje rekord i zapisuję zawartość buforu podanj tabeli
::   WE: _a - akronim tabeli
::----------------------------------------------------------------------------------------------------------------------
_flds:=obj_new(($(_a+'.fld_num()'))());
exec('bufRec','#table',_a,_flds);
($(_a+'.get()'))();
exec('unbufRec','#table',_a,_flds);
obj_del(_flds);
~~


\for_each
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [GS] [12.10]
:: OPIS: Wykonuje formule _b dla wszystkich rekordow tabeli _a
::   WE: _a - alias do tabeli
::       _b - formula do wykonania
::       _c - (opcjonalny) wartosc drugiego argumentu metody for_each tabeli, jesli pominiety przyjety zostanie 1
::  OLD: \for_each/util.fml
::----------------------------------------------------------------------------------------------------------------------
_FILES:=_a.names();
_loop:=_FILES.first();
_left:=_FILES.size();
_echo:={? var_pres('_c')=type_of(0) || _c || 1 ?};

_a.cntx_psh();
{!
|? _loop
|! echo('Aktualizacja zbioru %1'@[_FILES.NAME],'Pozostało %1'@[$_left]);
   _a.use(_FILES.NAME);
   _a.clear();
   _a.for_each(_b,_echo);
   _left-=1;
   _loop:=_FILES.next()
!};
_a.cntx_pop();

echo()


\loop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [18.02]
:: OPIS: Wykonuje formułę dla wierszy wskazanej tabeli, ograniczenie dziedziny jest uwzględnione.
::   WE: _a [TABLE] - alias tabeli do przetworzenia
::       _b [STRING] - akronim kolumny zawierającej wskazania (REFERENCE/STRING)
::       _c [RULE] - formuła do wykonania
::       _d [ANY] - argument dla wykonywanej formuły, w przypadku wielu należy użyć tablicy
::   WY: ~~
::UWAGA: Poprawność argumentów wywołania nie jest weryfikowana.
::----------------------------------------------------------------------------------------------------------------------
_a.cntx_psh();
_filter:=_a.f_active();
{? ~{? _filter || _a.f_first() || _a.first() ?}
|| _a.cntx_pop();
   return(0)
?};

: ustal argument przekazywany do formuły
_arg:={? var_pres('_d')>0 || _d || ~~ ?};
: formułka pobierająca wskazanie
_ref:=$('_a.'+_b);

: przetwarzaj wskazania
_TAB:=ref_tab(_ref(_a));
_TAB.cntx_psh();
_TAB.prefix();
_loop:=1;
{!
|? _loop
|! {? _TAB.seek(_ref(_a))
   || _c(_arg)
   ?};
   _loop:={? _filter || _a.f_next() || _a.next() ?}
!};
: porządki
_TAB.cntx_pop();
_a.cntx_pop();

~~


\memo_empty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy notatka jest pusta
::   WE: _a - akronim tabeli
::       _b - ref() rekordu
::       _c - akronim pola
::   WY: zawartość pusta (1), zawartość niepusta (0)
::----------------------------------------------------------------------------------------------------------------------
_empty:=1;
_tab:=($_a)();
_tab.cntx_psh();
{? _tab.seek(#_b,ref_name(_b),1)
|| {? _tab.memo_lin(_c)<>'\n' || _empty:=0 ?}
?};
_tab.cntx_pop();
_empty


\cur_tab_disp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Wyswietla zawartosc bufora tabeli aktualnie wyswietlanego okna
::  OLD: \cur_tab_disp/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
cur_tab(1,1).display()


\sumator
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wylicza sumatory w oknie wertowania
::       Do zastosowania przed wyświetleniem PIERWSZEGO pola z podsumowaniem w oknie
::   WE: [_a] - tabela (domyślnie cur_tab(1,1)
::       _b - akronim 1. sumowanego pola
::       [_c...] - akronimy kolejnych sumowanych pól
::   WY: tablica wynikowa z sumami
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(SYSLOG) || _tab:=_a || _tab:=cur_tab(1,1) ?};
_max:=_-1;
_sumator:=obj_new(_max);
{! _it:=1.._max |! _sumator[_it]:=0 !};

{! _it:=1.._max
|! {? var_pres('_['+$(_it+1)+']')<>type_of('')
   || FUN.error('Parametr nr %1 formuły \\sumator/#table.fml nie jest typu tekstowego.'@[$(_it+1)]);
      return(_sumator)
   |? var_pres(_[_it+1],_tab)<>20 & var_pres(_[_it+1],_tab)<>22
   || FUN.error(
         'Parametr nr %1 [%2] formuły \\sumator/#table.fml nie jest akronimem pola numerycznego tabeli %3.'@
         [$(_it+1),_[_it+1],2-(!_tab)]
      );
      return(_sumator)
   ?}
!};

{? _tab.f_active()
|| {? ~_tab.sel_size()
   || _tab.cntx_psh();
      _next:=_tab.f_first();
      {!
      |? _next
      |! {! _it:=1.._max |! _sumator[_it]+=($(!_tab+'.'+_[_it+1]))() !};
         _next:=_tab.f_next()
      !};
      _tab.cntx_pop()
   ?}
|| _expr:='sql(\'select ';
   {! _it:=1.._max
   |! _expr+='sum('+_[_it+1]+')'+{? _it<_max || ', ' || ' ' ?}
   !};
   _expr+='from prefixed_table(:_a)\',_a';
   {! _it:=1.._max |! _expr+=',\''+_[_it+1]+'\'' !};
   _expr+=')';
   _sum:=($_expr)(_tab);
   {? _sum.first() || {! _it:=1.._max |! _sumator[_it]:=_sum[_it] !} ?}
?};
_sumator


\r_lock_one
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Jeśli wcześniej nie założony, zakłada r_lock(1,1,1) w tabeli _a dla rekordu _b
::   WE: _a - Alias tabeli
::       _b - TAB.ref() / $TAB.ref()
::   WY: 0-r_lock nie powiódł się, 1-wykonano r_lock, 2-rekord już ma r_lock
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__R_LOCK_ONE')<100
|| __R_LOCK_ONE:=tab_tmp_out_tr(1,
      'REF' ,'STRING[16]'  ,''
      )
?};

_Tab:=_a;
_ref:={? type_of(_b)=type_of('') || _b || $_b ?};
_res:=0;
::debug();
{? __R_LOCK_ONE.find_key(_ref)
|| _res:=2
|| _Tab.cntx_psh();
   {? ref_name(_ref)<>_Tab.name() || _Tab.use(ref_name(_ref)) ?};
   _Tab.prefix();
   {? _Tab.seek(_ref)
   || _res:=_Tab.r_lock(1,1,1);
      {? _res
      || __R_LOCK_ONE.REF:=_ref;
         __R_LOCK_ONE.add()
      ?}
   ?};
   _Tab.cntx_pop()
?};
_res


\r_unlock_one
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Zdejmuje r_lock w tabeli _a dla rekordu _b jeśli _c=1
::   WE: _a - Alias tabeli
::       _b - TAB.ref() / $TAB.ref()
::       _c - wynik exec('r_lock_one','#table')
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_Tab:=_a;
_ref:={? type_of(_b)=type_of('') || _b || $_b ?};
_r_lock:=_c;

{? _c=1
|| _Tab.cntx_psh();
   {? ref_name(_ref)<>_Tab.name() || _Tab.use(ref_name(_ref)) ?};
   _Tab.prefix();
   {? _Tab.seek(_ref) || _Tab.r_unlock() ?};
   _Tab.cntx_pop();
   {? do_state()=0 & _Tab.f_active() & _Tab.sel_size()=0 || _Tab.f_rfresh() ?};
   {? var_pres('__R_LOCK_ONE')>100
   || {? __R_LOCK_ONE.find_key(_ref)
      || __R_LOCK_ONE.del()
      ?}
   ?}
?}


\buffer2buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Polom bufora tabeli _a wpisuje wartości pól bufora _b pod warunkiem że te w _b są niepuste
::       Uwaga! Modyfikuje również zawartość bufora _b - jego pola które miały wartości puste będą miały tam wartości void
::   WE: _a - obj_new - bufor docelowy
::       _b - obj_new - bufor źródłowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_dst:=_a;
_src:=_b;

:: Najpierw bufor źródłowy voiduje
_src.voidize();

:: Następnie maskuję bufor _src buforem _dst
_src.mask(_dst);
~~


\cascadel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Usuwa kaskadowo rekord z tabeli.
::   WE:  _a  [TABLE]  - alias do tabeli, z której ma być usunięty rekord
::       [_b] [REF]    - wskazanie na usuwany rekord, jeśli pominięty przyjęty będzie bieżący rekord w tabeli _a
::       [_c] [TABLE]  - alias do tabeli przechowującej informacje o tabelach powiązanych z tabelą, z której jest
::                       usuwany rekord, jeśli brak, to zostanie utworzona tabela powiązań dla tabeli _a
::       [_d] [TABLE]  - alias do tabeli przechowującej informacje o nazwach zbiórow tabel powiązanych, jeśli
::                       pominięty, to zostanie utworzona tabela zawierąjaca dane właściwe dla zawartości _c
::       [_e] [NUMBER] - tryb działania:
::                         0 - usunięty zostanie rekord określony w _b,
::                         różny od 0 - usunięte zostaną tylko powiązania z rekordem określonym w _b
::   WY: 1/0 zależnie od tego czy usuwanie rekordu powiodło się
::  OLD: \cascadel/util.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('MAP')<100 || exec('map','#table') ?};
{? var_pres('_a')<>type_of(SYSLOG) || return(0) ?};
{? var_pres('_b')<>type_of(null()) || _b:=_a.ref() ?};
{? _b=null() || return(0) ?};
{? var_pres('_c')<>type_of(SYSLOG) || _c:=exec('link_tab','#table',_a) ?};
{? var_pres('_d')<>type_of(SYSLOG) || _d:=exec('mask_tab','#table',_c) ?};
_e:=(var_pres('_e')=type_of(0) & _e);

_state:=do_state();
{? _state=0 || do()
|? _state=2 || return(0)
?};

_tab:=form(2-!_a,-8);
_msg:=no_msg(1);
_c.cntx_psh();
_c.prefix(_tab);
{? _c.first() & (_a.count()>0 | _c.find_key(_tab))
|| _del:="
      _c.cntx_psh();
      _d.cntx_psh();
      _ret:=exec('cascadel','#table',_a,_b,_c,_d);
      _d.cntx_pop();
      _c.cntx_pop();
      _ret
   ";
   _c.first();
   {!
   |? _child:=($_c.CHILD)();
      exec('progress','#table',_child,3);
      _d.prefix(_c.CHILD);
      _child.cntx_psh();
      {? _d.first()
      || _ndx:=|_c.INDEX;
         {? _tmp:=(_ndx='') || _ndx:=_child.ndx_tmp(,,|_c.FIELD,,) ?};
         {!
         |? _child.use(_d.NAME);
            _child.index(_ndx);
            _child.prefix(_b);
            {? _child.first()
            || {!
               |? {? _child.count()>0 || _del(_child,_child.ref(),_c,_d)>1
                  |? _child=_a || _del(_child,_child.ref(),_c,_d)>1
                  |? _child.count()<0 || undo(); 0
                  || _result:=_child.del();
                     {? errno()
                     || _result:=0;
                        undo()
                     ?};
                     _result
                  ?}
               !}
            ?};
            _d.next() & do_state()=1
         !};
         {? _tmp
         || _child.ndx_drop(_ndx)
         ?}
      ?};
      _child.cntx_pop();
      &_child;
      _c.next() & do_state()=1 & _a.count()>0
   !}
?};
_c.cntx_pop();

_result:=0;
{? _state=0
|| {? _a.count()=0
   || {? ~_e
      || _result:=_a.del(,1);
         {? errno() || undo() ?}
      || _result:=1
      ?};
      end()
   || undo();
      end();
      exec('del_warn','#table')
   ?};
   prgs_clr()
|? do_state()=1
|| {? _a.count()=0
   || _result:=_a.del(,1);
      {? errno() || undo() ?}
   || undo()
   ?}
?};

no_msg(_msg);
_result


\link_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Uzupełnia informacje o powiązaniach między tabelami.
::   WE: _a - alias do tabeli, dla której mają być uzupełnione informacje
::       _b - (opcjonalny) alias do tabeli przechowujacej informacje o tabelach powiązanych, jeśli brak, to tabela
::            zostanie utworzona
::       _c - (opcjonalny) ciąg znaków zawierający akronimy tabel, dla których uzupełnienie informacji nie będzie
::            wykonywane
::   WY: alias do tabeli zawierającej informacje o powiązaniach między tabelami
::  OLD: \link_tab/util.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(SYSLOG) || return(0) ?};
{? var_pres('_b')<>type_of(SYSLOG) || _b:=exec('link_buf','#table') ?};
{? var_pres('_c')<>type_of('') || _c:=',' ?};

_table:=form(2-!_a,-8);
{? _c*(','+_table+',')=0 || _c+=_table+',' || return(0) ?};

exec('progress','#table',_a,1);

_b.cntx_psh();
MAP.FIELD.cntx_psh();

{? MAP.joins(_a)
|| _b.blank();
   _b.TABLE:=_table;
   {!
   |? _b.CHILD:=MAP.FIELD.TAB;
      _b.FIELD:=MAP.FIELD.ACR;
      _b.INDEX:=MAP.fore_key(_b.TABLE,_b.CHILD);
      exec('link_tab','#table',($_b.CHILD)(),_b,_c);
      _b.add();
      MAP.FIELD.next()
   !}
?};

MAP.FIELD.cntx_pop();
_b.cntx_pop();
_b


\mask_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Tworzy i wypełnia tabele przechowujacą maski tabel.
::   WE: _a - alias do tabeli przechowującej akronimy tabel
::   WY: _b - alias do tabeli
::  OLD: \mask_tab/util.fml
::----------------------------------------------------------------------------------------------------------------------
_buf:=tab_tmp(2, 'TABLE','STRING[8]','Akronim tabeli', 'NAME','STRING[8]','Nazwa zbioru' );

_a.prefix();
{? _a.first()
|| {!
   |? _child:=($_a.CHILD)();
      exec('progress','#table',_child,2);
      _mask:=_child.names();
      _buf.TABLE:=_a.CHILD;
      {? _mask.first
      || {!
         |? _buf.NAME:=_mask.NAME;
            _buf.add();
            _mask.next()
         !}
      ?};
      obj_del(_mask);
      &_child;
      _a.next()
   !}
?};

_buf


\progress
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Wyświetla (aktualizuje, jeśli jest wyświetlone) okienko zawierające informacje o postępie operacji
::       kaskadowego usuwania danych
::   WE:
::   WY:
::  OLD: \progress/util.fml
::----------------------------------------------------------------------------------------------------------------------
_msg:=
   {? var_pres('_b')<>type_of(0) || ''
   |? _b=1 || 'Wyszukiwanie informacji powiązanych z kartoteką'@
   |? _b=2 || 'Ustalanie nazw źródeł danych kartoteki'@
   |? _b=3 || 'Usuwanie rekordów powiązanych z kartoteki'@
   || ''
   ?};
progress(,_msg+_a.comment(),FUN.TYT,1)


\link_buf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Tworzy tabelę zawierającą informacje o powiązaniach między tabelami.
::   WE:
::   WY: alias do tabeli
::  OLD: \link_buf/util.fml
::----------------------------------------------------------------------------------------------------------------------
_buf:=tab_tmp(3,
   'TABLE','STRING[8]','Tabela nadrzędna',
   'CHILD','STRING[8]','Tabela podrzędna',
   'FIELD','STRING[8]','Pole złączenia',
   'INDEX','STRING[8]','Akronim indeksu'
);

_wnd:=_buf.mk_sel('Tabele'@,'T',1);
_buf.win_sel(_wnd);
_buf


\map
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Deklaracja klasy MAP i powolanie obiektu MAP.
::   WE:
::   WY:
::  OLD: \mask/util.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('MAP',@.CLASS)>0 || return() ?};
{? var_pres('MISC',@.CLASS)<=0 || exec(,'_misc') ?};
{? var_pres('STRING',@.CLASS)<=0 || exec(,'_string') ?};

obj_decl('MAP',

   obj_fld('nfo',~~),
   obj_fld('mm',~~),
   obj_fld('TABLE',~~),
   obj_fld('FIELD',~~),
   obj_fld('INDEX',~~),
   obj_fld('NDXFL',~~),

   obj_meth('__init',"
      .mm:=obj_new(@.CLASS.MISC);
      .mm.echo:=0;
      .make_nfo();
      {? .test_src()
      || {! _ii:=1..obj_len(.nfo)
         |! {? ~.load(_ii)
            || .rebuild();
               return()
            ?}
         !}
      || .rebuild()
      ?}
   "),

   obj_meth('rebuild',"
      .fill_nfo();
      _synch:=0;
      {? SYSLOG.first()
      || _msg:=0;
         {!
         |? {? ~SYSLOG.r_lock(1,1,1)
            || {? ~_msg
               || _msg:=1;
                  progress(,'Trwa odtwarzanie struktur pomocniczych'@,exec('nazwa','#system'),1,0)
               ?};
               1
            || {? _msg
               || prgs_clr();
                  0
               ?}
            ?}
         !};
         &_msg;
         _synch:=1
      ?};
      {! _ii:=1..obj_len(.nfo) |! .save(_ii) !};
      _name:=.src_name('s');
      {? _handle:=fopen(_name,'w',1)
      || fwrite(_handle,$#date());
         fclose(_handle)
      ?};
      {? _synch || SYSLOG.r_unlock() ?}
   ",-1),

   obj_meth('test_src',"~exec('check_crc_def','#table')",-1),

   obj_meth('src_name',".src_name($_a)",type_of(0)),
   obj_meth('src_name',"'map_nfo'+_a+'.txt'",type_of('')),

   obj_meth('load',"
      _name:=.src_name(_a);
      {? _handle:=fopen(_name,'r',1)
      || fclose(_handle);
         .mm.import(_name,.nfo[_a][1])
      ?}
   ",type_of(0)),

   obj_meth('save',"
      .nfo[_a][1].prefix();
      .mm.export(.src_name(_a),.nfo[_a][1])
   ",type_of(0)),

   obj_meth('find_fld',"
         .nfo[2][1].index(.nfo[2][3]);
         .nfo[2][1].prefix();
         .nfo[2][1].find_key(.form_acr(_a),.form_acr(_b))
   ",type_of(''),type_of('')),

   obj_meth('fld_join',"
         .nfo[2][1].index(.nfo[2][3]);
         .nfo[2][1].prefix(form(_a,-8));
         {? .nfo[2][1].find_key(form(_b,-8))
         || .nfo[2][1].REF
         || ''
         ?}
   ",type_of(''),type_of('')),

   obj_meth('joins',".joins(2-!_a)",type_of(SYSLOG)),

   obj_meth('joins',"
         .nfo[2][1].index(.nfo[2][4]);
         .nfo[2][1].prefix(form(_a,-8));
         .nfo[2][1].first()
   ",type_of('')),

   obj_meth('cntjoins',"
      .cntjoins(2-!_a,2-!_b)
   ",type_of(SYSLOG),type_of(SYSLOG)),

   obj_meth('cntjoins',"
         .nfo[2][1].cntx_psh();
         .nfo[2][1].index(.nfo[2][4]);
         .nfo[2][1].prefix(form(_a,-8),form(_b,-8));
         _ret:=.nfo[2][1].size();
         .nfo[2][1].cntx_pop();
         _ret
   ",type_of(''),type_of('')),

   obj_meth('fore_key',"
      .fore_key(2-!_a,2-!_b)
   ",type_of(SYSLOG),type_of(SYSLOG)),

   obj_meth('fore_key',"
      {? .cntjoins(_a,_b)=1 & .forekeys(_a)
      || {? .nfo[4][1].find_key(form(_b,-8)) || return(.nfo[4][1].NDX) ?}
      ?};
      ''
   ",type_of(''),type_of('')),

   obj_meth('forekeys',".forekeys(2-!_a)",type_of(SYSLOG)),

   obj_meth('forekeys',"
         .nfo[4][1].index(.nfo[4][3]);
         .nfo[4][1].prefix(form(_a,-8),8*'-',1);
         .nfo[4][1].first()
   ",type_of('')),

   obj_meth('make_nfo',"
      .nfo:=obj_new(4);

      .nfo[1]:=obj_new(3);
      .TABLE:=.nfo[1][1]:=tab_tmp(1,
         'NUM','INTEGER',   'Numer',
         'ACR','STRING[8]', 'Akronim',
         'COM','STRING[60]','Komentarz'
      );
      .nfo[1][2]:=.nfo[1][1].index('?');
      .nfo[1][3]:=.nfo[1][1].ndx_tmp(,,'ACR',,0);
      .nfo[1][1].index(.nfo[1][3]);

      .nfo[2]:=obj_new(4);
      .FIELD:=.nfo[2][1]:=tab_tmp(2,
         'TAB','STRING[8]', 'Tabela',
         'NUM','INTEGER',   'Numer',
         'ACR','STRING[8]', 'Akronim',
         'TXT','STRING[40]','Nazwa',
         'COM','STRING[60]','Komentarz',
         'REF','STRING[8]', 'Złączenie'
      );
      .nfo[2][2]:=.nfo[2][1].index('?');
      .nfo[2][3]:=.nfo[2][1].ndx_tmp(,,'TAB',,0,'ACR',,0);
      .nfo[2][4]:=.nfo[2][1].ndx_tmp(,,'REF',,0,'TAB',,0,'NUM',,0);

      .nfo[3]:=obj_new(3);
      .INDEX:=.nfo[3][1]:=tab_tmp(2,
         'TAB','STRING[8]','Tabela',
         'NUM','INTEGER',  'Numer',
         'ACR','STRING[8]','Akronim',
         'UNQ','INTEGER',  'Unikalny'
      );
      .nfo[3][2]:=.nfo[3][1].index('?');
      .nfo[3][3]:=.nfo[3][1].ndx_tmp(,,'TAB',,0,'UNQ',,0,'NUM',,0);

      .nfo[4]:=obj_new(3);
      .NDXFL:=.nfo[4][1]:=tab_tmp(3,
         'TAB','STRING[8]','Tabela',
         'NDX','STRING[8]','Indeks',
         'NUM','INTEGER',  'Numer',
         'ACR','STRING[8]','Pole',
         'REF','STRING[8]','Złączenie',
         'LNK','STRING[8]','Reprezentant'
      );
      .nfo[4][2]:=.nfo[4][1].index('?');
      .nfo[4][3]:=.nfo[4][1].ndx_tmp(,,'REF',,0,'LNK',,0,'NUM',,0,'TAB',,0);

      {! _ii:=1..obj_len(.nfo) |! .make_wnd(.nfo[_ii][1]) !}
   ",-1),

   obj_meth('make_wnd',"
      _a.win_sel(_a.mk_sel(,'T',1))
   ",type_of(SYSLOG)),

   obj_meth('fill_nfo',"
      {! _ii:=1..obj_len(.nfo)
      |! .nfo[_ii][1].clear();
         .nfo[_ii][1].erase()
      !};
      {! _ii:=1..tab_num
      |! {? tab_real(_ii) || .add_tab(_ii) ?}
      !}
   ",-1),

   obj_meth('add_tab',"
      _acr:=tab_acr(_a);
      _tab:=($_acr)();
      .nfo[1][1].prefix();
      .nfo[1][1].blank();
      .nfo[1][1].NUM:=_a;
      .nfo[1][1].ACR:=.tab_acr(_tab);
      .nfo[1][1].COM:=_tab.comment();
      {? .nfo[1][1].add()
      || .add_fld(_tab);
         .add_ndx(_tab)
      ?}
   ",type_of(0)),

   obj_meth('add_fld',"
         .nfo[2][1].prefix();
         .nfo[2][1].blank();
         .nfo[2][1].TAB:=.tab_acr(_a);
         {! _ii:=1.._a.fld_num()
         |! .nfo[2][1].NUM:=_ii;
            .nfo[2][1].ACR:=.form_acr(_a.fld_acr(.nfo[2][1].NUM));
            .nfo[2][1].TXT:=_a.fld_name(.nfo[2][1].NUM);
            .nfo[2][1].COM:=_a.fld_comm(.nfo[2][1].NUM);
            .nfo[2][1].REF:=.form_acr(_a.fld_join(.nfo[2][1].NUM));
            {? var_pres(_a.fld_acr(.nfo[2][1].NUM),_a)=32 || .nfo[2][1].REF:=.nfo[2][1].TAB ?};
            .nfo[2][1].add()
         !}
   ",type_of(SYSLOG)),

  obj_meth('add_ndx',"
         .nfo[3][1].prefix();
         .nfo[3][1].blank();
         .nfo[3][1].TAB:=.tab_acr(_a);
         {! _ii:=1.._a.ndx_num()
         |! .nfo[3][1].NUM:=_ii;
            .nfo[3][1].ACR:=.form_acr(_a.ndx_acr(.nfo[3][1].NUM));
            .nfo[3][1].UNQ:=_a.ndx_uniq(.nfo[3][1].NUM);
            {? .nfo[3][1].add() || .add_fld(_a,.nfo[3][1].NUM) ?}
         !}
   ",type_of(SYSLOG)),

   obj_meth('add_fld',"
         .nfo[4][1].prefix();
         .nfo[4][1].blank();
         .nfo[4][1].TAB:=.tab_acr(_a);
         .nfo[4][1].NDX:=.form_acr(_a.ndx_acr(_b));
         {! _ii:=1.._a.ndx_nfld(_b)
         |! .nfo[4][1].NUM:=_ii;
            .nfo[4][1].ACR:=.form_acr(_a.ndx_afld(_b,.nfo[4][1].NUM));
            .nfo[4][1].REF:=.form_acr(.fld_join(.nfo[4][1].TAB,.nfo[4][1].ACR));
            .nfo[4][1].LNK:=.form_acr(_a.ndx_jfld(_b,.nfo[4][1].NUM));
            .nfo[4][1].add()
         !}
   ",type_of(SYSLOG),type_of(0)),

   obj_meth('tab_acr',"form(2-!_a,-8)",type_of(SYSLOG)),
   obj_meth('form_acr',"{? _a<>'' || form(_a,-8) || 8*'-' ?}",type_of(''))

);

MAP:=obj_new(@.CLASS.MAP)


\check_crc_def
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PJ] [12.10]
:: OPIS: Formuła porównuje zapisaną sumę kontrolną dla pliku merit.def z bieżącą.
::       Do przechowywania sumy tworzony jest plik crc.def zgodnie z pth.
::   WE:
::   WY: 0 - nie ma roznic, 1 - znaleziono roznice
::  OLD: \check_crc_def/skid_log.fml
::----------------------------------------------------------------------------------------------------------------------
_d:=fopen('merit.def','br',1,0,1);
:: jeśli nie da się wczytać pliku z merit.def to przyjmujemy, że istnieją róźnice
{? ~_d.is_open() || return(1) ?};
_wy:=0;
_crc:=hash(_d);
_f:=fopen('crc.def','r',1,0,1);
:: jeśli nie ma pliku crc.def to tworzy się nowy i przyjmujemy, że są różnice w defie
{? ~_f.is_open()
|| _fnew:=fopen('crc.def','w',1,0,1);
   {? _fnew.is_open()
   || _fnew.fwrite(_crc);
      _fnew.fclose();
      _wy:=1
   ?}
|| _crc_old:=form(_f.fread());
:: jeśli są różnice to tworzy nowa wersje pliku crc
   {? _crc<>_crc_old
   || _wy:=1;
      _fnew:=fopen('crc.def','w',1,0,1);
      {? _fnew.is_open()
      || _fnew.fwrite(_crc);
         _fnew.fclose()
      ?}
   ?};
   _f.fclose()
?};
_d.fclose();
_wy


\uidref_live
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy podany uidref() prowadzi do nieusuniętego rekordu
::   WE: _a [STRING] - uidref()
::   WY: 1 - rekord istnieje, 0 - rekord usunięty
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_tab:=ref_tab(_a);
{? var_pres('_tab')>100
|| _tab.cntx_psh();
   _result:=_tab.seek(_a,ref_name(_a),1);
   _tab.cntx_pop()
?};
_result


\has_field
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Sprawdza czy tabela zawiera pole o podanym akronimie i typie
::   WE: _a - TABLE - uchwyt do tabeli
::       _b - STRING - akronim szukanego pola
::       _c - STRING - typ szukanego pola (INTEGER, STRING, REAL, DATE, itp)
::   WY: 0 - tabela nie ma szukanego pola
::       1 - tabela ma pole
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_acr:=_b;
_type:=_c;

_result:=0;

_fields:=exec('mbTabFields_tab','#table',_tab);
:: Pętla od tyłu bo raczej szukamy nowych pól
{? _fields.last()
|| {!
   |? {? _fields.FLD_ACR=_acr & _fields.FLD_TRAW=_type
      || _result:=1
      ?};
      _fields.prev() & _result=0
   !}
?};
_result


\get_acronym
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Zwraca akronim pola podanego typu
::   WE: _a - TABLE - uchwyt do tabeli
::       _b - STRING - typ szukanego pola (INTEGER, STRING, REAL, DATE, _TABELA)
::   WY: STRING lub ''
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_type:=_b;

_result:='';

_fields:=exec('mbTabFields_tab','#table',_tab);
{? _fields.first()
|| {!
   |? {? _fields.FLD_TRAW=_type
      || _result:=_fields.FLD_ACR
      ?};
      _fields.next() & _result=''
   !}
?};
_result


\rec_after_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PS] [17.00]
:: OPIS: Zwraca rekord, na którym tabela ma się ustawić po usunięciu obecnie wskazywanego rekordu.
::   WE: _a - alias do tabeli
::   WY: _a.ref() - ref do rekordu, który powinien być zaznaczony po usunięciu obecnie wskazywanego rekordu
::----------------------------------------------------------------------------------------------------------------------
_cur_rec:=_a.ref();
_a.last();
_last_rec:=_a.ref();
_a.seek(_cur_rec);

:: Jak rekord jest ostatni, to zwracany jest poprzedni. W przeciwnym wypadku zwracany jest następny.
{? _cur_rec=_last_rec
|| _a.prev()
|| _a.next()
?};

:: Powrót do rekordu zaznaczonego na początku, wynik zapisywany jest w _result
_result:=_a.ref();
_a.seek(_cur_rec);
:: Null jest zwracany, gdy istnieje tylko 1 rekord, tj wynik jest rekordem bieżącym.
{? _result<>_cur_rec || _result || null() ?}


\acr_no
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PS] [17.14]
:: OPIS: Zwraca numer pola o danym akronimie w schemacie tabeli.
::   WE: _a - TABLE - uchwyt do przeszukiwanej tabeli
::       _b - STRING - akronim pola
::   WY: INTEGER - indeks pola w tabeli o danym akronimie, lub -1 jeżeli go nie znaleziono
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_acr:=_b;

{! _it:=1.._tab.fld_num
|! {? _tab.fld_acr(_it)=_b
   || return(_it)
   ?}
!};
return(-1)


\tab_list
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Zwraca listę tabel dostępnych do wykorzystania. Tabele systemowe są pomijane.
::   WE: [_a] [RULE/STRING/ARRAY/TABLE] - akronimy dodatkowo pomijanych tabel w przypadku:
::             RULE - treść formuły sprawdzającej, czy tabela ma być pominięta;
::             STRING - lista akronimów pomijanych tabel oddzielonych przecinkami;
::             ARRAY - tablica zawierająca akronimy pomijanych tabel;
::             TABLE - tabela posortowana wedłu akronimów pomijanych tabel.
::   WY: alias tabeli tymczasowej
::----------------------------------------------------------------------------------------------------------------------
: tabela tymczasowa umożliwiająca wybór
_BUF:=exec('wyb_symbol_tab','#stalesys');
_BUF.hdr_sel('Dostępne tabele'@);

_TAB:=~~;
_test:="0";

_at:=var_pres('_a');

{? _at=type_of("")
|| _test:=_a

|? _at=type_of('') | _at>100
|| _TAB:={? _at>100 || _a || spli_str(_a) ?};
   _test:="
      _len:=obj_len(_b);
      {! _n:=1.._len
      |! {? _a=_b[_n]
         || return(1)
         ?}
      !};
      0
   "
|? _at=type_of(SYSLOG)
|| _TAB:=_a;
   _test:="_b.find_key(_a,)"
?};

: lista tabel stałych
{! _num:=1..tab_num()
|! {? tab_real(_num)
   || _acr:=tab_acr(_num);
      {? ~_test(_acr,_TAB) & ~exec('tab_sys','#table',_num)
      || _BUF.blank();
         _BUF.SYMBOL:=_acr;
         _BUF.OPIS:=($_acr)().comment();
         _BUF.add()
      ?}
   ?}
!};

_BUF


\tab_names
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [18.22]
:: OPIS: Zwraca tablicę zawierającą maski tabeli danej argumentem
::   WE: _a [TABLE] - alias tabeli
::   WY: wskazanie tablicy
::----------------------------------------------------------------------------------------------------------------------
_DBS:=_a.names();

_names:=obj_new(_DBS.size());
_loop:=_DBS.last();
_ni:=0;
{!
|? _loop
|! _names[_ni+=1]:=_DBS.NAME;
   _loop:=_DBS.prev()
!};
_names


\tab_sys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [18.42]
:: OPIS: Sprawdza, czy dana tabela jest tabelą systemową.
::   WE: _a [TABLE/STRING/INTEGER] - alias/akronim/numer sprawdzanej tabeli
::   WY: 0/1 - tabela nie jest/jest tabelą systemową lub ~~ w przypadku blędu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(SYSLOG)
|| _TAB:=_a

|? var_pres('_a')=type_of('') & _a<>'' & var_pres(_a)=type_of(SYSLOG)
|| _TAB:=($_a)()

|? var_pres('_a')=type_of(0) & _a>0 & _a<=tab_num() & tab_real(_a)
|| _TAB:=tab_alias(_a)

|| return()
?};

_mark:=1+_TAB.name(1);

_mark>='0' & _mark<='9'


\is_temporary
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Sprawdza czy przekazany uchwyt do tabeli jest tabelą tymczasową
::   WE: _a - TABLE - uchwyt tabeli
::   WY: 0 - nie jest tymczasowa
::       1 - jest tymczasowa
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_name:=_tab.name(1);

_letter:=1+_name;

_result:=~~;
{? _letter='0' | _letter='1'
||
:: Zero i jeden w pierwszej literze maski mogą mieć tylko tabele systemowe, a te
:: są zawsze stałe
   _result:=0
|? _letter>='2' & _letter<='9'
||
:: Cyfry inne niż 0 i jeden mają tabele tymczasowe
   _result:=1
||
:: Każdy inny przypadek oznacza tabelę stałą
   _result:=0
?};
_result


\prefix
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Formuła została stworzona jako skrót dla pozyskania informacji np. o istnieniu rekordów w dziedzinie
::       (rozumianej jako wynik metody first()) lub ilości tych rekordów (metoda size()). Jednak zastosowań może być
::       znacznie więcej. Jeżeli pominiemy odkładanie kontekstów (parametr _b), to formuła może służyć do
::       jednowierszowego założenia prefixu dla wskazanego indeksu.
::       Przy zakładaniu prefixu uwzględniono założenia związane z ostatnim polem napisowym.
::       Tak jak OSOBA.prefix('Kowal') oznacza coś innego niż OSOBA.prefix('Kowal',), tak samo
::       exec('prefix','#table',OSOBA,,,,,'Kowal') oznacza coś innego niż exec('prefix','#table',OSOBA,,,,,'Kowal',).
::       Poprawność parametrów nie jest sprawdzana.
::   WE:  _a  [TABLE]  - Uchwyt tabeli.
::       [_b] [NUMBER] - Pomijaj odkładanie kontekstu [0*/1].
::       [_c] [STRING] - Nazwa metody klasy TABLE, której wynik zostanie zwrócony. Brak parametru oznacza brak
::                       dodatkowej akcji. Wynikiem formuły będzie wówczas ~~.
::       [_d] [STRING] - Maska tabeli [domyślnie: bieżąca].
::       [_e] [STRING] - Akronim indeksu [domyślnie: bieżący].
::       [_f] [ANY]    - Wartość kolejnego pola w prefixie.
::       [_g] [ANY]    - Wartość kolejnego pola w prefixie.
::       [_h] [ANY]    - Wartość kolejnego pola w prefixie.
::       [_i] [ANY]    - Wartość kolejnego pola w prefixie.
::       [_j] [ANY]    - Wartość kolejnego pola w prefixie.
::       [..] [ANY]    - Wartość kolejnego pola w prefixie.
::   WY: Wynik zależny od parametru _c.
::----------------------------------------------------------------------------------------------------------------------
_TAB:=_a;
_cntx:=~(var_pres('_b')=type_of(0) & _b);
{? _cntx
|| _TAB.cntx_psh()
?};
::_c
{? var_pres('_d')=type_of('') & _TAB.name()<>_d
|| _TAB.use(_d)
?};
{? var_pres('_e')=type_of('') & _e<>''
|| _TAB.index(_e)
?};
_ret:=~~;
{? _<6
|| _TAB.prefix()
|| _prfx:='';
   _par:=obj_new(_);
   {! _lp:=6 .. _
   |! _par[_lp]:=_[_lp];
      _prfx+=','+{? _par[_lp]<>~~ || '_b['+$_lp+']' || '' ?}
   !};
   ($('_a.prefix('+(1-_prfx)+')'))(_TAB,_par)
?};
{? var_pres('_c')=type_of('') & _c<>''
|| _ret:=($('_a.%1()' [_c]))(_TAB)
?};
{? _cntx
|| _TAB.cntx_pop()
?};
_ret


\idput_refresh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła aktualizująca znacznik czasowy wskazanego rekordu.
::   WE: _a [STRING/REFERENCE] - Wskazanie rekordu (ref / SQL-ref / uidref).
::   WY: Status operacji: 0/1
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;

_ret:=0;
_TAB:=ref_tab(_ref);
_TAB.cntx_psh();
_name:=ref_name(_ref);
{? _TAB.name()<>_name
|| _TAB.use(_name)
?};
_TAB.prefix();
{? _TAB.seek(_ref)
|| _TAB.trig_off('*','*');
   _ret:=_TAB.put(,1);
   _TAB.trig_on('*','*')
?};
_TAB.cntx_pop();
_ret


\tab_tmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła dostarcza mechanizm wspomagający tworzenie tabeli tymczasowej.
::   WE:
::   WY: Uchwyt "obiektu".
::----------------------------------------------------------------------------------------------------------------------
_STRU:=obj_new('TAB','add','create');

_STRU.TAB:=tab_tmp(1,
   'LP','INTEGER','Lp.',
   'ACR','STRING[8]','Akronim pola',
   'TYPE','STRING[12]','Typ pola',
   'NAME','STRING[64]','Nazwa pola'
);

:: Metoda definiuje kolejną kolumnę w tworzonej tabeli. Parametry (_a, _b, _c) odpowiadają parametrom definiującym pole
:: w funkcji tab_tmp().
_STRU.add:="
   _lp:=.TAB.size()+1;
   .TAB.blank();
   .TAB.LP:=_lp;
   .TAB.ACR:=_a;
   .TAB.TYPE:=_b;
   .TAB.NAME:=_c;
   .TAB.add()
";

:: Metoda, na podstawie definicji tworzonej metodami add() tworzy tablicę tymczasową. Parametr _a definiuje liczbę pól
:: w indeksie [domyślnie: 1].
_STRU.create:="
   _ind:={? var_pres('_a')=type_of(0) || _a || 1 ?};
   _cols:='';
   _loop:=.TAB.first();
   {!
   |? _loop
   |! _cols+=',\\'%1\\',\\'%2\\',\\'%3\\''[.TAB.ACR,.TAB.TYPE,.TAB.NAME];
      _loop:=.TAB.next()
   !};
   ($('tab_tmp(%1%2)' [$_ind,_cols]))()
";

_STRU


\tab_fmod_ax
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Odświeża filtr programowy po wykonaniu akcji zmieniającej dane.
::   WE: _a [TABLE] - alias tabeli, jeśli pominięty, to przyjęta aktualnie przeglądana tabela.
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_TAB:=
   {? var_pres('_a')<>type_of(SYSLOG)
   || cur_tab(1,1)
   || _a
   ?};

{? _TAB.f_active()
|| _TAB.f_rfresh()
?};
~~


\idput_ndx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła aktualizuje znaczniki modyfikacji rekordów wskazanych parametrami.
::       UWAGA!
::       Poprawność argumentów wywołania nie jest weryfikowana - użycie niezgodne ze specyfikacją może powodować błędy.
::   WE:  _a  [TABLE]  - Uchwyt tabeli, w której będą aktualizowane znaczniki modyfikacji.
::                       Zmiana dotyczy WYŁĄCZNIE bieżącej maski (metoda names() nie może być użyta w transakcji).
::        _b  [STRING] - Akronim indeksu, według którego będzie odbywać się przetwarzanie.
::        _c  [ANY]    - Wartość klucza w indeksie (wartość kolejnego pola w prefiksie).
::       [_d] [ANY]    - Wartość klucza w indeksie (wartość kolejnego pola w prefiksie).
::       [_e] [ANY]    - Wartość klucza w indeksie (wartość kolejnego pola w prefiksie).
::       [_f] [ANY]    - Wartość klucza w indeksie (wartość kolejnego pola w prefiksie).
::       [_g] [ANY]    - Wartość klucza w indeksie (wartość kolejnego pola w prefiksie).
::       [_h] [ANY]    - Wartość klucza w indeksie (wartość kolejnego pola w prefiksie).
::       [_i] [ANY]    - Wartość klucza w indeksie (wartość kolejnego pola w prefiksie).
::   WY: Liczba zaktualizowanych rekordów.
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
_a.cntx_psh();
_a.index(_b);

{? _=3
|| _a.prefix(_c)
|| _prfx:='';
   _par:=obj_new(_);
   {! _lp:=3.._
   |! _par[_lp]:=_[_lp];
      _prfx+='_b['+$_lp+'],'
   !};
   {? type_of(_[_])<>type_of('') || _prfx:=_prfx-1 ?};
   ($('_a.prefix('+_prfx+')'))(_a,_par)
?};

{? _a.first()
|| _a.trig_off('*','*');
   {!
   |? _ret+=_a.put(,1);
      _a.next()
   !};
   _a.trig_on('*','*')
?};

_a.cntx_pop();
_ret


\sha4tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [21.37]
:: OPIS: Zwraca wynik funkcji skrótu sha1 dla wskazanych zawartości pól tabeli
::   WE: _a - akronim tabeli
::       _b - napis zawierający akronumy pól po przecinku
::----------------------------------------------------------------------------------------------------------------------
_tab_str:={? var_pres('_a')>0 & type_of(_a)=type_of('') || _a || '' ?};
_fld_str:={? var_pres('_b')>0 & type_of(_b)=type_of('') || _b || '' ?};
_txt:='';
{? _tab_str<>'' & _fld_str<>''
|| _tab:=($_tab_str)();
   _flds:=spli_str(_fld_str,',');
   {! _ii:=1..obj_len(_flds)
   |! {? var_pres(_flds[_ii],_tab)>0
      || _val:=($(_tab_str+'.'+_flds[_ii]))();
         _txt+=exec('to_string','#convert',_val)+'|'
      ?}
   !}
?};
hash(_txt)


\compare_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Porównuje zawartość dwóch tabel pod względem zgodności struktury pól
::       (czy tabele mają taka samą liczbę pól o takich samych akronimach oraz typach)
::   WE: _a - tabela 1
::       _b - tabela 2
::   WY: 1 (identyczna zawartość), 0 (są różnice)
::----------------------------------------------------------------------------------------------------------------------
_tab1:=_a;
_tab2:=_b;
_res:=1;

:: Zebranie listy pól obu tabel
_fields1:=exec('mbTabFields_tab','#table',_tab1);
_fields2:=exec('mbTabFields_tab','#table',_tab2);

{? _fields1.size()=_fields2.size()
|| {? _fields1.first()
   || _ndx_tmp:=_fields2.ndx_tmp(,,'FLD_ACR',,,'FLD_TYPE',,);
      _fields2.index(_ndx_tmp);
      {!
      |?
         _fields2.prefix(_fields1.FLD_ACR,_fields1.FLD_TYPE,);
         {? ~_fields2.first()
         || _res:=0
         ?};
         _fields1.next() & _res=1
      !}
::      {? var_pres('_ndx_tmp')>0
::      || _fields2.ndx_drop(_ndx_tmp)
::      ?}
   ?}
|| _res:=0
?};

_res


:Sign Version 2.0 jowisz:1045 2023/08/23 10:46:47 6ea4bcf9aaedb0aade70f4be2f07842a1bf3657f1772fa867b45241370d71b4c9f8b534e12239413f54103c04b92f8bc7b5812bb6a3aa30f46137e1c7a9a1a44e6f221baaa865554144a1be5257b0d79ef17889485defb41066859972994834fd17db9d758b67a57db7e5a9060d72c6721a681a75a98a1fc13019612ee627ae7
