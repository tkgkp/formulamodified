:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #esign.fml
:: Utworzony: 28.08.2019
:: Autor: RWR
::======================================================================================================================
:: Zawartość: Plik zawiera definicję klasy ESIGN wspomagającej obsługę podpisu elektronicznego.
::            Obecna funkcjonalność umożliwia:
::             - podpisanie pliku lub plików;
::             - podpisywanie wszystkich plików we wskazanym (lokalnym) katalogu;
::             - weryfikację podpisu pliku lub plików.
::            Należy przy tym pamiętać o następujących zasadach:
::             1. Operacja podpisania / weryfikacji może być przeprowadzona wyłącznie na pliku lokalnym.
::             2. W przypadku grupy N plików zdecydowanie szybsza jest operacja grupowa przeprowadzona na N plikach
::                niż N operacji przeprowadzanych na pojedynczym pliku.
::             3. Do weryfikacji podpisu elektronicznego w pliku/plikach (podpisywania zresztą też) wykorzystywana jest
::                zewnętrzna biblioteka. Nie radzi ona sobie z weryfikacją "dziwnych" plików - nie zgłasza przy tym
::                żadnych błędów. Należy zatem unikać weryfikacji plików, które nie mają rozszerzenia PDF i SIG.
::            Klasa powstała głównie z myślą o obsłudze plików, które są załącznikami. Przyjęto przy tym założenia:
::             1. W rekordzie może istnieć dodatkowe pole do przechowywania podpisanego załącznika.
::             2. Zarówno podczas podpisywania jak i weryfikacji podpisu można podać akronim pola, w którym zapisana
::                zostanie data podpisania.
::======================================================================================================================


\esign_decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Definicja klasy ESIGN wspomagającej obsługę podpisu elektronicznego.
::   WE:
::   WY:
:: ~OST: INTMPDIR, INEXEDIR, INTMKTMPDIR , INFCOPY
::----------------------------------------------------------------------------------------------------------------------
:: Przy powtórnym wywołaniu deklaracji klasy ESIGN - zakończ.
{? var_pres('ESIGN',@.CLASS)>0
|| return()
?};

:: Deklaracja wykorzystywanych klas.
exec('fun_decl','#message');
exec('JCQ_decl','#message');
exec('xml_t_decl','#xml_t');

obj_decl('ESIGN',

::----------------------------------------------------------------------------------------------------------------------
:: Stałe ---------------------------------------------------------------------------------------------------------------
::----------------------------------------------------------------------------------------------------------------------

   obj_fld('d0',date(0,0,0)),
   obj_fld('tVOID',type_of(~~)),
   obj_fld('tSTRING',type_of('')),

:: Separator katalogów po stronie klienta.
   obj_fld('sep0',exec('sep','#file',0)),

::----------------------------------------------------------------------------------------------------------------------
:: Pola ----------------------------------------------------------------------------------------------------------------
::----------------------------------------------------------------------------------------------------------------------

:: Uchwyt obiektu klasy FUN_CLASS - tworzony w konstruktorze.
   obj_fld('FUN',~~),

:: Uchwyt obiektu klasy JCQ - tworzony w konstruktorze.
   obj_fld('KOMM',~~),

:: Uchwyt obiektu klasy XML_T (tworzony w konstruktorze) wykorzystywany do tworzenia TaskList.
   obj_fld('XML',~~),

:: Tabela tymczasowa (bufor roboczy przetwarzania) i tablica indeksów - tworzone w konstruktorze.
   obj_fld('TAB',~~),
   obj_fld('NDX',~~),
   obj_fld('grp',~~),

:: Tabela tymczasowa (+ tablica indeksów) ze szczegółami podpisu - tworzona w konstruktorze.
   obj_fld('TSIGN',~~),
   obj_fld('NSIGN',~~),

:: Uchwyt obiektu klasy TEMDIR.
   obj_fld('TEMP',~~),

:: Zmienna pomocnicza, której wartość jest tworzona na podstawie wartości obiektu TEMP.
   obj_fld('dir',''),

:: Tryb pracy: 'd' - katalog / 'f' - pliki. Zabronione jest:
::  - mieszanie trybów;
::  - inicjalizacja (start/stop) dla trybu 'd'.
   obj_fld('mode',''),

::----------------------------------------------------------------------------------------------------------------------
:: Metody prywatne -----------------------------------------------------------------------------------------------------
::----------------------------------------------------------------------------------------------------------------------

   obj_meth('erase',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Metoda zastępuje metodę klasy TABLE niedostępną w transakcji.
::   WE:
::   WY: Wynik operacji: 0/1.
::----------------------------------------------------------------------------------------------------------------------
   "  _TAB:=_a;
      {? _TAB.first()
      || {!
         |? _TAB.del()
         !}
      ?};
      ~_TAB.first()
   ",type_of(SYSLOG),-1),


   obj_meth('error',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda prywatna.
::       Obsługa komunikatów o błędach.
::   WE:  _a  [STRING] - Komunikat, lub kod komunikatu.
::       [_b] [ANY]    - Dla wybranych kodów komunikatu możliwe jest przekazanie dodatkowych parametrów/informacji.
::       [_c] [ANY]    - Dla wybranych kodów komunikatu możliwe jest przekazanie dodatkowych parametrów/informacji.
::       [_d] [ANY]    - Dla wybranych kodów komunikatu możliwe jest przekazanie dodatkowych parametrów/informacji.
::       [_e] [ANY]    - Dla wybranych kodów komunikatu możliwe jest przekazanie dodatkowych parametrów/informacji.
::   WY: Numer błędu ze znakiem minus.
::----------------------------------------------------------------------------------------------------------------------
   "  _ret:={? 1+_a='#' || -#(1-_a) || -1000 ?};
      _msg:=
         {? _a='#1'
         || 'Brak inicjalizacji sesji przetwarzania.'@
         |? _a='#2'
         || 'Próba ponownej inicjalizacji sesji przetwarzania.'@
         |? _a='#3'
         || 'Nieprawidłowy akronim pola.'@+'\n'+
            'W strukturze tabeli ""%1"" nie występuje pole o akronimie ""%2"".'@ [_b,_c]
         |? _a='#4'
         || 'Nieprawidłowy typ pola.'@+'\n'+
            'Pole ""%1"".""%2"" nie jest typu %3.'@ [_b,_c,_d]
         |? _a='#11'
         || 'Nieprawidłowa wartość parametru.'@+'\n'+
            'Oczekiwana pełna ścieżka dostępu (@) do pliku lokalnego.'@
         |? _a='#12'
         || 'Brak dostępu do pliku:\n%1'@ [_b]
         |? _a='#13'
         || 'Brak dostępu do katalogu:\n%1'@ [_b]
         |? _a='#14'
         || 'Brak plików w katalogu:\n%1'@ [_b]
         |? _a='#100'
         || 'Próba wywołania metody prywatnej.'@
         |? _a='#101'
         || 'Błąd wewnętrzny.'@+{? var_pres('_b')=.tSTRING || '\n'+_b || '' ?}
         |? _a='#102'
         || exec('indevice_nacc_msg','#system')
         || _a
         ?};
      {? _msg<>''
      || {? app_info('web_sesid')<>''
         || web_msg(_msg)
         || _meth:='';
            _stack:=form_stack(-1);
            {! _lp:=2 .. obj_len(_stack)
            |? _stack[_lp].file='' & _stack[_lp].name<>''
            |! _meth+=_stack[_lp].name+' <- '
            !};
            echo('Klasa obiektu: ESIGN | Metoda: %1 | Kod błędu: %2'@ [_meth-4,$_ret]);
            .FUN.error(_msg);
            echo()
         ?}
      ?};
      _ret
   ",type_of('')),


   obj_meth('cloneTAB',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda prywatna.
::       Metoda tworzy kopię tabeli .TAB.
::   WE: _a [TABLE]  - Uchwyt tabeli do sklonowania.
::       _b [NUMBER] - Liczba pól w indeksie.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  _TAB:=_a;
      _ind_fld:=_b;

      _flds:='';
      {! _lp:=1 .. _TAB.fld_num()
      |! _flds+=',\\'%1\\',,,,\\'%1\\'' [_TAB.fld_acr(_lp)]
      !};
      ($('_a.ext_tab('+$_ind_fld+',1'+_flds+')'))(_TAB)
   ",type_of(SYSLOG),type_of(0),-1),


   obj_meth('blob_add',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda prywatna.
::       Silnik metod definiujących kolejny załącznik do opatrzenia podpisem elektronicznym lub weryfikacji.
::   WE: _a [STRING] - Typ przetwarzania S - sign / V - verify.
::       _b [TABLE]  - Uchwyt do tabeli.
::       _c [STRING] - Akronim pola z załącznikiem źródłowym.
::       _d [STRING] - Akronim pola z załącznikiem wynikowym.
::       _e [STRING] - Akronim pola z datą podpisania.
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   "  _type:=_a;
      _TAB:=_b;
      _attin:=_c;
      _attout:=_d;
      _dtsign:=_e;

      _stack:=form_stack(2);

      {? ~(_stack[2].name<>'' & _stack[2].file='')
      || .error('#100')
      |? .mode='' | (.mode='f' & var_pres('TEMP',.)=.tVOID) | .mode='s'
      || .error('#1')
::       _type
      |? _type<>'S' & _type<>'V'
      || .error('#101','Nieprawidłowy typ przetwarzania.'@)
::       _attin
      |? _vp:=var_pres(_attin,_TAB,'diff_blob');
         _vp<0
      || .error('#3',2-!_TAB,_attin)
      |? _vp<>33
      || .error('#4',2-!_TAB,_attin,'BLOBRAW')
::       _attout
      |? _vp:={? _attout='' || 33 || var_pres(_attout,_TAB,'diff_blob') ?};
         _vp<0
      || .error('#3',2-!_TAB,_attout)
      |? _vp<>33
      || .error('#4',2-!_TAB,_attout,'BLOBRAW')
::       _dtsign
      |? _vp:={? _dtsign='' || 21 || var_pres(_dtsign,_TAB) ?};
         _vp<0
      || .error('#3',2-!_TAB,_dtsign)
      |? _vp<>21
      || .error('#4',2-!_TAB,_dtsign,'DATE')
      |? exec('cli_functions','#system')<=0
      || .error('#102')
::
      |? .TAB.blank();
         .TAB.ID:=$_TAB.ref();
         .TAB.FORG:=_TAB.bl_info(_attin,'NAME');
         .TAB.SIZE:=_TAB.bl_info(_attin,'SIZE');
         .TAB.CRT_DATE:=_TAB.bl_info(_attin,'CREAT_DATE');
         .TAB.CRT_TIME:=_TAB.bl_info(_attin,'CREAT_TIME');
         .TAB.MOD_DATE:=_TAB.bl_info(_attin,'MODIFY_DATE');
         .TAB.MOD_TIME:=_TAB.bl_info(_attin,'MODIFY_TIME');
         .TAB.TYPE:='B';
         .TAB.ACR_ATT:=_attout;
         .TAB.ACR_DTS:=_dtsign;
         .TAB.FORG<>'' & (_fn:=exec('get_unique_file_name','#file',.TAB.FORG,.dir))<>''
      || ($('_a.F%1:=_b' [_type]))(.TAB,_fn);
         _TAB.bl_get(_attin,.dir+_fn,0) & .TAB.add()
      ?}
   ",type_of(''),type_of(SYSLOG),type_of(''),type_of(''),type_of(''),-1),


   obj_meth('dir_add',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [21.37]
:: OPIS: Metoda prywatna.
::       Metoda dodaje do przetworzenie (podpis / weryfikacja) wszystkie pliki ze wskazanego katalogu (bez
::       podkatalogów). Jednocześnie można przetwarzać tylko jeden katalog. Łączenie przetwarzania katalogu z plikami
::       nie jest możliwe.
::   WE: _a [STRING] - Typ przetwarzania S - sign / V - verify.
::       _b [STRING] - Pełna ścieżka dostępu do katalogu lokalnego (z @), który ma być przetwarzany.
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   "  _type:=_a;
      _dir:=_b;

      _stack:=form_stack(2);

      {? ~(_stack[2].name<>'' & _stack[2].file='')
      || .error('#100')
      |? .mode<>''
      || .error('#2')
::       _type
      |? _type<>'S' & _type<>'V'
      || .error('#101','Nieprawidłowy typ przetwarzania.'@)
::       _path
      |? 1+_dir<>'@'
      || .error('#11',_dir)
      |? fexists(_dir,0)<>2
      || .error('#13',_dir)
      |? _FILE:=fdir(_dir,1,0);
         ~_FILE.first()
      || .error('#14',_dir)
      |? exec('cli_functions','#system')<=0
      || .error('#102')
      |? _files:=0;
         {!
         |? {? _FILE.TYPE='f'
            || .TAB.blank();
               .TAB.FORG:=_FILE.NAME;
               .TAB.PATH:=_dir;
               .TAB.TYPE:='F';
               .TAB.UPDATE:=0;
               ($('_a.F%1:=_b' [_type]))(.TAB,.TAB.FORG);
               _files+=.TAB.add()
            ?};
            _FILE.next()
         !};
         _files=0
      || .error('#14',_dir)
      || .dir:=_dir+{? _dir+1=.sep0 || '' || .sep0 ?};
         .mode:='d'
      ?}

   "),


   obj_meth('file_add',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda prywatna.
::       Metoda dodaje plik do opatrzenia podpisem elektronicznym.
::   WE: _a [STRING] - Typ przetwarzania S - sign / V - verify.
::       _b [STRING] - Pełna ścieżka dostępu do pliku lokalnego (z @), który ma być przetwarzany.
::       _c [NUMBER] - Czy aktualizować oryginał po prawidłowym podpisaniu [0*/1]?
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   "  _type:=_a;
      _path:=_b;
      _update:=_c;

      _stack:=form_stack(2);

      {? ~(_stack[2].name<>'' & _stack[2].file='')
      || .error('#100')
      |? .mode='' | (.mode='f' & var_pres('TEMP',.)=.tVOID) | .mode='s'
      || .error('#1')
::       _type
      |? _type<>'S' & _type<>'V'
      || .error('#101','Nieprawidłowy typ przetwarzania.'@)
::       _path
      |? ~(1+_path<>'@' | 5+_path<>'#!tmp')
      || .error('#11',_path)
      |? fexists(_path,0)<>1
      || .error('#12',_path)
      |? exec('cli_functions','#system')<=0
      || .error('#102')
::
      |? _dira:=spli_str(_path,.sep0);
::       Tylko nazwa pliku.
         _fn:=_dira[obj_len(_dira)];
::       Pełna ścieżka dostępu do katalogu (bez @ na początku i bez separatora na końcu).
         _dir:=1-_path-(+_fn+1);
         .TAB.blank();
         .TAB.FORG:=_fn;
         .TAB.PATH:=_dir;
         .TAB.TYPE:='F';
         .TAB.UPDATE:=_update;
         .TAB.FORG<>'' & (_fn:=exec('get_unique_file_name','#file',.TAB.FORG,.dir))<>''
      || ($('_a.F%1:=_b' [_type]))(.TAB,_fn);
         fcopy(_path,.dir+_fn,0,0) & .TAB.add()
      ?}
   ",type_of(''),type_of(''),type_of(0),-1),


   obj_meth('sign_task_list',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Metoda prywatna.
::       Tworzy plik w formacie XML z zadaniami do wykonania dla biblioteki Szafir.
::   WE: _a [STRING] - Typ podpisu.
::   WY: Ścieżka do utworzonego pliku.
::----------------------------------------------------------------------------------------------------------------------
   "  _signt:=gsub(_a,' ','');

      _stack:=form_stack(2);

      {? ~(_stack[2].name<>'' & _stack[2].file='')
      || return(.error('#100'))
      ?};

      {? .TAB.first()
      || _dir:=gsub(1-.dir,'\\\\','/');
         _signa:=spli_str(_signt,',');
         {? _signa[1]=''
         || _signa[1]:='XAdES-BES'
         ?};
         _ext:={? _signa[1]='PKCS#7' || '.sig' |? _signa[1]='XAdES-BES' || '.XAdES' || '' ?};
         .XML.reset();
         _tl:=.XML.addElement('TaskList');
            _sg:=.XML.addElement('SigningTask',,_tl);
               .XML.addElement('Format',_signa[1],_sg);
               {? _signt*',DataEmbedding='=0
::                Parametr 'DataEmbedding' jest obowiązkowy, a nie został podany w wywołaniu - ustawmy go na true.
               || .XML.addElement('DataEmbedding','true',_sg)
               ?};
               {! _lp:=2 .. obj_len(_signa)
               |! _poz:=_signa[_lp]*'=';
                  {? _poz>0
                  || _name:=form((_poz-1)+_signa[_lp]);
                     _val:=form(_poz-_signa[_lp]);
                     .XML.addElement(_name,_val,_sg)
                  ?}
               !};
               {!
               |? _sti:=.XML.addElement('SigningTaskItem',,_sg);
                     .XML.addAttr('Id','ID-%1'[form(#.TAB.ref(),-10,0,'9')]);
                     _fin:='file:///%1'[gsub(_dir+.TAB.FS,' ','%20')];
                     _fout:=_fin+_ext;
                     _dts:=.XML.addElement('DataToSign',,_sti);
                        .XML.addElement('URI',_fin,_dts);
                     _stc:=.XML.addElement('SignatureToCreate',,_sti);
                        .XML.addElement('URI',_fout,_stc);
                  .TAB.next()
               !};
         _fn:='@'+tmp_dir()+.sep0+'task.xml';
         {? .XML.write(_fn)
         || _fn
         || ''
         ?}
      || ''
      ?}
   ",type_of(''),-1),


obj_meth('copy_xml_file',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [21.37]
:: OPIS: Metoda prywatna.
::       Metoda kopiuje pliki xml potrzebne podczas podpisywania lub weryfikacji podpisanych plików
::   WE:
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
   "  _res:=1;
      _exe_dir:=exe_dir();
      _name_src:='settings.xml';
      _hash_src:=exec('hash','#file',_name_src,1);
      {! _ind:=1..2
      |! _name_dst:='@%1/xades/%2'[_exe_dir,{? _ind=1 || 'settings_cryptoproviders.xml' || 'settings_verify.xml' ?}];
         {? _hash_src<>exec('hash','#file',_name_dst,0)
         || _res*=fcopy(_name_src,_name_dst,1,0,1)
         ?}
      !};
      _res
   ",-1),


   obj_meth('sign_core',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda prywatna.
::       Główna część silnika / mechanizmu do opatrywania plików podpisem elektronicznym.
::   WE: _a [STRING] - Typ podpisu.
::       _b [NUMBER] - Tryb komunikatów:
::                         0 - Brak komunikatów.
::                         1 - Tylko komunikaty o błędach.
::                         2 - Raport z przetwarzania.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  _signt:=_a;
      _verbose:=_b;

      _stack:=form_stack(2);

      {? ~(_stack[2].name<>'' & _stack[2].file='')
      || return(.error('#100'))
      ?};

      _task_list:=.sign_task_list(_signt);
      _log:='@'+tmp_dir()+.sep0+'sign.xml';

      .copy_xml_file();
      _dtb:=date();
      sign('CUSTOM_TASKLIST',_task_list,_log);
      _dta:=date();

      _ret:=1;

      _fh:=fopen(_log,'br',0,0,1,1);
      {? _fh.is_open()
      || _buf:=obj_new('baseDir','dtsign','dtb','txt','new');
         _buf.baseDir:='file:///'+gsub(1-.dir,%92,%47);
         _buf.dtsign:=_dtb=_dta;
         _buf.dtb:=_dtb;

         params_set(
            'TAB',.TAB,
            'buf',_buf
         );
         .TAB.cntx_psh();
         .TAB.index(.NDX.FS);
         {? _fh.fgetsize()=0
         || {? _verbose>0
            || .FUN.info('Raport z opatrywania pliku(-ów) podpisem elekronicznym nie zawiera żadnych informacji.'@)
            ?};
            _ret:=0
         |? ~xml_sax_parse(_fh,,,
               "" _par:=params_get();
                  _TAB:=_par.TAB;
                  _buf:=_par.buf;
                  _depth:=xml_path();
                  _path:='';
                  {! _lp:=1 .. _depth
                  |! _path+='<'+xml_path('name',_depth-_lp)+'>'
                  !};
                  {? _path='<TaskList><SigningTask><SigningTaskItem>'
                  || _TAB.blank()
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><Result>'
                  || {! _lp:=1 // 4 .. obj_len(_e)
                     |! {? _e[_lp]='code'
                        || _TAB.SRESCODE:=_e[_lp+3];
                           {? _buf.dtsign & _TAB.SRESCODE='0'
                           || _TAB.DTSIGN:=_buf.dtb
                           ?}
                        ?}
                     !}
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><Description>'
                  || {! _lp:=1 // 4 .. obj_len(_e)
                     |! {? _e[_lp]='code'
                        || _TAB.SDESCODE:=_e[_lp+3]
                        ?}
                     !}
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><SigningCertificate>'
                  || {! _lp:=1 // 4 .. obj_len(_e)
                     |! {? _e[_lp]='certificateType'
                        || _TAB.CERTTYPE:=_e[_lp+3]
                        ?}
                     !}
                  ?};
                  _par.buf.txt:='';
                  1
               "",
               "" _par:=params_get();
                  _buf:=_par.buf;
                  _txt:=_buf.txt;
                  _TAB:=_par.TAB;
                  _depth:=xml_path();
                  _path:='';
                  {! _lp:=1 .. _depth
                  |! _path+='<'+xml_path('name',_depth-_lp)+'>'
                  !};
                  {? _path='<TaskList><SigningTask><SigningTaskItem><DataToSign><URI>'
                  || _txt:=url_decode(_txt);
                     {? _txt*_buf.baseDir=1
                     || _txt:=(+_buf.baseDir)-_txt
                     ?};
                     _buf.new:=~_TAB.find_key(_txt,);
                     {? _buf.new
                     || _TAB.blank();
                        _TAB.FS:=_txt
                     ?};
                     _TAB.memo_set(,'X509');
                     _TAB.memo_set(,'SUBJECT');
                     _TAB.memo_set(,'ISSUER')
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SignatureToCreate><URI>'
                  || _txt:=url_decode(_txt);
                     {? _txt*_buf.baseDir=1
                     || _txt:=(+_buf.baseDir)-_txt
                     ?};
                     _TAB.FV:=_txt
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><Result>'
                  || _TAB.SRESTXT:=_txt
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><Description>'
                  || _TAB.SDESTXT:=_txt
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><SigningCertificate><Subject>'
                  || _TAB.memo_set(_buf.txt,'SUBJECT')
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><SigningCertificate><Issuer>'
                  || _TAB.memo_set(_buf.txt,'ISSUER')
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><SigningCertificate><Serial>'
                  || _TAB.SERIAL:=_buf.txt
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><SigningCertificate><ValidFrom>'
                  || _dt:=exec('iso_datetime_parse','#convert',_buf.txt,1);
                     _TAB.DTFROM:=_dt.date;
                     _TAB.TMFROM:=_dt.time
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><SigningCertificate><ValidTo>'
                  || _dt:=exec('iso_datetime_parse','#convert',_buf.txt,1);
                     _TAB.DTTO:=_dt.date;
                     _TAB.TMTO:=_dt.time
                  |? _path='<TaskList><SigningTask><SigningTaskItem><SigningResult><SigningCertificate><Base64Binary>'
                  || _TAB.memo_set(_buf.txt,'X509');
                     _fh:=fopen(null(),'bw',,1,1);
                     {? _fh.is_open()
                     || _ret:=base64('decode',_buf.txt,_fh);
                        {? type_of(_ret)=type_of(0) & _ret
                        || _TAB.FINGER:=~-hash(_fh,'sha1')
                        ?};
                        _fh.fclose()
                     ?}
                  |? _path='<TaskList><SigningTask><SigningTaskItem>'
                  || {? _buf.new
                     || _TAB.add()
                     || _TAB.put()
                     ?} & _TAB.memo_put(,'X509') & _TAB.memo_put(,'SUBJECT') & _TAB.memo_put(,'ISSUER')
                  ?};
                  1
               "",
               ""params_get().buf.txt+=_a""
            )
         || {? _verbose>0
            || .FUN.info('Analiza raportu z opatrywania pliku(-ów) podpisem elektronicznym nie powiodła się.'@)
            ?};
            _ret:=0
         ?};
         .TAB.cntx_pop();
         _fh.fclose();
         ferase(_log,0)
      || {? _verbose>0
         || .FUN.info('Brak dostępu do raportu z opatrywania pliku(-ów) podpisem elekronicznym.'@)
         ?};
         _ret:=0
      ?};

      {? _ret & _dtb<>_dta & .TAB.first()
::       Obsługa sytuacji wyjątkowej.
::       W trakcie podpisywania nie uzyskujemy żadnej informacji o dacie podpisania. Wstępnie zakładamy, że pliki
::       zostały podpisane w "dniu dzisiejszym". Jeżeli jednak w tym czasie zmieniła się data, to niestety założenie to
::       traci ważność. Jedynym sposobem poznania daty podpisu, jest jego weryfikacja.
      || .verify_core(_verbose)
      ?};

      _ret
   ",type_of(''),type_of(0),-1),


   obj_meth('verify_core',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda prywatna.
::       Główna część silnika / mechanizmu do weryfikacji podpisu.
::   WE: _a [NUMBER] - Tryb komunikatów:
::                         0 - Brak komunikatów.
::                         1 - Tylko komunikaty o błędach.
::                         2 - Raport z przetwarzania.
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   "  _verbose:=_a;

      _stack:=form_stack(2);

      {? ~(_stack[2].name<>'' & _stack[2].file='')
      || return(.error('#100'))
      ?};

      .erase(.TSIGN);
      .copy_xml_file();

      _log:='@'+tmp_dir()+.sep0+'verify.xml';
      {? ~xades_v(.dir+'*',0,_log,1)
      || {? _verbose>0
         || .FUN.info('Weryfikacja podpisu elektronicznego nie powiodła się.'@)
         ?};
         return(0)
      ?};

      _fh:=fopen(_log,'br',0,0,1,1);
      {? ~_fh.is_open()
      || {? _verbose>0
         || .FUN.info('Brak dostępu do raportu z weryfikacji podpisu elekronicznego.'@)
         ?};
         return(0)
      |? _fh.fgetsize()=0
      || _fh.fclose();
         ferase(_log,0);
         {? _verbose>0
         || .FUN.info('Pusty raport z weryfikacji podpisu elekronicznego.'@)
         ?};
         return(0)
      ?};

      _ret:=1;

      _buf:=obj_new('baseDir','txt','filename');
      _buf.baseDir:='file:///'+gsub(1-.dir,%92,%47);
      _buf.filename:='';
      params_set(
         'TAB',.TAB,
         'TSIGN',.TSIGN,
         'buf',_buf
      );
      .TAB.cntx_psh();
      .TAB.index(.NDX.FV);
      .TAB.prefix();
      .TSIGN.cntx_psh();
      .TSIGN.index(.NSIGN.FV);
      .TSIGN.prefix();
      {? xml_sax_parse(_fh,

::          Start document
            ""echo(); 1"",

::          End document
            """",

::          Start element
            "" _par:=params_get();
               _TAB:=_par.TAB;
               _TSIGN:=_par.TSIGN;
               _buf:=_par.buf;
               _depth:=xml_path();
               _path:='';
               {! _lp:=1 .. _depth
               |! _path+='<'+xml_path('name',_depth-_lp)+'>'
               !};
               {? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature>'
               || _TSIGN.blank();
                  _TSIGN.memo_set(,'X509');
                  _TSIGN.memo_set(,'SUBJECT');
                  _TSIGN.memo_set(,'ISSUER');
                  _TSIGN.FV:=_buf.filename;
                  {? _TAB.find_key(_TSIGN.FV,)
                  || _TSIGN.ID:=_TAB.ID;
                     _TSIGN.FORG:=_TAB.FORG;
                     _TSIGN.PATH:=_TAB.PATH
                  ?}
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult><Result>'
               || {! _lp:=1 // 4 .. obj_len(_e)
                  |! {? _e[_lp]='code'
                     || _TSIGN.VRESCODE:=_e[_lp+3]
                     ?}
                  !}
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult><Description>'
               || {! _lp:=1 // 4 .. obj_len(_e)
                  |! {? _e[_lp]='code'
                     || _TSIGN.VDESCODE:=_e[_lp+3]
                     ?}
                  !}
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult>'
                        '<SigningCertificate>'
               || {! _lp:=1 // 4 .. obj_len(_e)
                  |! {? _e[_lp]='certificateType'
                     || _TSIGN.CERTTYPE:=_e[_lp+3]
                     ?}
                  !}
               ?};

               _par.buf.txt:='';
               1
            "",

::          End element
            "" _par:=params_get();
               _TAB:=_par.TAB;
               _TSIGN:=_par.TSIGN;
               _buf:=_par.buf;
               _depth:=xml_path();
               _path:='';
               {! _lp:=1 .. _depth
               |! _path+='<'+xml_path('name',_depth-_lp)+'>'
               !};
               {? _path='<TaskList><VerifyingTask>'
               || _buf.filename:=''
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><SignatureContainer><URI>'
               || _buf.txt:=url_decode(_buf.txt);
                  echo(_buf.txt);
                  {? _buf.txt*_buf.baseDir=1
                  || _buf.txt:=(+_buf.baseDir)-_buf.txt
                  ?};
                  _buf.filename:=_buf.txt
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><TimeStampList><TimeStamp>'
                        '<GMTTime>'
::                Podpis znakowany czasem.
               || _dt:=exec('iso_datetime_parse','#convert',_buf.txt,1);
                  _TSIGN.DTSIGN:=_dt.date;
                  _TSIGN.TMSIGN:=_dt.time
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult><Result>'
               || _TSIGN.VRESTXT:=_buf.txt
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult><Description>'
               || _TSIGN.VDESTXT:=_buf.txt
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult><SignatureID>'
               || _TSIGN.IDSIGN:=_buf.txt
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult><SigningTime>'
::                Data i czas podpisu (z "końcówki").
::                Jeżeli wcześniej był znacznik czasowy, to uznajemy go za bardziej wiarygodny.
               || {? _TSIGN.DTSIGN=date(0,0,0) & _TSIGN.TMSIGN=time(0,0,0)
                  || _dt:=exec('iso_datetime_parse','#convert',_buf.txt,1);
                     _TSIGN.DTSIGN:=_dt.date;
                     _TSIGN.TMSIGN:=_dt.time
                  ?}
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult>'
                        '<SigningCertificate><Subject>'
               || _TSIGN.memo_set(_buf.txt,'SUBJECT')
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult>'
                        '<SigningCertificate><Issuer>'
               || _TSIGN.memo_set(_buf.txt,'ISSUER')
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult>'
                        '<SigningCertificate><Serial>'
               || _TSIGN.SERIAL:=_buf.txt
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult>'
                        '<SigningCertificate><ValidFrom>'
               || _dt:=exec('iso_datetime_parse','#convert',_buf.txt,1);
                  _TSIGN.DTFROM:=_dt.date;
                  _TSIGN.TMFROM:=_dt.time
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult>'
                        '<SigningCertificate><ValidTo>'
               || _dt:=exec('iso_datetime_parse','#convert',_buf.txt,1);
                  _TSIGN.DTTO:=_dt.date;
                  _TSIGN.TMTO:=_dt.time
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature><VerificationResult>'
                        '<SigningCertificate><Base64Binary>'
               || _TSIGN.memo_set(_buf.txt,'X509');
                  _fh:=fopen(null(),'bw',,1,1);
                  {? _fh.is_open()
                  || _ret:=base64('decode',_buf.txt,_fh);
                     {? type_of(_ret)=type_of(0) & _ret
                     || _TSIGN.FINGER:=~-hash(_fh,'sha1')
                     ?};
                     _fh.fclose()
                  ?}
               |? _path='<TaskList><VerifyingTask><VerifyingTaskItem><Signature>'
               || _TSIGN.add() & _TSIGN.memo_put(,'X509') & _TSIGN.memo_put(,'SUBJECT') & _TSIGN.memo_put(,'ISSUER')
               ?};
               1
            "",

::          Text
            ""params_get().buf.txt+=_a""
         )
      || _loop:=.TAB.first();
         {!
         |? _loop
         |! .TSIGN.prefix(.TAB.FV,);
            {? .TSIGN.last()
::             Przepisujemy dane ostatniego podpisu.
            || .TAB.VRESCODE:=.TSIGN.VRESCODE;
               .TAB.VRESTXT:=.TSIGN.VRESTXT;
               .TAB.VDESCODE:=.TSIGN.VDESCODE;
               .TAB.VDESTXT:=.TSIGN.VDESTXT;
               .TAB.DTSIGN:=.TSIGN.DTSIGN;
               .TAB.TMSIGN:=.TSIGN.TMSIGN;
               .TAB.IDSIGN:=.TSIGN.IDSIGN;
               .TAB.CERTTYPE:=.TSIGN.CERTTYPE;
               .TAB.memo_set(.TSIGN.memo_txt(,1,'X509'),'X509');
               .TAB.FINGER:=.TSIGN.FINGER;
               .TAB.memo_set(.TSIGN.memo_txt(,1,'SUBJECT'),'SUBJECT');
               .TAB.memo_set(.TSIGN.memo_txt(,1,'ISSUER'),'ISSUER');
               .TAB.SERIAL:=.TSIGN.SERIAL;
               .TAB.DTFROM:=.TSIGN.DTFROM;
               .TAB.TMFROM:=.TSIGN.TMFROM;
               .TAB.DTTO:=.TSIGN.DTTO;
               .TAB.TMTO:=.TSIGN.TMTO;
               .TAB.put() & .TAB.memo_put(,'X509') & .TAB.memo_put(,'SUBJECT') & .TAB.memo_put(,'ISSUER')
            ?};
            _loop:=.TAB.next()
         !}

      || {? _verbose>0
         || .FUN.info('Analiza raportu z weryfikacji podpisu elektronicznego nie powiodła się.'@)
         ?};
         _ret:=0
      ?};
      .TSIGN.cntx_pop();
      .TAB.cntx_pop();
      _fh.fclose();
      ferase(_log,0);

      _ret
   ",type_of(0),-1),

::----------------------------------------------------------------------------------------------------------------------
:: Metody publiczne ----------------------------------------------------------------------------------------------------
::----------------------------------------------------------------------------------------------------------------------

   obj_meth('__init',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda inicjująca obiekt - utworzenie kilku struktur złożonych.
::   WE: _a [OBJECT]    - Wskazanie tworzonego obiektu.
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
   "  _a.FUN:=obj_new(@.CLASS.FUN_CLASS);

      _a.KOMM:=obj_new(@.CLASS.JCQ);

      _a.XML:=obj_new(@.CLASS.XML_T);

      _a.TAB:=tab_tmp(2,
         'ID','STRING[16]','SQL-ref rekordu źródłowego'@,
         'FORG','STRING[64]','Oryginalna nazwa pliku'@,
::       Dodatkowe informacje identyfikujące o załączniku (nazwy załączników mogą się powtarzać).
         'SIZE','INTEGER','Rozmiar'@,
         'CRT_DATE','DATE','Data utworzenia pliku'@,
         'CRT_TIME','TIME','Godzina utworzenia pliku'@,
         'MOD_DATE','DATE','Data modyfikacji pliku'@,
         'MOD_TIME','TIME','Godzina modyfikacji pliku'@,
::       Podpisywanie.
         'FS','STRING[64]','Plik do podpisu'@,
         'SRESCODE','STRING[10]','Rezultat - kod'@,
         'SRESTXT','STRING[255]','Rezultat - opis'@,
         'SDESCODE','STRING[10]','Komentarz - kod'@,
         'SDESTXT','STRING[255]','Komentarz - opis'@,
::       Weryfikacja.
         'FV','STRING[64]','Plik do weryfikacji'@,
         'VRESCODE','STRING[10]','Rezultat - kod'@,
         'VRESTXT','STRING[255]','Rezultat - opis'@,
         'VDESCODE','STRING[10]','Komentarz - kod'@,
         'VDESTXT','STRING[255]','Komentarz - opis'@,
::       Podpis.
         'DTSIGN','DATE','Data podpisu'@,
         'TMSIGN','TIME','Godzina podpisu'@,
         'IDSIGN','STRING[40]','Identyfikator podpisu'@,
::       Certyfikat.
         'CERTTYPE','STRING[20]','Typ certyfikatu'@,
         'X509','SYS_MEMO','Certyfikat'@,
         'FINGER','STRING[40]','Odcisk palca'@,
         'SUBJECT','SYS_MEMO','Przedmiot'@,
         'ISSUER','SYS_MEMO','Wystawca'@,
         'SERIAL','STRING[255]','Numer seryjny'@,
         'DTFROM','DATE','Ważny od dnia'@,
         'TMFROM','TIME','Ważny od godziny'@,
         'DTTO','DATE','Ważny do dnia'@,
         'TMTO','TIME','Ważny do godziny'@,
::       Pola techniczne.
         'UPDATE','INTEGER','Czy aktualizować?'@,
::          Pole wykorzystywane przy podpisywaniu - czy aktualizować "oryginał" po podpisaniu?
         'TYPE','STRING[1]','Typ rekordu'@,
::          Typ rekordu (opisuje skąd wziął się plik):
::             B - plik jest załącznikiem (pochodzi z pola typu BLOBRAW);
::             F - plik dyskowy.
         'ACR_ATT','STRING[8]','Akronim pola z załącznikiem'@,
         'ACR_DTS','STRING[8]','Akronim pola z datą podpisania'@,
         'PATH','STRING[255]','Ścieżka dostępu do katalogu źródłowego'@
      );
      _a.NDX:=obj_new('ID','FS','FV');
      _a.NDX.ID:=_a.TAB.index('?');
      _a.NDX.FS:=_a.TAB.ndx_tmp(,,'FS',,);
      _a.NDX.FV:=_a.TAB.ndx_tmp(,,'FV',,);

      _a.TSIGN:=tab_tmp(3,
         'ID','STRING[16]','SQL-ref rekordu źródłowego'@,
         'FORG','STRING[64]','Oryginalna nazwa pliku'@,
         'PATH','STRING[255]','Ścieżka dostępu do katalogu źródłowego'@,
         'FV','STRING[64]','Nazwa weryfikowanego pliku'@,
::       Podpis
         'DTSIGN','DATE','Data podpisu'@,
         'TMSIGN','TIME','Godzina podpisu'@,
         'IDSIGN','STRING[40]','Identyfikator podpisu'@,
::       Wynik weryfikacji
         'VRESCODE','STRING[10]','Rezultat - kod'@,
         'VRESTXT','STRING[255]','Rezultat - opis'@,
         'VDESCODE','STRING[10]','Komentarz - kod'@,
         'VDESTXT','STRING[255]','Komentarz - opis'@,
::       Certyfikat
         'CERTTYPE','STRING[20]','Typ certyfikatu'@,
         'X509','SYS_MEMO','Certyfikat'@,
         'FINGER','STRING[40]','Odcisk palca'@,
         'SUBJECT','SYS_MEMO','Przedmiot'@,
         'ISSUER','SYS_MEMO','Wystawca'@,
         'SERIAL','STRING[255]','Numer seryjny'@,
         'DTFROM','DATE','Ważny od dnia'@,
         'TMFROM','TIME','Ważny od godziny'@,
         'DTTO','DATE','Ważny do dnia'@,
         'TMTO','TIME','Ważny do godziny'@
      );

      _a.NSIGN:=obj_new('ID','FV');
      _a.NSIGN.ID:=_a.TSIGN.index('?');
      _a.NSIGN.FV:=_a.TSIGN.ndx_tmp(,,'FV',,,'DTSIGN',,,'TMSIGN',,);

      ~~
   "),


   obj_meth('show',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda wyświetla bieżący stan tabeli roboczej (np. do śledzenia).
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
   "  {? .grp=~~
      || _ws1:=.TAB.mk_sel('Pliki do podpisu / weryfikacji'@,,,,,,,,'U');
         .TAB.win_fld(_ws1,,'FORG',,,-15);
         .TAB.win_fld(_ws1,,'ID');
         .TAB.win_fld(_ws1,,'FS',,,-15);
         .TAB.win_fld(_ws1,,'SRESCODE',,,-7);
         .TAB.win_fld(_ws1,,'SRESTXT',,,-20);
         .TAB.win_fld(_ws1,,'SDESCODE',,,-7);
         .TAB.win_fld(_ws1,,'SDESTXT',,,-20);
         .TAB.win_fld(_ws1,,'FV',,,-15);
         .TAB.win_fld(_ws1,,'VRESCODE',,,-7);
         .TAB.win_fld(_ws1,,'VRESTXT',,,-20);
         .TAB.win_fld(_ws1,,'VDESCODE',,,-7);
         .TAB.win_fld(_ws1,,'VDESTXT',,,-20);
         .TAB.win_fld(_ws1,,'DTSIGN',,,-10);
         .TAB.win_fld(_ws1,,'TMSIGN',,,-8);
         .TAB.win_fld(_ws1,,'CERTTYPE',,,-5);
         .TAB.win_fld(_ws1,,'FINGER',,,-20);
         .TAB.win_fld(_ws1,,'TYPE');
         .TAB.win_act(_ws1,,'Szukaj');
         .TAB.win_act(_ws1,,'Kolejność');
         .TAB.win_sel(_ws1);

         _we:=.TAB.mk_edit('Plik do podpisu / weryfikacji'@);
         .TAB.win_esep(_we,'Źródło'@);
         .TAB.win_efld(_we,,'TYPE',,,3);
         .TAB.win_efld(_we,,'FORG',,,80);
         .TAB.win_efld(_we,,'ID',,,80);
         .TAB.win_efld(_we,,'PATH',,,80);
         .TAB.win_esep(_we,'Podpis'@);
         .TAB.win_efld(_we,,'FS',,,80);
         .TAB.win_efld(_we,,'SRESCODE');
         .TAB.win_efld(_we,,'SRESTXT',,,80);
         .TAB.win_efld(_we,,'SDESCODE');
         .TAB.win_efld(_we,,'SDESTXT',,,80);
         .TAB.win_esep(_we,'Weryfikacja'@);
         .TAB.win_efld(_we,,'FV',,,80);
         .TAB.win_efld(_we,,'VRESCODE');
         .TAB.win_efld(_we,,'VRESTXT',,,80);
         .TAB.win_efld(_we,,'VDESCODE');
         .TAB.win_efld(_we,,'VDESTXT',,,80);
         .TAB.win_efld(_we,,'DTSIGN');
         .TAB.win_efld(_we,,'TMSIGN',,,8);
         .TAB.win_esep(_we,'Certyfikat'@);
         .TAB.win_efld(_we,,'CERTTYPE');
         .TAB.win_efld(_we,,'X509',,,80,-2);
         .TAB.win_efld(_we,,'FINGER');
         .TAB.win_efld(_we,,'SUBJECT',,,80,-2);
         .TAB.win_efld(_we,,'ISSUER',,,80,-2);
         .TAB.win_efld(_we,,'DTFROM');
         .TAB.win_efld(_we,,'TMFROM',,,8);
         .TAB.win_efld(_we,,'DTTO');
         .TAB.win_efld(_we,,'TMTO',,,8);
         .TAB.win_esep(_we,'Pola techniczne'@);
         .TAB.win_efld(_we,,'ACR_ATT');
         .TAB.win_efld(_we,,'ACR_DTS');
         .TAB.win_efld(_we,,'UPDATE',,,,,,'Aktualizacja oryginału'@,,,'check-box',
            'check_label=""%1""' ['Tak, oryginał będzie aktualizowany'],""1"",""0""
         );
         .TAB.win_edit(_we);

         _ws2:=.TSIGN.mk_sel('Informacje o podpisach'@,,,,,,,,'U');
         .TSIGN.win_fld(_ws2,,'DTSIGN',,,-10);
         .TSIGN.win_fld(_ws2,,'TMSIGN',,,-8);
         .TSIGN.win_fld(_ws2,,'VRESCODE',,,-7);
         .TSIGN.win_fld(_ws2,,'VRESTXT',,,-20);
         .TSIGN.win_fld(_ws2,,'VDESCODE',,,-7);
         .TSIGN.win_fld(_ws2,,'VDESTXT',,,-20);
         .TSIGN.win_fld(_ws2,,'CERTTYPE',,,-5);
         .TSIGN.win_fld(_ws2,,'FINGER',,,-20);
         .TSIGN.win_fld(_ws2,,'ISSUER',,,-20);
         .TSIGN.win_fld(_ws2,,'SUBJECT',,,-20);
         .TSIGN.win_act(_ws2,,'Szukaj');
         .TSIGN.win_act(_ws2,,'Kolejność');
         .TSIGN.win_sel(_ws2);

         _we:=.TSIGN.mk_edit('Podpis'@);
         .TSIGN.win_esep(_we,'Podpis'@);
         .TSIGN.win_efld(_we,,'DTSIGN',,,10);
         .TSIGN.win_efld(_we,,'TMSIGN',,,8);
         .TSIGN.win_efld(_we,,'IDSIGN',,,80);
         .TSIGN.win_esep(_we,'Weryfikacja'@);
         .TSIGN.win_efld(_we,,'VRESCODE');
         .TSIGN.win_efld(_we,,'VRESTXT',,,80);
         .TSIGN.win_efld(_we,,'VDESCODE');
         .TSIGN.win_efld(_we,,'VDESTXT',,,80);
         .TSIGN.win_esep(_we,'Certyfikat'@);
         .TSIGN.win_efld(_we,,'CERTTYPE');
         .TSIGN.win_efld(_we,,'X509',,,80,-5);
         .TSIGN.win_efld(_we,,'FINGER');
         .TSIGN.win_efld(_we,,'SUBJECT',,,80,-2);
         .TSIGN.win_efld(_we,,'ISSUER',,,80,-2);
         .TSIGN.win_efld(_we,,'DTFROM');
         .TSIGN.win_efld(_we,,'TMFROM',,,8);
         .TSIGN.win_efld(_we,,'DTTO');
         .TSIGN.win_efld(_we,,'TMTO',,,8);
         .TSIGN.win_edit(_we);

         _grp:=.TAB.grp_make('Raport z przetwarzania'@);
         .TAB.grp_sel(_grp,.TAB,_ws1,,$(""params_set(_par:=params_get()); grp_disp(_par.TSIGN,'""+_ws2+""')""));
         .TAB.grp_splt(_grp,,'horizontal','sign',20);
         .TAB.grp_sel(_grp,.TSIGN,_ws2,,,,,,""cur_tab(1,1).prefix(cur_tab().FV,)"");

         .TAB.win_sel(_grp)

      ?};

      .TSIGN.cntx_psh();
      .TSIGN.index(.NSIGN.FV);
      .TAB.cntx_psh();
      params_set('TSIGN',.TSIGN);
      .TAB.select();
      .TAB.cntx_pop();
      .TSIGN.cntx_pop();
      ~~
   ",-1),


   obj_meth('start',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda rozpoczyna sesję przetwarzania (podpisywania lub weryfikacji).
::   WE:
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   "  {? (.mode='f' & var_pres('TEMP',.)<>.tVOID) | .mode='d'
      || .error('#2')
      |? .TEMP:=fmk_tmp_dir(1);
         type_of(.TEMP)<>.tVOID
      || .dir:='@'+.TEMP.get_path()+.sep0;
         .mode:='f';
         1
      ?}
   ",-1),


   obj_meth('stop',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda kończy sesję przetwarzania (podpisywania lub weryfikacji).
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
   "  {? var_pres('TEMP',.)>100
      || obj_del(.TEMP)
      ?};
      .TEMP:=~~;
      .erase(.TAB);
      .mode:='';
      ~~
   ",-1),


   obj_meth('s_blob_add',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda dodaje do opatrzenia podpisem elektronicznym plik z załącznika bieżącego rekordu tabeli _a.
::   WE:  _a  [TABLE]  - Uchwyt do tabeli.
::        _b  [STRING] - Akronim pola z załącznikiem do podpisania.
::       [_c] [STRING] - Akronim pola, w którym będzie umieszczony podpisany załącznik. Pominięcie parametru oznacza,
::                       że załącznik nie zostanie zaktualizowany [domyślnie: ''].
::       [_d] [STRING] - Akronim pola, w którym będzie umieszczona data podpisu. Pominięcie parametru oznacza, że
::                       data nie będzie nigdzie zapisana.
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   ".blob_add('S',_a,_b,_c,_d)",type_of(SYSLOG),type_of(''),type_of(''),type_of(''),-1),


   obj_meth('s_blob_add',".blob_add('S',_a,_b,'','')",type_of(SYSLOG),type_of(''),-1),
   obj_meth('s_blob_add',".blob_add('S',_a,_b,'',_d)",type_of(SYSLOG),type_of(''),type_of(~~),type_of(''),-1),
   obj_meth('s_blob_add',".blob_add('S',_a,_b,_c,'')",type_of(SYSLOG),type_of(''),type_of(''),-1),


   obj_meth('s_dir_add',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [21.37]
:: OPIS: Metoda dodaje do opatrzenia podpisem elektronicznym katalog - podpisane będą wszystkie zawarte w nim
::       (bez podkatalogów) pliki.
::   WE: _a [STRING] - Pełna ścieżka dostępu do katalogu lokalnego (z @), który ma być przetwarzany.
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   ".dir_add('S',_a)"),


   obj_meth('s_file_add',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda dodaje plik do opatrzenia podpisem elektronicznym.
::   WE:  _a  [STRING] - Pełna ścieżka dostępu do pliku lokalnego (z @), który ma być przetwarzany.
::       [_b] [NUMBER] - Czy aktualizować oryginał po prawidłowym podpisaniu [0*/1]?
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   ".file_add('S',_a,_b)",type_of(''),type_of(0),-1),


   obj_meth('s_file_add',".file_add('S',_a,0)",type_of(''),-1),


   obj_meth('v_blob_add',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda dodaje do weryfikacji podpisu elektronicznego plik z załącznika bieżącego rekordu tabeli _a.
::   WE:  _a  [TABLE]  - Uchwyt do tabeli.
::        _b  [STRING] - Akronim pola z załącznikiem.
::       [_c] [STRING] - Akronim pola, z datą podpisu. Pominięcie parametru oznacza, że data nie będzie porównana.
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   ".blob_add('V',_a,_b,'',_c)",type_of(SYSLOG),type_of(''),type_of(''),-1),


   obj_meth('v_blob_add',".blob_add('V',_a,_b,'','')",type_of(SYSLOG),type_of(''),-1),


   obj_meth('v_file_add',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda dodaje plik do weryfikacji podpisu elektronicznego.
::   WE: _a [STRING] - Pełna ścieżka dostępu do pliku lokalnego (z @), który ma być przetwarzany.
::   WY: 1/0 lub ujemny kod błędu.
::----------------------------------------------------------------------------------------------------------------------
   ".file_add('V',_a,0)",type_of(''),-1),


   obj_meth('sign',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda opatruje podpisem elektronicznym pliki dodane wcześniej metodą s_blob_add().
::   WE: [_a] [STRING] - Typ podpisu + elementy dodatkowe, [domyślnie: XAdES-BES].
::                       Jeżeli chcemy zdefiniować elementy dodatkowe, to typ podpisu MUSI wystąpić na początku tego
::                       napisu.
::                       Elementy dodatkowe są napisami postaci 'param1=val1'.
::                       Typ podpisu oraz elementy dodatkowe są oddzielane przecinkami.
::                       Obecnie (biblioteka w wersji 1.8.4.443) dostępne są następujące parametry:
::                         DataEmbedding = false/true*
::                         EncodeToBase64 = false/true*
::                       Parametr DataEmbedding jest obowiązkowy dla Szafira - zostanie dodany przez metodę, nawet
::                       jeżeli nie został podany w opisywanym parametrze. Kolejność parametrów ma znaczenie.
::                       Niepodanie DataEmbedding nie jest problemem - zostanie dodany przez metodę w odpowiednim
::                       miejscu. Jeżeli jednak podane zostaną obydwa parametry, ale w nieodpowiedniej kolejności
::                       (innej niz podana wyżej), Szafir odmówi współpracy nie podając przyczyny.
::       [_b] [NUMBER] - Tryb komunikatów:
::                         0 - Brak komunikatów.
::                         1 - Tylko komunikaty o błędach.
::                         2 - Raport z przetwarzania [domyślnie].
::   WY: Tablica elementów nazwanych:
::          status - Kod rezultatu przetwarzania (1/0 lub ujemny kod błędu).
::          TAB    - Tabela z wynikami przetwarzania.
::          dir    - Pełna ścieżka dostępu do lokalnego (z @ na początku) katalogu tymczasowego (roboczego), do którego
::                   przekopiowane zostały pliki do podpisu.
::          sep    - Separator katalogów po stronie klienta.
::----------------------------------------------------------------------------------------------------------------------
   "  _signt:=_a;
      _verbose:={? _b>=0 & _b<=2 || _b || 2 ?};

      _ret:=obj_new('status','TAB','dir','sep');
      _ret.status:=0;
      _ret.TAB:=~~;
      _ret.dir:='';
      _ret.sep:=.sep0;

      {? .mode='' | (.mode='f' & var_pres('TEMP',.)=.tVOID)
      || _ret.status:=.error('#1');
         return(_ret)
      |? ~.TAB.first()
      || return(_ret)
      ?};

      _ret.status:=.sign_core(_signt,_verbose);

      {? _ret.status=1 & .TAB.first()
::       Jeżeli do tej pory nie napotkaliśmy na problemy, to czas uaktualnić dane.
      || .KOMM.init();
         _size:=.TAB.size();
         _lp:=0;
         _pb:=_pp:=0;
         _inTermN:=~exec('interm','#system');
         {!
         |? _lp+=1;
            _pb:=(100*_lp/_size)$2;
            {? _pp<>_pb
            || _pp:=_pb;
               progress(_pb,
                  'Aktualizacja daty opatrzenia dokumentu podpisem elektronicznym. Proszę czekać ...'@,
                  'Przetwarzanie danych'@
               )
            ?};
            _icon:='xwin16.png:13';
            _root:=.KOMM.sect_beg(.TAB.FORG);
            {? .TAB.SRESCODE='0' & .TAB.DTSIGN<>.d0
            || .KOMM.add('%1: %2' ['Data opatrzenia podpisem elektronicznym'@,$.TAB.DTSIGN]);
               {? .TAB.TYPE='B'
::                Plik jest załącznikiem.
               || {? .TAB.ACR_ATT<>'' | .TAB.ACR_DTS<>''
                  || _TAB:=ref_tab(.TAB.ID);
                     _name:=ref_name(.TAB.ID);
                     _TAB.cntx_psh();
                     {? _TAB.name()<>_name
                     || _TAB.use(_name)
                     ?};
                     {? _TAB.seek(.TAB.ID)
                     || _fn:=
                           {? exec('split_file_name','#file',.TAB.FV).ext=exec('split_file_name','#file',.TAB.FORG).ext
::                            Jeżeli podpis nie zmienił rozszerzenia pliku, to zapamiętajmy go pod oryginalną nazwą.
                           || .TAB.FORG
                           || .KOMM.add('%1: %2' ['Nowa nazwa'@,.TAB.FV]);
                              .TAB.FV
                           ?};
                        do();
                        {? .TAB.ACR_DTS<>''
                        || ($('_a.%1:=_b; _a.put()' [.TAB.ACR_DTS]))(_TAB,.TAB.DTSIGN)
                        ?};
                        {? .TAB.ACR_ATT<>''
                        || _TAB.bl_put(.TAB.ACR_ATT,.dir+.TAB.FV,0,,_fn)
                        ?};
                        {? end()
                        || .KOMM.add('Aktualizacja rekordu źródłowego (%1) zakończona sukcesem.'@ [.TAB.ID])
                        || .KOMM.add('Aktualizacja rekordu źródłowego (%1) nie powiodła się.'@ [.TAB.ID]);
                           _icon:='xwin16.png:14';
                           _ret.status:=0
                        ?}
                     || .KOMM.add('Rekordu źródłowego (%1) nie udało się odnaleźć.'@ [.TAB.ID]);
                        _icon:='xwin16.png:14'
                     ?};
                     _TAB.cntx_pop();
                     obj_del(_TAB)
                  ?}

               |? .TAB.TYPE='F'
               || {? _inTermN
                  || .KOMM.add('%1: %2' ['Katalog źródłowy'@,.TAB.PATH])
                  ?};
                  {? .TAB.UPDATE
                  || _fn:=
                        {? exec('split_file_name','#file',.TAB.FV).ext=exec('split_file_name','#file',.TAB.FORG).ext
::                         Jeżeli podpis nie zmienił rozszerzenia pliku, to zapamiętajmy go pod oryginalną nazwą.
                        || .TAB.FORG
                        || .KOMM.add('%1: %2' ['Nowa nazwa'@,.TAB.FV]);
                           .TAB.FV
                        ?};
                     {? fcopy(.dir+.TAB.FV,'@'+.TAB.PATH+.sep0+_fn,0,0,1)
                     || .KOMM.add('Utworzenie pliku opatrzonego podpisem elektronicznym zakończone sukcesem.'@)
                     || .KOMM.add('Utworzenie pliku opatrzonego podpisem elektronicznym nie powiodło się.'@);
                        _icon:='xwin16.png:14';
                        _ret.status:=0
                     ?}
                  ?}
               ?}
            || {? .TAB.TYPE='B'
               || .KOMM.add('%1: %2' ['Rekord źródłowy'@,.TAB.ID])
               |? .TAB.TYPE='F'
               || {? _inTermN
                  || .KOMM.add('%1: %2' ['Katalog źródłowy'@,.TAB.PATH])
                  ?}
               ?};
               .KOMM.add('Opatrzenie podpisem elektronicznym nie powiodło się (szczegóły techniczne poniżej).'@);
               .KOMM.add('%1: %2 - %3' ['Rezultat'@,.TAB.SRESCODE,.TAB.SRESTXT]);
               .KOMM.add('%1: %2 - %3' ['Komentarz'@,.TAB.SDESCODE,.TAB.SDESTXT]);
               _icon:='xwin16.png:14';
               _ret.status:=0
            ?};
            .KOMM.sect_end();
            .KOMM.update(_root,,_icon);
            .TAB.next()
         !};
         prgs_clr();
         {? _verbose>1
         || .KOMM.select('Raport z opatrywania podpisem elektronicznym'@)
         ?};
         _ret.TAB:=.cloneTAB(.TAB,2);
         _ret.dir:=.dir
      ?};

      _ret

   ",type_of(''),type_of(0),-1),


   obj_meth('sign',".sign('PAdES',2)",-1),
   obj_meth('sign',".sign(_a,2)",type_of(''),-1),
   obj_meth('sign',".sign('PAdES',_b)",type_of(~~),type_of(0),-1),


   obj_meth('verify',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Metoda weryfikuje podpisy elektroniczne w plikach dodanych wcześniej metodą v_blob_add().
::   WE: _a [NUMBER] - Tryb komunikatów:
::                         0 - Brak komunikatów.
::                         1 - Tylko komunikaty o błędach.
::                         2 - Raport z przetwarzania [domyślnie].
::   WY: Tablica elementów nazwanych:
::          status - Kod rezultatu przetwarzania (1/0 lub ujemny kod błędu).
::          TAB    - Tabela z wynikami przetwarzania.
::          TSIGN  - Tabela ze szczegółowymi informacjami o podpisach.
::          dir    - Pełna ścieżka dostępu do lokalnego (z @ na początku) katalogu tymczasowego (roboczego), do którego
::                   przekopiowane zostały pliki do weryfikacji.
::          sep    - Separator katalogów po stronie klienta.
::----------------------------------------------------------------------------------------------------------------------
   "  _verbose:={? _a>=0 & _a<=2 || _a || 2 ?};

      _ret:=obj_new('status','TAB','TSIGN','dir','sep');
      _ret.status:=0;
      _ret.TAB:=~~;
      _ret.TSIGN:=~~;
      _ret.dir:='';
      _ret.sep:=.sep0;

      {? .mode='' | (.mode='f' & var_pres('TEMP',.)=.tVOID)
      || _ret.status:=.error('#1');
         return(_ret)
      |? ~.TAB.first()
      || return(_ret)
      ?};

      _ret.status:=.verify_core(_verbose);
      {? _ret.status=1 & .TAB.first()
::       Jeżeli weryfikacja przebiegła pomyślnie, to czas uaktualnić dane.
      || .KOMM.init(120);
         .TSIGN.cntx_psh();
         .TSIGN.index(.NSIGN.FV);
         _inTermN:=~exec('interm','#system');
         {!
         |? _icon:='';
            _txt:=
               .TAB.FORG+' '+
               {? .TAB.TYPE='B'
               || '(Rozmiar: %1 | Data i godzina utworzonia / modyfikacji: %2 %3 / %4 %5)'
                  [$.TAB.SIZE,.TAB.CRT_DATE$1,.TAB.CRT_TIME$3,.TAB.MOD_DATE$1,.TAB.MOD_TIME$3]
               || '(%1)' [.TAB.PATH]
               ?};
            _root:=.KOMM.sect_beg(_txt);
            {? .TAB.DTSIGN=.d0
            || .KOMM.add('Plik nie jest opatrzony podpisem elektronicznym.'@)
            || .TSIGN.prefix(.TAB.FV,);
               {? .TSIGN.first()
               || _bd:='<brak danych>'@;
                  {!
                  |? .KOMM.sect_beg('Data i godzina podpisu: %1 %2'@ [.TSIGN.DTSIGN$1,.TSIGN.TMSIGN$3]);
                     _cn:=exec('x509_str','#convert',.TSIGN.memo_txt(,1,'SUBJECT'),'CN');
                     .KOMM.add('Sygnatariusz: %1'@ [{? _cn='' || _bd || _cn ?}]);
                     .KOMM.add('Typ certyfikatu: %1'@ [{? .TSIGN.CERTTYPE='' || _bd || .TSIGN.CERTTYPE ?}]);
                     .KOMM.add(
                        'Okres ważności certyfikatu: %1 %2 - %3 %4'@
                        [.TSIGN.DTFROM$1,.TSIGN.TMFROM$3,.TSIGN.DTTO$1,.TSIGN.TMTO$3]
                     );
                     .KOMM.sect_end();
                     .TSIGN.next()
                  !}
               ?};
               .TSIGN.prefix()
            ?};
            {? .TAB.TYPE='B' & .TAB.ACR_DTS<>''
            || _TAB:=ref_tab(.TAB.ID);
               _name:=ref_name(.TAB.ID);
               _TAB.cntx_psh();
               {? _TAB.name()<>_name
               || _TAB.use(_name)
               ?};
               {? _TAB.seek(.TAB.ID)
               || _before:=($('_a.%1' [.TAB.ACR_DTS]))(_TAB);
                  {? _before=.TAB.DTSIGN
                  || _icon:={? .TAB.DTSIGN=.d0 || 'xwin16.png:180' || 'xwin16.png:178' ?}
                  |? ($('_a.%1:=_b; _a.put()' [.TAB.ACR_DTS]))(_TAB,.TAB.DTSIGN)
                  || .KOMM.add('Data podpisu wymagała aktualizacji (%1 -> %2).'@ [$_before,$.TAB.DTSIGN],,'0:255:0');
                     _icon:={? .TAB.DTSIGN=.d0 || 'xwin16.png:181' || 'xwin16.png:179' ?}
                  || .KOMM.add('Daty podpisu nie udało się zaktualizować.'@,,'255:0:0');
                     _icon:='xwin16.png:81';
                     _ret.status:=0
                  ?}
               ?};
               _TAB.cntx_pop();
               obj_del(_TAB)

            |? .TAB.TYPE='F'
            || {? _inTermN
               || .KOMM.add('%1: %2' ['Katalog źródłowy'@,.TAB.PATH])
               ?}
            ?};
            .KOMM.sect_end();
            {? _icon<>''
            || .KOMM.update(_root,,_icon)
            ?};
            .TAB.next()
         !};
         .TSIGN.cntx_pop();
         {? _verbose>1
         || .KOMM.select('Raport z weryfikacji podpisu elektronicznego'@,,,,,.TAB.size()=1)
         ?};
         _ret.TAB:=.cloneTAB(.TAB,2);
         _ret.TSIGN:=.cloneTAB(.TSIGN,6);
         _ret.dir:=.dir
      ?};

      _ret
   ",type_of(0),-1),


   obj_meth('verify',".verify(2)",-1)

)

:Sign Version 2.0 jowisz:1045 2022/08/30 15:31:45 c26a0758a0d258ff5eaa97dcbb732cb59b1df05ec3f919a5be2c1aed1313204c2331ce03a1966fcff66ca127777c5716ad943d2e3f28dee700c021741c1015c2e872441721316d423a4256d8b3ca131fcaeb3150daed1d13c2a805b547f11532dca542e4a69d525bc18af6ee4651869ccfd4fe806c0e929fcf01fe7598f38933
