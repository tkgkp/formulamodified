:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: #math.fml [17.00]
:: Utworzony: 17.12.2014
:: Autor: AK
::======================================================================================================================
:: Zawartość: Uniwersalne formuły operujące na liczbach
::======================================================================================================================


\min
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca minimalną wartość z podanych parametrów
::   WE: _a - wartość 1
::       ...
::      [_?] - wartość n
::   WY: minimalna wartość z podanych
::UWAGA: Parametry bez [] sa wymagane, formula może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \min/math.fml
::----------------------------------------------------------------------------------------------------------------------
_min:=_a; {! __:=2.._ |! {? _min>_[__] || _min:=_[__] ?} !}; _min


\max
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca maksymalną wartość z podanych parametrów
::   WE: _a - wartość 1
::       ...
::      [_?] - wartość n
::   WY: maksymalna wartość z podanych
::UWAGA: Parametry bez [] sa wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \max/math.fml
::----------------------------------------------------------------------------------------------------------------------
_max:=_a; {! __:=2.._ |! {? _max<_[__] || _max:=_[__] ?} !}; _max


\sum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca sumę wartości podanych parametrów
::   WE: _a - wartość 1
::       ...
::      [_?] - wartość n
::   WY: suma podanych wartości
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::  OLD: \sum/math.fml
::----------------------------------------------------------------------------------------------------------------------
_sum:=_a; {! __:=2.._ |! _sum+=_[__] !}; _sum


\mean_arithmetic
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca średnią arytmetyczną wartości podanych parametrów
::   WE: _a - wartość 1
::       ...
::      [_?] - wartość n
::   WY: średnia arytmetyczna
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \mean_arithmetic/math.fml
::----------------------------------------------------------------------------------------------------------------------
_sum:=_a; {! __:=2.._ |! _sum+=_[__] !};
_mean:=(1.0*_sum)/_;
_mean


\mean_geometric
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca średnią geometryczną wartości podanych parametrów
::   WE: _a - wartość 1
::       ...
::      [_?] - wartość n
::   WY: średnia geometryczna
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \mean_geometric/math.fml
::----------------------------------------------------------------------------------------------------------------------
_multi:=_a; {! __:=2.._ |! _multi*=_[__] !};
_mean:=pow(_multi,1/_);
_mean


\mean_harmonic
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca średnią harmoniczną wartości podanych parametrów
::   WE: _a - wartość 1
::       ...
::      [_?] - wartość n
::   WY: średnia harmoniczna lub -1 jesli wystapil blad
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \mean_harmonic/math.fml
::----------------------------------------------------------------------------------------------------------------------
_mean:=-1;
_can_continue:=1;
:: Sprawdzam czy wśród argumentów nie ma zera - jeżeli jest to średnia harmoniczna powinna mieć wartość nieskonczoną,
:: co jak wiadomo nie może poprawnie działać w programie
{! _it:=1.._
|? _can_continue>0
|!
   _arg:=_[_it];
   {? _arg=0
   || FUN.wdrerror(
         'Funkcja mean_harmonic\\#math.fml niedozwolony argument zerowy - nie można obliczyć średniej harmonicznej'@);
      _can_continue:=0
   ?}
!};

{? _can_continue>0
||
   _harm:=1/_a;
   {! __:=2.._
   |! _harm+=1/_[__]
   !};
   _mean:={? _harm=0 || 0 || _/_harm ?}
?};
_mean


\mean_RMS
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca średnią kwadratową (root mean square RMS) wartości podanych parametrów
::   WE: _a - wartość 1
::       ...
::      [_?] - wartość n
::   WY: średnia kwadratowa
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \mean_RMS/math.fml
::----------------------------------------------------------------------------------------------------------------------
_sumq:=pow(_a,2); {! __:=2.._ |! _sumq+=pow(_[__],2) !};
_mean:=pow(_sumq,1/2);
_mean


\zaokr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Zaokraglanie wartosci pola
::   WE: _a - sposob zaokraglania
::       _b - zaokraglana wartosc
::       _c - ilosc miejsc po przecinku
::   WY: zaokraglona wartosc
::  OLD: \zaokr/polap.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_b;
_int:=int(_tab);
{? _a='N' & _int<>_tab
|| _tab:=ceil(_tab)
|| _tab:=_tab $ _c
?};
_tab


\ceil
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Funkcja ceil, która najpierw pozbywa się śmieci wynikających z zaokrągleń
::   WE: _a - wartość do przetworzenia
::  OLD: \ceil/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a=0
|| 0
|| _abs:=|_a;
   _round:=15-log10(_abs);
   _a:=_a$_round;
   ceil(_a)
?}


\floor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Funkcja floor, która najpierw pozbywa się śmieci wynikających z zaokrągleń
::   WE: _a - wartość do przetworzenia
::----------------------------------------------------------------------------------------------------------------------
{? _a=0
|| 0
|| _abs:=|_a;
   _round:=15-log10(_abs);
   _a:=_a$_round;
   floor(_a)
?}


\round_trash
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Funkcja która pozbywa się śmieci wynikających z zaokrągleń
::   WE: _a - wartość do przetworzenia
::----------------------------------------------------------------------------------------------------------------------
{? _a=0
|| 0
|| _abs:=|_a;
   _round:=15-log10(_abs);
   _a:=_a$_round
?}


\opermut
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.30]
:: OPIS: ograniczenie liczby permutacji
::   WE: _a - rozmiar 1
::       _b - rozmiar 2
::   WY: tablica ograniczen
::  OLD: \opermut/find_ukl.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=obj_new(2);
_wyn[1]:={? _a>8 || 8 || _a ?};
_wyn[2]:={? _b>8 || 8 || _b ?};
{? _wyn[1]=8 || _wyn[2]:=1
|? _wyn[2]=8 || _wyn[1]:=1
?};
_wyn


\lpermut
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.30]
:: OPIS: liczba permutacji
::   WE: _a - rozmiar
::   WY: liczba permutacji
::  OLD: \lpermut/find_ukl.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=1;
{? _a>0 || {! _i.._a |! _wyn:=_wyn*_i !} ?};
_wyn


\comp_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.30]
:: OPIS: porownanie tabel danych czy pierwsza jest dokladna kombinacja drugiej (porownywne sa pierwsze pola)
::   WE: _a - tabela 1
::       _b - tabela 2
::   WY: 1-poprawny uklad 0-nie
::  OLD: \comp_tab/find_ukl.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=1;
_lena:=obj_len(_a);
_lenb:=obj_len(_b);
_i:=1;
_j:=1;
{? _lena>0 & _lenb>0 & _lena<=_lenb
|| {!
   |? _sum:=_a[_i][1];
      {!
      |? _sum-=_b[_j][1];
         _j+=1;
         {? _sum>0
         || _j<=_lenb
         || 0
         ?}
      !};
      {? _sum<>0
      || _wyn:=0;
         0
      |? _i<_lena
      || {? _j<=_lenb
         || _i+=1;
            1
         || _wyn:=0;
            0
         ?}
      || {? _j<_lenb
         || _sum:=0;
            {!
            |? _sum+=_b[_j][1];
               _j+=1;
               ~_sum & _j<=_lenb
            !};
            _wyn:=~_sum
         ?};
         0
      ?}
   !}
|| _wyn:=0
?};
_wyn


\rekurent
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.30]
:: OPIS: uklada kolejny uklad permutacji
::   WE: _a - tabela
::       _b - rozmiar
::       _c - numer permutacji
::       _d - podrozmiar tabeli
::  OLD: \rekurent/find_ukl.fml
::----------------------------------------------------------------------------------------------------------------------
{? _>=4 || {? type_of(_d)<>1 || _d:=0 ?} || _d:=0 ?};

_lperm:=exec('lpermut','#math',_b-1);
_poz  :=(_c-1)%_lperm+1;
_nr   :=(_c-1)%*_lperm+1;
{? _lperm>1
|| {! _i:=_poz..(_b-1)
   |! {? _d
      || {! _j.._d |! _a[_i][_j]==_a[_i+1][_j] !}
      || _a[_i]==_a[_i+1]
      ?}
   !};
   exec('rekurent','#math',_a,_b-1,_nr,_d)
|| {? _poz=1 & _b>1
   || {? _d
      || {! _j.._d |! _a[1][_j]==_a[2][_j] !}
      || _a[1]==_a[2]
      ?}
   ?}
?}


\maxint
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Zwraca maksymalną wartość liczby typu INTEGER
::----------------------------------------------------------------------------------------------------------------------
2147483647


\minint
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Zwraca minimalną wartość liczby typu INTEGER
::----------------------------------------------------------------------------------------------------------------------
-2147483648


\next_value
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwraca następną wartość dla liczby. Jeżeli liczba jest ułamkowa, to dodaje najmniejszy ułamek
::       Przykładowo 17.28 na wejściu da wynik na wyjściu 17.29
::   WE: _a - NUMBER - liczba której znaleźć następną wartość
::       [_b] - INTEGER - [1]/-1 - kierunek zmiany wartości: dodawanie,odejmowanie
::       [_c] - INTEGER - ile miejsc po przecinku dodawać, jeżeli nie podane to samo wymyśla
::   WY: NUMBER następna wartość liczby
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_nr:=_a;
_dir:=1;
{? var_pres('_b')=type_of(0)
|| _dir:=_b
?};
_fract_len:=0;
{? var_pres('_c')=type_of(0)
|| _fract_len:=_c
?};

_result:=_nr;
_str:=form(_nr,,,'9.');
_fract_pos:=_str*'.';

{? _fract_pos>0 | _fract_len>0
||
:: Liczba ułamkowa
   {? _fract_len=0
   || _fract_len:=(+_str)-_fract_pos
   ?};

   _fract_add:=#('0.'+((_fract_len-1)*'0')+'1');
   {? _dir>0
   || _result+=_fract_add
   || _result-=_fract_add
   ?}
||
:: Liczba całkowita
   {? _dir>0
   || _result+=1
   || _result-=1
   ?}
?};
_result


\nwd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [23.25]
:: OPIS: Zwraca największy wspólny dzielnik dwóch liczb naturalnych. (GCD)
::   WE: _a [INTEGER] - liczba naturalna
::       _b [INTEGER] - liczba naturalna
::   WY: _nwd [INTEGER] - największy wspólny dzielnik
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(0) | var_pres('_b')<>type_of(0) | _a<=0 | _b<=0 | _a$0-_a<>0 | _b$0-_b<>0
|| FUN.error('Dopuszczalne jedynie liczby naturalne.'@);
   return(1)
?};
{!
|? {? _a>_b
   || _a-=_b
   |? _b>_a
   || _b-=_a
   ?};

   _a<>_b
!};
_nwd:=_a;
_nwd

:Sign Version 2.0 jowisz:1045 2023/07/27 11:26:01 6f40bf45515c6ac263c292aeba5b9c80679753e4a2b86be3088ac1da0dc6acd166b3a0f08e7f76ce5007573cc305e6a4e664138df0aefed01781039fb6e8c764cfff6f6cffdc8b6b7903f152184ade9e4f1c27bf9991668a4f882f5c120dbaca0c67381a01a7994531248c5b235df27d7242dd0a22732aece188dac76ea091ab
