:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #interval.fml
:: Utworzony: 08.10.2015
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły do obsługi interwałów, okresów, zakresów czasowych (plus obsługa tabel IVAL_*)
::======================================================================================================================


\buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Bufor tabeli IVAL_DEF
::   WY: obj_new()
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
exec('IVAL_DEF','#buffer')


\add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Dodaje do tabeli IVAL_DEF jeden rekord
::   WE: _a - obj_new - tablica nazwana będąca buforem tabeli exec('buffer','#interval')
::   WY: IVAL_DEF.ref() lub null
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100
         || _a
         || exec('buffer','#interval')
         ?};
_result:=null();

IVAL_DEF.cntx_psh();
IVAL_DEF.index('UNIQ');
IVAL_DEF.clear();
IVAL_DEF.blank();
_buffer.set();

{? IVAL_DEF.TYPE1=exec('get_name_default','#interval')
|| IVAL_DEF.TYPE1:=null();
   IVAL_DEF.VALUE1:=0
?};

{? IVAL_DEF.TYPE2=exec('get_name_default','#interval')
|| IVAL_DEF.TYPE2:=null();
   IVAL_DEF.VALUE2:=0
?};

{? IVAL_DEF.KIND='G'
|| IVAL_DEF.TYPE1:=null();
   IVAL_DEF.TYPE2:=null();
   IVAL_DEF.VALUE1:=0;
   IVAL_DEF.VALUE2:=0;
   IVAL_DEF.VALUE3:=time(0,0,0)
|? IVAL_DEF.KIND='D'
|| IVAL_DEF.TIME:=time(0,0,0)
?};

_tm_stamp:=0;
:: Obliczam faktyczny czas trwania zdefiniowanego interwału
{? IVAL_DEF.KIND='G'
|| IVAL_DEF.TM_STAMP:=exec('create','#tm_stamp',date(0,0,0),IVAL_DEF.TIME)
|? IVAL_DEF.KIND='D'
|| IVAL_DEF.TM_STAMP:=0;
   _tm_month:=exec('month','#tm_stamp');
   _tm_week:=exec('week','#tm_stamp');
   _tm_day:=exec('day','#tm_stamp');
   {? IVAL_DEF.TYPE1<>null()
   || {? IVAL_DEF.TYPE1=exec('get_name_months','#interval')
      || IVAL_DEF.TM_STAMP+=IVAL_DEF.VALUE1*_tm_month
      |? IVAL_DEF.TYPE1=exec('get_name_weeks','#interval')
      || IVAL_DEF.TM_STAMP+=IVAL_DEF.VALUE1*_tm_week
      |? IVAL_DEF.TYPE1=exec('get_name_days','#interval')
      || IVAL_DEF.TM_STAMP+=IVAL_DEF.VALUE1*_tm_day
      ?}
   ?};
   {? IVAL_DEF.TYPE2<>null()
   || {? IVAL_DEF.TYPE2=exec('get_name_months','#interval')
      || IVAL_DEF.TM_STAMP+=IVAL_DEF.VALUE2*_tm_month
      |? IVAL_DEF.TYPE2=exec('get_name_weeks','#interval')
      || IVAL_DEF.TM_STAMP+=IVAL_DEF.VALUE2*_tm_week
      |? IVAL_DEF.TYPE2=exec('get_name_days','#interval')
      || IVAL_DEF.TM_STAMP+=IVAL_DEF.VALUE2*_tm_day
      ?}
   ?};
   {? IVAL_DEF.VALUE3<>time(0,0,0)
   || IVAL_DEF.TM_STAMP+=exec('create','#tm_stamp',date(0,0,0),IVAL_DEF.VALUE3)
   ?}
?};
_tm_stamp:=IVAL_DEF.TM_STAMP;

{? IVAL_DEF.find_key(IVAL_DEF.KIND,IVAL_DEF.TYPE1,IVAL_DEF.TYPE2,IVAL_DEF.VALUE1,IVAL_DEF.VALUE2,IVAL_DEF.VALUE3,IVAL_DEF.TIME)
|| _result:=IVAL_DEF.ref();
   {? _tm_stamp<>IVAL_DEF.TM_STAMP
   ||
::    Auto naprawa błędnych rekordów IVAL_DEF
      IVAL_DEF.TM_STAMP:=_tm_stamp;
      IVAL_DEF.put()
   ?}
|| {? IVAL_DEF.add()>0
   || _result:=IVAL_DEF.ref()
   ?}
?};
IVAL_DEF.cntx_pop();
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Kasuje podany rekord tabeli IVAL_DEF (wykonywane w transakcji!!!)
::   WE: _a - IVAL_DEF.ref()
::       _b - INTEGER - tryb dialogów:  0 - brak
::                                     [1] - na ekran
::                                      2 - do komm
::   WY: >0 -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PUBLICZNA><DEL>
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_result:=0;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
IVAL_DEF.cntx_psh(); IVAL_DEF.clear();
{? IVAL_DEF.seek(_ref)
|| {? exec('can_delete','#interval',_ref,_dialog)>0
   || {? IVAL_DEF.del(,1)>0
      || _result:=1
      || undo();
         _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=0
?};

IVAL_DEF.cntx_pop();
{? _mydo || end() ?};
_result


\import_names
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zakłada rekordy w tabeli IVAL_NAM
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------

IVAL_NAM.cntx_psh();
IVAL_NAM.index('NR');

_nr:=0;
_names:=obj_new(4);
_names[1]:='Wybierz...';
_names[2]:='Miesięcy:';
_names[3]:='Tygodni:';
_names[4]:='Dni:';

_can_continue:=1;
_result:=0;

{! _it:=1..obj_len(_names)
|? _can_continue>0
|! IVAL_NAM.prefix(_nr);
   {? IVAL_NAM.first()
   || IVAL_NAM.NAME:=_names[_it];
      _can_continue:=IVAL_NAM.put()
   || IVAL_NAM.blank();
      IVAL_NAM.NR:=_nr;
      IVAL_NAM.NAME:=_names[_it];
      _can_continue:=IVAL_NAM.add()
   ?};
   _nr+=1
!};
IVAL_NAM.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\fld_blank
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuły na wartość początkową pól tabeli IVAL_DEF
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:=~~;
{? _fld='KIND'
|| _result:='B'
|? _fld='TYPE1' | _fld='TYPE2'
|| _result:=exec('get_name_default','#interval')
?};
_result


\fld_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuły przed wyświetleniem pól tabeli IVAL_DEF
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

~~


\fld_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuły przed redakcją pól tabeli IVAL_DEF
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:=1;

VAR_DEL.delete('buffer_before');
buffer_before:=exec('buffer','#interval');
buffer_before.get();

{? _fld='TYPE1'
|| IVAL_NAM.prefix();
   _where:='IVAL_NAM.NAME<>\':_a\'';
   IVAL_NAM.f_set('NAME','',_where,'Wybierz...');
   ~~
|? _fld='TYPE2'
||
   {? IVAL_DEF.TYPE1=exec('get_name_days','#interval')
   || _result:=0
   ?};
   {? _result>0
   ||
      IVAL_NAM.prefix();
      _where:='IVAL_NAM.NAME<>\':_a\' and IVAL_NAM.NR<>:_b and IVAL_NAM.NR>:_b';
      IVAL_NAM.f_set('NAME','',_where,'Wybierz...',IVAL_DEF.TYPE1().NR)
   ?};
   ~~
?};
_result


\fld_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuły na F3 pól tabeli IVAL_DEF
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

~~


\fld_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuły po redakcji pól tabeli IVAL_DEF
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:=~~;
{? _fld='KIND'
|| ~~
|? _fld='TYPE1'
||
   {? buffer_before.TYPE1<>IVAL_DEF.TYPE1 & IVAL_DEF.TYPE2<>null()
   || IVAL_DEF.TYPE2:=exec('get_name_default','#interval');
      IVAL_DEF.VALUE2:=0
   ?};
   ~~
?};
exec('edit_enablator','#interval');
win_disp();
_result


\fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuły na format wyświetlania pól tabeli IVAL_DEF
::   WY: STRING
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_fld:=cur_afld();
{? _fld='TIME'
|| _result:='hour_chars=3'
?};
_result


\fld_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuły na format redagowania pól tabeli IVAL_DEF
::   WY: STRING
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_fld:=cur_afld();
{? _fld='TIME'
|| _result:='hour_chars=3'
?};
_result


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyświetla wszystkie zdefiniowane interwały
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
IVAL_DEF.cntx_psh();
IVAL_DEF.index('TM_STAMP');
IVAL_DEF.prefix();
IVAL_DEF.win_sel('WER');
IVAL_DEF.select();
IVAL_DEF.cntx_pop();
~~


\ival_add_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Dołącz' w oknie zdefiniowanych interwałów czasu
::   WE: [_a] - czy wyświetlać okno edycyjne, czy od razu dodawać to co w buforze
::   WY: IVAL_DEF.ref - ref dodanego rekordu lub null()
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_edit:=1;
{? var_pres('_a')=type_of(0)
|| _edit:=_a
?};

:: Importuje nazwy interwałów
exec('import_names','#interval');

_buffer:=exec('buffer','#interval');

_result:=null();
_can_continue:=1;

{? _edit>0
|| _can_continue:=0;
   IVAL_DEF.blank();
   IVAL_DEF.win_edit('RED');
   exec('edit_enablator','#interval','RED',IVAL_DEF);
   {? IVAL_DEF.edit("exec('validate','#interval')")
   || _can_continue:=1
   ?}
?};
{? _can_continue>0
|| _buffer.get();
   _result:=exec('add','#interval',_buffer)
?};
_result


\ival_upd_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Popraw' w oknie zdefiniowanych interwałów czasu
::   WE: [_a] - czy wyświetlać okno edycyjne, czy od razu putować to co w buforze
::       [_b] - INTEGER - 0/[1] - czy po utworzeniu nowego rekordu usuwać stary
::   WY: IVAL_DEF.ref() - ref nowo utworzonego rekordu lub null
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};
_del_old:=1;
{? var_pres('_b')=type_of(0)
|| _del_old:=_b
?};

:: Zapamiętuję stary rekord
_old:=IVAL_DEF.ref();

_result:=null();
_can_continue:=1;

{? _dialog>0
||
   _can_continue:=0;
:: Wyświetlam poprawianie
   IVAL_DEF.win_edit('RED');
   exec('edit_enablator','#interval','RED',IVAL_DEF);
   {? IVAL_DEF.edit("exec('validate','#interval')")
   || _can_continue:=1
   ?}
?};

{? _can_continue>0
||
:: Dodaję nowy
   IVAL_DEF.TM_STAMP:=0;
   _result:=exec('ival_add_act','#interval',0);
   {? _result=null()
   || _can_continue:=0
   ?}
?};

{? _can_continue>0 & _del_old>0
||
:: Usuwam stary jeśli się da
   IVAL_DEF.cntx_psh();
   IVAL_DEF.prefix();
   {? IVAL_DEF.seek(_old)
   || exec('delete','#interval',IVAL_DEF.ref(),0)
   ?};
   IVAL_DEF.cntx_pop()
?};
_result


\ival_del_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja w oknie - usunięcie rekordu
::   WE: [_a] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

_result:=0;
_can_continue:=1;

_tab:=cur_tab(1,1);

_group:=0;
{? _tab.sel_size()>0
|| _group:=1;
   _dialog:=0
?};

:: Sprawdzam czy można usunąć
{? _group>0
|| {? _dialog>0
   || _c_dialog:=2
   || _c_dialog:=0
   ?};
   _can_continue:=exec('can_delete','#interval',,_c_dialog)
|| {? _dialog>0
   || _c_dialog:=1
   || _c_dialog:=0
   ?};
   _can_continue:=exec('can_delete','#interval',,_c_dialog)
?};

{? _dialog>0 & _can_continue>0
|| _can_continue:=FUN.ask('Usunąć interwał?'@)
?};
{? _can_continue>0
|| _result:=exec('delete','#interval',_tab.ref())
?};
_result


\delete_act_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja usuń grupa przed w oknie wertowania tabeli IVAL_DEF
::   WY: 0 - porazka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tab:=cur_tab(1,1);
{? FUN.ask('Zaznaczono: %1 rekordów. Czy usunąć je wszystkie?'@[$_tab.sel_size()])
|| _result:=1;
   sel_nchk();
   KOMM.init(200,,'Usuwanie interwałów','')
?};
_result


\delete_act_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja usuń grupa po w oknie wertowania tabeli IVAL_DEF
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
KOMM.select(,,,,,0);
~~


\can_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza możliwość usunięcia rekordu IVAL_DEF
::   WE: [_a] - IVAL_DEF.ref, jeśli nie podany to aktualny rekord
::       [_b] - INTEGER - czy wyswietlac komunikaty:  0  - nie
::                                                   [1] - wyskakujący komunikat
::                                                    2  - w KOMM
::   WY: 0 - nie można usunąć rekordu
::       1 - można usuwać
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
_display:=1;
{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_result:=1;
_can_continue:=1;

IVAL_DEF.cntx_psh();
{? var_pres('_a')=type_of(IVAL_DEF.ref())
|| _ref:=_a;
   _can_continue:=0;
   IVAL_DEF.clear();
   {? IVAL_DEF.seek(_ref)
   || _can_continue:=1
   ?}
?};

{? _can_continue>0
|| {? IVAL_DEF.count()>0
   || _msg:='Interwał powiązany, usuwanie zabronione.'@;
      {? _display=1
      || FUN.emsg(_msg)
      |? _display=2
      || KOMM.add(_msg,2,,1)
      ?};
      _result:=0
   ?}
?};
IVAL_DEF.cntx_pop();
_result


\ival_clean_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Czyść' w oknie zdefiniowanych interwałów czasu
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy usunąć wszystkie nieużywane definicje interwałów czasowych?'@)
|| IVAL_DEF.cntx_psh();
   IVAL_DEF.index('TM_STAMP');
   IVAL_DEF.prefix();
   {? IVAL_DEF.first()
   || {!
      |? _next:=0;
         _ref_nxt:=null();
         IVAL_DEF.cntx_psh();
         {? IVAL_DEF.next()
         || _ref_nxt:=IVAL_DEF.ref()
         ?};
         IVAL_DEF.cntx_pop();

         _can_continue:=exec('delete','#interval',IVAL_DEF.ref(),0);

         {? _ref_nxt<>null()
         || _next:=IVAL_DEF.seek(_ref_nxt)
         ?};
         _next>0
      !}
   ?};
   IVAL_DEF.cntx_pop();
   ~~
?};
~~


\edit_enablator
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła enablująca lub disablująca pola w oknie redagowania
::   WE: [_a] - STRING - akronim okna w którym się znajdują pola
::       [_b] tabela, której dotyczy okno
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_win:='';
{? var_pres('_a')=type_of('')
|| _win:=_a
|| _win:=cur_win(1,1)
?};
_tab:=~~;
{? var_pres('_b')>100
|| _tab:=_b
|| _tab:=cur_tab(1,1)
?};

{? IVAL_DEF.KIND='B'
||
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'TIME');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE1');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE2');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE3');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'TYPE1');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'TYPE2');

   _tab.efld_opt(_win,'mark=0',IVAL_DEF,'TIME');
   _tab.efld_opt(_win,'mark=0',IVAL_DEF,'TYPE1')

|? IVAL_DEF.KIND='G'
|| _tab.efld_opt(_win,'mark=1',IVAL_DEF,'TIME');
   _tab.efld_opt(_win,'enable=1',IVAL_DEF,'TIME');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE1');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE2');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE3');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'TYPE1');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'TYPE2');
   ~~
|? IVAL_DEF.KIND='D'
|| _tab.efld_opt(_win,'mark=1',IVAL_DEF,'TYPE1');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'TIME');
   _tab.efld_opt(_win,'enable=1',IVAL_DEF,'VALUE1');
   _tab.efld_opt(_win,'enable=1',IVAL_DEF,'VALUE2');
   _tab.efld_opt(_win,'enable=1',IVAL_DEF,'VALUE3');
   _tab.efld_opt(_win,'enable=1',IVAL_DEF,'TYPE1');
   _tab.efld_opt(_win,'enable=1',IVAL_DEF,'TYPE2');
   ~~
?};

{? IVAL_DEF.TYPE1=exec('get_name_default','#interval') | IVAL_DEF.TYPE1=null
||
:: Jeśli pierwsze pole ma Wybierz lub puste to nie ma sensu redagować drugiego
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'TYPE2');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE2');
   ~~
|? IVAL_DEF.TYPE1=exec('get_name_days','#interval')
||
:: Jeśli w pierwszym polu wybrano Dni to nie ma sensu redagować drugiego
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'TYPE2');
   _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE2');
   ~~
?};
{? IVAL_DEF.TYPE1=null()
|| _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE1')
?};
{? IVAL_DEF.TYPE2=null()
|| _tab.efld_opt(_win,'enable=0',IVAL_DEF,'VALUE2')
?};
~~


\get_name_default
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyszukuje rekord w tabeli IVAL_NAM 'Wybierz'
::   WY: IVAL_NAM.ref
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
IVAL_NAM.cntx_psh();
IVAL_NAM.index('NR');
IVAL_NAM.prefix(0);
{? IVAL_NAM.first()
|| _result:=IVAL_NAM.ref()
?};
IVAL_NAM.cntx_pop();
_result


\get_name_months
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyszukuje rekord w tabeli IVAL_NAM 'Miesięcy:'
::   WY: IVAL_NAM.ref
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
IVAL_NAM.cntx_psh();
IVAL_NAM.index('NR');
IVAL_NAM.prefix(1);
{? IVAL_NAM.first()
|| _result:=IVAL_NAM.ref()
?};
IVAL_NAM.cntx_pop();
_result


\get_name_weeks
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyszukuje rekord w tabeli IVAL_NAM 'Tygodni:'
::   WY: IVAL_NAM.ref
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
IVAL_NAM.cntx_psh();
IVAL_NAM.index('NR');
IVAL_NAM.prefix(2);
{? IVAL_NAM.first()
|| _result:=IVAL_NAM.ref()
?};
IVAL_NAM.cntx_pop();
_result


\get_name_days
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyszukuje rekord w tabeli IVAL_NAM 'Dni:'
::   WY: IVAL_NAM.ref
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
IVAL_NAM.cntx_psh();
IVAL_NAM.index('NR');
IVAL_NAM.prefix(3);
{? IVAL_NAM.first()
|| _result:=IVAL_NAM.ref()
?};
IVAL_NAM.cntx_pop();
_result


\validate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Waliduje rekord interwału
::   WE: _a - obj_new() - bufor do analizy
::   WY: STRING - akronim pola do którego wrócić lub ''
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? IVAL_DEF.KIND='G'
|| {? IVAL_DEF.TIME=time(0,0,0)
   || FUN.emsg('Pole z czasem musi być wypełnione.'@);
      _result:='TIME'
   |? IVAL_DEF.TIME~1<0
   || FUN.emsg('Liczba godzin nie może być mniejsza od zera.'@);
      _result:='TIME'
   ?}
|? IVAL_DEF.KIND='D'
|| _default:=exec('get_name_default','#interval');
   {? (IVAL_DEF.TYPE1=_default | IVAL_DEF.TYPE1=null())
   || FUN.emsg('Typ składnika czasowego musi być wypełniony.'@);
      _result:='TYPE1'
   ?};
   {? _result='' & IVAL_DEF.VALUE1<0
   || FUN.emsg('Wartość składnika czasowego nie może być mniejsza od zera.'@);
      _result:='VALUE1'
   ?};
   {? _result='' & IVAL_DEF.VALUE2<0
   || FUN.emsg('Wartość składnika czasowego nie może być mniejsza od zera.'@);
      _result:='VALUE2'
   ?};
   {? _result=''& IVAL_DEF.VALUE3~1>23
   || FUN.emsg('Godzina nie może być większa niż 23.'@);
      _result:='VALUE3'
   ?}
?};
_result


\buffer_compare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy w buforze tabeli IVAL_DEF jest coś innego niż przekazany bufor, lub jeśli
::       nie przekazany to coś innego niż bufor po blank().
::       Uwaga - wyłącza z porównania pole IVAL_DEF.KIND
::   WE: [_a] - obj_new - obiekt bufora który porównywać z buforem tabeli, jeśli nie podany to tworzy się
::              na podstawie blank()
::   WY: 1 - bufor jest domyślny lub taki sam jak przekazano, uzytkownik nic nie kombinował w oknie
::       0 - bufor zawiera coś, więc trzeba dodać lub zmodyfikować rekord
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_buffer_table:=exec('buffer','#interval');
_buffer_table.get();

{? var_pres('_a')>100
|| _buffer_compare:=_a
|| IVAL_DEF.cntx_psh();
   IVAL_DEF.blank();
   _buffer_compare:=exec('buffer','#interval');
   _buffer_compare.get();
   IVAL_DEF.cntx_pop();

:: Jeśli porównuję z blankiem, a w buforze tabeli typy są puste to przypisuję im wartości domyślne
:: żeby porównanie nie zwróciło że jest różne
   {? _buffer_table.TYPE1=null()
   || _buffer_table.TYPE1:=exec('get_name_default','#interval')
   ?};
   {? _buffer_table.TYPE1=null()
   || _buffer_table.TYPE1:=exec('get_name_default','#interval')
   ?}
?};

_result:=exec('compare','#table',_buffer_compare,_buffer_table,1,'Ref');
_result


\to_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca stringową postać przekazanego interwału czasowego
::   WE: _a - REAL - tm_stamp - czas trwania
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tm_stamp:=_a;

_result:='';
{? _tm_stamp>0
||
   _tm_day:=exec('day','#tm_stamp');
   {? _tm_stamp>_tm_day
   ||
::    Więcej niż dzień
      _ile_dni:=_tm_stamp/_tm_day;
      _ceil:=floor(_ile_dni);
      _result:=$_ceil;
      {? _ceil=1
      || _result+=' dzień'
      || _result+=' dni'
      ?};
      _time:=exec('tm_stamp2time','#tm_stamp',_tm_stamp);
      _result+=' '+_time$3;
      ~~
   ||
::    mniej niż dzień
      _time:=exec('tm_stamp2time','#tm_stamp',_tm_stamp);
      _result:=_time$3
   ?}
?};
_result


\add_to_point
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Do przekazanego punktu czasowego dodaje interwał czasowy podany w argumencie
::   WE: _a - REAL - punkt czasowy do którego dodać
::       [_b] - IVAL_DEF.ref - interwał który dodać lub bieżacy rekord
::   WY: REAL - tm_stamp wynikowy
::  TAG: <PUBLIC>
::----------------------------------------------------------------------------------------------------------------------
_start:=_a;
_ref:=null();
{? var_pres('_b')=type_of(IVAL_DEF.ref())
|| _ref:=_b
?};

_result:=0;
_can_continue:=1;

IVAL_DEF.cntx_psh();
{? _ref<>null()
|| IVAL_DEF.clear();
   {? IVAL_DEF.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _result:=_start;
   {? IVAL_DEF.KIND='G'
   || _result+=exec('time','#tm_stamp',IVAL_DEF.TIME)
   |? IVAL_DEF.KIND='D'
   ||
      {? IVAL_DEF.TYPE1<>null()
      || _result:=exec('type_add','#interval',_result,IVAL_DEF.TYPE1,IVAL_DEF.VALUE1)
      ?};
      {? IVAL_DEF.TYPE2<>null()
      || _result:=exec('type_add','#interval',_result,IVAL_DEF.TYPE2,IVAL_DEF.VALUE2)
      ?};
      {? IVAL_DEF.VALUE3<>time(0,0,0)
      || _result+=exec('time','#tm_stamp',IVAL_DEF.VALUE3)
      ?}
   ?}
?};
IVAL_DEF.cntx_pop();
_result


\type_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Do przekazanego TM_STAMPA dodaje przekazaną wartość podanego typu
::   WE: _a - REAL - punkt czasowy do którego dodać
::       [_b] - IVAL_NAME.ref() - typ wartości
::        _c - INTEGER - wartość
::   WY: REAL - przesunięty tm_stamp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_start:=_a;

_ref:=null();
{? var_pres('_b')=type_of(IVAL_NAM.ref())
|| _ref:=_b
?};

_value:=_c;

_result:=0;
_can_continue:=1;

IVAL_NAM.cntx_psh();
{? _ref<>null()
|| IVAL_NAM.clear();
   {? IVAL_NAM.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? IVAL_NAM.ref()=exec('get_name_months','#interval')
   ||
      _date:=exec('tm_stamp2date','#tm_stamp',_start);
      _time:=exec('tm_stamp2time','#tm_stamp',_start);

      _new_date:=exec('add_months','#interval',_date,_value);
      _result:=exec('create','#tm_stamp',_new_date,_time)
   |? IVAL_NAM.ref()=exec('get_name_weeks','#interval')
   || _result:=_start+(_value*exec('week','#tm_stamp'))
   |? IVAL_NAM.ref()=exec('get_name_days','#interval')
   || _result:=_start+(_value*exec('day','#tm_stamp'))
   ?}
?};
IVAL_NAM.cntx_pop();
_result


\add_months
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Do podanej daty dodaje N miesięcy.
::       Jeżeli mamy 15 stycznia to dodanie 1 miesiąca zwróci 15 lutego.
::       Jeżeli mamy 31 stycznia to dodanie 1 miesiąca zwróci 28 lutego (lub 29 jeżeli rok przestępny)
::   WE: _a - DATE - data do której dodać
::       _b - INTEGER - ile miesięcy dodać
::   WY: DATE - wynikowa data
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_date:=_a;
_add:=_b;

_year:=_date~1;
_month:=_date~2;
_day:=_date~3;
_plus:=_b;
:: Przesuwam się o N miesięcy i zwracam ostatni dzień tego miesiaca
_data:=date(_year+((_month+_add)%12),((_month+_add)%*12),0);
{? _day>_data~3
||
:: Jeżeli dzień z podanej daty przekracza maksymalną ilość dni w danym miesiącu
:: to zwracam ostani dzień miesiąca
   _result:=_data
||
:: Jeżeli dzień z podanej daty jest mniejszy niż maksymalna ilość dni w danym miesiącu
:: to tworzę nową datę w przesuniętym miesiącu
   _result:=date(_data~1,_data~2,_day)
?};
_result


\interval
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca tablice nazwana - interwal czasowy
::   WY: obj_new()
::  OLD: \interval/px_utils.fml
::----------------------------------------------------------------------------------------------------------------------
_interval:=obj_new(  'START',
                     'END');
_interval.START:=0;
_interval.END:=0;
_interval


\intervals_chk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Bada zaleznosc pomiedzy dwoma interwalami czasowymi
::   WE: _a - interwal1 - obiekt nazwany exec('interval','#interval')
::       _b - interwal2 - obiekt nazwany exec('interval','#interval')
::   WY:
::       =0 - interwaly sie nie przecinaja w zaden sposob ze soba
::       =1
::                               |-------------------------------------------|
::                               |+++++++++++++++++++ interwal1              |
::                               |-------------------------------------------|
::          |----------------------------------------|
::          |  interwal2          +++++++++++++++++++|
::          |----------------------------------------|
::
::       =2
::          |-----------------------------------------------------------------------|
::          |            ++++++++++++++++++++++++++++  interwal1                    |
::          |-----------------------------------------------------------------------|
::                      |----------------------------|
::                      |+++ interwal2 (_c.._d) +++++|
::                      |----------------------------|
::
::       =3
::          |------------------------------------|
::          | interwal1           +++++++++++++++|
::          |------------------------------------|
::                               |-----------------------------------|
::                               |+++++++++++++++  interwal2         |
::                               |-----------------------------------|
::       =4
::                      |-------------------------------|
::                      |+++++interwal1          +++++++|
::                      |-------------------------------|
::          |-----------------------------------------------------------------------|
::          |            +++++++++++++++++++++++++++++++  interwal2                 |
::          |-----------------------------------------------------------------------|
::  OLD: \intervals_chk/px_utils.fml
::----------------------------------------------------------------------------------------------------------------------
_ti1:=_a;
_ti2:=_b;

_result:=0;

{? _ti2.START<_ti1.START & _ti2.END<_ti1.END & _ti2.END>=_ti1.START
|| _result:=1
?};
{? _ti2.START>=_ti1.START & _ti2.END<=_ti1.END
|| _result:=2
?};
{? _ti1.START<_ti2.START & _ti1.END<_ti2.END & _ti1.END>=_ti2.START
|| _result:=3
?};
{? _ti1.START>=_ti2.START & _ti1.END<=_ti2.END
|| _result:=4
?};
_result


\intervals_and
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca interwal ktory jest czescia wspolna dwoch podanych interwalow
::   WE: _a - interwal1 - obiekt nazwany exec('interval','#interval')
::       _b - interwal2 - obiekt nazwany exec('interval','#interval')
::   WY: obj_new() - tablica nazwana - interwal czasowy
::  OLD: \intervals_and/px_utils.fml
::----------------------------------------------------------------------------------------------------------------------
_ti1:=_a;
_ti2:=_b;

_result:=exec('interval','#interval');

:: zwracam iloraz tylko jesli interwaly sie przecinaja
{? exec('intervals_chk','#interval',_ti1,_ti2)>0
||
:: max startu
   {? _ti1.START>_ti2.START
   || _result.START:=_ti1.START
   || _result.START:=_ti2.START
   ?};
:: min konca
   {? _ti1.END<_ti2.END
   || _result.END:=_ti1.END
   || _result.END:=_ti2.END
   ?}
?};
_result


\intervals_sum
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [18.42]
:: OPIS: Zwraca interwal ktory jest sumą dwoch podanych interwalow
::   WE: _a - interwal1 - obiekt nazwany exec('interval','#interval')
::       _b - interwal2 - obiekt nazwany exec('interval','#interval')
::   WY: obj_new() - tablica nazwana - interwal czasowy
::  OLD: \intervals_and/px_utils.fml
::----------------------------------------------------------------------------------------------------------------------
_ti1:=_a;
_ti2:=_b;

_result:=exec('interval','#interval');

:: zwracam sume tylko jesli interwaly sie przecinaja
{? exec('intervals_chk','#interval',_ti1,_ti2)>0
||
:: min startu
   {? _ti1.START<_ti2.START
   || _result.START:=_ti1.START
   || _result.START:=_ti2.START
   ?};
:: max konca
   {? _ti1.END>_ti2.END
   || _result.END:=_ti1.END
   || _result.END:=_ti2.END
   ?}
?};
_result


\interval_dur
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca czas trwania intervalu
::   WE: _a - interwal - obiekt nazwany exec('interval','#interval')
::       _b - czy uwzgledniac timezoneOffset
::   WY: REAL
::  OLD: \interval_dur/px_utils.fml
::----------------------------------------------------------------------------------------------------------------------
_interval:=_a;
_withTZO:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_result:=_interval.END-_interval.START;
{? _result<0
|| _result:=_result*(-1)
?};
{? _withTZO
|| _d_p:=exec('tm_stamp2date','#tm_stamp',_result.START);
   _d_k:=exec('tm_stamp2date','#tm_stamp',_result.END);
   _g_p:=exec('tm_stamp2time','#tm_stamp',_result.START);
   _g_k:=exec('tm_stamp2time','#tm_stamp',_result.END);
   _result+=exec('timezoneOffset','#datetime',_d_p,_g_p,'m') - exec('timezoneOffset','#datetime',_d_k,_g_k,'m')
?};
_result


\tm_stamp2interval
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Przekształca podanego tm_stampa w interwał czasowy czyli rekord IVAL_DEF
::   WE: _a - REAL - tm_stamp
::   WY: IVAL_DEF.ref lub null jeśli coś się wykrzaczy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tm_stamp:=_a;

_result:=null();

_int_buf:=exec('buffer','#interval');

_hours:=_tm_stamp/exec('hour','#tm_stamp');
{? _hours>24
||
:: Więcej niż 24 godziny, robię interwał dzienny
   _int_buf.KIND:='D';
   _int_buf.TYPE1:=exec('get_name_days','#interval');
   _days:=_tm_stamp/exec('day','#tm_stamp');
   _days_floor:=floor(_days);
   _tail:=(_days-_days_floor)*exec('day','#tm_stamp');
   _time:=exec('tm_stamp2longtime','#tm_stamp',_tail);

   _int_buf.VALUE1:=_days_floor;
   _int_buf.VALUE3:=_time;
   _result:=exec('add','#interval',_int_buf);
   ~~
||
:: Mniej niż 24 godziny, robię interwał godzinowy
   _int_buf.KIND:='G';
   _int_buf.TIME:=exec('tm_stamp2longtime','#tm_stamp',_tm_stamp);
   _result:=exec('add','#interval',_int_buf);
   ~~
?};
_result


\interval_diff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwraca dwa interwały które nie są częścią wspólną przekazanych dwóch interwałów
::       Przekazane dwa interwały muszą się zazębiać w jakiś sposób.
::   WE: _a - obj_new() - interwał 1 - wynik działania exec('interval','#interval')
::       _b - obj_new() - interwał 2 - wynik działania exec('interval','#interval')
::   WY: obj_new('LEFT','RIGHT') gdzie LEFT i RIGHT to wynik działania exec('interval','#interval')
::       lub ~~ jeżeli przekazane interwały się nie przecinają
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_interval1:=_a;
_interval2:=_b;

_result:=~~;
::_result.LEFT:=exec('interval','#interval');
::_result.RIGHT:=exec('interval','#interval');

:: wykonuje tylko jesli interwaly sie przecinaja
{? exec('intervals_chk','#interval',_interval1,_interval2)>0
|| _result:=obj_new('LEFT','RIGHT');
   _intersection:=exec('intervals_and','#interval',_interval1,_interval2);
   _start1:=_interval1.START;
   _start2:=_interval2.START;
   _end1:=_interval1.END;
   _end2:=_interval2.END;

   _res_start1:=0;
   _res_start2:=0;
   _res_end1:=0;
   _res_end2:=0;

   _res1:=exec('interval','#interval');
   _res2:=exec('interval','#interval');

   {? _start2<_start1 &
         _end2<_end1 &
         _end2>=_start1
   ||
::                            |-------------------------------------------|
::                            |+++++++++++++++   interval1                |
::                            |-------------------------------------------|
::       |----------------------------------------|
::       |   interval2         +++++++++++++++    |
::       |----------------------------------------|
      _res_start1:=_interval2.START;
      _res_end1:=_intersection.START;
      _res1.START:=_res_start1;
      _res1.END:=_res_end1;

      _res_start2:=_intersection.END;
      _res_end2:=_interval1.END;
      _res2.START:=_res_start2;
      _res2.END:=_res_end2;

      _result.LEFT:=_res1;
      _result.RIGHT:=_res2;
      ~~
   |? _start2>=_start1 &
         _end2<=_end1
   ||
::          |-----------------------------------------------------------------------|
::          |            ++++++++++++++++++            interval1                    |
::          |-----------------------------------------------------------------------|
::                      |------------------|
::                      |+++interval2++++++|
::                      |------------------|
      _res_start1:=_interval1.START;
      _res_end1:=_intersection.START;
      _res1.START:=_res_start1;
      _res1.END:=_res_end1;

      _res_start2:=_intersection.END;
      _res_end2:=_interval1.END;
      _res2.START:=_res_start2;
      _res2.END:=_res_end2;

      _result.LEFT:=_res1;
      _result.RIGHT:=_res2;
      ~~
   |? _start1<_start2 &
         _end1<_end2 &
         _end1>=_start2
   ||
::       |------------------------------------|
::       | interval1           +++++++++++++++|
::       |------------------------------------|
::                            |-----------------------------------|
::                            |+++++++++++++++  interval2         |
::                            |-----------------------------------|
      _res_start1:=_interval1.START;
      _res_end1:=_intersection.START;
      _res1.START:=_res_start1;
      _res1.END:=_res_end1;

      _res_start2:=_intersection.END;
      _res_end2:=_interval2.END;
      _res2.START:=_res_start2;
      _res2.END:=_res_end2;

      _result.LEFT:=_res1;
      _result.RIGHT:=_res2;
      ~~
   |? _start1>=_start2 &
         _end1<=_end2
   ||
::                      |------------------|
::                      |+++interval1++++++|
::                      |------------------|
::          |-----------------------------------------------------------------------|
::          |            ++++++++++++++++++            interval2                    |
::          |-----------------------------------------------------------------------|
      _res_start1:=_interval2.START;
      _res_end1:=_intersection.START;
      _res1.START:=_res_start1;
      _res1.END:=_res_end1;

      _res_start2:=_intersection.END;
      _res_end2:=_interval2.END;
      _res2.START:=_res_start2;
      _res2.END:=_res_end2;

      _result.LEFT:=_res1;
      _result.RIGHT:=_res2;
      ~~
   ?}
?};
_result


\to_string2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Przekształca podany interwał czasowy na ludzką i czytelną formę STRINGową
::   WE: _a - obj_new - interwał
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_interval:=_a;
_date1:=exec('tm_stamp2date','#tm_stamp',_interval.START);
_date2:=exec('tm_stamp2date','#tm_stamp',_interval.END);

_result:='';
{? _date1=_date2
||
::  Interwał zaczyna i kończy się w tym samym dniu
   _time_end:=exec('tm_stamp2time','#tm_stamp',_interval.END);
   _result:=16+tm_form(_interval.START)+' - '+(_time_end$1)
||
   _duration:=_interval.END-_interval.START;
   _hours:=_duration/exec('hour','#tm_stamp');
   _time_start:=exec('tm_stamp2time','#tm_stamp',_interval.START);
   {? _time_start=time(0,0,0) & _hours=24
   ||
::    Interwał od północy do północy
      _result:=16+tm_form(_interval.START)+' - '+$_hours+':00'
   ||
::    Interwał przecina dwa dowolne dni
      _result:=(16+tm_form(_interval.START))+' - '+(16+tm_form(_interval.END))
   ?}
?};
_result


\equals
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Porównuje dwa interwały. Są równe tylko jeżeli zaczynają i kończą się w tym samym momencie
::   WE: _a - obj_new - interwał 1
::       _b - obj_new - interwał 2
::   WY: 0 - nie są równe
::       1 - są równe
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_interval1:=_a;
_interval2:=_b;

_result:=0;
{? _interval1.START=_interval2.START & _interval1.END=_interval2.END
|| _result:=1
?};
_result

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:09 325756ff775e3623aa72dccea00247d124d2874b73d2089d15cda3136fe250eae253bded7da2ef8a84e77d294af8014e6c9daeea491460ad513f329db179a5d0b472238de9db19a84cb378a2533bfeb805c263ea8dc9497031317dfd57408cca1d88bd07f75d49eee3c649aed18f66bf3379da4901a038a224f844b789ad1420
