:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b_port.fml
:: Utworzony: 18.12.2014 [17.00]
:: Autor: AWI
::======================================================================================================================
:: Zawartość: Formuły do obsługi tabeli B_PORT
::======================================================================================================================


\buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Zwraca obiekt nazwany - bufor tabeli B_PORT
::   WY: obj_new()
::----------------------------------------------------------------------------------------------------------------------
exec('B_PORT','#buffer')


\kind_in
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca symbol rodzaju portu - wejściowy
::   WY: STRING[3]
::----------------------------------------------------------------------------------------------------------------------
'IN'


\kind_internal
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca symbol rodzaju portu - wewnętrzny
::   WY: STRING[3]
::----------------------------------------------------------------------------------------------------------------------
'INT'


\kind_out
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca symbol rodzaju portu - wyjściowy
::   WY: STRING[3]
::----------------------------------------------------------------------------------------------------------------------
'OUT'


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Kasuje podany rekord tabeli B_PORT (wykonywane w transakcji!!!)
::   WE: _a - B_PORT.ref()
::      [_b] - INTEGER - [0]/1 - czy uswać B_PORT z jego wszystkimi B_POCONNami
::      [_c] - INTEGER - [0]/1 - czy uswać B_PORT z jego wszystkimi B_VALPRTami
::      [_d] - INTEGER - [0]/1/2 - czy uswać B_PORT z jego wszystkimi B_SIGPRTami
::   WY: >0 -wyczyszczone,
::      <=0 -niewyczyszczone
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;
_poconn:=0;
{? var_pres('_b')=type_of(0)
|| _poconn:=_b
?};
_valprt:=0;
{? var_pres('_c')=type_of(0)
|| _valprt:=_c
?};
_sigprt:=0;
{? var_pres('_d')=type_of(0)
|| _sigprt:=_d
?};

_result:=0;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
B_PORT.cntx_psh(); B_PORT.clear();
{? B_PORT.seek(_ref)
|| _can_poconn:=~_poconn;
   _can_valprt:=~_valprt;
   _can_sig:=0;
   {? _sigprt=0
   || _can_sig:=1
   |? _sigprt=2
   || _can_sig:=0
   ?};

   {? exec('can_delete','#b_port',_ref,_can_poconn,_can_valprt,_can_sig)>0
   || {? exec('clean','#b_port',_ref,_poconn,_valprt,_sigprt)>0
      ||
::       Sprawdzam czy rekord jeszcze istnieje, bo mógł zostać usunięty wewnątrz clean
         {? B_PORT.get()
         ||
            {? B_PORT.del(,1)>0
            || _result:=1
            || undo();
               _result:=-4
            ?}
         || _result:=1
         ?}
      || _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=0
?};
B_PORT.cntx_pop();
{? _result<0
|| undo()
?};

{? _mydo || end() ?};
_result


\can_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy można usunąć B_PORT, czyli czy ma powiązania z BI_PORT i B_POCONN
::   WE: _a - B_PORT.ref()
::       [_b] - INTEGER - 0/[1] - czy sprawdzać powiązania z B_POCONNami
::       [_c] - INTEGER - 0/[1] - czy sprawdzać powiązania z B_VALPRTami
::       [_d] - INTEGER - 0/[1] - czy sprawdzać powiązania z B_SIGPRTami
::----------------------------------------------------------------------------------------------------------------------
_b_port:=_a;

_poconn:=1;
{? var_pres('_b')=type_of(0)
|| _poconn:=_b
?};
_valprt:=1;
{? var_pres('_c')=type_of(0)
|| _valprt:=_c
?};
_sigprt:=1;
{? var_pres('_d')=type_of(0)
|| _sigprt:=_d
?};

_result:=1;
_can_continue:=1;

B_POCONN.cntx_psh();
BI_PORT.cntx_psh();
B_VALPRT.cntx_psh();
B_SIGPRT.cntx_psh();

:: Sprawdza instancje portów
{? _can_continue>0
|| _names:=BI_PORT.names();
   {? _names.first()
   || {!
      |? BI_PORT.use(_names.NAME);
         BI_PORT.index('PORT');
         BI_PORT.prefix(_b_port);
         {? BI_PORT.first()
         || _result:=0;
            _can_continue:=0
         ?};
         _can_continue>0 & _names.next()
      !}
   ?}
?};

:: Sprawdza powiązania portów z czynnościami
{? _poconn>0
||
   {? _can_continue>0
   || B_POCONN.index('FROM');
      B_POCONN.prefix(_b_port);
      {? B_POCONN.first()
      || _result:=0;
         _can_continue:=0
      ?}
   ?};
   {? _can_continue>0
   || B_POCONN.index('TO');
      B_POCONN.prefix(_b_port);
      {? B_POCONN.first()
      || _result:=0;
         _can_continue:=0
      ?}
   ?}
?};
{? _valprt>0
||
   {? _can_continue>0
   || B_VALPRT.index('S1');
      B_VALPRT.prefix(_b_port);
      {? B_VALPRT.first()
      || _result:=0;
         _can_continue:=0
      ?}
   ?}
?};

{? _sigprt>0 & _can_continue>0
|| B_SIGPRT.index('B_PORT');
   B_SIGPRT.prefix(_b_port);
   {? B_SIGPRT.first()
   || _result:=0;
      _can_continue:=0
   ?}
?};

B_SIGPRT.cntx_pop();
B_VALPRT.cntx_pop();
B_POCONN.cntx_pop();
BI_PORT.cntx_pop();
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
:: UTW: WH [17.00]
:: OPIS: Czyści powiązania do rekordu tabeli B_PORT
:: WE: _a - B_PORT.ref()
::     [_b] - INTEGER - [0]/1 - czy uswać też B_POCONNy
::     [_c] - INTEGER - [0]/1 - czy uswać też B_VALPRTy
::     [_d] - INTEGER - [0]/1/2 - czy uswać też B_SIGPRTy
:: WY: >0 -wyczyszczone,
:: <=0 -niewyczyszczone
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};

_ref:=_a;
_poconn:=0;
{? var_pres('_b')=type_of(0)
|| _poconn:=_b
?};
_valprt:=0;
{? var_pres('_c')=type_of(0)
|| _valprt:=_c
?};
_sigprt:=0;
{? var_pres('_d')=type_of(0)
|| _sigprt:=_d
?};

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---

:: Usunięcie warunków na bramach używających tego portu
B_CHOICE.cntx_psh();
B_CHOICE.index('B_PORT');
B_CHOICE.prefix(_ref);
{? B_CHOICE.first()
|| {!
   |? _can_continue:=exec('delete','#b_choice',B_CHOICE.ref());
      B_CHOICE.first() & _can_continue>0
   !}
?};
B_CHOICE.index('PREL_DST');
B_CHOICE.cntx_pop();

{? _poconn>0
|| B_POCONN.cntx_psh();
   {? _can_continue>0
   ||
      B_POCONN.index('FROM');
      B_POCONN.prefix(_ref);
      {? B_POCONN.first()
      || {!
         |? _can_continue:=exec('delete','#b_poconn',B_POCONN.ref());
            B_POCONN.first() & _can_continue>0
         !}
      ?}
   ?};
   {? _can_continue>0
   || B_POCONN.index('TO');
      B_POCONN.prefix(_ref);
      {? B_POCONN.first()
      || {!
         |? _can_continue:=exec('delete','#b_poconn',B_POCONN.ref());
            B_POCONN.first() & _can_continue>0
         !}
      ?}
   ?};
   B_POCONN.cntx_pop();
   ~~
?};
{? _valprt>0
|| {? _can_continue>0
   || B_VALPRT.cntx_psh();
      B_VALPRT.index('S1');
      B_VALPRT.prefix(_ref);
      {? B_VALPRT.first()
      || {!
         |? _can_continue:=exec('delete','#b_valprt',B_VALPRT.ref());
            B_VALPRT.first() & _can_continue>0
         !}
      ?};
      B_VALPRT.cntx_pop()
   ?}
?};

{? _can_continue>0
||
   {? _sigprt=1
   || B_SIGPRT.index('B_PORT');
      B_SIGPRT.prefix(_ref);
      {? B_SIGPRT.first()
      || {!
         |? _can_continue:=exec('delete','#b_sigprt',B_SIGPRT.ref());
            B_SIGPRT.first() & _can_continue>0
         !}
      ?}
   |? _sigprt=2
   ||
      B_SIGPRT.index('B_PORT');
      B_SIGPRT.prefix(_ref);
      {? B_SIGPRT.first()
      || {!
         |? _next:=0;
            _ref_nxt:=null();
            B_SIGPRT.cntx_psh();
            {? B_SIGPRT.next()
            || _ref_nxt:=B_SIGPRT.ref()
            ?};
            B_SIGPRT.cntx_pop();

            B_SIGPRT.cntx_psh();
            B_SIGPRT.prefix();
            B_SIGPRT.B_PORT:=null();
            _can_continue:=B_SIGPRT.put();
            B_SIGPRT.cntx_pop();

            {? _ref_nxt<>null()
            || _next:=B_SIGPRT.seek(_ref_nxt)
            ?};
            _next>0 & _can_continue>0
         !}
      ?}
   ?}
?};

:: --- wszystkie powiązania usunięte? ---
{? _can_continue>0
|| _result:=1
|| undo()
?};
{? _mydo || end() ?};

_result


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Funkcja dodająca wpis do tabeli B_PORT
::   WE: _a - obj_new - tablica nazwana będąca buforem tabeli exec('buffer','#b_port')
::   WY:      [REFERENCE]  - wskazanie na dodany rekord (lub już istniejący)
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100 || _a || return(null) ?};
_res:=null();

{? var_pres('B_ACTELE',_buffer)<>type_of(null()) || _buffer.B_ACTELE:=null() ?};

B_PORT.cntx_psh();
B_PORT.index('UNIK');
B_PORT.prefix(_buffer.B_ELE,_buffer.B_PREL,_buffer.B_ACTELE,_buffer.KIND,_buffer.SYMBOL);
{? B_PORT.first()
|| _res:=B_PORT.ref()
|| B_PORT.blank(1);
   _buffer.set();
   {? B_PORT.add()
   || _res:=B_PORT.ref()
   ?}
?};
B_PORT.cntx_pop();
_res


\put
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Funkcja poprawiająca wpis do tabeli B_PORT
::   WE: _a - obj_new - tablica nazwana będąca buforem tabeli exec('buffer','#b_port')
::   WY:      [REFERENCE]  - wskazanie na dodany rekord (lub już istniejący)
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100 || _a || return(null) ?};
_res:=null();

B_PORT.cntx_psh();
B_PORT.index('UNIK');
B_PORT.prefix(_buffer.B_ELE,null(),null(),_buffer.KIND,_buffer.SYMBOL);
{? B_PORT.first()
|| _buffer.set();
   {? B_PORT.put()
   || _res:=B_PORT.ref()
   ?}
?};
B_PORT.cntx_pop();
_res


\getPorts
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Tworzy tablicę nazwaną portów wejścia/wyjścia dla wskazanego elementu
::   WE: _a - [REFERENCE] - wskazanie na element
::       _b - [STRING]    - rodzaj danych ('IN' - wejściowy, 'INT' - wewnętrzny, 'OUT' - wyjściowy)
::       _c - [REFERENCE] - element procesu
::   WY: tablica nazwana z portami wejściowymi/wyjściowymi danego elementu lub ~~ w przypadku ich braku
::----------------------------------------------------------------------------------------------------------------------
 _b_ele:={? var_pres('_a')=type_of(null) || _a || return(~~) ?};
_rodzaj:={? var_pres('_b')=type_of('')   || _b || return(~~) ?};
_b_prel:={? var_pres('_c')=type_of(null) || _c || return(~~) ?};

{? _rodzaj<>'IN' &
   _rodzaj<>'INT' &
   _rodzaj<>'OUT'
|| return(~~)
?};
_ports:=~~;
B_PORT.cntx_psh();
B_PORT.index('B_ELE');
B_PORT.prefix('T',_b_ele,_rodzaj,);

_we_fml:='';
{? B_PORT.first()
|| {!
   |? {? +B_PORT.SYMBOL & B_PORT.ACTIVE='T'
      || {? _we_fml<>'' || _we_fml+="','" ?};
         _we_fml+=B_PORT.SYMBOL
      ?};
      B_PORT.next()
   !}
?};

:: Pobranie portów wejściowych dodanych ręcznie w definicji procesu
B_PORT.index('UNIK');
B_PORT.prefix(null(),_b_prel,null(),_rodzaj,);

{? B_PORT.first()
|| {!
   |? {? +B_PORT.SYMBOL & B_PORT.ACTIVE='T'
      || {? _we_fml<>'' || _we_fml+="','" ?};
         _we_fml+=B_PORT.SYMBOL
      ?};
      B_PORT.next()
   !}
?};
B_PORT.cntx_pop();

{? _we_fml<>''
|| _we_fml:='obj_new(\''+_we_fml+'\')';
   _ports:=($_we_fml)()
?};
_ports


\import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Importuje/aktualizuje definicje portów dla wszystkich czynności
::   WE: [_a] - czy wyswietlać raport (domyślnie - 1), czy tylko zwrócić wynik działania (0)
::       [_b] - B_DOMAIN.ref - obszar którego czynności aktualizować, jeśli nie podane to wszystkie obszary
::       [_c] - tab_tmp - tabelka tymczasowa do optymalizacji zawierająca akronimy tabel i info czy jest tam pole IDADD
::                        wynik działania exec('tab_optimize_idadd','#b_action')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _display:=_a || _display:=1 ?};

_b_domain:=null();
{? var_pres('_b')=type_of(B_DOMAIN.ref())
|| _b_domain:=_b
?};

{? var_pres('_c')>100
|| _tab_optimize:=_c
|| _tab_optimize:=exec('tab_optimize_idadd','#b_action')
?};

_B_PROC:=tab_tmp(1,'REF','STRING[16]','$B_PROC.ref()');

Cntx.psh(B_ACTION,B_ELE,B_TYPE,B_PORT);
_exit:="Cntx.pop(B_ACTION,B_ELE,B_TYPE,B_PORT)";

{? _display>0 || KOMM.init(255,,'Importowanie parametrów czynności') ?};

{? _b_domain=null()
||
   B_DOMAIN.index('SYMBOL');
   B_DOMAIN.prefix();
   {? B_DOMAIN.first()
   ||
::    iteracja po obszarach
      {!
      |?
::       iteracja po czynnościach
         B_ACTION.index('PROC3');
         B_ACTION.prefix('T','T',B_DOMAIN.ref());
         {? B_ACTION.first()
         || {!
            |? _fun_g:='main';
               _plik:=exec('filename','#b_action');
               exec('imp4act','#b_port',_fun_g,_plik,,_tab_optimize);
:: aktualizacja powiązań portów do czynności startowej
               B_PREL.cntx_psh();
               B_PREL.index('ELSTART');
               B_PREL.prefix(B_ACTION.B_ELE);
               {? B_PREL.first()
               ||
                  {!
                  |?
                     {? B_PREL.STARTACT='T' & ~_B_PROC.find_key($B_PREL.B_PROC)
                     ||
                        _B_PROC.REF:=$B_PREL.B_PROC; _B_PROC.add()
                     ?};
                     B_PREL.next()
                  !}
               ?};
               B_PREL.cntx_pop();
               B_ACTION.next()
            !}
         ?};
         B_DOMAIN.next()
      !}
   ?}
||
:: iteracja po czynnościach
   B_ACTION.index('PROC3');
   B_ACTION.prefix('T','T',_b_domain);
   {? B_ACTION.first()
   || {!
      |? _fun_g:='main';
         _plik:=exec('filename','#b_action');
         exec('imp4act','#b_port',_fun_g,_plik);
:: aktualizacja powiązań portów do czynności startowej
         B_PREL.cntx_psh();
         B_PREL.index('ELSTART');
         B_PREL.prefix(B_ACTION.B_ELE);
         {? B_PREL.first()
         ||
            {!
            |?
               {? B_PREL.STARTACT='T' & ~_B_PROC.find_key($B_PREL.B_PROC)
               ||
                  _B_PROC.REF:=$B_PREL.B_PROC; _B_PROC.add()
               ?};
               B_PREL.next()
            !}
         ?};
         B_PREL.cntx_pop();
         B_ACTION.next()
      !}
   ?}
?};
:: aktualizacja powiązań portów do czynności startowej
:: - obecnie powoduje błędy dlatego wyłączona - do przemyślenia w przyszłości
_loop:=0& _B_PROC.first();
{!
|? _loop
|!
   _b_proc:=exec('FindAndGet','#table',B_PROC,_B_PROC.REF,,,null());
   exec('port4event','#b_actsta',_b_proc,'remove');
   exec('port4event','#b_actsta',_b_proc,'create','N');
   exec('route_delete4bproc','#b_proute',_b_proc);
   exec('route_create4bproc','#b_proute',1,_b_proc);
   _loop:=_B_PROC.next()
!};
{? _display>0
||
:: Raportuje błędy i uwagi, o ile są
   {? ~KOMM.empty()
   || KOMM.select()
   ?}
?};
:: gotowe
_exit();
~~


\parse
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyłuskuje pola definicji portu z podanego wiersza
::   WE: _a - wiersz z definicją
::   WY: obiekt z definicją
::----------------------------------------------------------------------------------------------------------------------
_wiersz:=_a;

_res:=obj_new('TYPE','KIND','SYMBOL','NAME','REQUIRED','FML_VAL','FML_EXP','KEYREF','GRPKEY');

_formula:="
:: tekst jest w cudzysłowach, szukam kończącego (wewnątrz mogą wystąpić "" lub \")
   _pos:=_a*(_b+'=\"');
   {? _pos<>0
   || _txt:=(_pos+(+_b)+1)-_a;
      _txt:=gsub(_txt,'\"\"','__quotation__');
      _txt:=gsub(_txt,'\\\\\"','__quotation__');
      _pos:=_txt*'\"';
      {? _pos<>0 || _txt:=(_pos-1)+_txt ?};
      _txt:=gsub(_txt,'__quotation__','\"');
      _txt
:: tekst jest bez cudzysłowów, szukam przecinka
   || _pos:=_a*(_b+'=');
      {? _pos=0
      || ''
      || _txt:=(_pos+(+_b))-_a;
         _pos:=_txt*',';
         {? _pos<>0 || _txt:=(_pos-1)+_txt ?};
         _txt
      ?}
   ?}
";

_res.TYPE:=_formula(_wiersz,'type');
_res.KIND:=_formula(_wiersz,'kind'); {? _res.KIND='' || _res.KIND:='WE' ?};
_res.SYMBOL:=_formula(_wiersz,'symbol');
_res.NAME:=_formula(_wiersz,'name');
_res.REQUIRED:=_formula(_wiersz,'required');
_res.FML_VAL:=_formula(_wiersz,'fml_val');
_res.FML_EXP:=_formula(_wiersz,'fml_exp');
_res.KEYREF:=_formula(_wiersz,'keyref');  {? _res.KEYREF='' || _res.KEYREF:='N' ?};
_res.GRPKEY:=_formula(_wiersz,'grpkey');  {? _res.GRPKEY='' || _res.GRPKEY:='N' ?};

_res


\kind_typeports
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: [rr] [17.00]
:: OPIS: Zwraca symbole rodzajów portów
::   WY: lista oddzielona średnikami
::----------------------------------------------------------------------------------------------------------------------
'IN;INT;OUT;'


\kind_opis
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca opisy dla parametru wejściowego
::   WE: _a - rodzaj parametru
::   WY: .Mianownik, .Dopelniacz, .MnogiMianownik
::----------------------------------------------------------------------------------------------------------------------
_kind:=_a;

{? _kind=exec('kind_in','#b_port')
|| _res:=exec('opis_in','#b_port')
|? _kind=exec('kind_internal','#b_port')
|| _res:=exec('opis_internal','#b_port')
|? _kind=exec('kind_out','#b_port')
|| _res:=exec('opis_out','#b_port')
|| ''
?}


\opis_in
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca opisy dla parametru wejściowego
::   WY: .Mianownik, .Dopelniacz, .MnogiMianownik
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new('M','D','MM');
_res.M:='wejściowy';
_res.D:='wejściowego';
_res.MM:='wejściowe';
_res


\opis_internal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca opisy dla parametru wewnętrznego
::   WY: .Mianownik, .Dopelniacz, .MnogiMianownik
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new('M','D','MM');
_res.M:='wewnętrzny';
_res.D:='wewnętrznego';
_res.MM:='wewnętrzne';
_res


\opis_out
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca opisy dla parametru wyjściowego
::   WY: .Mianownik, .Dopelniacz, .MnogiMianownik
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new('M','D','MM');
_res.M:='wyjściowy';
_res.D:='wyjściowego';
_res.MM:='wyjściowe';
_res


\ports
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca tabelę tymczasową portów na podstawie pliku z komentarzami formuły głównej
::   WE: _a - nazwa pliku formuły
::       _b - nazwa funkcji głównej
::----------------------------------------------------------------------------------------------------------------------
_plik:=_a;
_fun_g:=_b;

_B_PORT:=tab_tmp(2,
   'KIND','STRING[3]','Rodzaj',
   'SYMBOL','STRING[32]','Symbol',
   'TYPE','STRING[100]','Typ',
   'NAME','STRING[251]','Nazwa',
   'REQUIRED','STRING[1]','Wymagany',
   'FML_VAL','STRING[251]','Formuła dla wartości podawanej ręcznie',
   'FML_EXP','STRING[251]','Formuła eksportowa dla wartości ręcznej',
   'KEYREF','STRING[1]','Rekord kluczowy',
   'GRPKEY','STRING[1]','Klucz grupujący'
);

:: obiekt plikowy z zawartością treści komentarzy do formuły
_fun_str:=exec('string_fun','#file',_plik,_fun_g,'::# kind=',,'^','::#');
_split:=spli_str(_fun_str,'\n');

{? obj_len(_split)>0
||
   {! _it:=1..obj_len(_split)
   |!
      _wiersz:=_split[_it];
      {? _wiersz<>'\n' & _wiersz<>''
      || _wiersz:='kind='+_wiersz;
         _b_port:=exec('parse','#b_port',_wiersz);
::       symbol ma same wielkie litery
         _b_port.SYMBOL:=~-_b_port.SYMBOL;
::       rodzaj portu
         _kind:=_b_port.KIND;
         {? _kind='WE'  || _B_PORT.KIND:=exec('kind_in','#b_port')
         |? _kind='WEW' || _B_PORT.KIND:=exec('kind_internal','#b_port')
         |? _kind='WY'  || _B_PORT.KIND:=exec('kind_out','#b_port')
         ?};
         _B_PORT.SYMBOL:=_b_port.SYMBOL;
         _B_PORT.TYPE:=_b_port.TYPE;
         _B_PORT.NAME:=_b_port.NAME;
         _B_PORT.REQUIRED:=_b_port.REQUIRED;
         _B_PORT.FML_VAL:=_b_port.FML_VAL;
         _B_PORT.FML_EXP:=_b_port.FML_EXP;
         _B_PORT.KEYREF:=_b_port.KEYREF;
         _B_PORT.GRPKEY:=_b_port.GRPKEY;
         _B_PORT.add();

         obj_del(_b_port)
      ?}
   !}
?};
_B_PORT.clear();
_B_PORT


\has_poconns_we
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy podany port ma jakieś połączenia wchodzące do niego w podanym elemencie procesu
::   WE: _a - B_PORT.ref()
::       _b - B_PREL.ref()
::   WY: 0 - brak wejściowych powiązań
::       1 - istnieją wejściowe powiązania do tego portu
::----------------------------------------------------------------------------------------------------------------------
_b_port:=_a;
_b_prel:=_b;

_result:=0;

B_PREL.cntx_psh(); B_PREL.clear();
B_PORT.cntx_psh(); B_PORT.clear();
B_POCONN.cntx_psh();
B_POCONN.index('TO');
{? B_PORT.seek(_b_port) & B_PREL.seek(_b_prel)
|| B_POCONN.prefix(_b_port,B_PREL.B_PROC,B_PREL.ref());
   {? B_POCONN.size()>0
   || _result:=1
   ?}
?};
B_POCONN.cntx_pop();
B_PORT.cntx_pop();
B_PREL.cntx_pop();
_result


\files
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.00]
:: OPIS: Zwraca tablicę do obsługi plików z głównymi formułami czynności
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,
   'PLIK','STRING[255]','Plik'@,
   'FORMULA','STRING[15]','Formuła'@
);
_files:=files('!*.fml');
{? _files.first()
|| {!
   |? {? _files.FILENAME<>'!call.fml'
      || {? _fd:=fopen(_files.FILENAME,'ur',1)
         || {!
            |? {? (_line:=fread(_fd))<>'\n'
               || {? 1+_line='\\'
                  || _tab.PLIK:=_files.FILENAME;
                     _tab.FORMULA:=1-_line
                  ?};
                  {? 3+_line='::#' & _tab.PLIK<>''
                  || _tab.add();
                     _tab.PLIK:=''
                  ?};
                  1
               ?}
            !};
            fclose(_fd)
         ?}
      ?};
      _files.next()
   !}
?};
_o:=_tab.mk_sel('Główna formuła czynności'@);
_tab.win_fld(_o,,'PLIK',,,30);
_tab.win_fld(_o,,'FORMULA',,,15);
_tab.win_act(_o,,'Formuła','Wybierz'@@,,,"sel_exit()",,1,,,,'W');
_tab.win_sel(_o);
_env:=obj_new('TAB','plik');
_env.TAB:=_tab;
_env.plik:="
   _plik:=obj_new('PLIK','FORMULA');
   _plik.PLIK:='';
   _plik.FORMULA:='';
   {? .TAB.select()
   || _plik.PLIK:=.TAB.PLIK;
      _plik.FORMULA:=.TAB.FORMULA
   ?};
   _plik
";
_env


\imp4act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Importuje/aktualizuje definicję portów dla czynności
::   WE:  _a  - formuła główna
::        _b  - plik
::       [_c] - wskazanie na czynność, wpp bieżąca czynność
::       [_d] - tab_tmp - tabelka tymczasowa do optymalizacji zawierająca akronimy tabel i info czy jest tam pole IDADD
::                        wynik działania exec('tab_optimize_idadd','#b_action')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_c')>0
|| B_ACTION.cntx_psh();
   B_ACTION.prefix();
   {? ~B_ACTION.seek(_c)
   || B_ACTION.cntx_pop();
      return()
   ?}
?};

{? var_pres('_d')>100
|| _tab_optimize:=_d
|| _tab_optimize:=exec('tab_optimize_idadd','#b_action')
?};

:: tabela robocza portów
{? var_pres('_B_PORT')<0
|| _B_PORT:=tab_tmp(2,
      'KIND','STRING[3]','Rodzaj',
      'SYMBOL','STRING[31]','Symbol',
      'NAME','STRING[250]','Nazwa',
      'TYPE','STRING[100]','Typ danych',
      'REQUIRED','STRING[1]','Wymagany',
      'FML_VAL','STRING[250]','Formuła dla wartości podawanej ręcznie',
      'FML_EXP','STRING[251]','Formuła eksportowa dla wartości ręcznej',
      'KEYREF','STRING[1]','Rekord kluczowy',
      'GRPKEY','STRING[1]','Klucz grupujący'
   )
?};
:: zidentyfikuj element
_b_ele:=B_ACTION.B_ELE;

_sect:='Czynność: '+B_ACTION.UID+' — '+B_ACTION.NAME;

_txt:='';
_error:=0; _remark:=0;
{? _b=''
|| _txt:='Nie znaleziono pliku z formułą główną %1 czynności.'@[_a];
   {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
   KOMM.add(_txt,'xwin16.png:81');
   KOMM.sect_end();
   _error:=1
|? ~exec('is_fun','#file',_b,_a)
|| _txt:='Brak funkcji %1 w pliku %2.fml'@[_a,_b];
   {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
   KOMM.add(_txt,'xwin16.png:81');
   KOMM.sect_end();
   _error:=1
||
:: czyszczenie tabeli roboczej
   _B_PORT.clear();
   _B_PORT.erase();

:: znajdź definicje portów w komentarzach formuły, pętla po definicjach
   _b_port:=exec('ports','#b_port',_b,_a);

:: Jeśli czynność ma właściwość typu LOOP to automatycznie dodaję argumenty
:: - wejściowy GRPKEY
:: - wejściowy GGRPKEY
:: - wyjściowy GRPKEY
:: - wyjściowy GGRPKEY
:: - wyjściowy LOOP który ułatwi konstruowanie warunku na bramie
   {? B_ACTION.LOOP='T'
   || _b_port.blank();
      _b_port.KIND:='OUT';
      _b_port.TYPE:='STRING';
      _b_port.REQUIRED:='N';
      _b_port.FML_VAL:='';
      _b_port.KEYREF:='N';
      _b_port.SYMBOL:='LOOP';
      _b_port.NAME:='Czy robić zapętlenie?';
      _b_port.add();
      _b_port.KIND:='IN';
      _b_port.SYMBOL:='GGRPKEY';
      _b_port.NAME:='Klucz grupujący';
      _b_port.GRPKEY:='T';
      _b_port.add();
      _b_port.KIND:='IN';
      _b_port.SYMBOL:='GRPKEY';
      _b_port.NAME:='Klucz grupujący';
      _b_port.add();
      _b_port.KIND:='OUT';
      _b_port.SYMBOL:='GGRPKEY';
      _b_port.NAME:='Klucz grupujący';
      _b_port.add();
      _b_port.KIND:='OUT';
      _b_port.SYMBOL:='GRPKEY';
      _b_port.NAME:='Klucz grupujący';
      _b_port.add()
   ?};

:: Jeśli czynność ma właściwość typu SEND to automatycznie dodaję argumenty wejściowe,
:: ale jeśli są to specjalizowane czynności do wysyłania SMS i NTC, to parametry ustawiane są w tych czynnościach.
   {? B_ACTION.SEND='T' & B_ACTION.UID<>'ZWS_SMS_SEND' & B_ACTION.UID<>'ZWS_NTC_SEND'
   || _b_port.blank();
      _b_port.KIND:='IN';
      _b_port.TYPE:='STRING';
      _b_port.REQUIRED:='N';
      _b_port.FML_VAL:='exec(\'edit_email\',\'#mailbox\',_a,_b)';
      _b_port.KEYREF:='N';
      _b_port.SYMBOL:='SENDER';
      _b_port.NAME:='Nadawca';
      _b_port.add();
      _b_port.SYMBOL:='FROM';
      _b_port.NAME:='Autor';
      _b_port.add();
      _b_port.SYMBOL:='REPLYTO';
      _b_port.NAME:='Odpowiedz do';
      _b_port.add();
      _b_port.FML_VAL:='exec(\'template_param\',\'#mailbox\',_a,_b)';
      _b_port.SYMBOL:='TEMPLATE';
      _b_port.NAME:='Wzorzec wiadomości';
      _b_port.add()
   ?};

   {? _b_port.first()
   ||
      {!
      |?
::       sprawdź powtórzenia
         _B_PORT.prefix(_b_port.KIND,_b_port.SYMBOL,);
         {? _B_PORT.first()
         || _txt:='Powtórzona definicja parametru '
                  '%1: %2 (%3/%4.fml)'@[exec('kind_opis','#b_port',_b_port.KIND).D,(50+_b_port.SYMBOL),_a,_b];
            {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
            KOMM.add(_txt,'xwin16.png:15');
            KOMM.sect_end();
            _remark:=1
         ||
::          błędy
            {? +_b_port.SYMBOL>31
            || _txt:='Za długi symbol parametru '
                     '%1: %2 (%3/%4.fml)'@[exec('kind_opis','#b_port',_b_port.KIND).D,(50+_b_port.SYMBOL),_a,_b];
               {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
               KOMM.add(_txt,'xwin16.png:81');
               KOMM.sect_end();
               _error:=1
            |? ~exec('valid_acronim','#string',31+_b_port.SYMBOL)
            || _txt:='Niedozwolone znaki w symbolu parametru '
                     '%1: %2 (%3/%4.fml)'@[exec('kind_opis','#b_port',_b_port.KIND).D,(50+_b_port.SYMBOL),_a,_b];
               {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
               KOMM.add(_txt,'xwin16.png:81');
               KOMM.sect_end();
               _error:=1
            |? +_b_port.FML_VAL>250
            || _txt:='Za długa formuła dla wartości podawanej ręcznie dla parametru '
                     '%1: %2 (%3/%4.fml)'@[exec('kind_opis','#b_port',_b_port.KIND).D,(50+_b_port.SYMBOL),_a,_b];
               {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
               KOMM.add(_txt,'xwin16.png:81');
               KOMM.sect_end();
               _error:=1
            |? ~exec('valid_formula','#field',_b_port.FML_VAL,0)
            || _txt:='Błąd składniowy w formule dla wartości podawanej ręcznie dla parametru '
                     '%1: %2 (%3/%4.fml)'@[exec('kind_opis','#b_port',_b_port.KIND).D,(50+_b_port.SYMBOL),_a,_b];
               {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
               KOMM.add(_txt,'xwin16.png:81');
               KOMM.sect_end();
               _error:=1
            ||
::             tylko uwagi
               {? +_b_port.NAME>250
               || _txt:='Za długa nazwa parametru '
                        '%1: %2 (%3/%4.fml)'@[exec('kind_opis','#b_port',_b_port.KIND).D,(50+_b_port.SYMBOL),_a,_b];
                  {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
                  KOMM.add(_txt,'xwin16.png:15');
                  KOMM.sect_end();
                  _remark:=1
               ?};

               _B_PORT.KIND:=_b_port.KIND;
               _B_PORT.SYMBOL:=_b_port.SYMBOL;
               _B_PORT.NAME:=_b_port.NAME;
               _B_PORT.TYPE:=_b_port.TYPE;
               _B_PORT.REQUIRED:=_b_port.REQUIRED;
               _B_PORT.FML_VAL:=_b_port.FML_VAL;
               _B_PORT.FML_EXP:=_b_port.FML_EXP;
               _B_PORT.KEYREF:=_b_port.KEYREF;
               _B_PORT.GRPKEY:=_b_port.GRPKEY;
               _B_PORT.add()
            ?}
         ?};
         _b_port.next()
      !}
   ?};
   obj_del(_b_port)
?};
_B_PORT.clear();
{? _B_PORT.first()
|| {!
   |?
::    zidentyfikuj typ danych
      B_TYPE.index('SYMBOL');
      B_TYPE.prefix(_B_PORT.TYPE,);
      {? B_TYPE.first() || _b_type:=B_TYPE.ref() || _b_type:=null() ?};

::    walidacja
      {? _B_PORT.SYMBOL=''
      || _txt:='Podano pusty symbol parametru '
               '(%1/%2.fml).'@[_a,_b];
         {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add(_txt,'xwin16.png:81');
         KOMM.sect_end();
         _error:=1
      |? _B_PORT.NAME=''
      || _txt:='Podano pustą nazwę parametru '
               '%1 (%2/%3.fml).'@[_B_PORT.SYMBOL,_a,_b];
         {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add(_txt,'xwin16.png:81');
         KOMM.sect_end();
         _error:=1
      |? _B_PORT.KIND<>exec('kind_in','#b_port') &
         _B_PORT.KIND<>exec('kind_internal','#b_port') &
         _B_PORT.KIND<>exec('kind_out','#b_port')
      || _txt:='Błędny rodzaj parametru '
               '%1: %2 (%3/%4.fml).'@[_B_PORT.SYMBOL,_B_PORT.KIND,_a,_b];
         {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add(_txt,'xwin16.png:81');
         KOMM.sect_end();
         _error:=1
      |? _B_PORT.REQUIRED<>'T' & _B_PORT.REQUIRED<>'N'
      || _txt:='Błędne określenie wymagalności parametru '
               '%1: %2 (%3/%4.fml).'@[_B_PORT.SYMBOL,_B_PORT.REQUIRED,_a,_b];
         {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add(_txt,'xwin16.png:81');
         KOMM.sect_end();
         _error:=1
      |? _B_PORT.KEYREF<>'T' & _B_PORT.KEYREF<>'N'
      || _txt:='Błędne określenie powoływania rekordu kluczowego '
               '%1: %2 (%3/%4.fml).'@[_B_PORT.SYMBOL,_B_PORT.KEYREF,_a,_b];
         {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add(_txt,'xwin16.png:81');
         KOMM.sect_end();
         _error:=1
      |? _b_type=null()
      || _txt:='Dla parametru: %1 nie znaleziono typu: %2 (%3/%4.fml).'@[_B_PORT.SYMBOL,_B_PORT.TYPE,_a,_b];
         {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add(_txt,'xwin16.png:81');
         KOMM.sect_end();
         _error:=1
      ||
::       dodaj/aktualizuj porty do czynności
         B_PORT.index('UNIK');
         B_PORT.prefix(_b_ele,null(),null(),_B_PORT.KIND,_B_PORT.SYMBOL,);
         {? B_PORT.first()
         ||
::          jeżeli port był, to aktualizuję
::          nie sprawdzam zmiany typu, do tego służy formuła walidująca calość
::          zawsze aktywuję
            {? exec('lock','#b_port',B_PORT.ref(),0)>0
            || B_PORT.B_TYPE:=_b_type;
               B_PORT.NAME:=_B_PORT.NAME;
               B_PORT.REQUIRED:={? _B_PORT.KIND='OUT' || 'N' || _B_PORT.REQUIRED ?};
               B_PORT.ACTIVE:='T';
               B_PORT.FML_VAL:=_B_PORT.FML_VAL;
               B_PORT.FML_EXP:=_B_PORT.FML_EXP;
               B_PORT.KEYREF:=_B_PORT.KEYREF;
               B_PORT.GRPKEY:=_B_PORT.GRPKEY;
               B_PORT.put();
               exec('unlock','#b_port',B_PORT.ref())
            || _txt:='Nie udało się zmodyfikować parametru %1: '
                     '%2 (%3/%4.fml) — zablokowany przez innego operatora.'@[exec('kind_opis','#b_port',B_PORT.KIND).D,B_PORT.SYMBOL,_a,_b];
               {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
               KOMM.add(_txt,'xwin16.png:81');
               KOMM.sect_end();
               _error:=1
            ?}
         ||
::          jeżeli portu nie było, to dodaję aktywny
            B_PORT.blank(1);
            B_PORT.B_ELE:=_b_ele;
            B_PORT.B_TYPE:=_b_type;
            B_PORT.KIND:=_B_PORT.KIND;
            B_PORT.SYMBOL:=_B_PORT.SYMBOL;
            B_PORT.NAME:=_B_PORT.NAME;
            B_PORT.REQUIRED:={? _B_PORT.KIND='OUT' || 'N' || _B_PORT.REQUIRED ?};
            B_PORT.ACTIVE:='T';
            B_PORT.FML_VAL:=_B_PORT.FML_VAL;
            B_PORT.FML_EXP:=_B_PORT.FML_EXP;
            B_PORT.KEYREF:=_B_PORT.KEYREF;
            B_PORT.GRPKEY:=_B_PORT.GRPKEY;
            B_PORT.C_EVENT:='N';
            B_PORT.add()
         ?}
      ?};
      _B_PORT.next()
   !}
?};
B_PORT.index('UNIK');
B_PORT.prefix(_b_ele,null(),null());
{? B_PORT.first()
|| _can_continue:=1;
   {!
   |? _next:=0;
      _ref_nxt:=null();
      B_PORT.cntx_psh();
      {? B_PORT.next()
      || _ref_nxt:=B_PORT.ref()
      ?};
      B_PORT.cntx_pop();

::    jezeli port był a teraz go nie ma... usunąć (o ile się uda), albo ostrzeżenie do KOMMa
      _deleted:=0;
      _B_PORT.prefix(B_PORT.KIND,B_PORT.SYMBOL,);
      {? ~_B_PORT.first()
      || _port_ref:=B_PORT.ref();
         {? exec('lock','#b_port',B_PORT.ref(),0)>0
         ||
            _del:=exec('delete','#b_port',B_PORT.ref());
            {? _del<=0
            ||
::             jeżeli nie udało się usunąć, to oznaczam jako nieaktywny
               B_PORT.ACTIVE:='N';
               B_PORT.put();
               _txt:='Nie udało się usunąć parametru %1: '
                     '%2 (%3/%4.fml) — wykorzystany w systemie.'@[exec('kind_opis','#b_port',B_PORT.KIND).D,B_PORT.SYMBOL,_a,_b];
               {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
               KOMM.add(_txt,'xwin16.png:15');
               KOMM.sect_end();
               _remark:=1
            || _deleted:=1
            ?};
            exec('unlock','#b_port',_port_ref)
         ||
            _txt:='Nie udało się usunąć parametru %1: '
                  '%2 (%3/%4.fml) — zablokowany przez innego operatora.'@[exec('kind_opis','#b_port',B_PORT.KIND).D,B_PORT.SYMBOL,_a,_b];
            {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
            KOMM.add(_txt,'xwin16.png:81');
            KOMM.sect_end();
            _error:=1
         ?}
      ?};

      {? _ref_nxt<>null()
      || _next:=B_PORT.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};

:: Sprawdzam czy tabele złączeniowe w portach mają pola typu IDADD
{? exec('valid_idadd','#b_action',,,,_tab_optimize)=0
|| _error:=1
?};

:: Jak coś nie tak, to informacja o problemie umieszczona w czynności
{? _error
|| B_ACTION.PROBLEM:='T';
   B_ACTION.put()
?};
KOMM.sect_end();
{? var_pres('_c')>0
|| B_ACTION.cntx_pop()
?}


\imp_port_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.00]
:: OPIS: Akcja importu portów dla czynności
::       Kontekst wywołania - bieżąca czynność
::----------------------------------------------------------------------------------------------------------------------
{? B_ACTION.MANUAL='T'
|| FUN.info('Czynność ręczna — nie można importować parametrów.'@)
|? FUN.ask('Czy zaimportować parametry czynności %1?'@[B_ACTION.UID])
|| KOMM.init(255,,'Importowanie parametrów czynności');
   _fun_g:='main';
   _plik:=exec('filename','#b_action');
   {? ~exec('is_fun','#file',_plik,_fun_g)
   || _FILES:=exec('files','#b_port');
      _fn:=_FILES.plik();
      {? _fn.PLIK<>''
      || _plik:=_fn.PLIK;
         _fun_g:=_fn.FORMULA
      ?}
   ?};
   exec('imp4act','#b_port',_fun_g,_plik);
   {? ~KOMM.empty()
   || KOMM.select()
   ?}
?}


\has_manual_val
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy port dla danego elementu procesu ma podaną wartość w definicji procesu
::   WE: _a - B_PREL.ref - element procesu
::       [_b] - B_PORT.ref lub bieżący rekord
::   WY: 0 - brak wartości zdefiniowanej ręcznie
::       1 - istnieje wartość dla portu w definicji procesu
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;

_ref:=null();
{? var_pres('_b')=type_of(SYSLOG.ref())
|| _ref:=_b
?};

_result:=0;
_can_continue:=1;

B_PORT.cntx_psh();
{? _ref<>null()
|| B_PORT.clear();
   {? B_PORT.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   B_VALPRT.cntx_psh();
   B_VALPRT.index('UNIK');
   B_VALPRT.prefix(_b_prel,B_PORT.ref());
   {? B_VALPRT.size()>0
   || _result:=1
   ?};
   B_VALPRT.cntx_pop();
   ~~
?};
B_PORT.cntx_pop();
_result


\add_port2prel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Dodanie portu wejściowego odpowiadającego portowi wyjściowemu
::   WE: _a - B_PORT.ref() - port źródłowy
::       _b - B_PREL.ref() - element docelowy
::   WY: null - jeśli brak połączenia
::       B_PORT.ref() - jeśli jest połączenie
::----------------------------------------------------------------------------------------------------------------------
_port_src:=_a;
_prel_dst:=_b;

_port_dst:=null();

B_PORT.cntx_psh();
B_PORT.index('UNIK');
B_PORT.prefix(null(),_prel_dst,null(),exec('kind_in','#b_port'),);
:: Wyznaczenie nowego symbolu portu
_nr_port:={? B_PORT.last() || B_PORT.SYMBOL+2 || '0' ?};
B_PORT.prefix();
{? B_PORT.seek(_port_src)
|| B_PORT.B_ELE:=null();
   B_PORT.B_PREL:=_prel_dst;
   B_PORT.KIND:=exec('kind_in','#b_port');
   B_PORT.SYMBOL:='p'+form(#_nr_port+1,-2,,'99');
   B_PORT.NAME:='Dynamiczny parametr wejściowy';
   {? B_PORT.add() || _port_dst:=B_PORT.ref() ?}
?};
B_PORT.cntx_pop();

_port_dst


\lock
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Blokuje port
::   WE: _a - B_PORT.ref
::       [_b] - INTEGER - 0/[1]/2 - czy wyswietlać dialogi: [1] - na ekran
::                                                           2 - do KOMMa
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_b_port:=_a;

{? var_pres('_b')=type_of(0)
|| _display:=_b
|| _display:=1
?};

_result:=0;

B_PORT.cntx_psh(); B_PORT.clear();
{? B_PORT.seek(_b_port)
||
   _ses_id:=exec('blk_lock','#table','B_PORT',B_PORT.ref(),,2);
   {? _ses_id=SYSLOG.ses_id()
   || _result:=1
   || _msg:='Parametr \'%1\' jest redagowany przez użytkownika \'%2\' na terminalu \'%3\''@[B_PORT.SYMBOL,B_PORT.ses_info(_ses_id,'log_name'),B_PORT.ses_info(_ses_id,'log_tty')];
      {? _display=1
      || FUN.emsg(_msg)
      |? _display=2
      || KOMM.add(_msg,7,,1)
      ?}
   ?}
?};
B_PORT.cntx_pop();
_result


\unlock
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Odblokowuje port
::   WE: _a - B_PORT.ref
::----------------------------------------------------------------------------------------------------------------------
_b_port:=_a;

B_PORT.cntx_psh(); B_PORT.clear();
{? B_PORT.seek(_b_port)
|| exec('blk_unlock','#table','B_PORT',B_PORT.ref())
?};
B_PORT.cntx_pop();
~~


\addBport4actEdi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Dodanie portów dla czynności ZWS_EDI_UNIW
::   WE: _a - B_PREL.ref()
::       [_b] - Środowisko modelera
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;

_env:=~~;
{? var_pres('_b')>100
|| _env:=_b
?};

_result:=0;
_can_continue:=1;

_load_port:=0;

:: usunięcie portów czynności
B_PORT.index('UNIK');
B_PORT.prefix(null(),_b_prel,null());
{? B_PORT.first()
|| _load_port:=1;
   {!
   |? _can_continue:=exec('delete','#b_port',B_PORT.ref(),1,1,1);
      B_PORT.first() & _can_continue>0
   !}
?};
{? _can_continue>0
||
:: dodanie portów czynności
   {? B_PREL.ISTDEF
   ||
      _b_port:=($B_PREL.ISTDEF().FMMAIN)('ports',B_PREL.ref());

      {? var_pres('_b_port')>100
      ||
         _loop:=_b_port.first();
         _load_port:=_loop;
         {!
         |? _loop
         |!
            B_PORT.ACTIVE:='T';
            B_PORT.B_ELE:=null();
            B_PORT.B_PREL:=B_PREL.ref();
            B_PORT.B_TYPE:=exec('FindInSet','#table','B_TYPE','SYMBOL',_b_port.TYPE);
            B_PORT.FML_VAL:=_b_port.FML_VAL;
            B_PORT.KEYREF:=_b_port.KEYREF;
            B_PORT.KIND:=_b_port.KIND;
            B_PORT.NAME:=_b_port.NAME;
            B_PORT.REQUIRED:=_b_port.REQUIRED;
            B_PORT.SYMBOL:=_b_port.SYMBOL;
            _can_continue:=B_PORT.add();
            _loop:=_can_continue>0 & _b_port.next()
         !}
      ?}
   ?}
?};

{? _can_continue>0
||
   _buffer:=exec('buffer','#b_valprt');

:: Ustalenie wartość portu wejściowego TYP
   B_PORT.index('UNIK');
   B_PORT.prefix(B_PREL.B_ELE,null(),null(),exec('kind_in','#b_port'),'TYP');
   {? B_PORT.first()
   || _value:=exec('edi_stale_txt','#b_port',B_PREL.ISTDEF_T);
      B_VALPRT.index('UNIK');
      B_VALPRT.prefix(B_PREL.ref(),B_PORT.ref());
      {? B_VALPRT.first()
      || {? _value=''
         || _can_continue:=exec('delete','#b_valprt',B_VALPRT.ref())
         || _buffer.cntx_get(B_VALPRT.ref());
            _buffer.FORMULA:=exec('val2fml','#convert',_value,type_of(''));
            _buffer.VALUE:=_value;
            _can_continue:=exec('put','#b_valprt',_buffer)
         ?}
      |? _value<>''
      || _buffer.B_PREL:=B_PREL.ref();
         _buffer.B_PORT:=B_PORT.ref();
         _buffer.FORMULA:=exec('val2fml','#convert',_value,type_of(''));
         _buffer.VALUE:=_value;
         _can_continue:=exec('add','#b_valprt',_buffer)
      ?}
   ?}
?};

{? _can_continue>0
||
:: Ustalenie wartość portu wejściowego ISTDEF
   B_PORT.index('UNIK');
   B_PORT.prefix(B_PREL.B_ELE,null(),null(),exec('kind_in','#b_port'),'ISTDEF');
   {? B_PORT.first()
   || _value:=B_PREL.ISTDEF;
      B_VALPRT.index('UNIK');
      B_VALPRT.prefix(B_PREL.ref(),B_PORT.ref());
      {? B_VALPRT.first()
      || {? _value=null()
         || _can_continue:=exec('delete','#b_valprt',B_VALPRT.ref())
         || _buffer.cntx_get(B_VALPRT.ref());
            _buffer.FORMULA:=exec('val2fml','#convert',_value,type_of(null()),'ISTDEF');
            _buffer.VALUE:=$_value;
            _can_continue:=exec('put','#b_valprt',_buffer)
         ?}
      |? _value
      || _buffer.B_PREL:=B_PREL.ref();
         _buffer.B_PORT:=B_PORT.ref();
         _buffer.FORMULA:=exec('val2fml','#convert',_value,type_of(null()),'ISTDEF');
         _buffer.VALUE:=$_value;
         _can_continue:=exec('add','#b_valprt',_buffer)
      ?}
   ?}
?};

:: przeładowanie zakładki parametrów wejściowych
{? _load_port & type_of(_env)>100
|| exec('load_port','#b_valprt',_env,_b_prel)
?};
{? _can_continue>0
|| _result:=1
?};
_result


\edi_stale_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Stałe tekstowe EDI
::   WE: _a - id stałej
::   WY: stała tekstowa
::----------------------------------------------------------------------------------------------------------------------
{? _a='R' || 'EDI odczyt'
|? _a='W' || 'EDI zapis'
|? _a='M' || 'Mechanizm importów'
|| ''
?}


\is_dynamic
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Sprawdza czy port jest dynamiczny
::   WE: [_a] - B_PORT.ref lub bieżący rekord
::   WY: 0 - nie jest dynamiczny
::       1 - jest dynamiczny
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(B_PORT.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

B_PORT.cntx_psh();
{? _ref<>null()
|| B_PORT.prefix();
   {? B_PORT.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? B_PORT.B_ELE=null() & B_PORT.B_PREL<>null()
   || _result:=1
   ?}
?};
B_PORT.cntx_pop();
_result


\clean_dynamic
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Czyści porty dynamiczne, które nie mają powiązań
::   WE: _a - B_PROC.ref
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_b_proc:=_a;

_can_continue:=1;
_result:=0;

B_PORT.cntx_psh();
B_PREL.cntx_psh();
B_ELE.cntx_psh();
B_PORT.index('DYNAMIC');

:: Prefix na porty dynamiczne
B_PORT.prefix(_b_proc,null());
{? B_PORT.first()
|| {!
   |? _next:=0;
      _del:=0;
      _ref_nxt:=null();
      B_PORT.cntx_psh();
      {? B_PORT.next()
      || _ref_nxt:=B_PORT.ref()
      ?};
      B_PORT.cntx_pop();

      {? B_PORT.KIND=exec('kind_in','#b_port') & B_PORT.B_PREL<>null()
      ||
         {? B_PORT.B_PREL().B_ELE().SYMBOL<>'ZWS_EDI_UNIW'
         ||
            B_POCONN.cntx_psh();
            B_POCONN.index('TO');
            B_POCONN.prefix(B_PORT.ref());
            {? B_POCONN.first()=0
            ||
::             B_PORT dynamiczny bez B_POCOONA jest kulawy, więc go usuwamy
               _del:=1
            ?};
            {? _del>0
            || _port_sym:=B_PORT.SYMBOL;
               _prel_sym:=exec('FindAndGet','#table',B_PREL,B_PORT.B_PREL,,"SYMBOL",'');
               {? exec('delete','#b_port',B_PORT.ref(),1,1,2)>0
               || {? _prel_sym<>'' & _prel_sym<>''
                  || _msg:='Nie udało się zaimportować dynamicznego parametru: %1 do elementu procesu %2'@[_port_sym,_prel_sym]
                  || _msg:='Nie udało się zaimportować dynamicznego parametru: %1'@[_port_sym]
                  ?};
                  exec('import_komm','#b_export',_msg)
               ?}
            ?};
            B_POCONN.cntx_pop()
         ?}
      ?};

      {? _ref_nxt<>null()
      || _next:=B_PORT.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
B_PORT.cntx_pop();
B_ELE.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\edi_rebuild_ports
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Iteruje po czynnościach typu EDI i jeżeli komunikat im się nie zaimportował to mu odtwarzamy porty
::   WE: _a - B_PROC.ref
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_b_proc:=_a;

_can_continue:=1;
_result:=0;

B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_b_proc,'B_ACTION');
{? B_PREL.first()
|| {!
   |? {? exec('is_edi','#b_prel',B_PREL.ref()) & B_PREL.ISTDEF=null()
      || _can_continue:=exec('addBport4actEdi','#b_port',B_PREL.ref())
      ?};
      B_PREL.next() & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 3834b03dcd84a136e9b464b91b3055fcb872a32ce35277b15a46d7cb5bae0c637a950c482ba88d26326127f16301a7eaeaf7f6bf5590178460f9ee57504ac0ae843c86d55e20b31d401fb716525759cc36433e6169e8e40fe8a23ae92b1acb36c7ca7aaff4b65ad78dcba55129020e1da8e2db82294c9d741b249aa43f107a16
