:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #var.fml [17.00]
:: Utworzony: 18.12.2014
:: Autor: TS
::======================================================================================================================
:: Zawartosc: Uniwersalne mechanizmy do obsługi zmiennych
::======================================================================================================================


\vd_decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [8.70]
:: OPIS: Definicja klasy i powołanie obiektu VAR_DEL do tworzenia i usuwania zmiennych
::       metody klasy:
::         new(_a,_b) - tworzy nową zmienną globalną i zwraca jej akronim
::                      _a - vartość jaka ma być przypisana do zmiennej
::                      _b - formula, ktora wykorzystana bedzie do przypisania do zmiennej np. obiektu "obj_new(1)".
::                      Jeżeli żaden parametr nie będzie podany zostanie do zmiennej przypisany typ pusty.
::                      np. VAR_DEL.new(10,"obj_new(_a)")
::         delete(_a,_b,...) - usuwa zmienne o nazwach podanych jako
::                             kolejne parametry metody (do 26)
::                      np. VAR_DEL.delete('TMP_TAB') - usuwa zmienną TMP_TAB
::  OLD: \vd_decl/skid.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('VD_CLASS',@.CLASS)<0 ||
   obj_decl('VD_CLASS',
            obj_meth('delete',"
               {! _nr:=1 .. _ |? _ |!
                  {? type_of(_[_nr])=2
                  || {? var_pres(_[_nr])>100
                     || obj_del(($_[_nr])());
                        ($('&'+_[_nr]))()
                     |? var_pres(_[_nr])>=0
                     || ($('&'+_[_nr]))()
                     ?}
                  ?}
               !}; 1
            "),
            obj_meth('new',"
               _value:={? var_pres('_a')>0 || _a || ~~ ?};
               _fml:={? var_pres('_b')>0 || _b || """" ?};
               exec('uniqvarname','#var','V',_value,_fml)
            ")
   )
?};
~~


\uniqvarname
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca unikalną nazwę zmiennej globalnej i jeżeli podano _b lub _c, to inicjuje zmienną
::   WE: STRING [_a] - prefiks zmiennej
::       ANY    [_b] - wartość początkowa zmiennej - występuje zainicjowanie zmiennej
::       STRING
::       FORMULA[_c] - formuła, której wynik zainicjuje zmienną (domyślnie '_a')
::   WY: STRING - nazwa zmiennej
::  OLD: \uniqvarname/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_prefix:={? var_pres('_a')=2 || _a || 'ąćęł' ?};
 _value:={? var_pres('_b')>0 || _b || ~~     ?};
_fml:=':='+{? (var_pres('_c')=2 | var_pres('_c')=3) & (+form(_c)) || form(_c) || '_a' ?};
:: czy inicjować zmienną?
_init:=_>1;

_varname:=_prefix;
{? var_pres(_prefix)>=0
||
   _size:=8-(+_prefix);
   _lp:=#('9'*_size)+1;
   {!
   |?
      _lp-=1;
      _varname:=_prefix+form(_lp,-_size,,'99');
      var_pres(_varname)>100 & _lp>0
   !};
   _varname
?};
{? _init
|| ($(_varname+_fml))(_value)
?};
_varname


\BigSpace
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Deklaracja klasy - przestrzeni, w której możemy zmieścić więcej niż 64k elementów
::  OLD: \BigSpace/communiq.fml
::----------------------------------------------------------------------------------------------------------------------
_cl_name:={? _>0 & type_of(_a)=2 || _a || 'BigSpace'?};
{? var_pres(_cl_name,@.CLASS)<=0
|| obj_decl(_cl_name
   ,obj_fld('this'    ,'wskazanie na siebie'             ;~~)
   ,obj_fld('S'       ,'uchwyt przestrzeni'              ;~~)
   ,obj_fld('XBlank'  ,'blank kolumny'                   ;~~)
   ,obj_fld('XSegZero','indeks zerowego el. w segmencie' ;~~)

   ,obj_fld('XPlNum'  ,'liczba powierzchni'              ;1)
   ,obj_fld('XPlSiz'  ,'liczba elementow powierzchni'    ;0)
   ,obj_fld('XSegNum' ,'liczba segmentow'                ;0)
   ,obj_fld('XSysMax' ,'ograniczenie systemowe'          ;65535)
   ,obj_fld('XDynamic','zmienna liczba elementow'        ;0)
   ,obj_fld('XPlBlk'  ,'wartosci domyslne dla powierzch' ;~~)

  ,obj_meth('getSO'   ,'pobiera wartosc wg .Seg i .Off'  ;".S[_a][.Seg][.Off]")
  ,obj_meth('setSO'   ,'ustala wartosc wg .Seg i .Off'   ;".S[_a][.Seg][.Off]:=_b")

   ,obj_fld('get'     ,'pobiera wartosc elementu'        ;"~~")
   ,obj_fld('set'     ,'ustala wartosc elementu'         ;"~~")

   ,obj_fld('Seg'     ,'segment'                         ;0)
   ,obj_fld('Off'     ,'offset'                          ;0)

   ,obj_fld('decode' ,'ustala .S i .O na podstawie _a'   ;"0")
  ,obj_meth('__init'  ,'konstruktor';"
         _a.this:=_a;
         {?_<2 | type_of(_b)<>1   || _b:=-1 ?};
         {?_>2 & type_of(_c)=1   || _a.XPlNum:=_c ?};
         {?_>3 & type_of(_d)>100 || _a.XPlBlk:=_d ?};

         {? _b=-1
         || _b:=_a.XSysMax;
            _a.XDynamic:=1;
            ~~
         ?};

         _a.XPlSiz:=_b;

         {? _a.XPlSiz>0
          & _a.XPlNum>0
         ||
::          główne parametry do zmiennych lokalnych - łatwiejsze użycie
            _size:=_a.XPlSiz;
            _lnum:=_a.XPlNum;
             _max:=_a.XSysMax;
::          liczba segmentów - dzielimy całkowicie liczbę elementów przez _max i dodajemy do wyniku 1
            _a.xsegadd(((_size-1)%_max)+1);
            ~~
         ?};
         ~~
      "
      )

   ,obj_fld('xblank' ,'blankuje aktualna kolumne w przestrzeni';"~~")

   ,obj_meth('xsegadd','dodaje segmenty';"
::       ile segmentów mamy dodać?
         _ile_seg:=int(_a);

         {? _ile_seg>0
         || _XSegNum:=.XSegNum+_ile_seg;

::          powołanie tablicy płaszczyzn
            _S:=obj_new(.XPlNum);
::          powołanie tablic segmentów
            {! _ss:=1.. .XPlNum |! _S[_ss]:=obj_new(_XSegNum) !};
::          powołanie pomocniczej tablicy współrzędnych
            _XSegZero:=obj_new(_XSegNum);
              _XBlank:=obj_new(_XSegNum);

::          teraz nieco inne ujęcie
::          dla każdego segmentu, który już istniał
            {! _seg:=1.. .XSegNum
            |!
               _XSegZero[_seg]:=.XSegZero[_seg];
               _XBlank[_seg]:=.XBlank[_seg];
::             dla każdego segmentu w każdej płaszczyźnie dodanie tablic elementów
               {! _ss:=1.. .XPlNum |! _S[_ss][_seg]:=.S[_ss][_seg] !}
            !};

::          dla każdego nowego segmentu
            _max:=.XSysMax;
            {! _seg:=.XSegNum+1.._XSegNum
            |!
::             nadanie wartości pomocniczych ułatwiających wyznaczanie segmentu i offsetu w metodzie .decode()
               _XSegZero[_seg]:=(_seg-1)*_max;
               _XBlank[_seg]:=obj_new(_max);
               {! _sg:=1.._max |! _XBlank[_seg][_sg]:='' !};
::             dla każdego segmentu w każdej płaszczyźnie dodanie tablic elementów
               {! _ss:=1.. .XPlNum
               |! _S[_ss][_seg]:=obj_new(_max)
               !}
            !};

::          gotowe tablice, więc możemy przepiać do globalnych
            .XSegNum:=_XSegNum;
            {? type_of(.S)>100        || obj_del(.S) ?};        .S:=_S;
            {? type_of(.XSegZero)>100 || obj_del(.XSegZero) ?}; .XSegZero:=_XSegZero;
            {? type_of(.XBlank)>100   || obj_del(.XBlank)   ?}; .XBlank:=_XBlank;
            .XPlSiz:=.XSegZero[.XSegNum]+.XSysMax;

::          teraz możemy zdefiniować metody do obsługi elementów w przestrzeni
            .get:=\"{?.decode(_b) || .getSO(_a)    || ~~ ?}\";
            .set:=\"{?.decode(_b) || .setSO(_a,_c) || ~~ ?}\";
::          możemy zdefiniować metodę dekodujacą adres na segment i offset
            .decode:={?.XSegNum=1
                     || \".Seg:=1; .Off:=_a\"
                     || \"
                          .Seg:=((_a-1)%.XSysMax)+1;
                          .Off:=_a-.XSegZero[.Seg]
                        \"
                     ?};
            {? .XDynamic
            || .decode:=$('{? _a>.XPlSiz || _seg:=((_a-1)%.XSysMax)+1; .xsegadd(_seg-.XSegNum); .decode(_a)|| '+.decode+'?}')
            ?};
            .decode:=$(.decode+';{? +.XBlank[.Seg][.Off]=0 || .xblank() ?}; .Off' );
            .xblank:='';
            {! _pl:=1.. .XPlNum
            |! .xblank:=.xblank+'.S['+$_pl+'][.Seg][.Off]:=.XPlBlk['+$_pl+']; \n'
            !};
            .xblank:=$(.xblank+'.XBlank[.Seg][.Off]:=''T'';~~');
            ~~
         ?}
      "
      ,1
      )
   )
?};
~~


\obj_new
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Tworzy interface do tworzenia tablic nazwanych
::   WY: obiekt
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzac czy zostały podane i może wystąpić błąd.
::  OLD: \obj_new/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('obj_new',@.CLASS)<100
|| obj_decl('obj_new'
::   deklaracja pol tablicy
     ,obj_fld('declare','')
::   tablica wartosci poczatkowych pol tablicy
     ,obj_fld('deftab' ,~~)
::   liczba wykorzystanych pol w tablicy
     ,obj_fld('deftabS', 0)
::   __init() - konstruktor
     ,obj_meth('__init' ,"_a.clean()")
::   .clean() - czyszczenie deklaracji i definicji
     ,obj_meth('clean' ,".declare:='';
                         {? type_of(.deftab)>100 || obj_del(.deftab) ?};
                         .deftabS:=0;
                         .deftab:=obj_new(65535);
                         1
                        "
              )
::   .fld(akronim,[prosta_wartosc_domyslna],[komentarze])
     ,obj_meth('fld'     ,".deftabS+=1; .declare+='\\n\\t'''+_a+''','; .deftab[.deftabS]:={? var_pres('_b')>0 || _b || ~~ ?}")
::   .fldv(akronim,[komentarze]) - pole o wartosci domyslnej takiej samej jak akronim
     ,obj_meth('fldv'    ,".deftabS+=1; .declare+='\\n\\t'''+_a+''','; .deftab[.deftabS]:=_a")
::   .meth(nazwa,[komentarz],formula)
     ,obj_meth('meth'    ,".deftabS+=1; .declare+='\\n\\t'''+_a+''','; .deftab[.deftabS]:=_c")
::   .new([no_blank]) - faktyczne powolanie obiektu i nadanie wartosci domyslnych
     ,obj_meth('new'     ,"
        _obj:='';
        _obj:=($(_obj+'obj_new('+{? .declare+1=','|| .declare-1 || .declare ?}+'\\n)'))();
        {? var_pres('_a')<>1 | _a<1
        || {! _ff:=1.. .deftabS |! _obj[_ff]:=.deftab[_ff] !}
        ?};
        _obj
      ")
   )
?};
obj_new(@.CLASS.obj_new)


\obj_new_hybrid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Tworzy hybrydę tablicy nazwanej i nienazwanej, gdzie od 1..n - odwołujemy się przez indeks, powyżej przez nazwę
::   WE: _a - liczba pól numerowanych
::       [_b..] - kolejne nazwy pól
::   WY: obiekt
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \obj_new_hybrid/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_fld_num:=_a;
_obj:="obj_new(";
{! _ff:=1.._fld_num |! _obj+="\n'Ó"+form(_ff,-7,,'99')+"'," !};
{? _>1
|| {! _ff:=2.._ |! _obj+="\n'"+form(_[_ff])+"'," !}
?};
{? _obj+1=','
|| _obj:=(_obj-1)+'\n)';
   ($_obj)()
|| ~~
?}


\empty_value
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca pustą wartość dla przekazanego parametru
::   WE: _a - INTEGER - numer typu, wynik działania type_of()
::   WY: ANY - pusta wartość danego typu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_type:=_a;

_result:=~~;

{? _type>0
||
   {? var_pres('__mb_ftypes')<100
   || exec('mbFieldsType','#table')
   ?};
   _types:=__mb_ftypes;
   {? _type>0 & _type<=obj_len(_types.default)
   || _result:=_types.default[_type]
   || FUN.info('Nieznany typ: '@+$_type)
   ?}
?};
_result


\is_empty_value
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy przekazana zmienna ma pustą wartość charakterystyczną dla własnego typu
::   WE: _a - ANY - jakaś zmienna
::   WY: 0 - zmienna ma wartość niepustą
::       1 - zmienna ma wartość pustą
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_var:=_a;

_result:=0;

_type:=type_of(_var);
{? _type=0
|| _result:=1
|| _empty:=exec('empty_value','#var',_type);
   {? _var=_empty
   || _result:=1
   ?}
?};
_result


\type_of_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Zwraca numer typu zmiennej FILE
::----------------------------------------------------------------------------------------------------------------------
:: 119
_file:=fopen(null(),'w',,,1);
_type:=type_of(_file);
obj_del(_file);
_type


\type_of_array
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Zwraca numer typu tablicowego
::----------------------------------------------------------------------------------------------------------------------
:: 117
_array:=obj_new(1);
_type:=type_of(_array);
_type


\is_develop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Inicjuje zmienną __develop
::       Kontekst działania: ustawiona zmienna OPERATOR.USER
::   WY: REAL - 0/1 - nowa wartość zmiennej __develop
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? user(7)='PRAC000004'
|| USERS.cntx_psh();
   {? fexists('../../__action/develop_%1.txt'[OPERATOR.USER().KOD],0)
   || _result:=1
   ?};
   USERS.cntx_pop()
?};
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 67c0ce9b9dd8356baf22da15f45df7af70c1a52295131950dc41bd134804f98dc576afa2f94a0eeb6fcf74511d1ba18660dc0713d90709be74ce2435debc2ae8e02cab3a1d0dbe715e6f3ffd349d2b9b26a5896dc0c347aef1c9b9be8b6b4c2fb056b625dee21c2103de6d0f7266126a99e65eec3ff9338bc9a1bca2d8cf70f4
