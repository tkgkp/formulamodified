:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b_bpmn.fml
:: Utworzony: 28.01.2015
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły do obsługi modelera graficznego BPMN
::======================================================================================================================


\dict_lanes
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyświetla słownik torów - wykonywane po dodaniu nowego basenu/toru na diagram
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><TORY><LISTA>
::----------------------------------------------------------------------------------------------------------------------
_uid_prel:='';
{? var_pres('_a')=type_of('')
|| _uid_prel:=_a
?};
_env:=params_get().env;
_result:='';
_firma:=exec('FindAndGet','#table',B_PROC,_env.SEL_PROC,,"FIRMA",null());
_lane:=null();
{? _uid_prel<>''
|| B_PREL.cntx_psh();
   B_PREL.index('UID');
   B_PREL.prefix(_env.SEL_PROC,_uid_prel,);
   {? B_PREL.first()
   || B_LANE.cntx_psh();
      B_LANE.index('B_ELE2');
      B_LANE.prefix(_firma,B_PREL.B_ELE);
      {? B_LANE.first()
      || _lane:=B_LANE.ref()
      ?};
      B_LANE.cntx_pop()
   ?};
   B_PREL.cntx_pop();
   ~~
?};
_ref:=exec('dictionary','#b_lane','ref',,_firma,_lane);
{? _ref<>null()
|| B_LANE.cntx_psh(); B_LANE.clear();
   {? B_LANE.seek(_ref)
   || _buffer:=exec('B_LANE','#buffer');
      _buffer.get();
      _args:=exec('args_xml','#xml');
      _args.BUFFER:=_buffer;
      _args.JAVA_OBJ:='B_LANE';
      _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
      _result:=exec('buffer2XML','#xml',_args)
   ?};
   B_LANE.cntx_pop();
   ~~
?};
_result


\dict_actions
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyświetla słownik czynności - wykonywane po dodaniu nowej czynności na diagram
::   WE: _a - STRING - typ wyświetlanych czynności - 'U' - użytkownika
::                                                   'M' - ręczne
::                                                   'S' - serwisowe
::                                                   'E' - wysyłające email
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><CZYNNOŚĆ><LISTA>
::----------------------------------------------------------------------------------------------------------------------
_type:=_a;

_result:='';
_ref:=exec('dictionary','#b_action','ref',_type);
{? _ref<>null()
|| B_ACTION.cntx_psh(); B_ACTION.clear();
   {? B_ACTION.seek(_ref)
   || _buffer:=exec('B_ACTION','#buffer');
      _buffer.get();
      _args:=exec('args_xml','#xml');
      _args.BUFFER:=_buffer;
      _args.JAVA_OBJ:='B_ACTION';
      _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
      _result:=exec('buffer2XML','#xml',_args)
   ?};
   B_ACTION.cntx_pop();
   ~~
?};
_result


\get_role_sym
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca symbol roli na podstawie przekazanego uidrefa
::   WE: _a - B_ELE.uidref()
::   WY: B_ROLE.NAME lub ''
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;

_result:='';
B_ROLE.cntx_psh();
B_ELE.cntx_psh();
B_ELE.clear();
{? B_ELE.seek(_uid)
||
   B_LANE.cntx_psh();
   B_LANE.index('B_ELE');
   B_LANE.prefix(B_ELE.ref());
   {? B_LANE.first()
   || _result:=B_LANE.B_ROLE().NAME
   ?};
   B_LANE.cntx_pop();
   ~~
?};
B_ELE.cntx_pop();
B_ROLE.cntx_pop();
_result


\get_pool_sym
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca symbol basenu na podstawie przekazanego firmy przypisanej do aktualnego procesu
::   WY: STRING
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? var_pres('D_ENV')>100
|| B_PROC.cntx_psh(); B_PROC.clear();
   {? B_PROC.seek(D_ENV.SEL_PROC)
   || _result:=B_PROC.FIRMA().OPIS
   ?};
   B_PROC.cntx_pop()
|| {? var_pres('env',params_get())>0
   || _env:=params_get().env;
      {? var_pres('SEL_PROC',_env)>0
      ||
         B_PROC.cntx_psh(); B_PROC.clear();
         {? B_PROC.seek(_env.SEL_PROC)
         || _result:=B_PROC.FIRMA().OPIS
         ?};
         B_PROC.cntx_pop()
      ?}
   ?}
?};
_result


\get_ele_sym
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca symbol elementu procesu na podstawie przekazanego uidrefa
::   WE: _a - B_ELE.ref
::   WY: STRING - nazwa elementu procesu
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;

_result:='';
B_ELE.cntx_psh();
B_ELE.clear();
{? B_ELE.seek(_uid)
|| {? B_ELE.CLASS='B_ACTION'
   || B_ACTION.cntx_psh();
      B_ACTION.index('B_ELE');
      B_ACTION.prefix(B_ELE.ref());
      {? B_ACTION.first()
      || _result:=B_ACTION.NAME
      ?};
      B_ACTION.cntx_pop()
   || _result:=B_ELE.SYMBOL
   ?}
?};
B_ELE.cntx_pop();
_result


\save_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Inicjuje zapis procesu
::   WE: _a - STRING - ścieżka do diagramu
::       _b - STRING - '0'/'1' - czy zapis po imporcie czy normalny
::       _c - STRING - nazwa pliku .proc po stronie serwera
::   WY: STRING - '0' - porażka
::                '1' - sukces
::                '-1' - porażka inicjalizacji importu
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_filepath:=_a;
_imported:=_b;

_fileproc:='';
{? var_pres('_c')=type_of('')
|| _fileproc:=_c
?};

_result:=1;

params_set(params_get());
_env:=params_get().env;

{? _env.IMPORT_GR>0
|| {? _imported='0'
   ||
::    Jeżeli import grupowy, ale _imported=0 to może oznaczać że ktoś importuje
::    pusty proces i trzeba przestawić _imported na '1' żeby się doimportowały informacje z nagłówka
      _imported:='1'
   ?}
?};

_env.IMPORTED:=_imported;
:: Na czas zapisu ustawiam modeler jako nieaktywny
exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'active=false');

:: Na czas zapisu znikam przyciski narzędziowe
exec('set_visible','#desktop','',_env.ctr_id,'przyciski',0);

:: Na czas zapisu znikam wszystkie akcje w oknie
{? _env.WIN_BPMN<>''
|| B_PROC.actions(_env.WIN_BPMN,'ZAWFPU',,1)
?};

B_PROC.cntx_psh(); B_PROC.clear();
{? var_pres('_env')>100
||
:: Czyszcze tabelki tymczasowe zawierającą refy elementów które są na diagramie
   _env.DIA_PRELS.tab.erase();
   _env.DIA_CONNS.tab.erase();

   {? B_PROC.seek(_env.SEL_PROC)
   ||
::    Blokuje proces na czas zapisu
      _fml:="
         params_set(params_get());
         _env:=params_get().env;
         exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressVisible=false')
      ";
      _info:='Proces: \''+B_PROC.SYMBOL+'\' jest redagowany';
      {? params_exec('blk_lock','#table','B_PROC',_env.SEL_PROC,,,_info,_fml)=0
      || _result:=0
      ?};
      {? _result>0
      ||
::       Czyszczę znacznik błędu importu na procesie
         B_PROC.IMP_ERR:='N';
         B_PROC.put();

::       Rozpoczynam transakcję
         _mydo:=do_state()=0;
         {? _mydo || do() ?};
         ~~
      ?};
::    Inicjuję KOMMa
      {? _env.IMPORT_GR=0
      || KOMM.init(250,,'Zapisywanie diagramu BPMN')
      ?};
      {? _result>0 & _imported='1'
      ||
         {? exec('procfile_init','#b_export',_fileproc)<=0
         || _result:=-1
         ?}
      ?};

      {? _result>0 & _imported='1'
      ||
::       Importuję interwały czasowe
         {? exec('procfile_done','#b_export','IVAL_DEF','ref_create_init')<=0
         || _result:=-1
         ?}
      ?};
      ~~
   || _result:=0
   ?};
   ~~
|| _result:=0
?};
{? _result=0
||
:: Jeśli nie udało się rozpocząć zapisu, to odbezpieczam modeler
   exec('set_value','#desktop','','b_design',_env.ctr_bpmn,'active=true');
   exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressVisible=false')
?};
B_PROC.cntx_pop();
$_result


\save_diagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zapisuje diagram BPMN do bazy danych
::   WE: _a - STRING - ścieżka do diagramu
::       _b - STRING - scieżka do diagramu w formacie SVG
::       [_c] - INTEGER - [1]/2 - komunikaty na ekran czy do KOMMa
::       [_d] - INTEGER - [0]/1 - czy ścieżka z plikami .graphml jest lokalna czy na serwerze
::   WY: STRING - '0' - porażka
::                '1' - sukces
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_file:=_a;

_svg_file:='';
{? var_pres('_b')=type_of('')
|| _svg_file:=_b
?};

_display:=1;
{? var_pres('_c')=type_of(0)
|| _display:=_c
?};

_dir_on_server:=0;
{? var_pres('_d')=type_of(0)
|| _dir_on_server:=_d
?};

_monkey:='@';
{? _dir_on_server>0
|| _monkey:=''
?};

{? exec('interm','#system') & _dir_on_server=0
|| _msg:=exec('interm_nacc_msg','#system');
   {? _display=1
   || FUN.emsg(_msg)
   |? _display=2
   || exec('import_komm','#b_export',_msg,,B_PROC.ref())
   ?};
   return('0')
?};

_env:=params_get().env;

_result:=0;
B_PROC.cntx_psh(); B_PROC.clear();

{? B_PROC.seek(_env.SEL_PROC)
|| {? _svg_file<>''
   ||
      {? fexists(_monkey+_svg_file)
      || _result:=B_PROC.bl_put('SVG',_monkey+_svg_file,0);
         {? _result=0
         ||
            _msg:='Bład zapisu procesu: %1 do pliku SVG.\n'
                  'Nie udało się zapisać pliku w bazie.'@[exec('B_PROC','#to_string')];
            {? _display=1
            || FUN.emsg(_msg)
            |? _display=2
            || exec('import_komm','#b_export',_msg,,B_PROC.ref())
            ?}
         ?}
      || _msg:='Bład zapisu procesu: %1 do pliku SVG.\n'
               'Nie znaleziono pliku z grafem.'@[exec('B_PROC','#to_string')];
         {? _display=1
         || FUN.emsg(_msg)
         |? _display=2
         || exec('import_komm','#b_export',_msg,,B_PROC.ref())
         ?}
      ?}
   ?};
   _result:=B_PROC.bl_put('GRAPHMLZ',_monkey+_file,0);
   _result
?};
B_PROC.cntx_pop();
B_PROC.get();
$_result


\save_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Kończy zapis procesu
::   WE: _a - STRING -  nazwa etapu na którym się coś wykrzaczyło w javie
::                      '' - zapis udało się doprowadzić do końca
::       [_b] - STRING - '0'/'1' - czy odtworzyć uprawnienia do czynności na podstawie procesu
::   WY: STRING - '0' - porażka
::                '1' - sukces
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_error:='';
{? var_pres('_a')=type_of('')
|| _error:=_a
?};

_refresh_perm:='';
{? var_pres('_b')=type_of('')
|| _refresh_perm:=_b
?};

_result:=1;

_can_continue:=1;

params_set(params_get());
_env:=params_get().env;

_imported:=_env.IMPORTED;

{? _env.IMPORT_GR>0
||
:: Import grupowy, wynik 2 spowoduje że po zapisie nie pojawi się diagram w modelerze
   _result:=2;

   {? _imported='0'
   ||
::    Jeżeli import grupowy, ale _imported=0 to może oznaczać że ktoś importuje
::    pusty proces i trzeba przestawić _imported na '1' żeby się doimportowały informacje z nagłówka
      _imported:='1'
   ?}
?};

{? var_pres('_env')>100
||
:: Tworzymy automatyczne warunki
::   exec('create_cond4gate','#b_cond',B_PROC.ref());

:: Importujemy dodatkowe rzeczy - połączenia argumentów, warunki bram itp
   {? _imported='1'
   ||
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Importowanie dodatkowych właściwości procesu...');
      {? exec('procfile_done','#b_export','B_PROC')<=0
      || _can_continue:=0
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Importowanie parametrów dynamicznych...');
      {? exec('procfile_done','#b_export','B_PORT')<=0
      || _can_continue:=0
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Importowanie warunków bram...');
      {? exec('procfile_done','#b_export','B_CHOICE')<=0
      || _can_continue:=0
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Importowanie powiązań parametrów...');
      {? exec('procfile_done','#b_export','B_POCONN')<=0
      || _can_continue:=0
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Importowanie harmonogramów zdarzeń...');
      {? exec('procfile_done','#b_export','B_TIMER')<=0
      || _can_continue:=0
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Importowanie komunikatów zdarzeń...');
      {? exec('procfile_done','#b_export','B_MSG')<=0
      || _can_continue:=0
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Importowanie ustalonych na procesie wartości...');
      {? exec('procfile_done','#b_export','B_VALPRT')<=0
      || _can_continue:=0
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Importowanie sygnałów...');
      {? exec('procfile_done','#b_export','B_SIGPRT')<=0
      || _can_continue:=0
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Sprzątanie nieużywanych ról...');
      {? exec('procfile_done','#b_export','B_ROLE')<=0
      || _can_continue:=0
      ?};
::    Usuwamy porty dynamiczne bez powiązań
      {? _can_continue>0
      || _can_continue:=exec('clean_dynamic','#b_port',_env.SEL_PROC)
      ?};

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Aktualizacja nazw połączeń z bram...');
      {? _can_continue>0
      ||
::       Iterujemy po warunkach bram i dla połączeń z nimi powiązanymi nawijamy pole B_CONN.NAME_MOD:=
         _can_continue:=exec('proc_name_mod','#b_conn',_env.SEL_PROC)
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

::    Iterujemy po czynnościach typu EDI i jeżeli komunikat im się nie zaimportował to mu odtwarzamy porty
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Aktualizacja czynności EDI...');
      {? _can_continue>0
      || _can_continue:=exec('edi_rebuild_ports','#b_port',_env.SEL_PROC)
      ?};
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressAdd=1');

      {? _can_continue=0
      || _error:='Importowanie dodatkowych składowych procesu'
      ?};
      ~~
   ?};

:: Po zapisie włączam akcje w oknie
   {? _env.WIN_BPMN<>''
   || B_PROC.actions(_env.WIN_BPMN,'',,1)
   ?};

   {? _error<>''
   || _msg:='Zapis procesu przerwany i wycofany na etapie: \n%1'@[_error];
      _error:=_msg;
      undo()
   ||
      _akc:=exec('FindAndGet','#table',B_PROC,_env.SEL_PROC,,"ACCEPTED",'');
::    Jeśli proces zaakceptowany, to po udanym zapisie wyłączam przycisk zapisz
      {? B_PROC.ACCEPTED='T' & _env.IMPORT_GR=0
      || exec('update_accept_status','#b_bpmn')
      ?};

      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressText=Usuwanie elementów nieobecnych na diagramie...');
::    Zapis się powiódł - uruchamiam sprzątanie tych elementów których nie ma na diagramie
      {? exec('not_on_diagram','#b_bpmn',_env.SEL_PROC,_env.DIA_PRELS,_env.DIA_CONNS,_refresh_perm)=0
      || _error:='Zapis procesu przerwany i wycofany na etapie usuwania elementów, których nie ma już na diagramie.';
         undo()
      ?}
   ?};

   end();

:: Uwaga to musi być robione poza transakcją, ponieważ usuwanie rekordów B_ACTROLE w pewnych
:: przypadkach powoduje uruchomienie funkcji exec('todoRelease',#bi_todo) która robi blk_lock na BI_PRELu
   B_PROC.cntx_psh();
   B_PROC.clear();
   {? B_PROC.seek(_env.SEL_PROC)
   ||
::    Jeśli proces zaakceptowany i w modelerze wykonano jakąś akcję która wymaga
::    odtworzenia uprawnień do ról to to robię
      {? _can_continue>0 & B_PROC.ACCEPTED='T' & _refresh_perm='1'
      ||
::       1. Usuwam uprawnienia które już nie powinny obowiązywać
         _tab_bprel:=_env.TAB_ACTROL_DEL;
         _tab_bprel.cntx_psh();
         _tab_bprel.prefix();
         {? _tab_bprel.first()
         || {!
            |?
               _b_prel:=exec('FindAndGet','#table',B_PREL,_tab_bprel.B_PREL,,,null());
               _b_role:=exec('FindAndGet','#table',B_ROLE,_tab_bprel.B_ROLE,,,null());
               {? _b_prel<>null() & _b_role<>null()
               || _can_continue:=exec('prel_actrol_del','#b_role',_b_prel,_env.SEL_PROC,_b_role)
               ?};
               _tab_bprel.next() & _can_continue>0
            !};

            {? _can_continue=0
            || _result:=0;
               _error:='Zapis procesu przerwany na etapie odtwarzania uprawnień czynności do ról.'@
            ?}
         ?};
         _tab_bprel.cntx_pop();

         {? _can_continue>0
         ||
::          2. Dodaję nowe uprawnienia które powinny obowiązywać
            _can_continue:=exec('procrol2actrol','#b_design',B_PROC.ref(),'');
            {? _can_continue=0
            || _result:=0;
               _error:='Zapis procesu przerwany na etapie odtwarzania uprawnień czynności do ról.'@
            ?}
         ?}
      ?}
   ?};
   B_PROC.cntx_pop();

   _env.SAVING:=0;

   {? _env.IMPORT_GR=0
   ||
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressFinalize=true');

::    Po zapisie wyłączam okno z progressem
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'progressVisible=false');

::    Po zapisie pojawiam przyciski narzędziowe
      exec('set_visible','#desktop','',_env.ctr_id,'przyciski',1)
   ?};


   {? _imported='1'
   || exec('procfile_clean','#b_export')
   ?};
   _tm_save_before:=0;
   {? _error<>''
   ||
::    Błąd został zgłoszony z javy, pokazuje komunikat
      {? KOMM.get_size()>0
      || _choice:=FUN.choice(_error,,'Szczegóły',,,,'Zamknij');
         {? _choice=1
         || KOMM.select()
         ?}
      || FUN.emsg(_error)
      ?}
   ||
::    Nie było błędu więc stempluje proces czasem ostatniego zapisu
      B_PROC.cntx_psh();
      B_PROC.clear();
      {? B_PROC.seek(_env.SEL_PROC)
      || _tm_save_before:=B_PROC.TM_SAVE;
         B_PROC.TM_SAVE:=exec('create','#tm_stamp');
         {? _imported='1'
         ||
::          Ustawiam czas kiedy proces był zaimportowany
            B_PROC.TM_IMP:=exec('create','#tm_stamp');
::          Usuwam bloba z grupowego importu procesów
            {? B_PROC.IMEX_GML<>null()
            || B_PROC.IMEX_GML:=null()
            ?}
         ?};
         B_PROC.put()
      ?};
      B_PROC.cntx_pop();

::    Nie było błędu z javy ale na wszelki wypadek pokazuje KOMMa jeśli coś by zawierał
      {? _env.IMPORT_GR=0
      || KOMM.select()
      ?}
   ?};


:: Odblokowuje proces
   exec('blk_unlock','#table','B_PROC',_env.SEL_PROC);
   ~~
|| _result:=0
?};

:: Po zapisie ustawiam modeler jako aktywny
exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'active=true');

:: Aktualizuje ikonkę informującą o niezapisanych zmianach
{? _env.IMPORT_GR=0
|| exec('update_mod_icon','#b_bpmn')
?};

:: Aktualizuję pole mówiące czy proces standardowy czy importowany
{? _imported='1'
||
:: Jeżeli import to zawsze aktualizuję
   exec('mod_status_update','#b_proc',_env.SEL_PROC)
||
:: Jeżeli normalny zapis to aktualizuję tylko jeżeli faktycznie się coś zmieniło
   {? _env.TM_MOD>_tm_save_before
   || exec('mod_status_update','#b_proc',_env.SEL_PROC)
   ?}
?};

:: Aktualizuje napis o statusie modyfikacji procesu
{? _env.IMPORT_GR=0
|| exec('update_status4diagram','#b_bpmn')
?};

:: Uruchamiam formułę po zapisie
_env.AFTER_SAVE_FML(_env.AFTER_SAVE_ARG);
_env.AFTER_SAVE_FML:="";
{? var_pres('AFTER_SAVE_ARG',_env)>100
|| obj_del(_env.AFTER_SAVE_ARG)
?};
_env.AFTER_SAVE_ARG:=~~;
$_result


\save_element
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zapisuje element diagramu
::   WE: _a - STRING - symbol elementu na diagramie
::       _b - STRING  - B_ELE.SYMBOL - element który zapisuje
::       [_c] - STRING - B_ROLE.NAME - rola powiązana z elementem
::       [_d] - STRING - B_PREL.UID - unikalny identyfikator B_PRELa który aktualizuje
::       [_e] - STRING - B_PREL.UID - unikalny identyfikator toru na którym umieścić element
::       [_f] - STRING - B_PREL.AUTOMAT - czy czynność jest automatyczna
::       [_g] - STRING - B_PREL.TYPE - typ czynności: 'U' - użytkownika
::                                                    'M' - ręczna
::                                                    'S' - usługowa
::                                                    'E' - wysłania
::       [_h] - STRING - B_PREL.ICON - typ ikony:     'U' - użytkownika
::                                                    'M' - ręczna
::                                                    'S' - usługowa
::                                                    'E' - wysłania
::       [_i] - STRING - czy element został zaimportowany
::       [_j] - STRING - '0'/'1' - czy odtworzyć uprawnienia do czynności na podstawie procesu
::       [_k] - STRING - B_PREL.ENABLED - czy element włączony
::   WY: STRING - XML reprezentujący dodany/zaktualizowany rekord lub kod błędu
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><ADD><PUT>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_symbol:=_a;
_b_ele:=_b;
_b_role:='';
{? var_pres('_c')=type_of('')
|| _b_role:=_c
?};
_uid_prel:='';
{? var_pres('_d')=type_of('')
|| _uid_prel:=_d
?};
_uid_lane:='';
{? var_pres('_e')=type_of('')
|| _uid_lane:=_e
?};
_automat:='';
{? var_pres('_f')=type_of('')
|| _automat:=_f
?};
_type:='';
{? var_pres('_g')=type_of('')
|| _type:=_g
?};
_icon:='';
{? var_pres('_h')=type_of('')
|| _icon:=_h
?};
_imported:=_env.IMPORTED;
{? var_pres('_i')=type_of('')
|| _imported:=_i
?};

_refresh_perm:='';
{? var_pres('_j')=type_of('')
|| _refresh_perm:=_j
?};
_enabled:='T';
{? var_pres('_k')=type_of('')
|| {? _k<>''
   || _enabled:=_k
   ?}
?};

_result:='';
_can_continue:=1;

_autochoice:=0;

B_ACTION.cntx_psh();
B_ACTION.index('B_ELE');
B_GATE.cntx_psh();
B_GATE.index('ELEMENT');
B_PREL.cntx_psh();
B_PREL.index('UID');
B_ROLE.cntx_psh();
B_ROLE.index('UNIK');
B_ELE.cntx_psh();
B_ELE.index('SYMBOL');
B_ELE.prefix(_b_ele,);
{? B_ELE.first()
||
   {? _imported='1'
   ||
      {? B_ELE.CLASS='B_ACTION'
      || _can_continue:=exec('action_chk','#b_export')
      ?};
      {? _can_continue=0
      || _result:='importError'
      ?}
   ?};
   {? _can_continue>0
   ||
      _buffer:=exec('buffer','#b_prel');
      _b_prel:=null();

      _add_new:=0;
      {? _uid_prel='' | (_uid_prel<>'' & _imported='1')
      || _add_new:=1;

         {? (_uid_prel<>'' & _imported='1')
         || B_PREL.cntx_psh();
            B_PREL.index('UID');
            B_PREL.prefix(_env.SEL_PROC,_uid_prel,);
            {? B_PREL.first()
            || _add_new:=0
            ?};
            B_PREL.cntx_pop()
         ?}
      ?};

      {? _add_new>0
      ||
::       Dodaje nowy rekord
         B_PREL.blank();
         _buffer.get();
         {? _imported='1'
         || _buffer.UID:=_uid_prel
         || _buffer.UID:=exec('uid','#blank')
         ?};
         _buffer.CODE:=exec('new_code','#b_design','B_PREL',_buffer.UID);
         _buffer.START:='N';
         _buffer.B_ELE:=B_ELE.ref();
         _buffer.CLASS:=B_ELE.CLASS;

         {? B_ELE.CLASS='B_ACTION'
         || exec('automat_setter','#b_bpmn',_buffer,_automat,0);
            exec('access_setter','#b_bpmn',_buffer);
            exec('loop_setter','#b_bpmn',_buffer);
            exec('type_setter','#b_bpmn',_buffer,_type,0);
            _buffer.RELEASE:={? exec('release','#b_action',B_ELE.SYMBOL) || 'T' || 'N' ?}
         |? B_ELE.CLASS='B_EVENT'
         || exec('enabled_setter','#b_bpmn',_buffer,_enabled,0);
            {? exec('is_event','#b_event',B_ELE.ref(),'startowe','nieokreślone')>0
            || _buffer.DESKTOP:='T'
            ?}
         ?}
      ||
::       Aktualizuje już istniejący
         B_PREL.prefix(_env.SEL_PROC,_uid_prel,);
         {? B_PREL.first()
         || _b_prel:=B_PREL.ref();
            _buffer.get();
            _buffer.B_ELE:=B_ELE.ref()
         ||
            _can_continue:=0;
::          Nie znalazłem elementu do aktualizacji więc przywracam ten element - dodaję go ponownie
::          po to żeby diagram nie był popsuty
            _msg:='Elementu procesu o symbolu: '+_symbol;
            _msg+=' został odtworzony, ponieważ nie znaleziono go w bazie danych.';
            KOMM.add(_msg,9,,1);
::          !!! REKURENCJA !!!
            _result:=exec('save_element','#b_bpmn',_symbol
                                                   ,_b_ele
                                                   ,_b_role
                                                   ,
                                                   ,_uid_lane
                                                   ,_automat
                                                   ,_type
                                                   ,_icon
                                                   ,_imported
                                                   ,_refresh_perm
                                                   ,_enabled)
         ?};
         {? _can_continue>0 & _refresh_perm='1' & B_PREL.B_PROC().ACCEPTED='T' & B_PREL.CLASS='B_ACTION'
         || {? _b_role<>B_PREL.B_ROLE().NAME
            || _tab_bprel:=_env.TAB_ACTROL_DEL;
               _tab_bprel.cntx_psh();
               _tab_bprel.prefix($B_PREL.ref());
               {? _tab_bprel.size()=0
               || _tab_bprel.blank();
                  _tab_bprel.B_PREL:=$B_PREL.ref();
                  _tab_bprel.B_ROLE:=$B_PREL.B_ROLE;
                  _tab_bprel.add()
               ?};
               _tab_bprel.cntx_pop()
            ?}
         ?}
      ?}
   ?};
   {? _can_continue>0
   ||
      _buffer.B_PROC:=_env.SEL_PROC;
      _buffer.SYMBOL:=_symbol;

      {? B_ELE.CLASS='B_ACTION'
      ||
         B_ACTION.prefix(B_ELE.ref());
         {? B_ACTION.first()
         || _buffer.USER:=B_ACTION.USER;
            _buffer.SERVICE:=B_ACTION.SERVICE
         ?}
      ?};

      {? _type='S' & _buffer.B_WORKER=null()
      || {? _b_ele='ZPR_SND_MAIL'
         || _buffer.B_WORKER:=exec('ref','#b_worker',exec('get','#params',100913,2))
         || _buffer.B_WORKER:=exec('ref','#b_worker',exec('get','#params',100912,2))
         ?}
      ?};

      {? exec('is_event','#b_event',B_ELE.ref(),exec('type_start','#b_event'))>0
      || _buffer.START:='T'
      ?};

      {? exec('is_event','#b_event',B_ELE.ref(),,exec('kind_condition','#b_event'))>0 & _buffer.B_WORKER=null()
      || _buffer.B_WORKER:=exec('ref','#b_worker',exec('get','#params',100911,2))
      ?};

      B_GATE.prefix(_buffer.B_ELE);
      {? B_GATE.first()
      ||
         {? _uid_prel<>'' & _imported='0' & _buffer.GATETYPE<>''
         ||
            {? B_GATE.TYPE<>_buffer.GATETYPE
            ||
::             Nastąpiła zmiana typu bramy
::               KOMM.add('Podczas zapisu nastąpiła zmiana typu bramy: %1'@[_buffer.SYMBOL],9,,1);
::             Jeżeli zmiana została dokonana na bramę rozdzielającą typu AND to tnę wszystkie warunki
::             oraz generuję automatyczne warunki dla bramy AND
               {? B_GATE.TYPE=exec('type_and','#b_gate') & B_GATE.KIND=exec('kind_split','#b_gate')
               || {? exec('delete4prel','#b_choice',_buffer.ref())
                  || KOMM.add('Z powodu zmiany typu bramy usunięto warunki na bramie: %1'@[_buffer.SYMBOL],9,,1)
                  ?};
                  _autochoice:=1;
::                Usuwam znacznik domyślnego wyjścia o ile był
                  exec('default_delete','#b_conn',_buffer.ref(),_env.TAB_CONN_DEF)
               ?};

::             Jeżeli zmiana została dokonana z bramy rozdzielającą typu AND to tnę wszystkie warunki automatyczne bramy AND
               {? _buffer.GATETYPE=exec('type_and','#b_gate') & _buffer.GATEKIND=exec('kind_split','#b_gate')
               || exec('delete4prel','#b_choice',_buffer.ref())
               ?};

               {? _buffer.GATETYPE=exec('type_complex','#b_gate')
               ||
::                Jeśli zmieniałem bramę złożoną na coś innego to czyszczę jej pola służące do obsługi
::                bramy złożonej
                  _buffer.G_CANCEL:='N';
                  _buffer.FMANMAIN:=''
               ?};

::             Jeżeli zmiana została dokonana na bramę zbierającą typu AND lub COMPLEXto tnę wszystkie B_POCONNy
               {? (B_GATE.TYPE=exec('type_and','#b_gate')| B_GATE.TYPE=exec('type_complex','#b_gate')) & B_GATE.KIND=exec('kind_merge','#b_gate')
               || {? exec('delete4prel','#b_poconn',_buffer.ref(),'FROM')>0
                  || KOMM.add('Z powodu zmiany typu bramy usunięto powiązania parametrów przechodzące przez bramę: %1'@[_buffer.SYMBOL],9,,1)
                  ?}
               ?}
            ?}
         ?};

         _buffer.GATETYPE:=B_GATE.TYPE;
         _buffer.GATEKIND:=B_GATE.KIND
      ?};
      _buffer.UID_PAR:=_uid_lane;
      _buffer.B_ELE:=B_ELE.ref();
      _buffer.CLASS:=B_ELE.CLASS;
      _buffer.ICON:=_icon;

      {? _b_role<>''
      || B_ROLE.prefix(exec('FindAndGet','#table',B_PROC,_env.SEL_PROC,,"FIRMA",null()),_b_role,);
         {? B_ROLE.first()
         || _buffer.B_ROLE:=B_ROLE.ref()
         ?}
      ?};

      {? _add_new>0
      ||
         {? _imported='1'
         || _read_res:=exec('read_buffer','#b_export',_uid_prel,'ref_create_save_element');

            {? _read_res.RESULT>0
            ||
::             Przed dodaniem B_PRELa podczas importu, nanoszę na niego informacje z importowanego
::             pliku .proc
               _read_res.OBJ.UID_PAR:='';
               exec('buffer2buffer','#table',_buffer,_read_res.OBJ);

               {? _buffer.B_SIGNAL<>null()
               ||
                  _signal_sym:=exec('FindAndGet','#table',B_SIGNAL,_buffer.B_SIGNAL,,"SYMBOL",'');
::                Sprawdzam czy sygnał znajduje się na czarnej liście
                  _env.TAB_IMEX_SIG.cntx_psh();
                  _env.TAB_IMEX_SIG.prefix(_signal_sym);
                  {? _env.TAB_IMEX_SIG.first()
                  ||
::                   Był jakiś problem z tym sygnałem więc nie importuję tego zdarzenia
                     _result:='importError';
                     _can_continue:=0
                  ?};
                  _env.TAB_IMEX_SIG.cntx_pop()
               ?}
            |? _read_res.RESULT=0
            || _result:='importError';
               _can_continue:=0
            ?}
         ?};
         {? _can_continue>0
         || _added:=exec('add','#b_prel',_buffer);
            {? _added<>null()
            || _env.DIA_PRELS.add(_added);
               B_PREL.cntx_psh(); B_PREL.clear();
               {? B_PREL.seek(_added)
               || _args:=exec('args_xml','#xml');
                  _args.MAX_REC:=1;
                  _args.TABLE:=B_PREL;
                  _args.JAVA_OBJ:='B_PREL';
                  _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
                  _result:=exec('record2XML','#xml',_args,_env.FIELDS)
               ?};
               B_PREL.cntx_pop();
               ~~
            || KOMM.add('Nie udało się dodać elementu procesu o symbolu: '+_symbol,2,,1)
            ?}
         ?}
      ||
         {? exec('put','#b_prel',_buffer,_b_prel)>0
         || _env.DIA_PRELS.add(_b_prel);
            _args:=exec('args_xml','#xml');
            _args.MAX_REC:=1;
            _args.BUFFER:=_buffer;
            _args.JAVA_OBJ:='B_PREL';
            _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
            _result:=exec('buffer2XML','#xml',_args)
         || KOMM.add('Nie udało się zaktualizować elementu o symbolu: '+_symbol,2,,1)
         ?}
      ?};
      {? _autochoice>0
      || exec('auto_choice','#b_choice',_buffer.ref())
      ?}
   ?};
   ~~
|| {? _imported='1'
   || KOMM.add('W systemie docelowym brak czynności: '+_b_ele,2,,1)
   || KOMM.add('Nie znaleziono elementu ogólnego o symbolu: '+_b_ele,2,,1)
   ?}
?};
B_ACTION.cntx_pop();
B_ELE.cntx_pop();
B_ROLE.cntx_pop();
B_PREL.cntx_pop();
B_GATE.cntx_pop();
B_PREL.get();
_result


\save_connection
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zapisuje połączenie pomiędzy dwoma elementami
::   WE: _a - STRING  - B_ELE.SYMBOL - element który zapisuje (połączenie)
::       _b - STRING  - B_CONN.NAME - nazwa połączenia które zapisuję
::       _c - STRING  - B_PREL.UID - unikalny identyfikator elementu źródłowego
::       _d - STRING  - B_PREL.UID - unikalny identyfikator elementu docelowego
::      [_e] - STRING - B_CONN.UID - identyfikator B_CONNa który aktualizuje
::      [_f] - STRING - czy element został zaimportowany
::      [_g] - STRING - czy połączenie domyślne
::   WY: STRING - XML reprezentujący dodany/zaktualizowany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_conn_bele:=_a;
_name:=_b;
_from:=_c;
_to:=_d;
_conn:='';
{? var_pres('_e')=type_of('')
|| _conn:=_e
?};
_imported:=_env.IMPORTED;
{? var_pres('_f')=type_of('')
|| _imported:=_f
?};

_default:='';
{? var_pres('_g')=type_of('')
|| _default:=_g
?};
_result:='';
_can_continue:=1;

{? _conn_bele='CONNECTION_TYPE_MESSAGE_FLOW'
||
:: Przepływy komunikatów na razie nie obsłużone w bazie więc od razu wychodzę (ale mogą wystąpić na diagramie)
   return('saveSkip')
?};

B_CHOICE.cntx_psh();
B_CHOICE.index('B_CONN');
B_PREL.cntx_psh();
B_PREL.index('UID');
B_CONN.cntx_psh();
B_CONN.index('UID');
B_ELE.cntx_psh();
B_ELE.index('SYMBOL');
B_ELE.prefix(_conn_bele,);
{? B_ELE.first()
|| _buffer:=exec('buffer','#b_conn');
   _b_conn:=null();
   {? _conn=''
   ||
::    Dodaje nowy rekord
      B_CONN.blank();
      _buffer.get();
      _buffer.UID:=exec('uid','#blank')
   ||
::    Aktualizuje już istniejący rekord
      B_CONN.prefix(_env.SEL_PROC,_conn,);
      {? B_CONN.first()
      || _b_conn:=B_CONN.ref();
         _buffer.get()
      ||
::       Nie znaleziono rekordu więc i tak dodaję nowy
         B_CONN.blank();
         _buffer.get();
         _buffer.UID:=_conn
      ?}
   ?};

   {? _can_continue>0
   ||
      _buffer.B_PROC:=_env.SEL_PROC;
      _buffer.B_ELE:=B_ELE.ref();
      _buffer.NAME:=_name;
      {? _default<>''
      ||

         _buffer.DEFAULT:=_default;
         {? _b_conn<>null()
         ||
::          Jeśli aktualizuję istniejacego B_CONNa to sprawdzam czy jego domyślność nie została
::          przypadkiem przeciążona (np podczas zmiany typu bramy)
            _tab_conn_def:=_env.TAB_CONN_DEF;
            _tab_conn_def.cntx_psh();
            _tab_conn_def.prefix($_b_conn);
            {? _tab_conn_def.first()
            || _buffer.DEFAULT:=_tab_conn_def.DEFAULT
            ?};
            _tab_conn_def.cntx_pop()
         ?}
      ?};

      B_PREL.prefix(_env.SEL_PROC,_from);
      {? B_PREL.first()
      || _buffer.FROM:=B_PREL.ref()
      || _can_continue:=0;
         {? _imported='1'
         ||
::          Jeśli import to zgłaszam błąd importu
            _result:='importError'
         ||
            _msg:='Nie znaleziono elementu źródłowego dla połączenia. Identyfikator elementu: '+_from;
            KOMM.add(_msg,2,,1)
         ?}
      ?};
      B_PREL.prefix(_env.SEL_PROC,_to);
      {? B_PREL.first()
      || _buffer.TO:=B_PREL.ref()
      || _can_continue:=0;

         {? _imported='1'
         ||
::          Jeśli import to zgłaszam błąd importu
            _result:='importError'
         ||
            _msg:='Nie znaleziono elementu docelowego dla połączenia. Identyfikator elementu: '+_to;
            KOMM.add(_msg,2,,1)
         ?}
      ?};

      {? _can_continue>0
      ||
         {? _b_conn=null()
         || _added:=exec('add','#b_conn',_buffer);
            {? _added<>null()
            || B_CONN.clear();
               {? B_CONN.seek(_added)
               || _env.DIA_CONNS.add(_added);

                  _args:=exec('args_xml','#xml');
                  _args.TABLE:=B_CONN;
                  _args.JAVA_OBJ:='B_CONN';
                  _args.MAX_REC:=1;
                  _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';

                  _result:=exec('record2XML','#xml',_args,_env.FIELDS);
                  {? _imported<>'1'
                  ||
::                   Jesli powiazanie wychodzi z bramy rozdzielajacej typu AND albo EVENT
::                   to tworze automatyczny B_CHOICE
                     exec('auto_choice','#b_choice',_buffer.FROM,_added);
::                   Dodanie połączeń portów dynamicznych
                     exec('add_poconn4dynamic_port','#b_valprt',B_CONN.ref())
                  ?}
               ||
                  _sym_from:=exec('FindAndGet','#table',B_PREL,_buffer.FROM,,"SYMBOL",'');
                  _sym_to:=exec('FindAndGet','#table',B_PREL,_buffer.TO,,"SYMBOL",'');
                  _msg:='Nie powiodło się znalezienie połączenia: '+_sym_from+' -> '+_sym_to;
                  KOMM.add(_msg,2,,1)
               ?}
            ||
               _sym_from:=exec('FindAndGet','#table',B_PREL,_buffer.FROM,,"SYMBOL",'');
               _sym_to:=exec('FindAndGet','#table',B_PREL,_buffer.TO,,"SYMBOL",'');
               _msg:='Nie powiodło się dodanie połączenia: '+_sym_from+' -> '+_sym_to;
               KOMM.add(_msg,2,,1)
            ?}
         ||

::          Sprawdzam czy połączenie wychodzące z bramy miało modyfikowaną przez użytkownika
::          nazwę, jeśli tak to nanoszę to do bazy po to by nie nadpisać w przyszłości tej nazwy
::          podczas automatycznego synchronizowania nazw dla połączeń wychodzących z bram
            _buffer.NAME_MOD:='N';
            exec('name_mod_update','#b_conn',_buffer);
            {? _buffer.NAME=''
            || _buffer.NAME_MOD:='N'
            ?};

            {? exec('put','#b_conn',_buffer,_b_conn)>0
            || _env.DIA_CONNS.add(_b_conn);
               _args:=exec('args_xml','#xml');
               _args.BUFFER:=_buffer;
               _args.JAVA_OBJ:='B_CONN';
               _args.MAX_REC:=1;
               _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
               _result:=exec('buffer2XML','#xml',_args)
            ||
               _sym_from:=exec('FindAndGet','#table',B_PREL,_buffer.FROM,,"SYMBOL",'');
               _sym_to:=exec('FindAndGet','#table',B_PREL,_buffer.TO,,"SYMBOL",'');
               _msg:='Nie powiodła się aktualizacja połączenia: '+_sym_from+' -> '+_sym_to;
               KOMM.add(_msg,2,,1)
            ?}
         ?}
      ?}
   ?}
?};
B_CONN.cntx_pop();
B_ELE.cntx_pop();
B_PREL.cntx_pop();
B_CHOICE.cntx_pop();
_result


\load_args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Argumenty dla funkcji ładujących diagram BPMN
::   WY: obj_new
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
:: Identyfikator kontrolki
   'CTR_ID'
:: Identyfikator modelera na pulpicie
   ,'BPMN_ID'
:: Proces którego diagram załadować
   ,'B_PROC'
:: Instancja procesu
   ,'BI_PROC'
:: Ścieżka do pliku z diagremem który załadować
   ,'FILEPATH'
:: Tytuł diagramu
   ,'TITLE'
:: Status procesu
   ,'STATUS'
:: Kolor statusu
   ,'STATUS_COLOR'
:: Czy diagram ma być dostępny do edycji
   ,'EDITABLE'
:: Czy po załadowaniu diagramu automatycznie go ułożyć
   ,'DO_LAYOUT'
:: Czy na diagramie mają być dostępne menu kontekstowe dla elemenów i strzałek
   ,'POPUP_MENU'
:: Czy ładowane podczas importu grupowego
   ,'IMPORT_GR'
:: Czy ładowane podczas exportu grupowego
   ,'EXPORT_GR'

);
_args.CTR_ID:='';
_args.BPMN_ID:='';
_args.B_PROC:=null();
_args.BI_PROC:=null();
_args.FILEPATH:='';
_args.TITLE:='';
_args.STATUS:='';
_args.STATUS_COLOR:='#666666';
_args.EDITABLE:=1;
_args.DO_LAYOUT:=0;
_args.POPUP_MENU:=1;
_args.IMPORT_GR:=0;
_args.EXPORT_GR:=0;
_args


\load_diagram4proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ładuje diagram BPMN z bazy danych do modelera
::   WE: _a - obj_new() - tablica nazwana z parametrami sterującymi ładowaniem diagramu wynik exec('load_args','#b_bpmn')
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLIC><PROCES><MODELER><YWORKS>
:: ~OST: INBLGET,INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=1;
{? exec('interm','#system')
|| FUN.emsg(exec('interm_nacc_msg','#system'));
   return(0)
?};
_separator:=exec('sep','#file');

B_PROC.cntx_psh(); B_PROC.clear();
{? B_PROC.seek(_args.B_PROC)
||
:: jest proces więc pokazuje modelera
   exec('set_visible','#desktop','',_args.CTR_ID,_args.BPMN_ID,1);
   _file:='';
   {? B_PROC.GRAPHMLZ<>null()
   || _file:=tmp_dir()+_separator+($B_PROC.tm_stamp())+'.'+B_PROC.bl_info('GRAPHMLZ','EXTENSION');
      B_PROC.bl_get('GRAPHMLZ','@'+_file,0)
   || _file:=tmp_dir()+_separator+($B_PROC.tm_stamp())+'.graphmlz'
   ?};
   _value:='';
   {? _args.DO_LAYOUT>0
   || _value:='do_layout=true;load='+_file
   || _value:='load='+_file
   ?};
   exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,_value);
:: Generuję tytuł diagramu
   {? _args.TITLE=''
   || {? _args.BI_PROC<>null()
      || _args.TITLE:=exec('record','#to_string',_args.BI_PROC,1)
      || _args.TITLE:=B_PROC.SYMBOL+' - '+B_PROC.NAME+' (wersja: '+B_PROC.VER+')'
      ?}
   ?};

:: Status
   exec('status4diagram','#b_bpmn',_args);

:: Obsługa po załadowaniu diagramu
   exec('load_after','#b_bpmn',_args);
   {? _args.EXPORT_GR=0
   || exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,'loading=false')
   ?}
||
:: Jeśli nie ma procesu to chowam modelera
   _result:=0;
   exec('set_visible','#desktop','',_args.CTR_ID,_args.BPMN_ID,0)
?};
B_PROC.cntx_pop();
_result


\append_diagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Ładuje diagram BPMN z bazy danych do modelera
::   WE: _a - obj_new() - tablica nazwana z parametrami sterującymi ładowaniem diagramu wynik exec('load_args','#b_bpmn')
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLIC><PROCES><MODELER><YWORKS>
:: ~OST: INBLGET,INFERASE,INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_args:=_a;

_result:=1;
_args.DO_LAYOUT:=1;
{? exec('interm','#system')
|| FUN.emsg(exec('interm_nacc_msg','#system'));
   return(0)
?};
_separator:=exec('sep','#file');

B_PROC.cntx_psh(); B_PROC.clear();
{? B_PROC.seek(_args.B_PROC)
||
   _file:=tmp_dir()+_separator+($B_PROC.tm_stamp())+'.graphmlz';
   {? B_PROC.GRAPHMLZ=null()
   || ferase('@'+_file)
   || B_PROC.bl_get('GRAPHMLZ','@'+_file,0)
   ?};
   _value:='';
   _value:='append_collect='+_file+';';

   _title:=B_PROC.SYMBOL+' - '+B_PROC.NAME+' (wersja: '+B_PROC.VER+')';
   _title:=gsub(_title,'\"','\"\"');
   _title:=gsub(_title,';','\";\"');
   _title:=gsub(_title,'=','\"=\"');
   _value+='append_title='+_title+';';
   _value+='append_bproc='+$B_PROC.ref();

   _current_proc:=null();
   {? ref_tab(_env.SEL_PROC)=B_PROC
   || _current_proc:=_env.SEL_PROC
   |? ref_tab(_env.SEL_PROC)=BI_PROC
   || _current_proc:=exec('FindAndGet','#table',BI_PROC,_env.SEL_PROC,,"B_PROC",null())
   ?};
   {? $B_PROC.ref()=$_current_proc
   ||
::    Proces dla którego uruchomiłem mega proces wyróżniam na diagramie kolorem
      _value+=';append_color=#27ae27'
   ?};

   exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,_value);
   ~~
|| _result:=0
?};
B_PROC.cntx_pop();
_result


\load_mega_bproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Ładuje diagram BPMN z bazy danych do modelera
::   WE: [_a] - INTEGER - [0]/1 - tryb działania: 0 - w oparciu o B_PROC
::                                                1 - w oparciu o BI_PROC
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLIC><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_mode:=0;
{? var_pres('_a')=type_of(0)
|| _mode:=_a
?};
_args:=exec('load_args','#b_bpmn');
_args.CTR_ID:=_env.ctr_id;
_args.BPMN_ID:=_env.ctr_bpmn;
_args.B_PROC:=_env.SEL_PROC;

_bproc_orginal:=_args.B_PROC;

{? var_pres('MEGA_PROCESY',_env)>100
|| obj_del(_env.MEGA_PROCESY)
?};
_env.MEGA_PROCESY:=exec('ref_table','#table');
{? _mode=0
|| exec('connected_bproc','#b_signal',_args.B_PROC,_env.MEGA_PROCESY,,_env.MEGA_RECURSIVE)
|? _mode=1
|| exec('connected_biproc','#b_signal',_args.B_PROC,_env.MEGA_PROCESY,,_env.MEGA_RECURSIVE)
?};

_tab:=_env.MEGA_PROCESY.tab;

_elements:=tab_tmp(2
   ,'UID','STRING[20]','Uid elementu'
   ,'B_PROC','STRING[16]','Proces'
   ,'SYMBOL','STRING[100]','SYMBOL'
   ,'TYPE','STRING[20]','Typ elementu'
   ,'KIND','STRING[20]','Rodzaj elementu'
   ,'CATEGORY','STRING[20]','Kategoria elementu'
   ,'B_SIGNAL','STRING[16]','Sygnał'
);
_appended:=exec('ref_table','#table');
B_PREL.cntx_psh();
B_PREL.index('PROC');
B_EVENT.cntx_psh();
B_EVENT.index('ELEMENT');
_tab.prefix();
{? _tab.first()
||
   _env.MEGA_PROCESY.add(_env.SEL_PROC);
   _tab.first();
   {!
   |?
      {? ref_tab(_tab.SQL)=B_PROC
      || _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null())
      |? ref_tab(_tab.SQL)=BI_PROC
      || _b_proc:=exec('FindAndGet','#table',BI_PROC,_tab.SQL,,"B_PROC",null())
      ?};
      {? _b_proc<>null()
      || _args.B_PROC:=_b_proc;

         {? _appended.r_find(_b_proc)=0
         || _appended.add(_b_proc);
            exec('append_diagram','#b_bpmn',_args);

            B_PREL.prefix(_b_proc,'B_EVENT');
            {? B_PREL.first()
            || {!
               |? {? B_PREL.B_SIGNAL<>null()
                  ||
                     B_EVENT.prefix(B_PREL.B_ELE);
                     {? B_EVENT.first()
                     ||
                        _elements.prefix(B_PREL.UID,$B_PREL.B_PROC);
                        {? _elements.size()=0
                        ||
                           _elements.blank();
                           _elements.UID:=B_PREL.UID;
                           _elements.SYMBOL:=B_PREL.SYMBOL;
                           _elements.TYPE:=B_EVENT.TYPE;
                           _elements.KIND:=B_EVENT.KIND;
                           _elements.CATEGORY:=B_EVENT.CATEGORY;
                           _elements.B_SIGNAL:=$B_PREL.B_SIGNAL;
                           _elements.B_PROC:=$B_PREL.B_PROC;
                           _elements.add()
                        ?}
                     ?}
                  ?};
                  B_PREL.next()
               !}
            ?}
         ?}
      ?};
      _tab.next()
   !};
   _elements.clear();

   _value:='';
   _value:='append_execute=true';
   exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,_value);
:: Czekam aż się wszystko wczyta
   _can_continue:=1;
   _it:=1;
   {!
   |?
      delay(,100);
      _res:=exec('get_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,'append_size');
      {? _res='0'
      || _can_continue:=0
      ?};
      _it+=1;
      echo('Wczytywanie: %1'@[$_it]);
      _can_continue>0
   !};

:: Jak się wczytało to generuję strzałki
   exec('connections_generator_bproc','#b_bpmn',_elements,_args.CTR_ID,_args.BPMN_ID);

:: Strzałki wygenerowane więc układam
   _value:='layout=true';
   exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,_value);

:: Czekam aż się ułoży
   _can_continue:=1;
   _it:=1;
   {!
   |?
      delay(,100);
      _res:=exec('get_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,'layouting');
      {? _res='false'
      || _can_continue:=0
      ?};
      _it+=1;
     echo('Układanie: %1'@[$_it]);
      _can_continue>0
   !};

   _env.MEGA_LOADED:=1;
   {? _mode=1
   || exec('refresh_element','#desktop','',_args.CTR_ID,_args.BPMN_ID)
   ?};

   exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,'loading=false');

:: Generuję tytuł diagramu
   {? _args.TITLE=''
   || _args.TITLE:=B_PROC.SYMBOL+' - '+B_PROC.NAME+' (wersja: '+B_PROC.VER+')'
   ?};

:: Obsługa po załadowaniu diagramu
   exec('load_after','#b_bpmn',_args)

||
:: Jeśli nie ma żadnych powiązanych procesów to chowam modelera żeby nie kusił
   exec('set_visible','#desktop','',_args.CTR_ID,'',0);
   FUN.info('Brak powiązanych procesów.'@);
   sel_exit()
?};
B_PREL.cntx_pop();
B_EVENT.cntx_pop();
1


\status4diagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Ustawia napis dla statusu wyświetlany na ekranie
::   WE: _a - obj_new() - tablica nazwana z parametrami sterującymi ładowaniem diagramu wynik exec('load_args','#b_bpmn')
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

B_PROC.get();
{? _args.STATUS=''
|| {? B_PROC.MODIFIED='N' & B_PROC.TM_IMP>0
   || _args.STATUS:='Standardowy'@;
      _args.STATUS_COLOR:='#009933'
   |? B_PROC.MODIFIED='T'
   || _args.STATUS:='Zmodyfikowany'@;
      _args.STATUS_COLOR:='#cc0000'
   ?}
?};
~~


\load_imported4proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ładuje diagram BPMN z bazy danych do modelera i od razu rozpoczyna jego import zamiast
::       normalnego ładowania (używane w ścieżce grupowego importu procesów)
::   WE: _a - obj_new() - tablica nazwana z parametrami sterującymi ładowaniem diagramu wynik exec('load_args','#b_bpmn')
::       _b - INTEGER - 0/1 - czy wywoływać funkcję import w kontrolce modelera?
::                            potrzebne do lepszej synchronizacji wątków w grupowym imporcie

::   WY: '' lub ścieżka do pliku graphml na terminalu który należy zaimportować
::  TAG: <PUBLIC><PROCES><MODELER><YWORKS>
:: ~OST: INBLGET,INFERASE,INFOPEN,INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_do_import:=_b;

_result:='';
_can_continue:=1;

_separator:=exec('sep','#file');
{? exec('interm','#system')
|| FUN.emsg(exec('interm_nacc_msg','#system'));
   return('')
?};

B_PROC.cntx_psh(); B_PROC.clear();
{? B_PROC.seek(_args.B_PROC)
||
   {? _args.IMPORT_GR=0
   || FUN.info('Proces pochodzi z grupowego importu. Aby móc go używać wymagany jest jego zapis.'@)
   ?};
:: jest proces więc pokazuje modelera
   exec('set_visible','#desktop','',_args.CTR_ID,_args.BPMN_ID,1);
   _file_imp:=tmp_dir()+_separator+($B_PROC.tm_stamp())+'.graphml';
   _filename:=tmp_dir()+_separator+($B_PROC.tm_stamp())+'.graphmlz';
   {? B_PROC.IMEX_GML=null()
   || _can_continue:=ferase('@'+_file_imp)
   || _can_continue:=B_PROC.bl_get('IMEX_GML','@'+_file_imp,0)
   ?};

   {? _can_continue>0
   || _result:=_file_imp;
      _file:=fopen('@'+_filename,'Uw',0,1);
      {? _file>0
      ||
         _value:='set_filepath='+_filename;
         fclose(_file);
         exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,_value)
      ?};
      {? _do_import>0
      || _value:='import='+_file_imp;
         exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,_value);
::       Generuję tytuł diagramu
         {? _args.TITLE=''
         || _args.TITLE:=B_PROC.SYMBOL+' - '+B_PROC.NAME+' (wersja: '+B_PROC.VER+')'
         ?};

::       Obsługa po załadowaniu diagramu
         exec('load_after','#b_bpmn',_args)
      ?}
   ?}
||
:: Jeśli nie ma procesu to chowam modelera
   _result:=0;
   exec('set_visible','#desktop','',_args.CTR_ID,_args.BPMN_ID,0)
?};
B_PROC.cntx_pop();
_result


\load_bidiagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [17.00]
:: OPIS: Ładuje diagram BPMN z bazy danych do modelera
::   WE: _a - obj_new() - tablica nazwana z parametrami sterującymi ładowaniem diagramu wynik exec('load_args','#b_bpmn')
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLIC><PROCES><MODELER><YWORKS>
:: ~OST: INBLGET,INFERASE,INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=1;

_separator:=exec('sep','#file');
{? exec('interm','#system')
|| FUN.emsg(exec('interm_nacc_msg','#system'));
   return(0)
?};
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID'); BI_PROC.clear();
{? BI_PROC.seek(_args.B_PROC)
||
:: jest proces więc pokazuje modelera
   exec('set_visible','#desktop','',_args.CTR_ID,_args.BPMN_ID,1);
   _file:=tmp_dir()+_separator+($BI_PROC.tm_stamp())+'.graphml';
   {? BI_PROC.GRAPHML=null()
   || ferase('@'+_file)
   || BI_PROC.bl_get('GRAPHML','@'+_file,0)
   ?};
   _value:='show=true';
   {? _args.DO_LAYOUT>0
   || _value+=';loading_icon=blocks';
      _value+=';loading_text=Układanie diagramu...';
      _value+=';adjustSizes=true';
      _value+=';do_layout=true;load='+_file
   || _value:=';load='+_file
   ?};

   exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,_value);

:: Generuję tytuł diagramu
   BI_PROC.B_PROC();
   {? _args.TITLE=''
   || _args.TITLE:=exec('BI_PROC','#to_string',1)
   ?};
:: Obsługa po załadowaniu diagramu
   exec('load_after','#b_bpmn',_args)
||
:: Jeśli nie ma procesu to chowam modelera
   _result:=0;
   exec('set_visible','#desktop','',_args.CTR_ID,_args.BPMN_ID,0)
?};
BI_PROC.cntx_pop();
_result


\load_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Obsługa modelera po załadowaniu diagramu
::   WE: _a - obj_new() - tablica nazwana z parametrami sterującymi ładowaniem diagramu wynik exec('load_args','#b_bpmn')
::       [_b] - INTEGER - [0]/1 - zawsze ustawiaj status, nawet jak pusty
::  TAG: <PUBLIC><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_force_status:=0;
{? var_pres('_b')=type_of(0)
|| _force_status:=_b
?};

_commands:='';
:: ustawiam tytuł diagramu jeśli podany
{? _args.TITLE<>''
|| _args.TITLE:=gsub(_args.TITLE,'\"','\"\"');
   _args.TITLE:=gsub(_args.TITLE,';','\";\"');
   _args.TITLE:=gsub(_args.TITLE,'=','\"=\"');
   _commands+='title='+_args.TITLE+';'
?};
{? _args.EDITABLE=0
|| _commands+='editable=none;'
?};
{? _args.POPUP_MENU=0
|| _commands+='popup_menu=false;'
?};
{? _args.STATUS<>''
||
   _args.STATUS:=gsub(_args.STATUS,'\"','\"\"');
   _args.STATUS:=gsub(_args.STATUS,';','\";\"');
   _args.STATUS:=gsub(_args.STATUS,'=','\"=\"');
   _commands+='status='+_args.STATUS+';';
   {? _args.STATUS_COLOR<>''
   || _commands+='statusColor='+_args.STATUS_COLOR+';'
   ?}
?};
{? _commands<>''
|| exec('set_value','#desktop','',_args.CTR_ID,_args.BPMN_ID,_commands)
?};
~~


\event_bele
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie
::   WE: _a - STRING - typ zdarzenia
::       _b - STRING - rodzaj zdarzenia
::       [_c] - STRING - kategoria zdarzenia (musi być określone dla zdarzenia typu pośredniego)
::   WY: STRING - XML reprezentujący dany rekord
::  TAG: <PRIVATE><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=_a;
_kind:=_b;
{? var_pres('_c')=type_of('')
|| _category:=_c
|? _kind=exec('type_start','#b_event')
|| _category:=exec('category_catch','#b_event')
|? _kind=exec('type_end','#b_event')
|| _category:=exec('category_throw','#b_event')
|| _category:=''
?};

_result:='';

B_ELE.cntx_psh();
B_EVENT.cntx_psh();
B_EVENT.index('TYP');
B_EVENT.prefix(_type,_kind,_category);
{? B_EVENT.first()
|| B_EVENT.B_ELE();
   _buffer:=exec('B_ELE','#buffer');
   _buffer.get();
   _args:=exec('args_xml','#xml');
   _args.BUFFER:=_buffer;
   _args.JAVA_OBJ:='B_ELE';
   _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
   _result:=exec('buffer2XML','#xml',_args)
?};
B_EVENT.cntx_pop();
B_ELE.cntx_pop();
_result


\event_bele_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie startowe nieokreślone
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_start','#b_event');
_kind:=exec('kind_none','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind);
_result


\event_bele_start_timer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie startowe czasowe
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_start','#b_event');
_kind:=exec('kind_timer','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind);
_result


\event_bele_start_signal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie startowe sygnałowe
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_start','#b_event');
_kind:=exec('kind_signal','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind);
_result


\event_bele_start_cond
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie startowe warunkowe
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_start','#b_event');
_kind:=exec('kind_condition','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind);
_result


\event_bele_inter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie pośrednie nieokreślone
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_intermed','#b_event');
_kind:=exec('kind_none','#b_event');
_category:=exec('category_throw','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind,_category);
_result


\event_bele_inter_timer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie pośrednie czasowe
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_intermed','#b_event');
_kind:=exec('kind_timer','#b_event');
_category:=exec('category_catch','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind,_category);
_result


\event_bele_inter_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie pośrednie czasowe
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_intermed','#b_event');
_kind:=exec('kind_message','#b_event');
_category:=exec('category_throw','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind,_category);
_result


\event_bele_inter_sig_catch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie pośrednie sygnałowe łapiące
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_intermed','#b_event');
_kind:=exec('kind_signal','#b_event');
_category:=exec('category_catch','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind,_category);
_result


\event_bele_inter_sig_throw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie pośrednie sygnałowe rzucające
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_intermed','#b_event');
_kind:=exec('kind_signal','#b_event');
_category:=exec('category_throw','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind,_category);
_result


\event_bele_inter_cond
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie pośrednie warunkowe
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_intermed','#b_event');
_kind:=exec('kind_condition','#b_event');
_category:=exec('category_catch','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind,_category);
_result


\event_bele_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie końcowe nieokreślone
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_end','#b_event');
_kind:=exec('kind_none','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind);
_result


\event_bele_end_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie końcowe wysyłające wiadomość
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_end','#b_event');
_kind:=exec('kind_message','#b_event');
_cat:=exec('category_throw','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind,_cat);
_result


\event_bele_end_signal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący zdarzenie końcowe wysyłające sygnał
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_end','#b_event');
_kind:=exec('kind_signal','#b_event');
_cat:=exec('category_throw','#b_event');
_result:=exec('event_bele','#b_bpmn',_type,_kind,_cat);
_result


\gate_bele
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący bramę
::   WE: _a - STRING - typ bramy
::       [_b] - STRING - rodzaj bramy, jeśli nie podany to pyta
::   WY: STRING - XML reprezentujący dany rekord
::  TAG: <PRIVATE><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=_a;
_kind:='';
{? var_pres('_b')=type_of('')
|| _kind:=_b
?};

_result:='';
_can_continue:=1;

{? _kind=''
|| _choice:=FUN.choice('Wybierz rodzaj bramy'@,,'Rozdzielająca <'@,'Zbierająca >'@);
   {? _choice>0
   || _kind:='';
      {? _choice=1
      || _kind:=exec('kind_split','#b_gate')
      |? _choice=2
      || _kind:=exec('kind_merge','#b_gate')
      ?}
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
||
   B_ELE.cntx_psh();
   B_GATE.cntx_psh();
   B_GATE.index('TYP');
   B_GATE.prefix(_type,_kind);
   {? B_GATE.first()
   || B_GATE.B_ELE();
      _buffer:=exec('B_ELE','#buffer');
      _buffer.get();
      _args:=exec('args_xml','#xml');
      _args.BUFFER:=_buffer;
      _args.JAVA_OBJ:='B_ELE';
      _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';

      _result:=exec('buffer2XML','#xml',_args)
   ?};
   B_GATE.cntx_pop();
   B_ELE.cntx_pop()
?};
_result


\gate_bele_and
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący bramę AND
::   WE: [_a] - B_PREL.UID - jeśli podany to rodzaj bramy zostanie odczytany z tego B_PRELa
::             (ma zastosowanie podczas zmiany typu bramy)
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_prel_uid:='';
{? var_pres('_a')=type_of('')
|| _prel_uid:=_a
?};
_gatekind:='';
{? _prel_uid<>''
|| B_PREL.cntx_psh();
   B_PREL.index('UID');
   B_PREL.prefix(_env.SEL_PROC,_prel_uid,);
   {? B_PREL.first()
   || _gatekind:=B_PREL.GATEKIND
   ?};
   B_PREL.cntx_pop()
?};

_type:=exec('type_and','#b_gate');
_result:=exec('gate_bele','#b_bpmn',_type,_gatekind);
_result


\gate_bele_xor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący bramę XOR
::   WE: [_a] - B_PREL.UID - jeśli podany to rodzaj bramy zostanie odczytany z tego B_PRELa
::             (ma zastosowanie podczas zmiany typu bramy)
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_prel_uid:='';
{? var_pres('_a')=type_of('')
|| _prel_uid:=_a
?};
_gatekind:='';
{? _prel_uid<>''
|| B_PREL.cntx_psh();
   B_PREL.index('UID');
   B_PREL.prefix(_env.SEL_PROC,_prel_uid,);
   {? B_PREL.first()
   || _gatekind:=B_PREL.GATEKIND
   ?};
   B_PREL.cntx_pop()
?};
_type:=exec('type_xor','#b_gate');
_result:=exec('gate_bele','#b_bpmn',_type,_gatekind);
_result


\gate_bele_or
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący bramę OR
::   WE: [_a] - B_PREL.UID - jeśli podany to rodzaj bramy zostanie odczytany z tego B_PRELa
::             (ma zastosowanie podczas zmiany typu bramy)
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_prel_uid:='';
{? var_pres('_a')=type_of('')
|| _prel_uid:=_a
?};
_gatekind:='';
{? _prel_uid<>''
|| B_PREL.cntx_psh();
   B_PREL.index('UID');
   B_PREL.prefix(_env.SEL_PROC,_prel_uid,);
   {? B_PREL.first()
   || _gatekind:=B_PREL.GATEKIND
   ?};
   B_PREL.cntx_pop()
?};
_type:=exec('type_or','#b_gate');
_result:=exec('gate_bele','#b_bpmn',_type,_gatekind);
_result


\gate_bele_event_inter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący bramę sterowaną zdarzeniami pośrednimi
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_event','#b_gate');
_result:=exec('gate_bele','#b_bpmn',_type,exec('kind_split','#b_gate'));
_result


\gate_bele_event_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący bramę wykluczającą sterowaną zdarzeniami startowymi
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_xor_event','#b_gate');
_result:=exec('gate_bele','#b_bpmn',_type,exec('kind_merge','#b_gate'));
_result


\gate_bele_complex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący bramę złożoną
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_type:=exec('type_complex','#b_gate');
_result:=exec('gate_bele','#b_bpmn',_type,exec('kind_merge','#b_gate'));
_result


\not_on_diagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprząta te elementy procesu których już nie ma na diagramie.
::       Wykonywane po zapisie diagramu, bazuje na tabelce z refami elementów które się udało przetworzyć z diagramu
::   WE: _a - B_PROC.ref() - proces któremu sprzątać
::       _b - obj_new - tablica refów zawierająca istniejące elementy diagramu - wynik exec('ref_table','#table')
::       _c - obj_new - tablica refów zawierająca istniejące połączenia diagramu - wynik exec('ref_table','#table')
::       [_d] - STRING - '0'/'1' - oznacza czy można usuwać role nawet na zaakeceptowanym procesie
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML><DEL>
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;
_dia_prels:=_b;
_dia_conns:=_c;

_del_role:='0';
{? var_pres('_d')=type_of('')
|| _del_role:=_d
?};

_result:=0;
_can_continue:=1;

B_PREL.cntx_psh();
B_PREL.index('SYMBOL');
B_PREL.prefix(_b_proc);
{? B_PREL.first()
|| {!
   |? _next:=0;
      _ref_nxt:=null();
      B_PREL.cntx_psh();
      {? B_PREL.next()
      || _ref_nxt:=B_PREL.ref()
      ?};
      B_PREL.cntx_pop();

::    Sprawdzam czy element był przetwarzany na diagramie
      {? _dia_prels.r_find(B_PREL.ref())=0
      ||
         _chk_akc:=1;
         {? B_PREL.CLASS='B_LANE' & _del_role='1'
         || _chk_akc:=0
         ?};
::       Nie ma go na diagramie więc tnę z bazy
         _can_continue:=exec('delete','#b_prel',B_PREL.ref(),1,_chk_akc,0)
      ?};
      {? _ref_nxt<>null()
      || _next:=B_PREL.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};
B_PREL.cntx_pop();

B_CONN.cntx_psh();
B_CONN.index('PROC');
B_CONN.prefix(_b_proc);
{? B_CONN.first()
|| {!
   |? _next:=0;
      _ref_nxt:=null();
      B_CONN.cntx_psh();
      {? B_CONN.next()
      || _ref_nxt:=B_CONN.ref()
      ?};
      B_CONN.cntx_pop();

::    Sprawdzam czy połączenie było przetwarzane na diagramie
      {? _dia_conns.r_find(B_CONN.ref())=0
      ||
::       Nie ma go na diagramie więc tnę z bazy
         _can_continue:=exec('delete','#b_conn',B_CONN.ref(),1)
      ?};

      {? _ref_nxt<>null()
      || _next:=B_CONN.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};
B_CONN.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\conn_bele_simple
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca rekord B_ELE reprezentujący połączenie proste (przepływ sekwencji)
::   WY: STRING - XML reprezentujący wybrany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><XML>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
B_ELE.cntx_psh();
B_ELE.index('CLASSSYM');
B_ELE.prefix('B_CONN','Połączenie proste');
{? B_ELE.first()
|| _args:=exec('args_xml','#xml');
   _args.TABLE:=B_ELE;
   _args.JAVA_OBJ:='B_ELE';
   _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
   _result:=exec('record2XML','#xml',_args)
?};
B_ELE.cntx_pop();
_result


\save_diagram_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Zapisz' w menu modelera i jako przycisk
::   WE:
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><AKCJA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_result:=0;

{? _env.SAVING=0
|| _env.SAVING:=1;
:: Usuwam wszystkie informacje dotyczące weryfikacji
   _env.TAB_KOMM.erase();
   _env.TAB_ACTROL_DEL.erase();
   exec('verify_info_push','#b_bpmn');

   _wyn:=exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'save');
   {? _wyn<>''
   || _result:=1
   ?}
?};
_result


\diagram_changed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła wykonywana każdorazowo po dokonaniu jakiejś zmiany na diagramie
::   WE: _a - STRING - rodzaj zmiany (kod zdarzenia yWorks)
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><ADD>
::----------------------------------------------------------------------------------------------------------------------
{? type_of(params_get())>100
||
   _env:=params_get().env;
   params_set(params_get());

   {? _env.MEGA_PROC=0
   ||
      _env.TM_MOD:=exec('create','#tm_stamp');
      {? _env.WIN_BPMN<>''
      || exec('update_mod_icon','#b_bpmn')
      ?}
   ?}
?};
~~


\update_mod_icon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Na podstawie tm_stampów modyfikacji i zapisu aktualnego procesu zapala lub gasi ikonkę
::       mówiącą że diagram niezapisany
::   WE: [_a] - tab_tmp - tabelka tymczasowa z elementami panelplusa
::       [_b] - INTEGER - czy wysyłać zaktualizowane elementy do panelplusa, czy nie
::  TAG: <PRYWATNA><PROCES><MODELER><YWORKS><ADD>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

{? var_pres('_a')>100
|| _elements:=_a
|| _elements:=exec('elements_table','#desktop')
?};

_update:=1;
{? var_pres('_b')=type_of(0)
|| _update:=_b
?};

B_PROC.get();
{? _env.TM_MOD>B_PROC.TM_SAVE
||
:: Są niezapisane zmiany - pokazuję ikonkę
   exec('set_visible_grp','#desktop','',_env.ctr_id,_env.ctr_dirty,1,_elements);

:: Jeśli proces zaakceptowany, to włączam przycisk zapisz
   {? B_PROC.ACCEPTED='T'
   || exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_save,1,_elements);
      B_PROC.actions_grayed(_env.WIN_BPMN,'AF')
   ?};
   ~~
||
:: Wszystkie zmiany zapisane - gaszę ikonkę
   exec('set_visible_grp','#desktop','',_env.ctr_id,_env.ctr_dirty,0,_elements)
?};
:: Aktualizuje panelplus
{? _update>0
|| exec('update','#desktop',_elements,_env.ctr_id)
?};
~~


\update_status4diagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Wymusza aktualizację statusu na diagramie (Standardowy/Zmodyfikowany)
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_args:=exec('load_args','#b_bpmn');
_args.CTR_ID:=_env.ctr_id;
_args.BPMN_ID:=_env.ctr_bpmn;
_args.B_PROC:=_env.SEL_PROC;
exec('status4diagram','#b_bpmn',_args);
exec('load_after','#b_bpmn',_args,1);
~~


\modeler_akc_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja akceptacji procesu w oknie modelera
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><AKCJA><AKCEPTACJA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

{? _env.TM_MOD>B_PROC.TM_SAVE
|| _msg:='Istnieją niezapisane zmiany na diagramie. Przed akceptacją procesu wymagany jest jego zapis.';
   _choice:=FUN.choice(_msg,,'Zapisz i akceptuj');
   {? _choice=1
   || _env.AFTER_SAVE_FML:="  params_exec('proc_akc_act','#b_design');
                              params_exec('update_accept_status','#b_bpmn');
                              ~~";
      exec('save_diagram_act','#b_bpmn')
   ?}
|| exec('proc_akc_act','#b_design');
   exec('update_accept_status','#b_bpmn')
?};
~~


\modeler_wyc_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja wycofania akceptacji procesu w oknie modelera
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><AKCJA><AKCEPTACJA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

exec('proc_wyc_act','#b_design');
exec('update_accept_status','#b_bpmn');
~~


\modeler_verify_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja weryfikacji procesu w oknie modelera
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><AKCJA><AKCEPTACJA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

{? _env.TM_MOD>B_PROC.TM_SAVE
|| _msg:='Istnieją niezapisane zmiany na diagramie. Przed weryfikacją procesu wymagany jest jego zapis.';
   _choice:=FUN.choice(_msg,,'Zapisz i weryfikuj');
   {? _choice=1
   || _env.AFTER_SAVE_FML:="params_exec('proc_verify_act','#b_design')";
      exec('save_diagram_act','#b_bpmn')
   ?}
|| exec('proc_verify_act','#b_design')
?};
~~


\properties4element
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja właściwości w menu popup elementu procesu
::   WE: _a STRING - B_PREL.UID - identyfikator elementu procesu
::       [_b] - STRING - $B_PROC.ref - proces w którym szukać elementu, jeśli nie podany to z _env.SEL_PROC
::   WY: STRING - XML reprezentujący zaktualizowany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><AKCJA><REDAKCJA>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;

_b_proc:='';
{? var_pres('_b')=type_of('')
|| _b_proc:=_b
?};

_env:=params_get().env;
params_set(params_get());

_result:='';
B_PROC.cntx_psh();
B_PREL.cntx_psh();
B_PREL.index('UID');
{? _uid<>''
||
   _proc:=null();
   _inst:=0;
   {? _env.SEL_PROC<>null() & ref_tab(_env.SEL_PROC)=BI_PROC
   || _inst:=1
   ?};
   {? _b_proc<>''
   || _proc:=exec('FindAndGet','#table',B_PROC,_b_proc,,,null())
   ||
      {? ref_tab(_env.SEL_PROC)=BI_PROC
      || _inst:=1;
         _proc:=exec('FindAndGet','#table',BI_PROC,_env.SEL_PROC,,"B_PROC",null())
      |? ref_tab(_env.SEL_PROC)=B_PROC
      || _proc:=_env.SEL_PROC
      ?}
   ?};
   B_PREL.prefix(_proc,_uid,);
   {? B_PREL.first()
   ||
      {? _env.TM_MOD>B_PROC.TM_SAVE
      || _msg:='Istnieją niezapisane zmiany na diagramie. Przed wyświetleniem właściwości elementu wymagany jest zapis procesu.';
         _choice:=FUN.choice(_msg,,'Zapisz i pokaż właściwości');
         {? _choice=1
         || _env.AFTER_SAVE_FML:="params_exec('properties4element','#b_bpmn',_a)";
            _env.AFTER_SAVE_ARG:=_uid;
            exec('save_diagram_act','#b_bpmn')
         ?}
      || B_PREL.cntx_psh();

         _b_prel:=B_PREL.ref();
::       Przed wyświetleniem właściwości zapamiętuję bufor elementu
         _buf_before:=exec('buffer','#b_prel');
         _buf_before.get();

         _adres:=exec('dokuwiki_address','#b_bpmn',_uid,0);
         {? _adres<>''
         || set_help(_adres)
         ?};

         exec('properties','#b_design',B_PREL.ref(),_env.LOCKED,_inst);

::       Po wyświetleniu właściwości tworzę bufor elementu
         _buf_after:=exec('buffer','#b_prel');
         _buf_after.cntx_get(_b_prel);

::       Porównuję oba bufory, jeżeli coś się zmieniło to zapalam wykrzyknik o zmianach
         _compare:=exec('compare','#table',_buf_before,_buf_after,0,'AUTOMAT','ENABLED');
         {? _compare=0
         || exec('diagram_changed','#b_bpmn')
         ?};
         {? exec('chk_out_names','#b_gate',B_PREL.ref())>0 & B_PREL.B_PROC().ACCEPTED<>'T'
         ||
::          Dla bram rozdzielającej typu innego niż and uruchamiam po wyświetleniu własności synchronizację
::          nazw dla strzałek wychodzących na podstawie zdefiniowanych warunków
            _uid:=gsub(B_PREL.UID,'\"','\"\"');
            _uid:=gsub(_uid,';','\";\"');
            _uid:=gsub(_uid,'=','\"=\"');
            _command:='gateNames='+_uid;
            _command+=' ;defaultConn='+_uid;
            _wyn:=exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,_command)
         ?};

::       Uruchamiam aktualizację elementu na diagramie - w ten sposób zawsze poprawnie zostanie odświeżony,
::       nawet jeśli najpierw nastąpił automatyczny zapis i zmieniły się jakieś jego właściwości
         _uid:=gsub(B_PREL.UID,';','\";\"');
         _uid:=gsub(_uid,'=','\"=\"');
         _command:='fetch='+_uid;
         _wyn:=exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,_command);

         B_PREL.cntx_pop()
      ?};
      B_PREL.get();
      _args:=exec('args_xml','#xml');
      _args.TABLE:=B_PREL;
      _args.JAVA_OBJ:='B_PREL';
      _args.MAX_REC:=2;
      _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
      _result:=exec('record2XML','#xml',_args,_env.FIELDS)
   || FUN.info('Nie znaleziono elementu w bazie danych.'@)
   ?}
|| FUN.info('Element niezapisany w bazie danych. Aby wyświetlić jego właściwości należy najpierw zapisać diagram.'@)
?};
B_PREL.cntx_pop();
B_PROC.cntx_pop();
_result


\properties4conn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja właściwości w menu popup połączenia elementów procesu
::   WE: _a STRING - B_CONN.UID - identyfikator połączenia
::       [_b] - STRING - $B_PROC.ref - proces w którym szukać elementu, jeśli nie podany to z _env.SEL_PROC
::   WY: STRING - XML reprezentujący zaktualizowany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><AKCJA><REDAKCJA>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;

_b_proc:='';
{? var_pres('_b')=type_of('')
|| _b_proc:=_b
?};

_env:=params_get().env;
params_set(params_get());

_result:='';

B_CONN.cntx_psh();
B_CONN.index('UID');
{? _uid<>''
||
   _inst:=0;
   {? _env.SEL_PROC<>null() & ref_tab(_env.SEL_PROC)=BI_PROC
   || _inst:=1
   ?};
   _proc:=null();
   {? _b_proc<>''
   || _proc:=exec('FindAndGet','#table',B_PROC,_b_proc,,,null())
   ||
      {? ref_tab(_env.SEL_PROC)=BI_PROC
      || _inst:=1;
         _proc:=exec('FindAndGet','#table',BI_PROC,_env.SEL_PROC,,"B_PROC",null())
      |? ref_tab(_env.SEL_PROC)=B_PROC
      || _proc:=_env.SEL_PROC
      ?}
   ?};
   B_CONN.prefix(_proc,_uid);
   {? B_CONN.first()
   || {? _env.TM_MOD>B_PROC.TM_SAVE
      || _msg:='Istnieją niezapisane zmiany na diagramie. Przed wyświetleniem właściwości połączenia wymagany jest zapis procesu.'@;
         _choice:=FUN.choice(_msg,,'Zapisz i pokaż właściwości'@);
         {? _choice=1
         || _env.AFTER_SAVE_FML:="params_exec('properties4conn','#b_bpmn',_a)";
            _env.AFTER_SAVE_ARG:=_uid;
            exec('save_diagram_act','#b_bpmn')
         ?}
      || B_CONN.cntx_psh();
         exec('properties','#b_design',B_CONN.ref(),_env.LOCKED,_inst);
         B_CONN.cntx_pop()
      ?};
      _args:=exec('args_xml','#xml');
      _args.TABLE:=B_CONN;
      _args.JAVA_OBJ:='B_CONN';
      _args.MAX_REC:=2;
      _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
      _result:=exec('record2XML','#xml',_args,_env.FIELDS)
   || FUN.info('Nie znaleziono połączenia w bazie danych.'@)
   ?}
|| FUN.info('Połączenie niezapisane w bazie danych. Aby wyświetlić jego właściwości należy najpierw zapisać diagram.'@)
?};
B_CONN.cntx_pop();
_result


\set_property
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja ustawiania właśności z graficznego modelera
::   WE: _a - STRING - B_PREL.UID - identyfikator elementu procesu
::       _b - STRING - nazwa własności
::       _c - STRING - nowa wartość własności
::   WY: STRING - XML reprezentujący zaktualizowany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><AKCJA><REDAKCJA><WŁAŚCIWOŚCI>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;
_property:=_b;
_value:=_c;

_env:=params_get().env;
params_set(params_get());

_result:='';

_buffer:=exec('buffer','#b_prel');

B_PREL.cntx_psh();
B_PREL.index('UID');
{? _uid<>''
|| B_PREL.prefix(_env.SEL_PROC,_uid,);
   {? B_PREL.first()
   || _buffer.get();

      {? _property='AUTOMAT'
      || exec('automat_setter','#b_bpmn',_buffer,_value)
      |? _property='TYPE'
      || exec('type_setter','#b_bpmn',_buffer,_value)
      |? _property='ENABLED'
      || exec('enabled_setter','#b_bpmn',_buffer,_value)
      ?};
      exec('diagram_changed','#b_bpmn',_property);
      exec('put','#b_prel',_buffer);
      _args:=exec('args_xml','#xml');
      _args.TABLE:=B_PREL;
      _args.JAVA_OBJ:='B_PREL';
      _args.MAX_REC:=2;
      _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
      _result:=exec('record2XML','#xml',_args,_env.FIELDS)
   || FUN.info('Nie znaleziono elementu w bazie danych.'@)
   ?}
|| FUN.info('Element niezapisany w bazie danych. Aby zmienić jego właściwości należy najpierw zapisać diagram.'@)
?};
B_PREL.cntx_pop();
_result


\fetch_prel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca na diagram rekord B_PRELa
::   WE: _a - STRING - B_PREL.UID - identyfikator elementu procesu
::       [_b] - STRING - $B_PROC.ref - proces w którym szukać elementu, jeśli nie podany to z _env.SEL_PROC
::   WY: STRING - XML reprezentujący rekord B_PREL
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><ZASILANIE>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;

_b_proc:='';
{? var_pres('_b')=type_of('')
|| _b_proc:=_b
?};

_result:='';

_env:=params_get().env;
params_set(params_get());

_buffer:=exec('buffer','#b_prel');

B_PREL.cntx_psh();
B_PREL.index('UID');

BI_PROC.cntx_psh();
{? _b_proc<>''
|| _sel_proc:=exec('FindAndGet','#table',B_PROC,_b_proc,,,null())
||
:: SEL_PROC czasem zwraca refa do BI_PROC, a czasem B_PROC, jeżeli zwróci BI_PROC
:: to podmieniam go w tym miejscu na B_PROC, żeby znaleźć elementy procesu.
   {? 4+$_env.SEL_PROC='bi_p'
   || BI_PROC.seek(_env.SEL_PROC);
      _sel_proc:=BI_PROC.B_PROC().ref()
   || _sel_proc:=_env.SEL_PROC
   ?}
?};
BI_PROC.cntx_pop();

{? _uid<>''
|| B_PREL.prefix(_sel_proc,_uid,);
   {? B_PREL.first()
   ||
      _args:=exec('args_xml','#xml');
      _args.TABLE:=B_PREL;
      _args.JAVA_OBJ:='B_PREL';
      _args.MAX_REC:=2;
      _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
      _result:=exec('record2XML','#xml',_args,_env.FIELDS)
   || FUN.info('Nie znaleziono elementu w bazie danych.'@)
   ?}
?};
B_PREL.cntx_pop();
_result


\automat_setter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ustawia pole AUTOMAT na podstawie przekazanego stringa
::   WE: _a - obj_new - bufor tabeli B_PREL
::       _b - STRING - 'T','N' - czy czynność ma być uruchamiana automatycznie
::       [_c] - INTEGER - 0/[1] - czy wyświetlać dialogi
::  TAG: <PRYWATNA><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_buffer:=_a;
_value:=_b;

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

B_ACTION.cntx_psh();
B_ACTION.index('B_ELE');
B_ACTION.prefix(_buffer.B_ELE);

{? B_ACTION.first()
|| {? B_ACTION.AUTOMAT='T'
   || {? _buffer.AUTOMAT='M' | _buffer.AUTOMAT='N'
      || {? _value='T'
         || _buffer.AUTOMAT:='T';
            _buffer.ASSIGNTD:='T'
         || _buffer.AUTOMAT:='M'
         ?}
      |? _buffer.AUTOMAT='T'
      || {? _value<>'T'
         || _buffer.AUTOMAT:='M'
         ?}
      ?}
   || {? _dialog>0
      || FUN.info('Opcja dostępna dla czynności automatycznych.'@)
      ?};
      _buffer.AUTOMAT:='N'
   ?}
?};
B_ACTION.cntx_pop();
~~


\access_setter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ustawia pole FMACCESS na podstawie przekazanego stringa
::   WE: _a - obj_new - bufor tabeli B_PREL
::  TAG: <PRYWATNA><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_buffer:=_a;

B_ACTION.cntx_psh();
B_ACTION.index('B_ELE');
B_ACTION.prefix(_buffer.B_ELE);

{? B_ACTION.first()
|| _buffer.FMACCESS:=B_ACTION.FMACCESS
?};
B_ACTION.cntx_pop();
~~


\loop_setter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ustawia pole LOOP na podstawie przekazanego stringa
::   WE: _a - obj_new - bufor tabeli B_PREL
::  TAG: <PRYWATNA><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_buffer:=_a;

B_ACTION.cntx_psh();
B_ACTION.index('B_ELE');
B_ACTION.prefix(_buffer.B_ELE);

{? B_ACTION.first()
|| _buffer.LOOP:=B_ACTION.LOOP
?};
B_ACTION.cntx_pop();
~~


\type_setter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ustawia pole TYPE na podstawie przekazanego stringa
::   WE: _a - obj_new - bufor tabeli B_PREL
::       _b - STRING - 'S','U','M','E' - czy czynność Serwisowa czy Użytkownika, (M)Ręczna, (E)wysłania
::       [_c] - INTEGER - 0/[1] - czy wyświetlać dialogi
::  TAG: <PRYWATNA><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_buffer:=_a;
_value:=_b;

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

B_ACTION.cntx_psh();
B_ACTION.index('B_ELE');
B_ACTION.prefix(_buffer.B_ELE);

{? B_ACTION.first()
|| {? B_ACTION.SERVICE='T'
   || {? _value='U'
      || _buffer.TYPE:='U';
         _buffer.B_WORKER:=null()
      |? _value='S'
      || _buffer.TYPE:='S';
         exec('automat_setter','#b_bpmn',_buffer,'N',0)
      || _buffer.TYPE:=_value
      ?}
   || {? _dialog>0
      || FUN.info('Opcja dostępna dla czynności serwisowych.'@)
      ?};
      {? B_ACTION.MANUAL='T'
      || _buffer.TYPE:='M';
         _buffer.B_CAN:='M'
      || _buffer.TYPE:=_value
      ?}
   ?}
?};
B_ACTION.cntx_pop();
~~


\enabled_setter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Ustawia pole ENABLED na podstawie przekazanego stringa
::   WE: _a - obj_new - bufor tabeli B_PREL
::       _b - STRING - 'T'/'N'
::       [_c] - INTEGER - 0/[1] - czy wyświetlać dialogi
::  TAG: <PRYWATNA><PROCES><MODELER><YWORKS>
::----------------------------------------------------------------------------------------------------------------------
_buffer:=_a;
_value:=_b;

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

_allow:=0;
_kind:=exec('kind_signal','#b_event');
{? _buffer.CLASS='B_EVENT' & exec('is_event','#b_event',_buffer.B_ELE,,_kind)
|| _allow:=1
?};
{? _allow=0
|| _kind:=exec('kind_timer','#b_event');
   {? _buffer.CLASS='B_EVENT' & exec('is_event','#b_event',_buffer.B_ELE,,_kind)
   || _allow:=1
   ?}
?};

{? _allow>0
|| _buffer.ENABLED:=_value;

   _kind:=exec('kind_timer','#b_event');
   {? exec('is_event','#b_event',_buffer.B_ELE,,_kind)
   ||
::    Dla zdarzeń z zegarkiem dodatkowa obsługa nawijająca tabelę B_TIMER
      {? _value='T'
      || B_PREL.cntx_psh(); B_PREL.prefix();
         {? B_PREL.seek(_buffer.Ref)
         || exec('btn_on','#b_timer',0)
         ?};
         B_PREL.cntx_pop()
      |? _value='N'
      || B_PREL.cntx_psh(); B_PREL.prefix();
         {? B_PREL.seek(_buffer.Ref)
         || exec('btn_off','#b_timer',0)
         ?};
         B_PREL.cntx_pop()
      ?}
   ?};
   ~~
|| {? _dialog>0
   || FUN.emsg('Opcja dostępna tylko dla zdarzeń sygnałowych i czasowych'@)
   ?}
?};
~~


\update_accept_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Uaktualnia stan: edycja/podgląd modelera na podstawie stanu akceptacji procesu
::   WE: [_a] - tab_tmp - tabelka tymczasowa z elementami panelplusa
::       [_b] - INTEGER - czy wysyłać zaktualizowane elementy do panelplusa, czy nie
::  TAG: <PRYWATNA><MODELER><PROCES>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;

{? var_pres('_a')>100
|| _elements:=_a
|| _elements:=exec('elements_table','#desktop')
?};

_update:=1;
{? var_pres('_b')=type_of(0)
|| _update:=_b
?};

params_set(params_get());
B_PROC.cntx_psh(); B_PROC.clear();
{? B_PROC.seek(_env.SEL_PROC)
||
:: Sprawdzam czy użytkownik ma rolę uprawniającą do modelowania procesów
   _user_upr:=exec('chk_role','#b__box',OPERATOR.USER,'ZPR_PRO_MODE') |
              exec('chk_role','#b__box',OPERATOR.USER,'ZPR_PRO_MODW');
   _actions:='';
   {? _user_upr=0 | _env.LOCKED=0
   ||
::    Brak uprawnień lub edytowany przez kogoś więc w modelerze włączam widok tylko do odczytu
      exec('set_value_grp','#desktop','',_env.ctr_id,_env.ctr_bpmn,'editable=none',,_elements);
      exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_save,0,_elements);
      exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_accept,0,_elements);
      exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_verify,0,_elements);
      _actions:='ZAF';

      B_PROC.hdr_ctr();
      B_PROC.hdr_ctr(' — PODGLĄD');

      ~~
   |? B_PROC.ACCEPTED='T' & _user_upr=1 & _env.LOCKED=1
   ||
::    Proces dostępny do częściowej edycji
      exec('set_value_grp','#desktop','',_env.ctr_id,_env.ctr_bpmn,'editable=simple',,_elements);
      exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_save,0,_elements);
      exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_accept,0,_elements);
      exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_verify,0,_elements);
      _actions:='ZAF';
      B_PROC.hdr_ctr();
      ~~
   |? B_PROC.ACCEPTED='N' & _user_upr=1 & _env.LOCKED=1
   ||
::    Proces dostępny do pełnej edycji
      exec('set_value_grp','#desktop','',_env.ctr_id,_env.ctr_bpmn,'editable=full',,_elements);
      exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_save,1,_elements);
      exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_accept,1,_elements);
      exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_verify,1,_elements);

      B_PROC.hdr_ctr();
      ~~
   ?};
:: Steruję przyciskiem wycofaj
   {? _user_upr>0 & _env.LOCKED>0 & B_PROC.ACCEPTED='T'
   || exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_wyc,1,_elements)
   || exec('set_enabled_grp','#desktop','',_env.ctr_id,_env.ctr_wyc,0,_elements);
      _actions+='W'
   ?};
:: Steruję akcjami w oknie
   B_PROC.actions_grayed(_env.WIN_BPMN,_actions);

:: Aktualizuje panelplus
   {? _update>0
   || exec('update','#desktop',_elements,_env.ctr_id)
   ?};
   ~~
?};
B_PROC.cntx_pop();
~~


\gate_choices
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca warunki na bramie w postaci vectora XML
::   WE: _a - STRING - B_PREL.UID - identyfikator elementu procesu
::   WY: STRING - XML reprezentujący rekordy B_CHOICE
::  TAG: <PUBLICZNA><PROCES><MODELER><YWORKS><XML><ZASILANIE>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;
_env:=params_get().env;
params_set(params_get());

_result:='';

B_PREL.cntx_psh();
B_PREL.index('UID');
{? _uid<>''
|| B_PREL.prefix(_env.SEL_PROC,_uid,);
   {? B_PREL.first()
   ||
      B_CHOICE.cntx_psh();
      B_CHOICE.index('B_PREL');
      B_CHOICE.prefix(B_PREL.ref());
      {? B_CHOICE.first()
      ||
         _tab:=obj_new(B_CHOICE.size());
         {! _it:=1..B_CHOICE.size()
         |! _tab[_it]:=''
         !};

         _args:=exec('args_xml','#xml');
         _args.TABLE:=B_CHOICE;
         _args.JAVA_OBJ:='B_CHOICE';
         _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
         _args.PROLOG:=1;
         _args.MAX_REC:=1;
         _it:=1;
         {!
         |?
            obj_del(_args.CONVERTED);
            _args.CONVERTED:=exec('ref_table','#table');
            _record:=exec('record2XML','#xml',_args,_env.FIELDS);
            {? _record<>''
            || _tab[_it]:=_record
            ?};
            _it+=1;
            B_CHOICE.next()
         !};

::       Mam warunki w tablicy, przekształcam tę tablicę w wektor
         _result+='<?xml version=\"1.0\" encoding=\"UTF-8\" ?>';
         _result+='<java class=\"java.beans.XMLDecoder\">\n';
         _result+=exec('vector','#xml','',_tab,1,0);
         _result+='</java>\n'
      ?};
      B_CHOICE.cntx_pop();
      ~~
   || FUN.info('Nie znaleziono elementu w bazie danych.'@)
   ?}
|| FUN.info('Brama niezapisana w bazie danych. Aby pobrać jej warunki należy najpierw zapisać diagram.'@)
?};
B_PREL.cntx_pop();
_result


\instance_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca definicję tabeli tymczasowej przesyłającej do modelera info o instancjach
::   WY: tab_tmp
::  TAG: <DESKTOP>
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(2,
:: 'POLE','TYP','Nazwa w oknie',
   'UID','STRING[15]','Unikalny identyfikator elementu'@
   ,'B_PROC','STRING[16]','Proces'@
   ,'BI_PREL','STRING[16]','Instancja elementu'@
   ,'TYPE','STRING[20]','Typ elementu'@
   ,'SYMBOL','STRING[100]','Symbol elementu'@
   ,'C_LINE','STRING[11]','Kolor linii'@
   ,'C_FILL1','STRING[11]','Kolor wypełnienia 1'@
   ,'C_FILL2','STRING[11]','Kolor wypełnienia 2'@
   ,'C_TEXT','STRING[11]','Kolor tekstu'@
   ,'C_ICON','STRING[11]','Kolor ikony'@
   ,'INFO_ON','STRING[1]','Czy wyświetlać dod. info'@
   ,'INFO_COL','STRING[11]','Kolor wypełnienia info'@
   ,'INFO_TXT','STRING[10]','Tekst info'@
   ,'SELECTED','STRING[1]','Czy zaznaczyć element'@
   ,'DASHED','STRING[1]','Czy element ma mieć ramkę przerywaną'@
   ,'LINE_W','REAL','Szerokość obramówiki'@
   ,'BLINK','STRING[1]','Czy mrugnąć danym elementem'@
   ,'SIZE','REAL','Liczba instancji'@
   ,'PENDING','REAL','Liczba instancji uruchomionych'@
   ,'TIP_NAME','STRING[100]','Nazwa sekcji w dymku'@
   ,'TOOLTIP','STRING[255]','Treść dymka'@
   ,'C_TIP','STRING[11]','Kolor tekstu dymka'@
   ,'REV_SYM','STRING[1]','Czy wycofywać zmiany symbolu'@
   ,'REV_LINE','STRING[1]','Czy wycofywać zmiany linii'@
   ,'REV_FIL1','STRING[1]','Czy wycofywać zmiany koloru wyp'@
   ,'REV_FIL2','STRING[1]','Czy wycofywać zmiany koloru wyp'@
   ,'REV_COLT','STRING[1]','Czy wycofywać zmiany koloru tekstu'@
   ,'REV_COLI','STRING[1]','Czy wycofywać zmiany koloru ikony'@
);
_tab


\instance_buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca tablicę nazwaną przesyłającą do modelera info o instancjach
::   WY: tab_tmp
::  TAG: <DESKTOP>
::----------------------------------------------------------------------------------------------------------------------
_buffer:=obj_new(
   'Ref'
   ,'UID'
   ,'TYPE'
   ,'SYMBOL'
   ,'C_LINE'
   ,'C_FILL1'
   ,'C_FILL2'
   ,'C_TEXT'
   ,'C_ICON'
   ,'INFO_ON'
   ,'INFO_COL'
   ,'INFO_TXT'
   ,'SELECTED'
   ,'DASHED'
   ,'LINE_W'
   ,'BLINK'
   ,'SIZE'
   ,'PENDING'
   ,'TOOLTIP'
   ,'C_TIP'
   ,'REV_SYM'
   ,'REV_LINE'
   ,'REV_FIL1'
   ,'REV_FIL2'
   ,'REV_COLT'
   ,'REV_COLI'
   ,'B_PROCES'
   ,'BI_PREL'

   ,'types'
   ,'acronyms'
   ,'ref'
);
_buffer.Ref:='';
_buffer.UID:='';
_buffer.TYPE:='';
_buffer.SYMBOL:='';
_buffer.C_LINE:='';
_buffer.C_FILL1:='';
_buffer.C_FILL2:='';
_buffer.C_TEXT:='';
_buffer.C_ICON:='';
_buffer.INFO_ON:='';
_buffer.INFO_COL:='';
_buffer.INFO_TXT:='';
_buffer.SELECTED:='';
_buffer.DASHED:='';
_buffer.LINE_W:=0;
_buffer.BLINK:='';
_buffer.SIZE:=0;
_buffer.PENDING:=0;
_buffer.TOOLTIP:='';
_buffer.C_TIP:='';
_buffer.B_PROCES:='';
_buffer.BI_PREL:='';

_buffer.acronyms:="
                   _tab:=obj_new(28);
                   _tab[1]:='Ref';
                   _tab[2]:='UID';
                   _tab[3]:='TYPE';
                   _tab[4]:='SYMBOL';
                   _tab[5]:='C_LINE';
                   _tab[6]:='C_FILL1';
                   _tab[7]:='C_FILL2';
                   _tab[8]:='C_TEXT';
                   _tab[9]:='C_ICON';
                   _tab[10]:='INFO_ON';
                   _tab[11]:='INFO_COL';
                   _tab[12]:='INFO_TXT';
                   _tab[13]:='SELECTED';
                   _tab[14]:='DASHED';
                   _tab[15]:='LINE_W';
                   _tab[16]:='BLINK';
                   _tab[17]:='SIZE';
                   _tab[18]:='PENDING';
                   _tab[19]:='TOOLTIP';
                   _tab[20]:='C_TIP';
                   _tab[21]:='REV_SYM';
                   _tab[22]:='REV_LINE';
                   _tab[23]:='REV_FIL1';
                   _tab[24]:='REV_FIL2';
                   _tab[25]:='REV_COLT';
                   _tab[26]:='REV_COLI';
                   _tab[27]:='B_PROC';
                   _tab[28]:='BI_PREL';
                   _tab
                  ";

_buffer.types:="
                   _tab:=obj_new(28);
                   _tab[1]:='STRING';
                   _tab[2]:='STRING';
                   _tab[3]:='STRING';
                   _tab[4]:='STRING';
                   _tab[5]:='STRING';
                   _tab[6]:='STRING';
                   _tab[7]:='STRING';
                   _tab[8]:='STRING';
                   _tab[9]:='STRING';
                   _tab[10]:='STRING';
                   _tab[11]:='STRING';
                   _tab[12]:='STRING';
                   _tab[13]:='STRING';
                   _tab[14]:='STRING';
                   _tab[15]:='REAL';
                   _tab[16]:='STRING';
                   _tab[17]:='REAL';
                   _tab[18]:='REAL';
                   _tab[19]:='STRING';
                   _tab[20]:='STRING';
                   _tab[21]:='STRING';
                   _tab[22]:='STRING';
                   _tab[23]:='STRING';
                   _tab[24]:='STRING';
                   _tab[25]:='STRING';
                   _tab[26]:='STRING';
                   _tab[27]:='STRING';
                   _tab[28]:='STRING';
                _tab
               ";
_buffer.ref:="null()";
_buffer


\instance_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Funkcja wywoływana na sztywno z modelera BPMN, po załadowaniu pulpitu z modelerem uruchamia wczytywanie
::       informacji o instancji/instancjach
::  TAG: <DESKTOP>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_tab:=exec('instance_tab','#b_bpmn');

{? _env.MODE_INST='SINGLE'
|| _inst:=exec('ref_table','#table');
   _inst.add(_env.SEL_PROC);
   exec('instance_fill_single','#b_bpmn',_tab,_inst,_env.SEL_PREL)
|? _env.MODE_INST='GROUP'
|| exec('instance_fill_group','#b_bpmn',_tab,_env.SEL_PROC)
|? _env.MODE_INST='MEGA'
|| {? _env.MEGA_LOADED>0
   ||
::    Jak wszystkie procesy na mega procesie wczytane, dopiero uruchamiam wczytywanie info o instancjach
      exec('instance_fill_single','#b_bpmn',_tab,_env.MEGA_PROCESY,_env.SEL_PREL)
   ?}
?};
_tab


\instance_fill_single
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wypełnia tablicę informacji o instancjach pojedynczą instancją.
::       Tablica jest przekazywaną do modelera, który ją przetwarza i nanosi te informacje na diagram.
::   WE: _a - tab_tmp() - tablica którą zasilić. Wynik działania exec('instance_tab','#b_bpmn')
::       _b - ref_table - tablica instancji procesów
::       [_c] - B_PREL.ref() - element który zaznaczyć
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_tab:=_a;
::_bi_proc:=_b;
_ref_table_inst:=_b;

_sel_prel:=null();
{? var_pres('_c')=type_of(B_PREL.ref())
|| _sel_prel:=_c
?};

_tab.cntx_psh();
BI_CONN.cntx_psh(); {? BI_CONN.name()='' || BI_CONN.use('bi_c____') ?};
BI_CONN.index('B_CONN2');
B_PREL.cntx_psh();
BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?}; BI_PREL.index('TM_BORN');
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID'); BI_PROC.clear();
B_PROC.cntx_psh();

_gray:='192:192:192';
_green:='39:174:39';
_white:='255:255:255';
_tab_inst:=_ref_table_inst.tab;
_tab_inst.cntx_psh();
{? _tab_inst.first()
|| {!
   |?
      {? BI_PROC.seek(_tab_inst.SQL)
      ||
::       Analiza elementów procesu
         B_PREL.index('PREL');
         B_PREL.prefix(BI_PROC.B_PROC);
         {? B_PREL.first()
         ||
::          Iteracja po definicji procesu
            {!
            |?
               _tab.prefix(B_PREL.UID,$B_PREL.B_PROC);
               _new:=0;
               {? _tab.first()=0
               ||
::                Nie ma jeszcze takiego elementu, zakładam nowy
                  _tab.blank();
                  _new:=1;
                  _tab.B_PROC:=$B_PREL.B_PROC;
                  _tab.UID:=B_PREL.UID;
                  _tab.TYPE:='NODE';
                  _tab.C_FILL1:=_white;
                  ~~
               ?};

               {? _sel_prel<>null() & _sel_prel=B_PREL.ref()
               || _tab.SELECTED:='T'
               ?};
               BI_PREL.index('TM_BORN');
               BI_PREL.prefix(BI_PROC.ref(),B_PREL.ref());
               {? BI_PREL.first()
               ||
::                Są instancje
                  _tab.SIZE+=BI_PREL.size();

::                Wypełniam ref pierwszej instancji procesu
                  {? _tab.BI_PREL=''
                  || _tab.BI_PREL:=$BI_PREL.ref()
                  ?};

::                Sprawdzam czy są uruchomione lub oczekujące instancje
                  _pending:=0;
                  BI_PREL.index('PREL');
                  BI_PREL.prefix(BI_PROC.ref(),B_PREL.ref(),exec('OCZEKUJACA','#bi_stat'));
                  {? BI_PREL.size()>0
                  || _pending:=BI_PREL.size()
                  ?};
                  {? _pending=0
                  || BI_PREL.prefix(BI_PROC.ref(),B_PREL.ref(),exec('URUCHOMIONA','#bi_stat'));
                     {? BI_PREL.size()>0
                     || _pending+=BI_PREL.size()
                     ?}
                  ?};
                  {? _pending=0
                  || BI_PREL.prefix(BI_PROC.ref(),B_PREL.ref(),exec('FL_CANCEL','#bi_stat'));
                     {? BI_PREL.size()>0
                     || _pending+=BI_PREL.size()
                     ?}
                  ?};
                  _tab.PENDING+=_pending
               ?};

               {? _tab.SIZE>0
               ||
::                Są instancje
                  _tab.INFO_ON:='T';
                  _tab.INFO_COL:='255:204:0';
                  _tab.C_LINE:=exec('color_line_all','#bi_prel',B_PREL.ref(),_ref_table_inst,'MBASE','')
               ||
::                Brak instancji
                  _tab.C_LINE:=_gray;
                  _tab.C_TEXT:=_gray;
                  _tab.C_ICON:=_gray
               ?};

               {? _tab.PENDING>0
               || _tab.INFO_TXT:=$_tab.SIZE+'/'+$_tab.PENDING
               || _tab.INFO_TXT:=$_tab.SIZE
               ?};

               {? _new
               || _tab.add()
               || _tab.put()
               ?};
               B_PREL.next()
            !}
         ?};

::       Analiza połączeń
         B_CONN.cntx_psh();
         B_CONN.index('UID');
         B_CONN.prefix(BI_PROC.B_PROC);
         {? B_CONN.first()
         || {!
            |?
               _tab.prefix(B_CONN.UID,$B_CONN.B_PROC);
               _new:=0;
               {? _tab.first()=0
               || _new:=1;
::                Nie ma jeszcze takiego elementu, zakładam nowy
                  _tab.blank();
                  _tab.B_PROC:=$B_CONN.B_PROC;
                  _tab.UID:=B_CONN.UID;
                  _tab.TYPE:='EDGE'
               ?};
               BI_CONN.prefix(BI_PROC.ref(),B_CONN.ref());
               _tab.SIZE+=BI_CONN.size();

               {? _tab.SIZE>0
               ||
::                Są instancje
                  _tab.C_LINE:='';
                  _tab.C_TEXT:=''
               ||
::                Brak instancji
                  _tab.C_LINE:=_gray;
                  _tab.C_TEXT:=_gray
               ?};
               {? _new>0
               || _tab.add()
               || _tab.put()
               ?};
               B_CONN.next()
            !}
         ?};
         B_CONN.cntx_pop();
         ~~
      ?};
      _tab_inst.next()
   !}
?};
_tab_inst.cntx_pop();
_tab.cntx_pop();
_tab.prefix();
B_PROC.cntx_pop();
BI_PROC.cntx_pop();
BI_PREL.cntx_pop();
B_PREL.cntx_pop();
BI_CONN.cntx_pop();
~~


\instance_fill_group
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wypełnia tablicę informacji o instancjach wszystkimi zakończonymi instancjami danego procesu
::       Tablica jest przekazywaną do modelera, który ją przetwarza i nanosi te informacje na diagram.
::   WE: _a - tab_tmp() - tablica którą zasilić. Wynik działania exec('instance_tab','#b_bpmn')
::       _b - B_PROC.ref() - proces który analizować
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_tab:=_a;
_b_proc:=_b;

_tab.cntx_psh();
BI_CONN.cntx_psh(); {? BI_CONN.name()='' || BI_CONN.use('bi_c____') ?};
BI_CONN.index('B_CONN2');
B_PREL.cntx_psh();
BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?};
BI_PREL.index('PREL3');
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('PROSTAN');
BI_PROC.prefix();
B_PROC.cntx_psh();
B_PROC.prefix();

_green_min:=0;
_green_max:=204;
_gray:='192:192:192';

{? B_PROC.seek(_b_proc)
||
:: Najpierw sprawdzam ile w ogóle jest instancji tego procesu o statusie zakończona
   BI_PROC.prefix(B_PROC.ref(),exec('ZAKONCZONY','#bi_stat'));
   _biproc_size:=BI_PROC.size();

   {? _biproc_size>0
   ||
::    Analiza elementów procesu
      B_PREL.index('PREL');
      B_PREL.prefix(B_PROC.ref());
      {? B_PREL.first()
      ||
::       Iteracja po definicji procesu
         {!
         |?
            _tab.blank();
            _tab.B_PROC:=$B_PREL.B_PROC;
            _tab.UID:=B_PREL.UID;
            _tab.TYPE:='NODE';

::          Prefiksuje instancje elementu, ale tylko dla zakończonych procesów
            BI_PREL.prefix(B_PREL.ref(),exec('ZAKONCZONY','#bi_stat'));
            {? BI_PREL.first()
            ||
::             Są instancje
               _tab.INFO_ON:='T';
               _tab.INFO_COL:='255:204:0';
               _tab.INFO_TXT:=$BI_PREL.size()
            ||
::             Brak instancji
               _tab.C_LINE:=_gray;
               _tab.C_TEXT:=_gray;
               _tab.C_ICON:=_gray
            ?};
            _tab.add();
            B_PREL.next()
         !}
      ?};

      _tab_pop:=tab_tmp(1,
         'COEF','REAL','Wspólczynnik popularności'@,
         'KOLOR','STRING[11]','Kolor dla danego współczynnika'@
      );

      _tab_flow:=tab_tmp(1,
         'UID','STRING[16]','UID połączenia'@,
         'FLOWS','REAL','Czy przeszło czy nie w danej instancji procesu'@
      );


::    Analiza połączeń
      B_CONN.cntx_psh();
      B_CONN.index('UID');
      B_CONN.prefix(B_PROC.ref());

      {? BI_PROC.first()
      || {!
         |?
            {? B_CONN.first()
            || {!
               |?
                  BI_CONN.prefix(BI_PROC.ref(),B_CONN.ref());
                  {? BI_CONN.size()>0
                  ||
::                   Przeszło co najmniej raz
                     _tab_flow.prefix(B_CONN.UID);
                     {? _tab_flow.first()
                     || _tab_flow.FLOWS+=1;
                        _tab_flow.put()
                     || _tab_flow.blank();
                        _tab_flow.UID:=B_CONN.UID;
                        _tab_flow.FLOWS:=1;
                        _tab_flow.add()
                     ?}
                  ?};
                  B_CONN.next()
               !}
            ?};
            BI_PROC.next()
         !}
      ?};
      _tab_flow.prefix();

      {? B_CONN.first()
      || {!
         |?
            _tab.blank();
            _tab.B_PROC:=$B_CONN.B_PROC;
            _tab.UID:=B_CONN.UID;
            _tab.TYPE:='EDGE';

::          Prefiksuje instancje połączenia
            _tab_flow.prefix(B_CONN.UID);

            BI_CONN.prefix(B_CONN.ref(),exec('ZAKONCZONY','#bi_stat'));
            {? _tab_flow.first()
            ||
::             Są instancje

::             W zależności od ilości instancji połączenia względem ilości instancji całego
::             procesu buduję kolor strzałki. Najjaśniejszy zielony to ścieżka najbardziej popularna
::             Najciemniejszy zielony to ścieżka najmniej popularna
               _popularity:=_tab_flow.FLOWS/_biproc_size;
               _tab.SIZE:=_popularity;
               _tab.SYMBOL:=B_CONN.NAME+'\n('+$((_popularity*100)$0)+' %)';
               _tab_pop.prefix(_popularity);
               {? _tab_pop.size()=0
               || _tab_pop.blank();
                  _tab_pop.COEF:=_popularity;
                  _tab_pop.add()
               ?}
            ||
::             Brak instancji
               _tab.C_LINE:=_gray;
               _tab.C_TEXT:=_gray
            ?};
            _tab.add();
            B_CONN.next()
         !}
      ?};
      B_CONN.cntx_pop();

      _tab.prefix();
      _tab_pop.prefix();

::    Buduje kolory dla każdej popularności
      _it:=0;
      {? _tab_pop.first()
      || _pop_size:=_tab_pop.size();
         _it:=_pop_size-1;
         {? _pop_size>1
         ||
            {!
            |?
               _krok:=(_green_max-_green_min)/(_pop_size-1);

::             Wyznaczam składnik koloru zielonego
               _rgb:=(_green_min+(_krok*_it))$0;

::             Normalizuje ten składnik
               _rgb:=exec('min','#math',_rgb,_green_max);
               _rgb:=exec('max','#math',_rgb,_green_min);

               _tab_pop.KOLOR:='255:'+$_rgb+':0';
               _tab_pop.put();

               _it-=1;
               _tab_pop.next()
            !}
         || _tab_pop.KOLOR:='255:'+$_green_max+':0';
            _tab_pop.put()
         ?}
      ?};

      B_CONN.prefix(B_PROC.ref());
      {? B_CONN.first()
      || {!
         |?
            _tab_flow.prefix(B_CONN.UID);
            {? _tab_flow.first()
            ||
               _tab.prefix(B_CONN.UID);
               {? _tab.first()
               ||
                  _tab_pop.prefix(_tab.SIZE);
                  {? _tab_pop.first()
                  || _tab.C_LINE:=_tab_pop.KOLOR;
                     _tab.put()
                  ?}
               ?}
            ?};
            B_CONN.next()
         !}
      ?}
   ?};
   ~~
?};
B_PROC.cntx_pop();
BI_PROC.cntx_pop();
BI_PREL.cntx_pop();
B_PREL.cntx_pop();
BI_CONN.cntx_pop();
_tab.cntx_pop();
_tab.prefix();
~~


\fetch_default_choice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca
::   WE: _a - STRING - B_PREL.UID - identyfikator elementu procesu
::   WY: STRING - XML reprezentujący rekord B_CONN
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;
_env:=params_get().env;
params_set(params_get());

_result:='';

B_PREL.cntx_psh();
B_PREL.index('UID');
{? _uid<>''
|| B_PREL.prefix(_env.SEL_PROC,_uid,);
   {? B_PREL.first()
   ||
      B_CONN.cntx_psh();
      B_CONN.index('FROM');
      B_CONN.prefix(_env.SEL_PROC,B_PREL.ref(),'T');
      {? B_CONN.first()
      || _args:=exec('args_xml','#xml');
         _args.TABLE:=B_CONN;
         _args.JAVA_OBJ:='B_CONN';
         _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';
         _result:=exec('record2XML','#xml',_args,_env.FIELDS)
      ?};
      B_CONN.cntx_pop();
      ~~
   || FUN.info('Nie znaleziono elementu w bazie danych.'@)
   ?}
|| FUN.info('Brama niezapisana w bazie danych. Aby pobrać jej warunki należy najpierw zapisać diagram.'@)
?};
B_PREL.cntx_pop();
_result


\after_layout
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła wykonywana po ułożeniu diagramu w podglądzie instancji, wywoływana z wnętrza kontrolki modelera
::  TAG: <DESKTOP>
::----------------------------------------------------------------------------------------------------------------------
_env:=__INST_2;
_command:='loading=false';
exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,_command);
grp_disp(_env.BI_PREL.TAB,_env.BI_PREL.WER,1);
~~


\after_selection
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła wykonywana po ułożeniu diagramu w podglądzie instancji, wywoływana z wnętrza kontrolki modelera
::   WE: _a - STRING - symbol zaznaczonego elementu
::  TAG: <DESKTOP>
::----------------------------------------------------------------------------------------------------------------------
_env:=__INST_2;

_symbol:=_a;
_tab:=_env.BI_PREL.TAB;

_id:='';
_split:=spli_str(_symbol,'Id: ');
{? obj_len(_split)>0
|| _split2:=spli_str(_split[2],'\n');
   {? obj_len(_split2)>0
   ||
      _id:=form(_split2[1])
   ?};
   ~~
?};
{? _id<>''
|| _ref:=null();
   _tab.cntx_psh();
   _tab.prefix(_id);
   {? _tab.first()
   || _ref:=_tab.ref()
   ?};
   _tab.cntx_pop();
   {? _ref<>null()
   || {? _tab.f_active()>0
      || _tab.f_seek(_ref)
      || _tab.seek(_ref)
      ?}
   ?}
?};
_env.sel_graph:=0;
grp_disp(_env.BI_PREL.TAB,_env.BI_PREL.WER,1);
_env.sel_graph:=1;
~~


\timer_inst
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wywoływane przez timer w desktopie. Uruchamia odświeżenie informacji o instancji na wyświetlanym diagramie
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_can_refresh:=1;
{? _env.PROC_STAT<>null() & _env.MEGA_PROC=0
|| {? _env.PROC_STAT<>exec('URUCHOMIONY','#bi_stat')
   || _can_refresh:=0
   ?}
?};

{? _can_refresh>0
||
   exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'process_info_revert=true',0);
   exec('refresh_element','#desktop','',_env.ctr_id,_env.ctr_bpmn)
?};
~~


\filter_diagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS:
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=__INST_2;

_tab:=_env.BI_PREL.TAB;

_result:=exec('instance_tab','#b_bpmn');
_tab.cntx_psh();
{? _tab.f_active()>0
|| _gray:='192:192:192';
   {? _tab.first()
   ||
      {!
      |? _result.blank();
         _result.TYPE:='NODE';
         _result.UID:=_tab.CODE;
         {? _tab.f_test>0
         || _result.C_LINE:='255:0:0';
            _result.DASHED:='N';
            _result.C_FILL1:='218:218:218';
            _result.C_FILL2:='218:218:218';
            _result.BLINK:='T'
         || _result.C_LINE:=_gray;
            _result.C_TEXT:=_gray
         ?};
         _result.add();
         _tab.next()
      !}
   ?}
?};
_tab.cntx_pop();
_result.clear();
_result


\verify_info_pull
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wysyła na diagram informacje o weryfikacji - formuła uruchamiana z desktop
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_tab:=exec('instance_tab','#b_bpmn');

_tab.cntx_psh();
_tab.clear();
_komm:=_env.TAB_KOMM;
_komm.clear();
{? _komm.size()>0
|| {? _komm.first()
   || {!
      |? _tab.prefix(_komm.UID);
         {? _tab.first()
         ||
            _tab.TOOLTIP+='\n'+_komm.MSG;
            _tab.put()
         ||
            _tab.blank();
            _tab.REV_SYM:='N';
            _tab.TYPE:=_komm.TYP;
            _tab.UID:=_komm.UID;
            _tab.C_LINE:=_komm.KOLOR;
            _tab.LINE_W:=3;
            _tab.TOOLTIP:=_komm.MSG;
            _tab.TIP_NAME:='Kategorie komunikatów weryfikacji:';


            _komm.cntx_psh();
            _komm.prefix(_tab.UID);
            _tab.INFO_ON:='T';
            _tab.INFO_TXT:=$_komm.size();
            _tab.INFO_COL:=_komm.KOLOR;
            _komm.cntx_pop();

            {? _komm.KIND=0
            ||
::             Błąd
               _tab.C_TIP:=exec('dec2hex','#color','255:102:102')
            |? _komm.KIND=1
            ||
::             Ostrzeżenie
               _tab.C_TIP:=exec('dec2hex','#color','255:204:51')
            |? _komm.KIND=2
            ||
::             Info
               _tab.C_TIP:=exec('dec2hex','#color','102:204:255')
            ?};
            _tab.add()
         ?};
         {? +_tab.TOOLTIP=255
         || _tab.TOOLTIP:=_tab.TOOLTIP-3;
            _tab.TOOLTIP+='...';
            _tab.put()
         ?};
         _komm.next()
      !}
   ?}
?};
_tab.cntx_pop();
_tab


\verify_info_push
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Nanosi na diagram informacje o weryfikacji procesu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;

exec('set_value','#desktop','','b_design',_env.ctr_bpmn,'process_info_revert=true');
exec('refresh_element','#desktop','','b_design',_env.ctr_bpmn);
~~


\action_parameters
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja parametry w menu popup czynności
::   WE: _a STRING - B_PREL.UID - identyfikator elementu procesu
::   WY: STRING - XML reprezentujący zaktualizowany rekord
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><AKCJA><REDAKCJA>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;
_env:=params_get().env;
params_set(params_get());

_result:='';
B_PROC.cntx_psh();
B_PREL.cntx_psh();
B_PREL.index('UID');
{? _uid<>''
||
   _proc:=null();
   {? ref_tab(_env.SEL_PROC)=BI_PROC
   || _proc:=exec('FindAndGet','#table',BI_PROC,_env.SEL_PROC,,"B_PROC",null())
   |? ref_tab(_env.SEL_PROC)=B_PROC
   || _proc:=_env.SEL_PROC
   ?};
   B_PREL.prefix(_proc,_uid,);
   B_PREL.prefix(_proc,_uid,);
   {? B_PREL.first()
   || {? B_PREL.CLASS='B_ACTION'
      ||
         B_ACTION.cntx_psh();
         B_ACTION.index('B_ELE');
         B_ACTION.prefix(B_PREL.B_ELE);
         {? B_ACTION.first()
         || exec('b_action_ports','#b_action')
         ?};
         B_ACTION.cntx_pop()
      || FUN.emsg('Parametry dostępne tylko dla czynności.'@)
      ?}
   ?}
?};
B_PREL.cntx_pop();
B_PROC.cntx_pop();
_result


\check_role
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy w systemie jest rola o podanym symbolu
::   WE: STRING - nazwa roli
::   WY: '0' - nie ma
::       '1' - jest
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_role:=_a;

_result:='0';

B_ROLE.cntx_psh();
B_ROLE.index('UNIK');
B_ROLE.prefix(REF.FIRMA,_role);
{? B_ROLE.first()
|| _result:='1'
?};
B_ROLE.cntx_pop();
_result


\dokuwiki_node
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja dokumentacja w menu popup elementu procesu
::   WE: _a - STRING - B_PREL.UID - identyfikator elementu procesu
::       [_b] - STRING - $B_PROC.ref - proces w którym szukać elementu, jeśli nie podany to z _env.SEL_PROC
::  TAG: <DESKTOP><PROCES><MODELER><YWORKS><AKCJA><REDAKCJA>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;

_b_proc:='';
{? var_pres('_b')=type_of('')
|| _b_proc:=_b
?};

_env:=params_get().env;
params_set(params_get());

_adres:=exec('dokuwiki_address','#b_bpmn',_uid,,_b_proc);

{? _adres<>''
|| exec('browser_launch','#help',_adres)
?};
~~


\dokuwiki_address
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca adres dokuwiki dla elementu procesu
::   WE: _a - STRING - B_PREL.UID - identyfikator elementu procesu
::       [_b] - INTEGER - 0/[1] - czy wyślwietlać dialogi o błędach
::       [_c] - STRING - $B_PROC.ref - proces w którym szukać elementu, jeśli nie podany to z _env.SEL_PROC
::   WY: STRING -  adres dokuwiki lub ''
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;

_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_b_proc:='';
{? var_pres('_c')=type_of('')
|| _b_proc:=_c
?};

_env:=params_get().env;
params_set(params_get());

B_PROC.cntx_psh();
B_PREL.cntx_psh();
B_PREL.index('UID');

_adres:='';
_modeler_base:=exec('set_help','#help','ZPR_PRO_MODE');

{? _uid<>''
||
   {? _modeler_base<>exec('default_address','#help')
   ||
      {? _uid='pool'
      || _adres:=_modeler_base+'_basen'
      ||
         _proc:=null();

         {? _b_proc<>''
         || _proc:=exec('FindAndGet','#table',B_PROC,_b_proc,,,null())
         ||
            {? ref_tab(_env.SEL_PROC)=BI_PROC
            || _proc:=exec('FindAndGet','#table',BI_PROC,_env.SEL_PROC,,"B_PROC",null())
            |? ref_tab(_env.SEL_PROC)=B_PROC
            || _proc:=_env.SEL_PROC
            ?}
         ?};
         B_PREL.prefix(_proc,_uid,);
         {? B_PREL.first() & _modeler_base<>''
         || {? B_PREL.CLASS='B_ACTION'
            ||
::             Czynność
               B_ACTION.cntx_psh();
               B_ACTION.index('B_ELE');
               B_ACTION.prefix(B_PREL.B_ELE);
               {? B_ACTION.first()
               || _adres:=exec('set_help','#help',B_ACTION.UID)
               ?};
               B_ACTION.cntx_pop()
            |? B_PREL.CLASS='B_EVENT'
            ||
::             Zdarzenie
               {? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_start','#b_event'),exec('kind_none','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_start_n'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_start','#b_event'),exec('kind_timer','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_start_c'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_start','#b_event'),exec('kind_condition','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_start_w'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_start','#b_event'),exec('kind_signal','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_start_os'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_intermed','#b_event'),exec('kind_none','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_posr_n'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_intermed','#b_event'),exec('kind_timer','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_posr_c'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_intermed','#b_event'),exec('kind_message','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_posr_k'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_intermed','#b_event'),exec('kind_condition','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_posr_w'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_intermed','#b_event'),exec('kind_signal','#b_event'),exec('category_catch','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_posr_os'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_intermed','#b_event'),exec('kind_signal','#b_event'),exec('category_throw','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_posr_ws'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_end','#b_event'),exec('kind_none','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_konc_n'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_end','#b_event'),exec('kind_message','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_konc_k'
               |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_end','#b_event'),exec('kind_signal','#b_event'))
               || _adres:=_modeler_base+'_zdarzenie_konc_ws'
               ?}
            |? B_PREL.CLASS='B_GATE'
            ||
::             Brama
               {? B_PREL.GATETYPE='OR'
               || _adres:=_modeler_base+'_brama_or'
               |? B_PREL.GATETYPE='AND'
               || _adres:=_modeler_base+'_brama_and'
               |? B_PREL.GATETYPE='XOR'
               || _adres:=_modeler_base+'_brama_xor'
               |? B_PREL.GATETYPE='XOR_EVENT'
               || _adres:=_modeler_base+'_brama_sterowana_startowymi'
               |? B_PREL.GATETYPE='EVENT'
               || _adres:=_modeler_base+'_brama_sterowana_posrednimi'
               |? B_PREL.GATETYPE='COMPLEX'
               || _adres:=_modeler_base+'_brama_zlozona'
               ?}
            ||
::             Cokolwiek innego
               {? _dialog>0
               || FUN.emsg('Brak dokumentacji dla danego typu elementu modelera.'@)
               ?}
            ?}
         || {? _dialog>0
            || FUN.info('Element niezapisany w bazie danych. Aby wyświetlić jego dokumentację należy najpierw zapisać diagram.'@)
            ?}
         ?}
      ?}
   || {? _dialog>0
      || FUN.emsg('Adres serwera dokumentacyjnego nie został ustawiony. Należy sprawdzić parametryzację systemu.'@)
      ?}
   ?}
|| {? _dialog>0
   || FUN.info('Element niezapisany w bazie danych. Aby wyświetlić jego dokumentację należy najpierw zapisać diagram.'@)
   ?}
?};
B_PREL.cntx_pop();
B_PROC.cntx_pop();
_adres


\gate_type_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Zmienia typ bramy
::   WE: _a - B_PREL.UID - element procesu
::   WY: STRING - na jaką bramę zmieniono: 'AND', 'XOR', 'OR', 'COMPLEX'
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_prel_uid:=_a;
_result:='';

_env:=params_get().env;
params_set(params_get());

{? _prel_uid<>''
|| B_PREL.cntx_psh();
   B_PREL.index('UID');
   B_PREL.prefix(_env.SEL_PROC,_prel_uid,);
   {? B_PREL.first()
   ||
      _title:='';
      _exceptions:='|'+B_PREL.GATETYPE+'|';
      {? B_PREL.GATEKIND=exec('kind_split','#b_gate')
      || _exceptions+='|COMPLEX|'
      ?};
      _result:=exec('gate_choice','#b_gate',_title,,_exceptions,,'Wybór bramy'@)
   || FUN.info('Nie znaleziono elementu procesu.'@)
   ?};
   B_PREL.cntx_pop()
|| FUN.info('Nie znaleziono elementu procesu.'@)
?};
_result


\connections_generator_bproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Generuje powiązania na diagramie pomiędzy sygnałami
::   WE: _a - tab_tmp - tablica tymczasowa zawierająca elementy z sygnałami ze wszystkich
::                      załadowanych procesów
::       _b - STRING - Id kontrolki z modelerem
::       _c - STRING - Id elementu modelera
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

_tab:=_a;
_ctr_id:=_b;
_bpmn_id:=_c;

_generated:=tab_tmp(4,
:: 'POLE','TYP','Nazwa w oknie',
   'SRC','STRING[20]','UID źródła',
   'DST','STRING[20]','UID celu',
   'SRC_PROC','STRING[16]','Proces źródłowy',
   'DST_PROC','STRING[16]','Proces docelowy'
);
_ndx1:=_tab.ndx_tmp(,,'B_PROC',,,'SYMBOL',,);
_ndx2:=_tab.ndx_tmp(,,'B_SIGNAL',,,'CATEGORY',,,'TYPE',,);
_tab.index(_ndx1);
_tab.clear();

{? _tab.first()
|| {!
   |? _can_continue:=1;
      _uid_src:=_tab.UID;
      _signal:=_tab.B_SIGNAL;
      _src_proc:=_tab.B_PROC;
::    Szukam elementu połączonego tym samym sygnałem
      _tab.cntx_psh();
      _tab.index(_ndx2);
      {? _tab.CATEGORY=exec('category_throw','#b_event')
      || _tab.prefix(_signal,exec('category_catch','#b_event'))
::      |? _tab.CATEGORY=exec('category_catch','#b_event')
::      || _tab.prefix(_signal,exec('category_throw','#b_event'))
      || _can_continue:=0
      ?};

      {? _can_continue>0 & _tab.first()
      || {!
         |?
::          Znalazłem element połączony tym samym sygnałem, generuję strzałkę tylko jeśli
::          jeszcze jej nie wygenerowałem
            _generated.prefix(_uid_src,_tab.UID,_src_proc,_tab.B_PROC);
            {? _generated.first()=0
            ||
               _conn_src:=exec('uid_normalize','#b_bpmn',_uid_src);
               _conn_src+='bproc:'+_src_proc;

               _conn_dst:=exec('uid_normalize','#b_bpmn',_tab.UID);
               _conn_dst+='bproc:'+_tab.B_PROC;

               _value:='create_edge_msg='+_conn_src+'-->'+_conn_dst;
               exec('set_value','#desktop','',_ctr_id,_bpmn_id,_value);
               _generated.blank();
               _generated.SRC:=_uid_src;
               _generated.DST:=_tab.UID;
               _generated.SRC_PROC:=_src_proc;
               _generated.DST_PROC:=_tab.B_PROC;
               _generated.add()
            ?};
            _tab.next()
         !}
      ?};
      _tab.cntx_pop();
      _tab.next()
   !}
?};
~~


\uid_normalize
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Normalizuje stringa w postaci UID w taki sposób aby bez przeszkód móc go przesłać
::       do modelera metodą set_value
::   WE: _a - STRING - wejściowy UID
::   WY: STRING - znormalizowany UID
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;
_uid:=gsub(_uid,'\"','\"\"');
_uid:=gsub(_uid,';','\";\"');
_uid:=gsub(_uid,'=','\"=\"');
_uid

:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 6f5f50938511bc060f5c3dddb4d97c776461cdfa6e7e1006598309c2098006aa9e724d1cdfe0f76106f396f0da489f8dfbd60e8f9442dc004abdbe6ac2048ac0b21f2fd8298553e31a2987399c62fb8a270692d13dc8b807e45f7932ecc225d0564c3a3aab0135ab55c932bf72501b2c56eff9f1fbe797d1ae82189f6cdbb344
