:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #order.fml
:: Utworzony: 11.05.2020
:: Autor: RWR
::======================================================================================================================
:: Zawartość: Formuły wspomagające obsługę pola typu "ORDER" - pola odpowiedzialnego za kolejność.
::            Pełna obsługa wymaga użycia (wywołania) każdej z poniższych formuł w odpowiednim miejscu.
::======================================================================================================================


\_error
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Funkcja wewnętrza do wyświetlania komunikatów o błędnie użytych funkcjach bibliotecznych.
::   WE: _a [STRING] - Komunikat o błędzie.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_msg:={? var_pres('_a')=type_of('') || _a || '' ?};
_msg+='\n'+'Stos wywołań'@+':';
_stack:=form_stack(3);
{! _lp:=2 .. 3
|! _msg+=' \\%1/%2.fml' [_stack[_lp].name,_stack[_lp].file]
!};
FUN.error(_msg)


\add_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła przygotowuje miejsce na nowy rekord, zmieniając wartości pola typu "ORDER" we wszystkich następnych
::       rekordach. Sugerowane miejsca wywołania formuły:
::          * Wyzwalacz "Dołącz - przed" (po walidacji rekordu).
::   WE:  _a  [TABLE]  - Uchwyt tabeli.
::        _b  [STRING] - Akronim indeksu.
::        _c  [STRING] - Akronim pola typu "ORDER" (pole musi byc typu INTEGER).
::        _d  [NUMBER] - Wartość pola typu "ORDER" dodawanego rekordu.
::       [_e] [ANY]    - Wartość wchodząca do prefiksu.
::       [_f] [ANY]    - Wartość wchodząca do prefiksu.
::       [_g] [ANY]    - Wartość wchodząca do prefiksu.
::   WY: Wynik aktualizacji:
::       ~~ - Błędne parametry wywołania (inny typ wyniku ma doprowadzić do błędu).
::       0  - Porażka;
::       1  - Brak porażki.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(@.CLASS.DBF_T)
|| _TAB:=_a
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['TABELA']);
   return()
?};
{? var_pres('_b')=type_of('') & _TAB.ndx_list().find_key(_b,)
|| _ndx:=_b
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['INDEKS']);
   return()
?};
{? var_pres('_c')=type_of('') & var_pres(_c,_TAB)=22
|| _fld:=_c
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['POLE']);
   return()
?};
{? var_pres('_d')=type_of(0)
|| _val:=_d
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['WARTOŚĆ']);
   return()
?};

_ds:=do_state();

{? _ds=2
|| return(0)
|? _ds=0
|| do()
?};

_TAB.cntx_psh();
_TAB.index(_b);
{? _>4
|| _prfx:='';
   _par:=obj_new(_);
   {! _lp:=5 .. _
   |! _par[_lp]:=_[_lp];
      _prfx+='_b['+$_lp+'],'
   !};
   {? type_of(_[_])<>type_of('')
   || _prfx:=_prfx-1
   ?};
   ($('_a.prefix(%1)' [_prfx]))(_TAB,_par)
|| _TAB.prefix()
?};
:: Ewentualna korekta wartości.
_max:={? _TAB.last() || _TAB.LP ?}+1;
{? _val>_max
|| _val:=_max
?};
{? _TAB.find_key(_val) & _TAB.last()
:: Najpierw sprawdźmy, czy wartość _val jest w ogóle zajęte - jeżeli nie, to nie musimy przygotowywać dla niego miejsca.
|| _TAB.trig_off('*','*');
   {!
   |? {? _TAB.LP>=_val
      || _TAB.LP+=1;
         _TAB.put();
         _TAB.prev()
      ?}
   !};
   _TAB.trig_on('*','*')
?};
_TAB.cntx_pop();

{? _ds=0
|| end()
|| do_state()=1
?}


\del_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła aktualizuje numerację (wartość pola typu ORDER), po "zniknięciu" wskazanego elementu.
::       Sugerowane miejsca wywołania formuły:
::          * Wyzwalacz "Usuń - po".
::          * Przeniesienie rekordu w inne miejsce metodą drag&drop.
::       Poprawność argumentów wywołania nie jest weryfikowana.
::   WE:  _a  [TABLE]  - Uchwyt tabeli.
::        _b  [STRING] - Akronim indeksu.
::        _c  [STRING] - Akronim pola typu "ORDER".
::        _d  [NUMBER] - Wartość pola typu "ORDER" elementu, który "zniknął".
::       [_e] [ANY]    - Wartość wchodząca do prefiksu.
::       [_f] [ANY]    - Wartość wchodząca do prefiksu.
::       [_g] [ANY]    - Wartość wchodząca do prefiksu.
::   WY: Wynik aktualizacji:
::       ~~ - Błędne parametry wywołania (inny typ wyniku ma doprowadzić do błędu).
::       0 - Porażka;
::       1 - Brak porażki.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(@.CLASS.DBF_T)
|| _TAB:=_a
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['TABELA']);
   return()
?};
{? var_pres('_b')=type_of('') & _TAB.ndx_list().find_key(_b,)
|| _ndx:=_b
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['INDEKS']);
   return()
?};
{? var_pres('_c')=type_of('') & var_pres(_c,_TAB)=22
|| _fld:=_c
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['POLE']);
   return()
?};
{? var_pres('_d')=type_of(0)
|| _val:=_d
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['WARTOŚĆ']);
   return()
?};

_ds:=do_state();

{? _ds=2
|| return(0)
|? _ds=0
|| do()
?};

_TAB.cntx_psh();
_TAB.index(_b);
{? _=4
|| _TAB.prefix()
|| _prfx:='';
   _par:=obj_new(_);
   {! _lp:=5 .. _
   |! _par[_lp]:=_[_lp];
      _prfx+='_b['+$_lp+'],'
   !};
   {? type_of(_[_])<>type_of('')
   || _prfx:=_prfx-1
   ?};
   ($('_a.prefix(%1)' [_prfx]))(_TAB,_par)
?};
{? _TAB.find_ge(_val)
|| _TAB.trig_off('*','*');
   {!
   |? ($('_a.%1:=_b' [_fld]))(_TAB,_val);
      {? _TAB.put()
      || _val+=1
      || undo()
      ?};
      _TAB.next()
   !};
   _TAB.trig_on('*','*')
?};
_TAB.cntx_pop();

{? _ds=0
|| end()
|| do_state()=1
?}


\dolacz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła może być użyta wyłącznie podczas obsługi akcji "Dołącz" (również dla tabeli hierachicznej). Zakładamy,
::       że dla tabeli dołączanego rekordu ustalone jest prawidłowe środowisko (indeks, prefiks).
::   WE:  _a  [STRING] - Akronim pola typu "ORDER".
::        _b  [STRING] - Kod obsługiwanej akcji:
::                         'before'    - Dołącza rekord w miejscu bieżącego (bieżący będzie po dołączonym) -
::                                       standardowe działanie akcji "Dołącz".
::                         'after'     - Dołącza rekord za bieżącym - standardowe działanie akcji "Dołącz za".
::                         ---------------------------------------------------------------------------------------------
::                                       Poniższe akcja mogą być użyte wyłącznie dla tabeli ze strukturą hierarchiczną:
::                         'child_l'   - Dołącza rekord podrzędny w stosunku do bieżącego, jako "ostatniego" potomka.
::                         'child_f'   - Dołącza rekord podrzędny w stosunku do bieżącego, jako "pierwszego" potomka.
::                         'child_t'   - Dołącza rekord podrzędny w stosunku do bieżącego, jako "pierwszego" potomka,
::                                       dodatkowo: kolejny rekord będzie dołączony jako podrzędny w stosunku do
::                                       dodanego ostatnio. Do ograniczenia poziomu zagłębienia można użyć formuły
::                                       z parametru _d.
::       [_c] [STRING] - Akronim pola typu TREE_REF - parametr MUSI być podany dla tabeli ze strukturę hierarchiczną (
::                       niepodanie go doprowadzi do niepożądanego działania). Parametr ma charakter optymalizujący
::                       działanie. Uzyskanie tej informacji z systemu jest możliwe, ale zdecydowanie kosztowniejsze.
::       [_d] [RULE]   - Formuła sprawdzająca poprawność dołączanego rekordu [domyślnie: "1"].
::       [_e] [RULE]   - Formuła wykonywana po dodaniu rekordu [domyślnie: "win_disp(); 1"].
::                       Jeżeli formuła zwróci wartość 0, to nie będzie proponowane dołączenie następnego rekordu.
::   WY: ~~ jeżeli błędnie podano wywołania (inny typ wyniku ma doprowadzić do błędu) lub liczba dołączonych rekordów.
::----------------------------------------------------------------------------------------------------------------------
_TAB:=cur_tab(1,1);

{? var_pres('_a')=type_of('') & var_pres(_a,_TAB)=22
|| _fld:=_a
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['POLE']);
   return()
?};
{? var_pres('_b')=type_of('') & ',before,after,child_f,child_l,child_t,'*',%1,' [_b]
|| _type:=_b
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['AKCJA']);
   return()
?};
_tree_fld:={? var_pres('_c')=type_of('') & var_pres(_c,_TAB)=32 || _c || '' ?};
{? 5+_type='child' & _tree_fld=''
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['TREE']);
   return()
?};
_fAE:={? var_pres('_d')=type_of("") || _d || "1" ?};
_fAA:={? var_pres('_e')=type_of("") || _e || "win_disp(); 1" ?};

{? +_tree_fld
|| {? 5+_type='child'
   || _parent:=#_TAB.ref();
      _prfx:=_TAB.cur_prfx();
      {? +_prfx
      || _prfx+=','
      ?}
   || _parent:=($('_a.%1' [_tree_fld]))(_TAB)
   ?}
?};
_delta:=_type='after';

_ret:=0;
_again:=1;
_blank:=1;
{!
|? _again
|! {? _blank
   || {? _type='child_f' | _type='child_t'
      || _val:=1
      |? _type='child_l'
      || _TAB.cntx_psh();
         ($('_a.prefix(%1)' [_prfx+$_parent]))(_TAB);
         _val:={? _TAB.last() || ($('_a.%1' [_fld]))(_TAB) ?}+1;
         _TAB.cntx_pop()
      || _val:={? _TAB.get() || ($('_a.%1' [_fld]))(_TAB)+_delta || 1 ?}
      ?};
      _TAB.blank();
      {? +_tree_fld
      || ($('_a.%1:=_b' [_tree_fld]))(_TAB,_parent)
      ?};
      ($('_a.%1:=_b' [_fld]))(_TAB,_val)
   ?};
   {? _TAB.edit(_fAE)
   || {? _TAB.add()
      || {? _type='child_t'
         || _parent:=#_TAB.ref()
         ?};
         _ret+=1;
         _blank:=1;
         _again:=_fAA()
      ?}
   || _again:=0
   ?}
!};
_ret


\przesun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła odpowiedzialna za przesuwanie (wyżej / niżej) bieżącego elementu. Zakładamy, że dla tabeli
::       dołączanego rekordu ustalone jest prawidłowe środowisko (indeks, prefiks).
::   WE:  _a  [STRING] - Akronim pola typu "ORDER".
::       [_b] [STRING] - Kierunek przesuwania:
::          'W' - Wyżej [domyślnie];
::          'N' - Niżej.
::       [_c] [STRING] - Akronim pola typu TREE_REF - parametr MUSI być podany dla tabeli ze strukturę hierarchiczną (
::                       niepodanie go doprowadzi do niepożądanego działania). Parametr ma charakter optymalizujący
::                       działanie. Uzyskanie tej informacji z systemu jest możliwe, ale zdecydowanie kosztowniejsze.
::       [_d] [NUMBER] - Pomiń wyłączanie wyzwalaczy [0*/1].
::   WY: Wynik operacji:
::       ~~ - Błędne parametry wywołania (inny typ wyniku ma doprowadzić do błędu).
::       1 - Sukces;
::       0 - Porażka.
::----------------------------------------------------------------------------------------------------------------------
_TAB:=cur_tab(1,1);

{? var_pres('_a')=type_of('') & var_pres(_a,_TAB)=22
|| _fld:=_a
|| exec('_error','#order','Brak lub nieprawidłowa wartość parametru "%1".'@ ['POLE']);
   return()
?};
_delta:={? var_pres('_b')=type_of('') & _b='N' || 1 || -1 ?};
_tree_fld:={? var_pres('_c')=type_of('') & var_pres(_c,_TAB)=32 || _c || '' ?};
_pomin:=var_pres('_d')=type_of(0) & _d;


_TAB.cntx_psh();
{? ~_pomin
|| _TAB.trig_off('*','*')
?};
do();
{? +_tree_fld
|| _prfx:=_TAB.cur_prfx();
   {? +_prfx
   || _prfx+=','
   ?};
   _prfx+=($('$_a.%1' [_tree_fld]))(_TAB);
   ($('_a.prefix(%1)' [_prfx]))(_TAB)
?};
_order:=($('_a.%1' [_fld]))(_TAB);
_new:=_order+_delta;
($('_a.%1:=_b' [_fld]))(_TAB,-1);
{? _TAB.put() & _TAB.find_key(_new)
|| ($('_a.%1:=_b' [_fld]))(_TAB,_order);
   {? _TAB.put() & _TAB.find_key(-1)
   || ($('_a.%1:=_b' [_fld]))(_TAB,_new);
      _TAB.put()
   || undo()
   ?}
|| undo()
?};
_ret:=end();
{? ~_pomin
|| _TAB.trig_on('*','*')
?};
_TAB.cntx_pop();
_ret

:Sign Version 2.0 jowisz:1045 2021/01/22 13:20:09 1eb1e68459e1692512cc162a47bdd7370d153aecb7c46686bb5755ad299dc0ba297c36034133926992425a1f88d6557478f012928b0c23d5bf55c0c433f10f4d869104190aca8d9284d15fedc455f381fff57f95b8bf2b682317e1b75119e9bda2f4b0bc4cb65f021d29ab1f130d97ffa178ada4e56c5bdc2073f78c928e3f74
