:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b__box.fml
:: Utworzony: 30.12.2014 [17.00]
:: Autor: AWI
::======================================================================================================================
:: Zawartość: Podręczne funkcje do obsługi procesowości
::======================================================================================================================


\config_error
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca komunikat błędu konfiguracji czynności (do użycia bezpośrednio w formułach realizujacych czynności)
::   WE: _a - proces
::      [_b] - tekst dodatkowej informacji
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of('')
|| FUN.error('Błąd konfiguracji czynności %1. \n\n%2'@[_a.buf_act.UID,_b])
|| FUN.error('Błąd konfiguracji czynności %1.'@[_a.buf_act.UID])
?};
~~


\cur_act_uid
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca symbol czynności aktualnie uruchomionej
::   WY: STRING - B_ACTION.UID lub ''
::----------------------------------------------------------------------------------------------------------------------
_proenv:=exec('proenv','#b_proman');
_stos:=_proenv.STOS_ALL;
_stos.topActUid()


\cur_domain
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca ref obszaru z czynności aktualnie uruchomionej
::   WY: B_DOMAIN.ref() lub null()
::----------------------------------------------------------------------------------------------------------------------
_proenv:=exec('proenv','#b_proman');
_stos:=_proenv.STOS_ALL;
_stos.topDom()


\cur_domain_sym
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca symbol obszaru z czynności aktualnie uruchomionej
::   WY: STRING - B_DOMAIN.SYMBOL lub ''
::----------------------------------------------------------------------------------------------------------------------
_proenv:=exec('proenv','#b_proman');
_stos:=_proenv.STOS_ALL;
_stos.topDomSym()


\desc_update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Uaktualnia opisy na TODO dla wszyskich instancji czynności powiązanych z danym rekordem
::   WE: _a - STRING - uidref rekordu w jakiejs tabeli, który być może ma keyRefa
::       [_b] - STRING - Symbol czynności której instancjom aktualizować opisy. Jeżeli nie podane to wszystkim
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_uid:='';
{? var_pres('_b')=type_of('')
|| _uid:=_b
?};

_result:=1;

B_KEYREF.cntx_psh();
{? _uid<>''
|| B_KEYREF.index('UID_REF');
   B_KEYREF.prefix(_uid,_ref)
|| B_KEYREF.index('KEYREF');
   B_KEYREF.prefix(_ref)
?};
{? B_KEYREF.first()
||
   {!
   |?
::    Uaktualniam opis na TODO
      {? exec('desc','#bi_todo',B_KEYREF.BI_PREL)<=0
      || _result:=0
      ?};
      B_KEYREF.next()
   !}
?};
B_KEYREF.cntx_pop();
_result


\inside_action
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy jestem w kontekście wywołanej formuły czynnościowej
::   WE: _a - STRING - symbol czynności np TTE_PZL_DTEC
::   WY: 1 - jestem w kontekście formuły czynności
::       0 - nie jestem
::----------------------------------------------------------------------------------------------------------------------
_action:=_a;

_result:=0;

:: Zwracam globalne srodowisko pracy manadzera
_proenv:=exec('proenv','#b_proman');
_stos_all:=_proenv.STOS_ALL;
_top_act:=_stos_all.topActUid();

{? _action=_top_act
|| _result:=1
?};
_result


\keyRefOtherProc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Sprawdza czy podany ref jest wykorzystywany w innym procesie od danego jako key ref
::   WE: _a - uidref
::       _b - uchwyt danego obiektu obsługujacego proces
::       [_c] 1-czy ma zwracać ilość innych wywolań 0(domyślnie)-nie
::   WY: 1-tak, 0-nie
::---------------------------------------------------------------------------------------------------------------------

{? _>=3 || {? type_of(_c)<>1 || _c:=0 ?} || _c:=0 ?};

_res:=0;
B_KEYREF.cntx_psh();
B_KEYREF.index('KEYREF');
B_KEYREF.prefix(_a);
{? B_KEYREF.first()
|| {!
   |? {? B_KEYREF.BI_PROC<>_b.bi_proc || _res+=1 ?};
      {? _res & ~_c || 0 || 1 ?} & B_KEYREF.next()
   !}
?};
B_KEYREF.cntx_pop();
_res


\mp_run_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Parametry wejściowe exec('mp_run','#b__box')
::   WY: uchwyt do tablicy nazwanej
::----------------------------------------------------------------------------------------------------------------------
_params:=obj_new('ACT_UID','UIDREF','KEYREFS','AKCJA','PORTS_IN','PORTS_ADJ','TODO_AUTO_MOJE',
                 'PROC_START','GRUPA','CONTEXT','B_PREL','WT_SKIP','QUIET','PROC_SYM','PROC_VER');
:: B_ACTION.UID
_params.ACT_UID:='';
:: TAB.uidref() lub tablica z rekordami kluczowymi
_params.UIDREF:=~~;
:: nazwa wywoływanej akcji w oknie
_params.AKCJA:='';
:: porty wejściowe
_params.PORTS_IN:=~~;
:: dopasowanie parametrów
:: 0-parametr w procesie może nie mieć wartości lub wartość zgodną z _params.PORTS_IN
:: 1-parametr w procesie musi mieć wartość zgodną z _params.PORTS_IN
_params.PORTS_ADJ:=0;
:: w razie potrzeby zmieniać status TODO automatycznych na ręczne podczas uruchamiania czynności [Tak/Nie]
_params.TODO_AUTO_MOJE:='T';
:: możliwy start procesu [Tak/Nie]
_params.PROC_START:='N';
:: czy akcja dla grupy rekordów (komunikaty przekierowane do KOMM)
_params.GRUPA:='N';
:: argumenty kontekstu wywołania
_params.CONTEXT:=~~;
:: proces do uruchomienia lub instancja procesu
_params.B_PREL:=~~;
:: webterm - pomijanie web_main
_params.WT_SKIP:=0;
:: Tryb cichy - bez interakcji użytkownika
_params.QUIET:='N';
:: Symbol procesu
_params.PROC_SYM:='';
:: Wersja procesu
_params.PROC_VER:='';
:: WY
_params


\mp_run
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Funkcja uruchamiająca czynność. Na podstaiwe UID czynności oraz przekazanego refa rekordu wyszukuje uruchomioną
::       instancję elementu procesu i uruchamia ją.
::   WE: _a - exec('mp_run_a','#b__box')
::   WY: wynik nie ma znaczenia
::----------------------------------------------------------------------------------------------------------------------
{? do_state()
|| FUN.info('Uruchomienie mp_run w transakcji niedostępne.'@);
   return(0)
?};

_params:={? var_pres('_a')=type_of(obj_new('obj')) || _a || return(-1) ?};

        _uid:={? var_pres('ACT_UID',_params)=type_of('')              || _params.ACT_UID        || return(-1)  ?};
       _refs:={? var_pres('UIDREF',_params)=type_of('')
               | var_pres('UIDREF',_params)=type_of(obj_new('obj'))   || _params.UIDREF         || ~~          ?};
      _akcja:={? var_pres('AKCJA',_params)=type_of('')                || _params.AKCJA          || ''          ?};
    _portsIn:={? var_pres('PORTS_IN',_params)=type_of(obj_new('obj')) || _params.PORTS_IN
              |? var_pres('PORTS_IN',_params)=type_of("")             || (_params.PORTS_IN)()   || ~~          ?};
  _auto_todo:={? var_pres('TODO_AUTO_MOJE',_params)=type_of('')       || _params.TODO_AUTO_MOJE || 'T'         ?};
 _proc_start:={? var_pres('PROC_START',_params)=type_of('')           || _params.PROC_START     || 'N'         ?};
      _grupa:={? var_pres('GRUPA',_params)=type_of('')                || _params.GRUPA          || 'N'         ?};
    _context:={? var_pres('CONTEXT',_params)=type_of(obj_new('obj'))  || _params.CONTEXT
              |? var_pres('CONTEXT',_params)=type_of("")              || (_params.CONTEXT)()    || ~~          ?};
     _b_prel:={? var_pres('B_PREL',_params)>0                         || _params.B_PREL         || null()      ?};
    _wt_skip:={? var_pres('WT_SKIP',_params)>0                        || _params.WT_SKIP        || 0           ?};
      _quiet:={? var_pres('QUIET',_params)=type_of('')                || _params.QUIET          || 'N'         ?};
  _ports_adj:={? var_pres('PORTS_ADJ',_params)=type_of(0)             || _params.PORTS_ADJ      || 0           ?};
   _proc_sym:={? var_pres('PROC_SYM',_params)=type_of('')             || _params.PROC_SYM       || ''          ?};
   _proc_ver:={? var_pres('PROC_VER',_params)=type_of('')             || _params.PROC_VER       || ''          ?};

{? var_pres('_context')>0 & var_pres('_context')<100
|| FUN.info('Przekazane do mp_run argumenty kontekstowe muszą być obiektem, a nie typem prostym.'@);
   return(-1)
|? +app_info('web_sesid')=0 & exec('FindInSet','#table','B_ACTION','UNIK',_uid,,"B_ACTION.B_CAN='W'",,,0)
|| FUN.info('Czynność należy wywołać w webTerm.'@);
   return(-2)
?};

{? type_of(_b_prel)=type_of('')
|| _b_prel:={? +_b_prel=16 || exec('FindAndGet','#table',B_PREL,_b_prel,,,null()) || null() ?}
?};

:: ustawienie kontekstu dokumentacji dla wykonywanej czynności
_path:=exec('set_help','#help',_uid);
_jTerm:=app_info('web_sesid')='';
{? _jTerm || set_help(_path) || web_set_help(_path) ?};

_continue:=1;
{? type_of(_refs)<>type_of(obj_new('refs'))
|| _refs:=exec('obj_ntab_set','#array',,'refs',_refs)
?};

{! _ind:=1..obj_len(_refs)
|! _ref:=_refs[_ind];
   {? _ref=~~
:: Nie przekazano uidref()
   || 1
   |? _ref=''
:: Jeśli _ref='' to znaczy, że wywołanie TAB.uidref() zwróciło '' ponieważ rekord został usunięty
   || _continue:=0
   |? +_ref=48 & (1+_ref<>'_')
:: Sprawdzenie czy _ref istnieje
   || _Tab:=ref_tab(_ref);
      {? var_pres('_Tab')>0
      || _Tab.cntx_psh();
         _Tab.use(ref_name(_ref));
         _Tab.cntx_psh();
         _Tab.prefix();
         _continue:=_Tab.seek(_ref);
         _Tab.cntx_pop();
         _Tab.cntx_pop();
         obj_del(_Tab)
      ?}
   ?}
!};
{? _continue=0
|| FUN.info('Wiersz został usunięty.'@);
   return(0)
?};

:: +-------------------------------------------------------------------------------------------------------------------+
:: | UWAGA                                                                                                             |
:: | Sprawdzamy, czy czynność jest procesowa w wariancie "nieprocesowym".                                              |
:: | Jeżeli tak, to jest uruchamiana formuła \n_main i w tym miejscu kończymy.                                         |
:: +-------------------------------------------------------------------------------------------------------------------+
{? exec('FindInSet','#table','B_ACTPRO','FIRMA',_uid,REF.FIRMA,"B_ACTPRO.RUNNPROC",1,,'')='T'
|| exec('n_main','#b_proman',_uid,_portsIn,_context,_akcja);
   return(0)
?};

_bi_prel:=null();
:: pobranie uruchomionych instancji czynności _uid
_biprels:=exec('getInstPrel4Ref','#b_keyref',_refs,_uid);
:: zalogowany użytkownik
_ope:=exec('operatorUser','#users');
:: czy użytkownik może uruchomić czynność poza procesem
_runmicro:=exec('runmicro','#b_action',_uid);
:: nazwa czynności
_act_name:=exec('FindInSet','#table','B_ACTION','UNIK',_uid,,"B_ACTION.NAME",,,'');

:: +-------------------------------------------------------------------------------------------------------------------+
:: | UWAGA                                                                                                             |
:: | Ewentualne zmiany w poniższym kodzie (dotyczącym ustalenia instancji czynności, która ma być uruchomiona)         |
:: | należy uwzględnić w formułe \get_bi_prel2run (w bieżącym pliku).                                                  |
:: +-------------------------------------------------------------------------------------------------------------------+
:: analiza uruchomionych instacji czynności
{? _biprels[1]
|| _BIPRELS:=tab_tmp(2
      ,'LP' ,'INTEGER'  ,'lp.'
      ,'TS' ,'REAL'     ,'czas startu'
      ,'II' ,'INTEGER'  ,'ii');
   _size:=obj_len(_biprels);
   {! _ii:=1.._size
   |! _BIPRELS.LP:=exec('FindAndGet','#table',BI_PREL,_biprels[_ii],,"BI_PREL.USERS",null())=_ope;
      _BIPRELS.TS:=exec('FindAndGet','#table',BI_PREL,_biprels[_ii],,"BI_PREL.START",null());
      _BIPRELS.II:=_ii;
      _BIPRELS.add()
   !};
   BI_PREL.cntx_psh();
   {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?}; BI_PREL.index('UID');
   _loop:=_BIPRELS.last();
   {!
   |? _loop
   |!
      _ref:=_biprels[_BIPRELS.II];
      BI_PREL.prefix();
      {? BI_PREL.seek(_ref) & BI_PREL.r_lock(1,1,1)
      || _canRunBiPrel:=exec('canRunBiPrel','#bi_todo',_ref,_ope);
         {? _canRunBiPrel=2
         || _bi_prel:=_ref
         |? _canRunBiPrel=-2 & ~_runmicro
         || _user:='';
            BI_TODO.cntx_psh();
            BI_TODO.index('UNIQUE'); BI_TODO.prefix(_ref);
            {? BI_TODO.first() & BI_TODO.BI_STAT=exec('TODO_MOJE','#bi_stat')
            || _user:=BI_TODO.USERS().DANE
            ?};
            BI_TODO.cntx_pop();
            _txt:='Akcja skojarzona z czynnością %1.'@[_act_name]
               +'\n'+'Czynność nie pozwala przydzielić zadania, które ma na liście zadań inny użytkownik.'@
               +{? _user='' || '' || '\n'+'Zadanie ma użytkownik %1.'@[_user] ?};
            {? _grupa='N'
            || FUN.info(_txt)
            || KOMM.add(_txt,7)
            ?};
            _continue:=0
         ?};
         BI_PREL.r_unlock()
      || FUN.info('Zadanie zablokowane przez innego użytkownika.'@);
         _continue:=0
      ?};
      _loop:=_continue & _bi_prel=null() & _BIPRELS.prev()
   !};
   BI_PREL.cntx_pop()
?};

:: Sprawdzam czy czynność jest procesowa
{? _continue>0 & exec('is_proces','#b_action',_uid)=0
|| _continue:=0;
   _msg:='Czynność: %1 (%2) nie występuje w procesie i nie może być obsłużona przez Menadżera Procesów.'@
         [exec('name','#b_action',_uid),_uid];
   FUN.info(_msg)
?};

{? _b_prel=null() & _continue>0 & _bi_prel=null()
:: nie ma uruchomionej czynności do której uzytkownik ma uprawnienia
:: wiec szukamy procesu z czynnoscia _uid znajdującą się bezpośrednio za elementem startowym
:: lub jeśli brak takiego procesu to uruchamiamy czynność _uid jako microproces
||
:: Zwracam globalne środowisko pracy manadżera
   _proenv:=exec('proenv','#b_proman');
   _stos_ini:=_proenv.STOS_INI;

   _prelCntx:=_stos_ini.topPrel();
   _desk:=obj_new('TAB','WER','NDX');
:: pobranie czynności _uid i procesów, w których ta czynność jest bezpośrednio za elementem startowym
:: zgodnie z uprawnieniami użytkownika _ope
   exec('usractTab','#b_desktop',_desk,_uid,,_portsIn,'MP_RUN',_ports_adj);
   _Tab:=_desk.TAB;
   {? _Tab.find_tab(,'REF_PREL',,'=',$_prelCntx)
:: uruchomienie elementu umieszczonego na stosie
   || _b_prel:=_prelCntx
:: na stosie nie było elementu lub nie ma go w _Tab
   || _one:=0;
      _sesid:=app_info('web_sesid');
      {? _proc_start='T' & _proc_sym<>'' & _proc_ver<>''
      || _Tab.prefix('T',_proc_sym,_proc_ver,);

         {? _Tab.first()=0
         || _continue:=0;
            _txt:='Akcja skojarzona z czynnością %1.\n\n'
                  'Określono konkretny proces do uruchomienia: %2 (wersja %3).\n'
                  'Nie można uruchomić tego procesu, ponieważ nie znaleziono go na liście procesów możliwych do uruchomienia.'@[_act_name,_proc_sym,_proc_ver];
            {? _grupa='N'
            || FUN.info(_txt)
            || KOMM.add(_txt,2,,1)
            ?}
         ?}
      || _Tab.prefix('T')
      ?};
      {? _Tab.first() & _proc_start='T'
::    proces
      || {? _Tab.next() & _Tab.first()
::       wiele procesów - użytkownik wybiera proces
         || {? +_sesid & _wt_skip=0
            || _mbid:=app_info('web_mbid');
               _tcid:=app_info('web_tcid');
               _tabid:=app_info('web_tabid');
               B_TAB_WT.index('PROC');
               B_TAB_WT.prefix(_tcid,_tabid);
               _loop:=B_TAB_WT.first(); {! |? _loop |! _loop:=B_TAB_WT.del() !};
               _loop:=_Tab.first();
               {!
               |? _loop
               |!
                  B_TAB_WT.blank(1);
                  B_TAB_WT.SESID:=_sesid;
                  B_TAB_WT.MBID:=_mbid;
                  B_TAB_WT.TCID:=_tcid;
                  B_TAB_WT.TABID:=_tabid;
                  B_TAB_WT.UID:=_Tab.UID;
                  B_TAB_WT.IN:=_Tab.IN;
                  B_TAB_WT.NAME:=_Tab.NAME;
                  B_TAB_WT.REF_PREL:=_Tab.REF_PREL;
                  _loop:=B_TAB_WT.add() & _Tab.next()
               !};
               web_params_set(exec('obj_ntab_set','#array',web_params_get(),
                  'ACT_UID',_params.ACT_UID,
                  'UIDREF',_params.UIDREF,
                  'AKCJA',_params.AKCJA,
                  'PORTS_IN',_params.PORTS_IN,
                  'TODO_AUTO_MOJE',_params.TODO_AUTO_MOJE,
                  'PROC_START',_params.PROC_START,
                  'GRUPA',_params.GRUPA,
                  'CONTEXT',_params.CONTEXT,
                  'B_PREL',~~
               ));
               B_TAB_WT.web_select('WER');
               _continue:=0
            || exec('deskWerProc','#b_desktop',_desk);
               {? _quiet='T'
               || {? _Tab.first()
                  || _b_prel:=exec('FindAndGet','#table',B_PREL,_Tab.REF_PREL);
                     _params.B_PREL:=_b_prel
                  || _continue:=0
                  ?}
               || {? _Tab.select()
                  || _b_prel:=exec('FindAndGet','#table',B_PREL,_Tab.REF_PREL);
                     _params.B_PREL:=_b_prel
                  || _continue:=0
                  ?}
               ?}
            ?}
::       jeden proces - automatyczny wybór procesu
         || _one:=1
         ?}
::    czynność
      || _Tab.prefix('N');
         _one:=_Tab.first();
         {? _one & ~_runmicro
         || _txt:='Akcja skojarzona z czynnością %1.'
               '\nAkcja może być uruchomiona gdy na liście zadań istnieje zadanie powiązane z tą czynnością.'@[
               _act_name];
            {? _grupa='N'
            || FUN.info(_txt)
            || KOMM.add(_txt,7)
            ?};
            _continue:=0
         ?}
      ?};
      {? _continue & _one
      ||
         _b_prel:=exec('FindAndGet','#table',B_PREL,_Tab.REF_PREL);
         {? +_sesid & _wt_skip=0
         ||
            exec('env_wt_core','#web_srv');
            {? Perm.hasPermissions(exec('FindInSet','#table','B_ACTION','UNIK',_params.ACT_UID))
            ||
               _params.B_PREL:=_Tab.REF_PREL;
               web_params_set(exec('obj_ntab_set','#array',web_params_get(),
                  'ACT_UID',_params.ACT_UID,
                  'UIDREF',_params.UIDREF,
                  'AKCJA',_params.AKCJA,
                  'PORTS_IN',_params.PORTS_IN,
                  'TODO_AUTO_MOJE',_params.TODO_AUTO_MOJE,
                  'PROC_START',_params.PROC_START,
                  'GRUPA',_params.GRUPA,
                  'CONTEXT',_params.CONTEXT,
                  'B_PREL',_params.B_PREL
               ));
               _fml:='!'+(-_uid);
               {? exec('lic','#b_action',_uid)>0
               || exec('web_main',_fml,'Area')
               || _txt:='Czynność: %1 — brak licencji.'@[_uid];
                  FUN.info(_txt)
               ?}
            ?};
            _continue:=0
         ?}
      ?}
   ?}
:: jest uruchomiona czynność do której użytkownik ma uprawnienia
|| {? _auto_todo='T'
   ||
::    zmiana statusu TODO automatycznych
      exec('FindAndGet','#table',BI_PREL,_bi_prel,,"
         {? BI_PREL.AUTOMAT='T' || BI_PREL.AUTOMAT:='A'; BI_PREL.put() ?}
      ",0)
   ?};
   _sesid:=app_info('web_sesid');
   {? _bi_prel & +_sesid & _wt_skip=0
   || web_params_set(exec('obj_ntab_set','#array',web_params_get(),
         'ACT_UID',_params.ACT_UID,
         'UIDREF',_params.UIDREF,
         'AKCJA',_params.AKCJA,
         'PORTS_IN',_params.PORTS_IN,
         'TODO_AUTO_MOJE',_params.TODO_AUTO_MOJE,
         'PROC_START',_params.PROC_START,
         'GRUPA',_params.GRUPA,
         'CONTEXT',_params.CONTEXT,
         'B_PREL',$_bi_prel
      ));
      exec('env_wt_core','#web_srv');
      _fml:='!'+(-_uid);
      {? exec('lic','#b_action',_uid)>0
      || params_exec('web_main',_fml,'Area')
      || _txt:='Czynność: %1 — brak licencji.'@[_uid];
         FUN.info(_txt)
      ?};
      _continue:=0
   ?}
?};
{? _continue>0
||
   _prel:={? _bi_prel || _bi_prel || _b_prel ?};
   {? _prel
   || exec('proMan','#b_proman',_prel,_akcja,_portsIn,'Area',,_context,_grupa,,,_quiet,,_uid)
   || _txt:='Brak uprawnień do czynności: %1 (%2).'@[exec('name','#b_action',_uid),_uid];
      {? exec('on','#mwapi') || mwa_status(401,_txt) ?};
      {? _grupa='N'
      || FUN.emsg(_txt)
      || KOMM.add(_txt,7)
      ?};
      0
   ?}
?}


\portsIn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Pobranie portów wejściowych czynności _[1]..._[n]
::   WE: _[1]..._[n] - kolejne argumenty B_ACTION.UID
::   WY: tablica czynności i ich portów wejściowych
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| _portsIn:=obj_new(1);
   _portsIn[1]:=~~;
   return(_portsIn)
?};

_len:=_;
_portsIn:=obj_new(_len);
_kind:=exec('kind_in','#b_port');

{! _ii:=1.._len
|!
   _portsIn[_ii]:=obj_new('UID','B_ELE','PORTS');
   _portsIn[_ii].UID:=_[_ii];
   _portsIn[_ii].B_ELE:=exec('FindInSet','#table','B_ACTION','UNIK',_portsIn[_ii].UID,,"B_ACTION.B_ELE",,,null());
   _portsIn[_ii].PORTS:=exec('getPorts','#b_port',_portsIn[_ii].B_ELE,_kind,null());
   _ii+=1
!};

_portsIn


\portsInSet
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Ustawienie wartości _d portu _c czynności _b w tablicy _a
::   WE: _a - tablica zwracana przez exec('portsIn','#b__box')
::       _b - B_ACTION.UID
::       _c - B_PORT.SYMBOL
::       _d - wartosc
::   WY: 0-nie ustawiono wartości, 1-ustawiono wartości
::----------------------------------------------------------------------------------------------------------------------
_portsIn:={? var_pres('_a')=type_of(obj_new('obj')) || _a || ~~ ?};
    _uid:={? var_pres('_b')=type_of('str')          || _b || '' ?};
   _port:={? var_pres('_c')=type_of('str')          || _c || '' ?};
    _val:={? _>=4                                   || _d || ~~ ?};

{? var_pres('_portsIn')=type_of(~~) || return() ?};
{? _uid='' || return() ?};
{? _port='' || return() ?};

_len:=obj_len(_portsIn);
_set:=0;
_ii:=1;

{!
|? _ii<=_len & _set=0
|!
   {? _portsIn[_ii].UID=_uid
   || _ff:='_a.PORTS.'+_port;
      ($_ff)(_portsIn[_ii]):=_val
   ?};
   _ii+=1
!}


\np_run
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Uruchamia czynność nieprocesową bez użycia menadżera procesów,
::       ale z uwzględnieniem uprawnień bieżącego operatora
::   WE: _a - UID czynności
::       Do formuły może być przekazany parametr za pomocą mechanizmu params_set()/params_get()
::       (w szczególności, gdy czynność używana jest w mechanizmie parametryzacji)
::   WY: -1 - błąd typu parametru wejściowego
::       ~~ - brak uprawnień do czynności
::       _result - wynik formuły czynności
::----------------------------------------------------------------------------------------------------------------------
_uid:={? var_pres('_a')=type_of('') || _a || return(-1) ?};
_result:=~~;

:: Sprawdzenie uprawnień
{? exec('chk_role','#b__box',OPERATOR.USER,_uid)
|| B_ACTION.cntx_psh();
   B_ACTION.index('UNIK');
   B_ACTION.prefix(_uid,);
   {? B_ACTION.first()
   ||
::    Sprawdzenie czy czynność jest aktywna
      {? B_ACTION.AKT='N'
      || FUN.info('Czynność nieaktywna: %1 — nie można uruchomić.'@[B_ACTION.UID])
::    Sprawdzenie czy czynność jest nieprocesowa
      |? B_ACTION.PROC='T'
      || FUN.info('Czynność procesowa: %1 — nie można uruchomić.'@[B_ACTION.UID])
::    Sprawdzenie licencji
      |? exec('lic','#b_action',B_ACTION.ref())=0
      || FUN.info('Czynność: %1 — brak licencji.'@[B_ACTION.UID])
::    Sprawdzenie uprawnień do danych
      |? ~Perm.hasPermissions(exec('FindInSet','#table','B_ACTION','UNIK',B_ACTION.UID))
      || ~~
::    Wywołanie funkcji głównej czynności z Buildera
      |? B_ACTION.FMMAIN<>''
      || params_set(params_get());
         _path:=exec('set_help','#help',_uid);
         {? app_info('web_sesid')=''
::          To nie jest webTerm. Uruchomienie czynności (nawet) nieprocesowej poprzedzamy ustawieniem środowiska.
         || _id:=__PARSES.clone('S','U');
            _pid:=__PARSES.getPID();
            {? _id='' | _pid=''
            || FUN.info('Przygotowanie środowiska nie powiodło się.'@)
            || __PARSES.pushEnv();
               {? __PARSES.setMode('S',_id,,_pid) & __PARSES.setEnv(B_ACTION.UID)
               || set_help(_path);
                  _result:=mb_exec(B_ACTION.FMMAIN)
               ?};
               __PARSES.popEnv();
               __PARSES.del(_id)
            ?}

::          webTerm: zakładamy, że za ustawienie środowiska w całości odpowiada programista.
         || web_set_help(_path);
            _result:=mb_exec(B_ACTION.FMMAIN)
         ?}
      || FUN.info('Brak zdefiniowanej formuły głównej dla czynności: %1.'@[B_ACTION.UID])
      ?}
   ?};
   B_ACTION.cntx_pop()
|| FUN.info('Brak uprawnień do czynności: %1 (%2).'@[exec('name','#b_action',_uid),_uid])
?};
_result


\chk_role
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Funkcja sprawdzająca czy użytkownik ma:
::       1. Odpowiednią rolę w celu uruchomienia czynności (jeżeli _b to ref lub uid czynności)
::       2. Odpowiednią rolę (jeżeli _b to nazwa roli)
::   WE: _a - USERS.ref()   - wskazanie na usera
::       _b - STRING|ref    - uid/ref czynności lub nazwa roli
::       [_c] - FIRMA.ref() - ref() firmy, domyślnie REF.FIRMA
::       [_d] - INTEGER - [1]/2 - wariant działania:
::                                1 - zaczyna pętlę od ról użytkownika. Korzystniejszy wydajnościowo,
::                                    kiedy użytkownik ma ma mniej ról niż średnio czynności w roli
::                                2 - zaczyna pętlę od czynności roli. Korzystniejszy wydajnościowo,
::                                    kiedy użytkownik ma więcej ról niż średnio czynności w roli
::   WY: 0 - brak uprawnień
::       1 - użytkownik ma wymaganą rolę aby uruchomić czynność
::----------------------------------------------------------------------------------------------------------------------
_user:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
_act:={? var_pres('_b')=type_of('') | var_pres('_b')=type_of(null) || _b || return(0) ?};
_firma:={? var_pres('_c')=type_of(null()) || _c || REF.FIRMA ?};
_wariant:=1;
{? var_pres('_d')=type_of(0)
|| _wariant:=_d
?};
_res:=0;
_b_action:=null();
_b_role:=null();

:: wyszukanie czynności
{? type_of(_act)=type_of('')
|| B_ACTION.cntx_psh();
   B_ACTION.index('UNIK');
   B_ACTION.prefix(_act,);
   {? B_ACTION.first()
   || _b_action:=B_ACTION.ref()
   || B_ROLE.cntx_psh();
      B_ROLE.index('UNIK');
      B_ROLE.prefix(REF.FIRMA,_act,);
      {? B_ROLE.first()
      || _b_role:=B_ROLE.ref()
      ?};
      B_ROLE.cntx_pop()
   ?};
   B_ACTION.cntx_pop()
|| _b_action:=_act
?};


{? _b_action<>null()
|| {? _wariant=1
   ||
      B_USRROL.cntx_psh();
      B_USRROL.index('USER');
      B_USRROL.prefix(_firma,_user);
      _dalej:=1;
      {? B_USRROL.first()
      || B_ACTROL.cntx_psh();
         B_ACTROL.index('UNIK');
         {!
         |? B_ACTROL.prefix(_firma,B_USRROL.B_ROLE,_b_action);
            {? B_ACTROL.first()
            || _res:=1;
               _dalej:=0
            ?};
            _dalej & B_USRROL.next()
         !};
         B_ACTROL.cntx_pop()
      ?};
      B_USRROL.cntx_pop()
   |? _wariant=2
   || _can_continue:=1;
      B_ACTROL.cntx_psh();
      B_USRROL.cntx_psh();
      B_USRROL.index('UNIK');
      B_ACTROL.index('DISP2');
      B_ACTROL.prefix(_firma,_b_action);
      {? B_ACTROL.first()
      || {!
         |? B_USRROL.prefix(_firma,B_ACTROL.B_ROLE,_user);
            {? B_USRROL.first()
            || _res:=1;
               _can_continue:=0
            ?};
            B_ACTROL.next() & _can_continue>0
         !}
      ?};
      B_ACTROL.cntx_pop();
      B_USRROL.cntx_pop();
      ~~
   ?}
|? _b_role<>null()
|| B_USRROL.cntx_psh();
   B_USRROL.index('UNIK');
   B_USRROL.prefix(REF.FIRMA,_b_role,_user);
   {? B_USRROL.first()
   || _res:=1
   ?};
   B_USRROL.cntx_pop();
   ~~
?};
_res


\getUsers4Action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.42]
:: OPIS: Funkcja zwraca listę użytkowników posiadających przypisaną czynność
::   WE: [_a] [TABLE]  - tabela zgodna ze schematem tabeli USERS
::        _b  [STRING] - identyfikator czynności
::       [_c] [RULE]   - dodatkowa formuła weryfikacjyjna - czy dodawać dany rekord
::   WY: tabela zgodna ze schematem tabeli USERS
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(P)  || _a || sql('select * from USERS where 2=1') ?};
_uid:={? var_pres('_b')=type_of('') || _b || return(_tab)                         ?};
_fml:={? var_pres('_c')=type_of("") || _c || "1"                                  ?};

_buffer:=exec('USERS','buffer');
_b_action:=null();

:: wyszukanie czynności
B_ACTION.cntx_psh();
B_ACTION.index('UNIK');
B_ACTION.prefix(_uid,);
{? B_ACTION.first() || _b_action:=B_ACTION.ref()?};
B_ACTION.cntx_pop();

{? _b_action<>null()
|| USERS.cntx_psh();
   B_USRROL.cntx_psh();
   B_USRROL.index('USER');
   B_USRROL.prefix(REF.FIRMA);
   _dalej:=1;
   {? B_USRROL.first()
   || B_ACTROL.cntx_psh();
      B_ACTROL.index('UNIK');
      {!
      |? B_ACTROL.prefix(REF.FIRMA,B_USRROL.B_ROLE,_b_action);
         {? B_ACTROL.first()
         || B_USRROL.USERS();
            {? USERS.AKT='T'
            || _tab.blank(1);
               _buffer.get().mask(_tab);
               {? ~_tab.find_rec() & _fml()
               || _tab.add()
               ?}
            ?}
         ?};
         _dalej & B_USRROL.next()
      !};
      B_ACTROL.cntx_pop()
   ?};
   B_USRROL.cntx_pop();
   USERS.cntx_pop()
?};
_tab


\uidref_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Zmienia uidref z _a na _b w tabelach BI_PORT, B_KEYREF
::   WE: _a - stary uidref
::       _b - nowy uidref
::   WY: 0-zamiana nie powiodła się, 1-zamiana powiodła się
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('') || return(0) ?};
{? var_pres('_b')<>type_of('') || return(0) ?};

_wyn:=1;
:: Aktualizacja w tabeli BI_PORT
_Tab:=sql('select REFERENCE REF from @BI_PORT where BI_PORT.VALUE=\':_a\' order by 1',_a);

_do_state:=do_state()=0;
{? _do_state || do() ?};

_loop:=_Tab.first();
{!
|? _loop
|!
   __ff_a:=_b;
   __ff_wyn:=0;
   _ff:="
      {? __ff_a<>''
      ||
         BI_PORT.VALUE:=__ff_a;
         __ff_wyn:=BI_PORT.put()
      ?}
   ";
   exec('FindAndGet','#table',BI_PORT,_Tab.REF,,_ff);
   _wyn:=__ff_wyn;
   _loop:=__ff_wyn & _Tab.next()
!};
VAR_DEL.delete('__ff_a','__ff_wyn');

:: Aktualizacja w tabeli B_KEYREF
{? _wyn
|| B_KEYREF.index('KEYREF');
   B_KEYREF.prefix(_a);
   _loop:=B_KEYREF.first();
   {!
   |? _loop
   |!
      B_KEYREF.cntx_psh();
      B_KEYREF.prefix();
      B_KEYREF.KEY_REF:=_b;
      _wyn:=B_KEYREF.put();
      B_KEYREF.cntx_pop();
      _loop:=_wyn & B_KEYREF.first()
   !}
?};

{? _do_state || end() ?};

_wyn


\record_keyrefed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy podany rekord jest aktualnie zapisany jako keyRef przez czynność o podanym identyfikatorze
::   WE: _a - TABELA.uidref() - identyfikator rekordu
::       _b - STRING - identyfikator czynności np 'TTE_PZL_DTEC'
::       [_c] - BI_PROC.ref() - instancja procesu w której szukać, jeśli nie podana to we wszystkich
::   WY: 0  - rekord nie jest aktualnie zapisany jako keyRef czynności
::       1  - rekord jest zapisany jako keyref w jakiejkolwiek instancji czynności
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_uidref:=_a;
_action:=_b;
_bi_proc:=null();
{? var_pres('_c')=type_of(null())
|| _bi_proc:=_c
?};

_result:=0;
B_KEYREF.cntx_psh();
{? _bi_proc<>null()
||
   {? exec('check_ref','#bi_arch',_bi_proc)>0
   ||
::    Dla archiwalnego BI_PRELa nic nie zwracam, bo nie ma sensu
      B_KEYREF.cntx_pop();
      return(0)
   ?};
   B_KEYREF.index('UID_REF2');
   B_KEYREF.prefix(_action,_uidref,ref_name(_bi_proc),_bi_proc)
||
   B_KEYREF.index('UID_REF');
   B_KEYREF.prefix(_action,_uidref)
?};
{? B_KEYREF.size()>0
|| _result:=1
?};
B_KEYREF.cntx_pop();
_result


\keyref_locked
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy dla podanego rekordu istnieje jakakolwiek instancja czynności która jest zablokowana
::       przez inną sesję programu czyli:
::          1. Czynność jest aktualnie uruchomiona
::          2. Czynność została zablokowana metodą lock() menadżera
::   WE: _a   - TABELA.uidref() - identyfikator rekordu
::       _b   - STRING - identyfikator czynności np 'TTE_PZL_DTEC'
::       [_c] - INTEGER - czy wyświetlać dialog mówiący o zablokowaniu
::   WY: 0 - rekord nie powiązany z zablokowaną instancją czynności
::       1 - rekord powiązany z co najmniej jedną zablokowaną instancją czynności
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_uidref:=_a;
_action:=_b;
_dialog:=_c;

_result:=0;

BLK.cntx_psh();
BLK.index('AMR');
B_KEYREF.cntx_psh();
B_KEYREF.index('UID_REF');
B_KEYREF.prefix(_action,_uidref);
{? B_KEYREF.first()
||
   _proenv:=exec('proenv','#b_proman');
   _stos_all:=_proenv.STOS_ALL;
   {!
   |?
      {? B_KEYREF.BI_PREL<>null()
      ||
::       Pobieram id sesji które być może blokuje rekord
         _ses_id:='';
         _my_lock:=0;
         BLK.prefix('BI_PREL',ref_name(B_KEYREF.BI_PREL),B_KEYREF.BI_PREL);
         {? BLK.first()
         ||
::          Jeżeli znalazł się rekord tabeli BLK powiązany z tym BI_PRELEM to są 3 przypadki
::          1. Jest to rekord śmieciowy, pochodzi z innej sesji która jest już nieaktywna
::          2. Powstał w wyniku blokady w tej sesji
::          3. Powstał w wyniku blokady w innej sesji

::          Próbuję zablokować ten rekord i jeśli się udało odczytać z niego sesję
::          W ten sposób gwarantuję że od momentu odczytu do momentu kiedy będę porównywał
::          ten numer sesji z bieżącym nic się temu rekordowi BLK nie stanie
            _my_lock:=BLK.r_lock(1,1,1);
            {? _my_lock>0
            || _ses_id:=BLK.SES_ID
            ?}
         ?};

::       W tym miejscu mogą powstać blokady tylko w innych sesjach programu
::       (ta sesja tędy przebiega i nie robi nic równolegle)
::       jeżeli rekordu BLK nie było, bo jeżeli był to został zablokowany i blokada na nim w innej sesji programu
::       się nie uda. Jeżeli BLKa nie było i powstała blokada w innej sesji to nie uda się exec('lock','#bi_prel',...)

         {? exec('lock','#bi_prel',B_KEYREF.BI_PREL,_dialog)
         ||
::          Udało się zablokować czyli nikt inny nie blokuje
            {? _ses_id<>SYSLOG.ses_id()
            ||
::             Mogę odblokować tylko jeżeli bieżąca sesja różni się od tej odczytanej wcześniej, bo
::             w innym przypadku jeżeli odblokowałbym w sesji która zablokowała mógłbym
::             popsuć działanie w kontekstach formułowych wyżej, które liczą że rekord będzie nadal zablokowany.

::             Tutaj program dojdzie tylko w przypadku 1.

::             W przypadku 2 nie powinienem tego odblokować ponieważ wyżej program liczy że będzie nadal zablokowane
::             W przypadku 3 w ogóle tu nie dojdzie bo exec('lock','#bi_prel',...) się nie powiedzie

               exec('unlock','#bi_prel',B_KEYREF.BI_PREL,_stos_all)
            ?}
         ||
::          Nie udało się zablokować, znaczy że zablokowane
            _result:=1
         ?}
      ?};
      B_KEYREF.next() & _result=0
   !}
?};
B_KEYREF.cntx_pop();
BLK.cntx_pop();
_result


\is_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK [17.00]
:: OPIS: Sprawdzenie czy czynność przekazana argumentem występuje w zaakceptowanym procesie.
::   WE:  _a  [STRING] - Identyfikator czynności.
::       [_b] [NUMBER] - Wyświetlać komunikat:
::                       0 - Nie [domyślnie];
::                       1 - Tak.
::       [_c] [NUMBER] - Czy sprawdzać tylko aktywne procesy
::                       0 - Nie [domyślnie];
::                       1 - Tak.
::       [_d] [NUMBER] - Czy sprawdzać tylko w bieżącej firmie
::                       0 - Nie [domyślnie];
::                       1 - Tak.
::   WY: 1/0 - Czynność jest w zaakceptowanym procesie / nie jest.
::----------------------------------------------------------------------------------------------------------------------
_zwrot:=0;
B_ACTION.cntx_psh();
B_ACTION.index('UNIK');
B_ACTION.prefix(_a,);
{? B_ACTION.first() & B_ACTION.B_ELE
|| _only_active:={? var_pres('_c')=type_of(0) || _c || 0 ?};
   _only_firm:={? var_pres('_d')=type_of(0) || _d || 0 ?};
   B_PROC.cntx_psh();
   B_PROC.prefix();
   B_PREL.cntx_psh();
   B_PREL.index('ACCESS');
   B_PREL.prefix(B_ACTION.B_ELE);
   {? B_PREL.first()
   || {!
      |? {? _only_firm
         || {? _only_active>0
            || _zwrot:=(B_PREL.B_PROC & B_PREL.B_PROC().ACCEPTED='T' & B_PROC.FIRMA=REF.FIRMA & B_PROC.ACTIVE='T')
            || _zwrot:=(B_PREL.B_PROC & B_PREL.B_PROC().ACCEPTED='T' & B_PROC.FIRMA=REF.FIRMA)
            ?}
         || {? _only_active>0
            || _zwrot:=(B_PREL.B_PROC & B_PREL.B_PROC().ACCEPTED='T' & B_PROC.ACTIVE='T')
            || _zwrot:=(B_PREL.B_PROC & B_PREL.B_PROC().ACCEPTED='T')
            ?}
         ?};
         ~_zwrot & B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop();
   B_PROC.cntx_pop()
?};
B_ACTION.cntx_pop();
{? ~_zwrot & var_pres('_b')=type_of(0) & _b
|| FUN.info(
      'Czynność może być uruchamiana wyłącznie w ramach\n'
      'zaakceptowanego procesu, a takiego nie udało się znaleźć.\n'
      'Zgłoś problem osobie odpowiedzialnej za projektowanie procesów.'@
   )
?};
_zwrot


\is_act_user
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK [17.00]
:: OPIS: Sprawdzenie czy czynność przekazana argumentem występuje w zaakceptowanym procesie
::       zadanie dla użytkownika
::   WE:  _a - identyfikator czynności.
::        _b - użytkownik (USERS.ref())
::        _c - TABELA.uidref() - identyfikator rekordu
::        _d - FIRMA (FIRMA.ref)
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_zwrot:=0;
B_PROC.cntx_psh(); B_PROC.prefix();
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID'); BI_PROC.prefix();
B_KEYREF.cntx_psh(); B_KEYREF.index('UID_REF'); B_KEYREF.prefix(_a,_c);
BI_TODO.cntx_psh(); {? BI_TODO.name()='' || BI_TODO.use('bi_t____') ?}; BI_TODO.index('UNIQUE');
{? B_KEYREF.first()
|| {! |?
      B_KEYREF.BI_PROC().B_PROC();
      {? B_PROC.ACCEPTED='T'
      || BI_TODO.prefix(B_KEYREF.BI_PREL,_b);
         {? BI_TODO.first()
         || {! |?
               _zwrot:=(BI_TODO.FIRMA=_d & BI_TODO.USERS=_b & BI_TODO.FREE=1);
               ~_zwrot & BI_TODO.next()
            !}
         ?}
      ?};
      ~_zwrot & B_KEYREF.next()
   !}
?};
B_KEYREF.cntx_pop(); B_PROC.cntx_pop(); BI_PROC.cntx_pop(); BI_TODO.cntx_pop();
_zwrot


\is_micro
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła na podstawie wskazania elementu procesu, sprawdza, czy jest to mikroproces.
::   WE: _a [REFERENCE] - Wskazanie elementu w procesie (B_PREL).
::       [_b] [NUMBER] - Wyświetlać komunikat:
::                       0 - Nie [domyślnie];
::                       1 - Tak.
::   WY: 1 - Mikroproces.
::       0 - Nie mikroproces.
::----------------------------------------------------------------------------------------------------------------------
B_PROC.cntx_psh();
_ret:=exec('FindAndGet','#table',B_PREL,_a,,"B_PROC().MICRO",0)='T';
B_PROC.cntx_pop();
{? _ret & var_pres('_b')=type_of(0) & _b
|| FUN.info(
      'Czynność może być uruchamiana wyłącznie w ramach aktywnego i zaakceptowanego procesu,\n'
      'a użytkownik musi mieć uprawnienia do odpowiedniej roli.\n'
      'Nie wszystkie z powyższych warunków są spełnione.\n'
      'Zgłoś problem osobie odpowiedzialnej za projektowanie procesów.'@
   )
?};
_ret


\todo_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyświetla zapisy na ToDo związane z danym rekordem,
::       czyli przypisane do BI_PREL-i powiązanych z B_KEYREF-ami do przekazanego TAB.uidref()
::   WE: _a - uidref()
::       [_b] - 1-uruchomienie 1 elementu na liście TODO jeśli jest, 0(domyślnie)-standardowe działanie
::   WY: ~~ lub wskazanie na BI_TODO (parametr _b)
::----------------------------------------------------------------------------------------------------------------------
_res:=~~;
{? var_pres('_a')<>type_of('') | +_a<>48 | ref_name(_a)=~~
|| FUN.info('Błędne wywołanie formuły: %1.'@['\\todo_select/#b__box.fml']);
   return()
?};
_autorun:={? var_pres('_b')=type_of(0) || _b || 0 ?};

{? app_info('web_sesid')<>''
|| exec('env_wt','b_proces')
?};
BI_TODO.cntx_psh();
ref_tab(_a).cntx_psh();

_args:=exec('select_4uidref_a','#bi_todo');
_args.load:=$("
   .BI_PREL.erase();
   B_KEYREF.cntx_psh();
   B_KEYREF.index('KEYREF');
   B_KEYREF.prefix('"+_a+"',);
   {? B_KEYREF.first()
   || {!
      |? .BI_PREL.REF:=$B_KEYREF.BI_PREL;
         .BI_PREL.add();
         B_KEYREF.next()
      !}
   ?};
   B_KEYREF.cntx_pop();
   BI_TODO.prefix();
   BI_TODO.f_set('DT,TM','',.where,.BI_PREL,exec('TODO_MOJE','#bi_stat'),exec('TODO_WOLNE','#bi_stat'))
");
:: - Z uprawnieniami do czynności ZPR_INS_ZADU użytkownik widzi wszystkie zadania wszystkich operatorów
:: - Bez uprawnień do czynności ZPR_INS_ZADU użytkownik widzi zadania wszystkich operatorów,
::   ale tylko przydzielone (TODO_MOJE) oraz wolne (TODO_WOLNE) wszystkich operatorów
{? exec('chk_role','#b__box',OPERATOR.USER,'ZPR_INS_ZADU')
|| _args.where:='BI_TODO.BI_PREL in (select :_a.REF from :_a)'
|| _args.where:='BI_TODO.BI_PREL in (select :_a.REF from :_a) and (BI_TODO.BI_STAT=:_b or BI_TODO.BI_STAT=:_c)'
?};
_args.uidref:=_a;

{? app_info('web_sesid')<>''
|| exec('maski','#b_proman');
   web_params_set('bi_prel',_a);
   BI_TODO.web_select('W_WEB_GR')
|| __PARSES.pushEnv();
   __PARSES.pushContext();
   _res:=exec('select_4uidref','#bi_todo',_args,_autorun);
   __PARSES.popContext();
   __PARSES.popEnv()
?};

ref_tab(_a).cntx_pop();
{? app_info('web_sesid')=''
|| AreaTitle.setTitle()
?};
BI_TODO.cntx_pop();
_res


\todo_fset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [17.00]
:: OPIS: Ograniczenie dziedziny przed obsługą okna
::----------------------------------------------------------------------------------------------------------------------
{? app_info('web_sesid')<>'' || exec('env_wt','b_proces') ?};
_a:=web_params_get.bi_prel;
_args:=exec('select_4uidref_a','#bi_todo');
BI_TODO.prefix();
_args.BI_PREL.erase();
B_KEYREF.cntx_psh();
B_KEYREF.index('KEYREF');
B_KEYREF.prefix(_a,);
_bi_prel:=null();
{? B_KEYREF.first()
||
   _bi_prel:=B_KEYREF.BI_PREL;
   {!
   |? _args.BI_PREL.REF:=$B_KEYREF.BI_PREL;
      _args.BI_PREL.add();
      B_KEYREF.next()
   !}
?};
_size:=_args.BI_PREL.size();
B_KEYREF.cntx_pop();

:: - Z uprawnieniami do czynności ZPR_INS_ZADU użytkownik widzi wszystkie zadania wszystkich operatorów
:: - Bez uprawnień do czynności ZPR_INS_ZADU użytkownik widzi zadania wszystkich operatorów,
::   ale tylko przydzielone (TODO_MOJE) oraz wolne (TODO_WOLNE) wszystkich operatorów
{? exec('chk_role','#b__box',OPERATOR.USER,'ZPR_INS_ZADU')
|| _args.where:='BI_TODO.BI_PREL in (select :_a.REF from :_a)'
|| _args.where:='BI_TODO.BI_PREL in (select :_a.REF from :_a) and (BI_TODO.BI_STAT=:_b or BI_TODO.BI_STAT=:_c)'
?};

BI_TODO.f_set('DT,TM','',_args.where,_args.BI_PREL,exec('TODO_MOJE','#bi_stat'),exec('TODO_WOLNE','#bi_stat'));
~~


\get_act_proc_params
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Zwraca porty wejściowe wraz z wartościami czynności startowej w procesie
::   WE:  _a [STRING]    - B_ACTION.UID
::        _b [REFERENCE] - B_PREL.ref() elementu startowego w procesie do którego użytkownik ma uprawnienia
::       [_c] [RULE]     - formuła na porty wejściowe
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_act_uid:=_a;
_b_prel:=_b;
_portsIn:=
   {? type_of(_c)=type_of("") & +_c
   || _c()
   || exec('portsIn','#b__box',_act_uid)
   ?};

_b_ele:=exec('FindInSet','#table','B_ACTION','UNIK',_act_uid,,"B_ACTION.B_ELE",,,null());
_b_proc:=exec('FindAndGet','#table',B_PREL,_b_prel,,"B_PREL.B_PROC",null());

B_CONN.index('FROM');
B_CONN.prefix(_b_proc,_b_prel);
_loop1:=B_CONN.first();
{!
|? _loop1
|!
   {? B_CONN.TO().B_ELE=_b_ele
   || B_PORT.index('B_ELE');
      B_PORT.prefix('T',_b_ele,exec('kind_in','#b_port'));
      {? B_PORT.first()
      || {!
         |?
::          Sprawdzam czy port ma zdefiniowaną wartość
            B_VALPRT.index('UNIK');
            B_VALPRT.prefix(B_CONN.TO,B_PORT.ref());
            {? B_VALPRT.first()
            || exec('portsInSet','#b__box',_portsIn,_act_uid,B_PORT.SYMBOL,($B_VALPRT.FORMULA)())
            ?};
            B_PORT.next()
         !}
      ?}
   ?};
   _loop1:=B_CONN.next()
!};

_portsIn[1].PORTS


\web_run
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wywołanie menadżera procesu pod webterm
::   WE:  _a - B_PREL.ref() lub BI_PREL.ref()
::        _b - Akcja okna
::       [_c] - [obj_new] - Porty wejściowe
::        _d - ścieżka uruchomienia (Todo, Proc, Area, web_Proc, web_Todo)
::       [_e] - uruchomienie w trybie usługowym - B_WORKER.ref()
::       [_f] - obj_new - dodatkowe argumenty kontekstowe które przesłać do czynności
::       [_g] - czy akcja dla grupy rekordów (komunikaty przekierowane do KOMM)
::       [_h] - BI_PREL.UID zdarzenia sygnałowego, do ostepmlowania uruchuchomionego zdarzenia przechwytującego
::       [_i] - wartości parametrów przekazywane przez sygnał
::       [_j] - uruchom automatycznie czynność w webTem
::   WY:
::----------------------------------------------------------------------------------------------------------------------
    _prel:={? var_pres('_a')=type_of('')             || {? ref_tab(_a)=B_PREL
                                                        || exec('FindAndGet','#table',B_PREL,_a,,,null())
                                                        |? ref_tab(_a)=BI_PREL
                                                        || exec('FindAndGet','#table',BI_PREL,_a,,,null())
                                                        || return()
                                                        ?}
           |? var_pres('_a')=type_of(null())         || _a || return() ?};
 _win_act:={? var_pres('_b')=type_of('')             || _b || return() ?};
 _portsIn:={? var_pres('_c')=type_of(obj_new('obj')) || _c
           |? var_pres('_c')=type_of("")             || (_c)() || ~~   ?};
_path:={? var_pres('_d')=type_of('')             || _d || FUN.error('Nie przekazano ścieżki wywołania.'@); return() ?};
_b_worker:={? var_pres('_e')=type_of(null())         || _e || null()   ?};
 _context:={? var_pres('_f')=type_of(obj_new('obj')) || _f
           |? var_pres('_f')=type_of("")             || (_f)() || ~~   ?};
   _grupa:={? var_pres('_g')=type_of('')             || _g || 'N'      ?};
 _sig_uid:={? var_pres('_h')=type_of('')             || _h || ''       ?};
 _sig_val:={? var_pres('_i')=type_of(obj_new('obj')) || _i || ~~       ?};
_web_auto:={? var_pres('_j')=type_of('')             || _j || 'N'      ?};

exec('proMan','#b_proman',_prel,_win_act,_portsIn,_path,_b_worker,_context,_grupa,_sig_uid,_sig_val,,_web_auto)


\isStartMultiProc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Funkcja sprawdza czy czynność może rozpoczynać kilka różnych procesów
::   WE: _a [STRING] - Identyfikator czynności.
::   WY: 0/1 lub -1 w przypadku błędnego parametru
::----------------------------------------------------------------------------------------------------------------------
_uid:={? var_pres('_a')=type_of('') || _a || return(-1) ?};

_proc:=obj_new('TAB');
:: pobranie czynności _uid i procesów, w których ta czynność jest bezpośrednio za elementem startowym
:: zgodnie z uprawnieniami użytkownika OPERATOR.USER
exec('usractTab','#b_desktop',_proc,_uid);
{? _proc.TAB.first()
|| {!
   |? {? _proc.TAB.PROC='N'
      || _proc.TAB.del(,1)=2
      || _proc.TAB.next()
      ?}
   !}
?};
_proc.TAB.size()>1


\authorized
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Sprawdza, czy dany operator posiada uprawnienia do choć jednej czynności obszaru roboczego przypisanej
::       do podanej dziedziny
::   WE: _a - STRING - symbol obszaru roboczego
::       _b - STRING - dziedzina
::       [_c] - STRING - dodatkowe ograniczenie wg podanych początkowych znaków czynności - domyślnie brak
::   WY: 1-ma 0-nie ma
::----------------------------------------------------------------------------------------------------------------------
_part_act:={? var_pres('_c')=type_of('') || _c || '' ?};

_res:=0;
_b_area:=_a;
_b_domain:=_b;

_areatask:=app_info('area_task');

_areatask.prefix(_b_area,);
{? _areatask.first()
|| {!
   |? _b_action:=_areatask.B_TASK;
      {? exec('FindInSet','#table','B_ACTION','UNIK',_b_action,,"B_ACTION.B_DOMAIN().SYMBOL",,,'')=_b_domain
       & (_part_act='' | _part_act=((+_part_act)+_b_action))
       & exec('chk_role','#b__box',OPERATOR.USER,_b_action)
      || _res:=1
      ?};
      _areatask.next() & _res=0
   !}
?};
obj_del(_areatask); &_areatask;
_res


\chk_EndOrAcc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Sprawdza, czy dany operator posiada uprawnienia czynności redakcji i akceptacji
::   WE: _a - STRING - kod czynności redakcji
::       _b - STRING - kod czynności akceptacji
::   WY: 0-nie ma do żadnej 1-ma do obu 2-ma do redakcji 4-ma do akceptacji
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_actionEnd:=_a;
_actionAcc:=_b;
_end:=exec('chk_role','#b__box',OPERATOR.USER,_actionEnd);
_acc:=exec('chk_role','#b__box',OPERATOR.USER,_actionAcc);
_wyn:={? _end & _acc || 1
      |? _end        || 2
      |? _acc        || 4
      ?};
_wyn


\valueBiPort
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Zwraca wartość pola VALUE dla wskazanego portu instancji procesu
::   WE: _a - BI_PREL
::       _b - rodzaj portu
::       _c - parametr
::   WY: wartość pola VALUE
::----------------------------------------------------------------------------------------------------------------------
_wyn:='';
BI_PORT.cntx_psh(); {? BI_PORT.name()='' || BI_PORT.use('bi_o____') ?};
B_PORT.cntx_psh();
BI_PORT.index('PRELRODZ');
BI_PORT.prefix(_a,_b);
{? BI_PORT.first()
|| {!
   |? {? BI_PORT.B_PORT().SYMBOL=_c
      || _wyn:=BI_PORT.VALUE;
         0
      || BI_PORT.next()
      ?}
   !}
?};
BI_PORT.cntx_pop();
B_PORT.cntx_pop();
_wyn


\is_okr_dom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.00]
:: OPIS: Czy istnieje okres dla dziedziny
::   WE: _a - okres
::       _b - dziedzina
::----------------------------------------------------------------------------------------------------------------------
{? _b='OBE' || _b:='OBG'
|? 'TTE|TPP|WYP|TRE'*_b || _b:='LMG'
|? 'LUO'*_b || _b:='LUM'
?};

{? 'CTR|FKS|FST|KAS|LMG|LSP|LZK|LUM|OBE|OBG|'*_b=0
|| 1
|| _jest:=0;
   B_DOMAIN.cntx_psh();
   B_DOMAIN.index('SYMBOL'); B_DOMAIN.prefix(_b,);
   {? B_DOMAIN.first()
   || OKR_OBSZ.cntx_psh();
      OKR_OBSZ.index('UNIK'); OKR_OBSZ.prefix(_a,B_DOMAIN.ref());
      _jest:=OKR_OBSZ.first();
      OKR_OBSZ.cntx_pop()
   ?};
   B_DOMAIN.cntx_pop();
   _jest
?}


\isActiveProcOrProblems
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Sprawdza czy wogóle jest aktywny jakiś proces gdzie ten rekord kluczony występuje oraz
::       sprawdza czy nie ma zgłoszonych problemów w tym procesie
::   WE: _a [STRING] - uid_ref rekordu
::   WY: obiekt z wynikami sprawdzania
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new('isActive','isProblem','b_proc');
_result.isActive:=0;
_result.isProblem:=0;
_result.b_proc:=null();
_uid_ref:={? var_pres('_a')=type_of('') || _a || return(_result) ?};

BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID'); BI_PROC.prefix();
B_KEYREF.cntx_psh();
B_KEYREF.index('KEYREF');
B_KEYREF.prefix(_uid_ref);
{? B_KEYREF.first()
|| _result.isActive:=1;
   _result.b_proc:=B_KEYREF.BI_PROC().B_PROC;
   {!
   |? _result.isProblem:=exec('isProblemsProc','#bi_msg',B_KEYREF.BI_PROC);
      ~_result.isProblem & B_KEYREF.next()
   !}
?};
B_KEYREF.cntx_pop();
BI_PROC.cntx_pop();
_result


\grpkeyDel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.42]
:: OPIS: Usuwa pozycję _a ze wszystkich kluczy grupujących
::   WE: _a - pozycja
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('delItem','#b_grpkey',_a)


\priority_action_red
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Akcja 'Priorytet' w okienku redagowania
::   WE: _a - STRING - akronim tabeli z polem PRIORITY
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:='';
{? var_pres('_a')=type_of('')
|| _tab:=_a
?};
{? _tab=''
|| _tab:=2-(!cur_tab(1,1))
?};
exec('priority_action_core','#b_design',_tab,0);
''


\priority_action_wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Akcja 'Priorytet' w okienku wertowania
::   WE: _a - STRING - akronim tabeli z polem PRIORITY
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:='';
{? var_pres('_a')=type_of('')
|| _tab:=_a
?};
{? _tab=''
|| _tab:=2-(!cur_tab(1,1))
?};
{? exec('priority_action_core','#b_design',_tab,1)>0
||
:: Uuaktualniam opisy na TODO - a przez to pośrednio priorytety
   exec('desc_update','#b__box',($_tab)().uidref())
?};
''


\auth_domain
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [JK] [19.22]
:: OPIS: Sprawdza, czy dany operator posiada uprawnienia do choć jednej czynności przypisanej
::       do podanej dziedziny
::   WE:   _a - STRING - kolejne dziedziny produktowe rozdzielone ','
::         _b - STRING - Wskazanie na kanały dostępu rozdzielone ',' (B - oba; M - Jterm; W - Webterm)
::   WY: 1-ma 0-nie ma
::----------------------------------------------------------------------------------------------------------------------
{? _<2 || return(0) ?};
_res:=0;
_b_domain:=spli_str(_a,','); _b_can:=spli_str(_b,',');
_max:=obj_len(_b_domain); _max2:=obj_len(_b_can);
_where:='where (B_ACTION.B_CAN='+'\''+_b_can[1]+'\'';
{? _max2>1
|| {! _ii:=2.._max2 |! _where+=' or B_ACTION.B_CAN='+'\''+_b_can[_ii]+'\'' !}
?};
_where+=') and (B_DOMAIN.SYMBOL='+'\''+_b_domain[1]+'\'';
{? _max>1
|| {! _ii:=2.._max |! _where+=' or B_DOMAIN.SYMBOL='+'\''+_b_domain[_ii]+'\'' !}
?};
_where+=')';
_t_action:=sql('select B_ACTION.UID from B_ACTION join B_DOMAIN '+_where);
{? _t_action.first()
|| {!
   |? _b_action:=_t_action.UID;
      {? exec('chk_role','#b__box',OPERATOR.USER,_b_action)
      || _res:=1
      ?};
      _t_action.next() & _res=0
   !}
?};
_res


\auth_domain2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Sprawdza czy dany użytkownik ma uprawnienia do przynajmniej jednej wymienionej dziedziny przez co najmniej
::       jeden wymieniony kanał(posiada uprawnienia chociaż do jednej czynności)
::   WE: _a - STRING - dziedzina lub kolejne dziedziny produktowe rozdzielone ','
::       [_b] - STRING - Wskazanie na kanały dostępu rozdzielone ',' (M - Jterm; W - Webterm, Q - Qlik). Jeżeli nie podane
::                       to dowolny kanał
::       [_c] - USERS.ref lub bieżący użytkownik
::   WY: 1 - jest uprawnienie
::       0 - brak uprawnień
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_domains:=_a;

_canals:='';
{? var_pres('_b')=type_of('')
|| _canals:=_b
?};

_user:=OPERATOR.USER;
{? var_pres('_c')=type_of(USERS.ref())
|| _user:=_c
?};

_can_continue:=1;
_result:=0;

B_USRDOM.cntx_psh();


{? _domains<>'' & _domains*','=0
|| _domains+=','
?};

{? _canals*'B'>0
|| _canals:=gsub(_canals,'B','M,W')
?};
{? _canals<>'' & _canals*','=0
|| _canals+=','
?};

{? _domains<>''
||
   _split:=spli_str(_domains,',');
   {! _it:=1..obj_len(_split)
   |? _can_continue>0
   |! _dom:=_split[_it];
      {? _dom<>''
      ||
         {? _canals<>''
         || {? var_pres('_splitc')>100
            || obj_del(_splitc)
            ?};
            _splitc:=spli_str(_canals,',');

            {! _it2:=1..obj_len(_splitc)
            |? _can_continue>0
            |! _can:=_splitc[_it2];
               {? _can<>''
               || _can_check:=1;
                  {? _can='M'
                  || B_USRDOM.index('DS_J')
                  |? _can='W'
                  || B_USRDOM.index('DS_W')
                  |? _can='Q'
                  || B_USRDOM.index('DS_Q')
                  || _can_check:=0
                  ?};
                  {? _can_check>0
                  ||
                     B_USRDOM.prefix(REF.FIRMA,_user,'T',_dom,);
                     {? B_USRDOM.first()
                     || _result:=1;
                        _can_continue:=0
                     ?}
                  ?}
               ?}
            !}
         || B_USRDOM.index('DS');
            B_USRDOM.prefix(REF.FIRMA,_user,_dom,);
            {? B_USRDOM.first()
            || _result:=1;
               _can_continue:=0
            ?}
         ?}
      ?}
   !}
?};
B_USRDOM.cntx_pop();
_result


\magic_happens
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Tu się dzieje cała magia sprzątania
::       KONTEKST - zaprefiksowana dziedzina BI_PREL
::   WE: _a - mp          - Menadżer procesu
::       _b - INTEGER     - tryb wyświetlania komunikatów
::       _c - INTEGER     - 0/1 - czy wyświetlać progressa
::       _d - BI_STAT.ref - status zadań które są czyszczone
::       _e - B_WORKER.ref
::   WY: obj_new - obiekt zwracający wynik
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;
_komm:=_b;
_progress:=_c;
_status:=_d;
_b_worker:=_e;

_result:=obj_new('IL_DEL'
                  ,'IL_CHK');
_result.IL_DEL:=0;
_result.IL_CHK:=0;

_il_del:=0;
_il_chk:=0;

_class:={? __develop || @.Class.cProMan || @.CLASS.cProMan ?};

_prg_step:=exec('progress_step','#b__box');

_lp:=1;
{!
|?
   {? _progress>0
   || {? _lp%*_prg_step=0
      || FUN.prg_next()
      ?}
   ?};

   _next:=0;
   _ref_nxt:=null();
   BI_PREL.cntx_psh();
   {? BI_PREL.next()
   || _ref_nxt:=BI_PREL.ref()
   ?};
   BI_PREL.cntx_pop();

   _il_chk+=1;
   _can_continue:=1;
   _bi_prel:=BI_PREL.ref();
   {? var_pres('_mp_local')>100
   || obj_del(_mp_local)
   ?};
   _mp_local:=obj_new(_class);
   {? exec('lock','#bi_prel',,_komm)>0
   ||
      _standard_clean:=1;
::    Sprawdzam czy czynność ma własną formułę na czyszczenie
      B_ACTION.prefix(BI_PREL.B_PREL().B_ELE);

      {? B_ACTION.first()
      ||
         {? exec('is_fun','#file',-('!'+B_ACTION.UID),'clean')
         ||
::          Istnieje formuła dedykowana czynności
            _stat:=exec('getStatus','#bi_prel',_bi_prel);
            exec('proMan','#b_proman',_bi_prel,'',,'Cleaner',,,,,,_b_worker<>null());
            _il_del+=_stat<>exec('getStatus','#bi_prel',_bi_prel);
            _standard_clean:=0;
            ~~
         ?}
      ?};

      {? _standard_clean>0 & _mp_local.setCntx(_bi_prel)
      ||
         {? var_pres('_keyRefs')>100
         || obj_del(_keyRefs)
         ?};
         _keyRefs:=_mp_local.getRefs();

         {? obj_len(_keyRefs)>0
         ||
            {! _it:=1..obj_len(_keyRefs)
            |? _can_continue>0
            |! _kref:=_keyRefs[_it];
               {? type_of(_kref)>0
               || {? +_kref=48 & type_of(ref_tab(_kref))>0
                  || {? var_pres('_tab')>100
                     || obj_del(_tab)
                     ?};
                     _tab:=ref_tab(_kref);
                     _ref:=exec('FindAndGet','#table',_tab,_kref,,,null());
                     {? _ref=null()
                     ||
                        exec('setStatus','#bi_prel',BI_PREL.ref(),__Status.URUCHOMIONA);
::                      Nie znaleziono rekordu kluczowego powiązanego z zadaniem, więc robię error
                        _msg:='Rekord kluczowy powiązany z zadaniem został usunięty. Zadanie zostało zatrzymane przez czynność czyszczącą zadania.'@;
                        _mp_local.error(_msg);
::                      obsluga statusu czynnosci na wyjsciu
                        _stat:=exec('getStatus','#bi_prel',_bi_prel);
                        {? _stat=__Status.FL_ERROR    || {? _mp_local.isMicro() || _mp_local.coreCancel() || _mp_local.coreError() ?} ?};
                        _can_continue:=0;
                        _il_del+=1
                     ?}
                  ?}
               ?}
            !}
         ?}
      ?};
      exec('unlock','#bi_prel',_bi_prel)
   ?};

   {? _ref_nxt<>null()
   || _next:=BI_PREL.seek(_ref_nxt)
   ?};
   _lp+=1;
   _next>0
!};
_result.IL_DEL:=_il_del;
_result.IL_CHK:=_il_chk;
_result


\clean_record
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Czyści zadania z listy TODO powiązanych z danym rekordem.
::   WE: _a - STRING - uidref rekordu w jakiejs tabeli, dla którego uruchomiony będzie cleaner
::       _b - czy wyświetlać komunikaty 0/[1]
::   WY: obj_new - obiekt zwracający wynik
::----------------------------------------------------------------------------------------------------------------------
_uid:='';
{? var_pres('_a')=type_of('')
|| _uid:=_a
?};

_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_result:=obj_new('IL_DEL','IL_CHK');
_result.IL_DEL:=0;
_result.IL_CHK:=0;

_il_del:=0;
_il_chk:=0;

{? _uid<>''
||
   _can_continue:=1;
   B_PREL.cntx_psh();
   BI_PROC.cntx_psh();
   BI_TODO.cntx_psh();
   BI_PREL.cntx_psh();
   B_KEYREF.cntx_psh();
   BI_TODO.use('bi_t____');

   BI_PROC.use('bi_p____');
   BI_PREL.use('bi_e____');
::   BI_PREL.index('CLASS2');
   BI_PREL.index('UID');
   B_ACTION.cntx_psh();
   B_ACTION.index('B_ELE');
   B_KEYREF.index('KEYREF');

   B_KEYREF.prefix(_uid);
   {? B_KEYREF.first()
   ||
      {!
      |?
         BI_PREL.cntx_psh();
         BI_PREL.use(ref_name(B_KEYREF.BI_PREL));
         BI_PREL.prefix(B_KEYREF.BI_PREL().UID);
         {? BI_PREL.first() & BI_PREL.FIRMA=REF.FIRMA & BI_PREL.B_PREL().CLASS='B_ACTION'
                            & (BI_PREL.BI_STAT=__Status.URUCHOMIONA | BI_PREL.BI_STAT=__Status.OCZEKUJACA)
         || {? var_pres('_res')>100
            || obj_del(_res)
            ?};
            _res:=exec('magic_happens','#b__box','',1,0,'',null());
            _il_chk+=_res.IL_CHK;
            _il_del+=_res.IL_DEL
         ?};
         BI_PREL.cntx_pop();
         B_KEYREF.next()
      !}

::      {? _can_continue>0 & _dialog>0
::      || _msg:='Zakończono czyszczenie.\n\n'
::               'Przetworzonych zadań: %1\n'
::               'Usuniętych zadań: %2'@[$_il_chk,$_il_del];
::         FUN.info(_msg)
::      ?}
   ?};
   BI_PROC.cntx_pop();
   BI_TODO.cntx_pop();
   BI_PREL.cntx_pop();
   B_PREL.cntx_pop();
   B_ACTION.cntx_pop();
   B_KEYREF.cntx_pop()
?};
_result.IL_DEL:=_il_del;
_result.IL_CHK:=_il_chk;
_result


\progress_step
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Zwraca krok dla progressa (dla cleanera)
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
10


\force_signal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Odpalenie "na siłę" sygnału rzucającego bez procesu w celu uruchomienia procesów konsumujących dany sygnał
::   WE: _a - B_SIGNAL.SYMBOL
::       [_b] - czy wielofirmowy ([N]/T)
::       [_c] - tablica indeksowana parametrów: obj_new('PARAMETR','VALUE')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _signal:=_a || return() ?};
{? var_pres('_b')=type_of('') || _wielofirmowy:=_b || _wielofirmowy:='N' ?};
{? var_pres('_c')>100 || _sig_val:=_c || _sig_val:=~~ ?};

exec('force','#b_signal',_signal,_wielofirmowy,_sig_val)


\autoRUN
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [20.14]
:: OPIS: Uruchamia automatycznie pierwsze zadanie powiązane wg rekordu kluczowego
::   WE: _a - TABELA.uidref
::       _b - tytuł zakładki do przywrócenia
::   WY: 1-uruchomiono 0-nie
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
{? var_pres('_b')<>type_of('') || _b:='' ?};

BI_TODO.cntx_psh();
_bi_todo:=exec('todo_select','#b__box',_a,1);
{? _bi_todo<>null() & (BI_TODO.prefix(); BI_TODO.seek(_bi_todo))
|| _res:=1;
   exec('todoRun','#bi_todo',_b)
?};
BI_TODO.cntx_pop();
_res


\get_proc_users
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Zwraca listę użytkowników danego procesu - wszystkich albo ograniczoną do jednej czynności
::   WE: _a - symbol procesu, np. 'RPO_ZLE' / ref procesu - B_PROC.ref()
::       [_b] - wersja procesu, np. '20.42' (jeżeli _a jest tekstem)
::       [_c] - identyfikator czynności, np. 'TTE_PZL_DZLE'
::       [_d] - ref roli - B_ROLE.ref()
::   WY: lista użytkowników (w postaci tabeli tymczasowej z zawartością: $USERS.ref(), USERS.KOD, $USERS.P, $USERS.OSOBA
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=null();
_role:=tab_tmp(1,'B_ROLE','STRING[16]','Rola');
_users:=tab_tmp(1
   ,'REF','STRING[16]','$USERS.ref()'
   ,'KOD','STRING[10]','USERS.KOD'
   ,'P','STRING[16]','$USERS.P'
   ,'OSOBA','STRING[16]','$USERS.OSOBA'
   ,'CNT','INTEGER','Licznik ról'
);
_firma:=exec('firma','ustawienia');

:: Ustalenie procesu
{? var_pres('_a')=type_of(null())
|| _b_proc:=_a
|? var_pres('_a')=type_of('') & var_pres('_b')=type_of('')
|| B_PROC.cntx_psh();
   B_PROC.index('SYM');
   B_PROC.prefix('N',_firma,_a,_b,);
   {? B_PROC.first() || _b_proc:=B_PROC.ref() ?};
   B_PROC.cntx_pop()
?};

:: Zebranie ról z elementów procesu
{? _b_proc<>null()
|| B_PREL.cntx_psh();
:: Zebranie wg czynności i jej ról w procesie
   {? var_pres('_c')=type_of('') & _c<>''
   || B_PREL.index('PROC');
      B_PREL.prefix(_b_proc,'B_ACTION',);
      {? B_PREL.first()
      || {!
         |? {? B_PREL.B_ELE().SYMBOL=_c
            || _role.prefix($B_PREL.B_ROLE,);
               {? ~_role.first() || _role.B_ROLE:=$B_PREL.B_ROLE; _role.add() ?}
            ?};
            B_PREL.next()
         !}
      ?}
:: Zebranie wg ról w procesie
   || B_PREL.index('PROC');
      B_PREL.prefix(_b_proc,'B_LANE',);
      {? B_PREL.first()
      || {!
         |? _role.prefix($B_PREL.B_ROLE,);
            {? ~_role.first() || _role.B_ROLE:=$B_PREL.B_ROLE; _role.add() ?};
            B_PREL.next()
         !}
      ?}
   ?};
   B_PREL.cntx_pop()
?};

:: Tworzenie listy użytkowników
_role.prefix();
{? _role.first()
|| B_USRROL.cntx_psh();
   USERS.cntx_psh();
   {!
   |? {? var_press('_d')<0 | var_press('_d')<>type_of(null()) | $_d=_role.B_ROLE
      || B_USRROL.index('UNIK');
      B_USRROL.prefix(_firma,BIT.sqlint(_role.B_ROLE));
      {? B_USRROL.first()
      || {!
         |? _users.prefix($B_USRROL.USERS,);
            {? ~_users.first()
            || _users.REF:=$B_USRROL.USERS;
               _users.KOD:=B_USRROL.USERS().KOD;
               _users.P:=$USERS.P;
               _users.OSOBA:=$USERS.OSOBA;
               _users.CNT:=1;
               _users.add()
            || _users.CNT+=1;
               _users.put()
            ?};
            B_USRROL.next()
         !}
         ?}
      ?};
      _role.next()
   !};
   B_USRROL.cntx_pop();
   USERS.cntx_pop()
?};

_users.prefix();
_users


\is_ks_dom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JK [20.42]
:: OPIS: Czy istnieje okres bilansu otwarcia/zamknięcia dla dziedziny
::   WE: _a - dziedzina
::----------------------------------------------------------------------------------------------------------------------
{? _a='OBE' || _a:='OBG'
|? 'TTE|TPP|WYP|TRE'*_a || _a:='LMG'
|? 'LUO'*_a || _a:='LUM'
?};
{? 'KAS|LMG|LSP|LZK|LUM|'*_a>0
|| 0
|| 1
?}


\get_bi_prel2run
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [21.37]
:: OPIS: Formuła wyszukuje instancję czynności, która byłaby uruchomiona przez menadżera procesów.
::   WE: _a [STRING]       - Identyfikator czynności.
::       _b [STRING/ARRAY] - Identyfikator lub tablica z identyfikatorami rekordów kluczowych.
::   WY: Wskazanie instancji czynności (BI_PREL) lub null().
::       ~~ - w przypadku błędu parametrów wywołania.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & +_a=12
|| _uid:=_a
|| return()
?};
{? var_pres('_b')=type_of('')
|| _refs:=obj_new(1);
   _refs[1]:=_b
|? var_pres('_b')=type_of(obj_new(1))
|| _refs:=_b
|| return()
?};

_bi_prel:=null();

:: pobranie uruchomionych instancji czynności _uid
_biprels:=exec('getInstPrel4Ref','#b_keyref',_refs,_uid);
:: zalogowany użytkownik
_ope:=exec('operatorUser','#users');
:: czy użytkownik może uruchomić czynność poza procesem
_runmicro:=exec('runmicro','#b_action',_uid);

:: +-------------------------------------------------------------------------------------------------------------------+
:: | Poniższy kod (dotyczący ustalenia instancji czynności, która ma być uruchomiona) został zapożyczony z formuły     |
:: | \mp_run (w bieżącym pliku). Zapożyczenie ma na celu uzyskanie dokładnie tej samej kolejności przetwarzania,       |
:: | a dokładniej: uzyskanie dokładnie tego samego wskazania na instancję.                                             |
:: +-------------------------------------------------------------------------------------------------------------------+
{? _biprels[1]
|| _BIPRELS:=tab_tmp(2
      ,'LP' ,'INTEGER'  ,'lp.'
      ,'TS' ,'REAL'     ,'czas startu'
      ,'II' ,'INTEGER'  ,'ii');
   _size:=obj_len(_biprels);
   {! _ii:=1.._size
   |! _BIPRELS.LP:=exec('FindAndGet','#table',BI_PREL,_biprels[_ii],,"BI_PREL.USERS",null())=_ope;
      _BIPRELS.TS:=exec('FindAndGet','#table',BI_PREL,_biprels[_ii],,"BI_PREL.START",null());
      _BIPRELS.II:=_ii;
      _BIPRELS.add()
   !};

   BI_PREL.cntx_psh();
   {? BI_PREL.name()=''
   || BI_PREL.use('bi_e____')
   ?};
   BI_PREL.index('UID');
   _continue:=1;
   _loop:=_BIPRELS.last();
   {!
   |? _loop
   |! _ref:=_biprels[_BIPRELS.II];
      BI_PREL.prefix();
      {? BI_PREL.seek(_ref) & BI_PREL.r_lock(1,1,1)
      || _canRunBiPrel:=exec('canRunBiPrel','#bi_todo',_ref,_ope,0);
         {? _canRunBiPrel=2
         || _bi_prel:=_ref
         |? _canRunBiPrel=-2 & ~_runmicro
         || _continue:=0
         ?};
         BI_PREL.r_unlock()
      || _continue:=0
      ?};
      _loop:=_continue & _bi_prel=null() & _BIPRELS.prev()
   !};
   BI_PREL.cntx_pop()

?};

_bi_prel


\get_b_grpkey4bi_prel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [21.37]
:: OPIS: Formuła zwraca tabelę tymczasową z elementami znajdującymi się na liście kluczy grupujących dla wskazanej
::       instancji procesu. Funkcja zakłada, że klucz grupujący jest zapisany jako parametr wyjściowy czynności.
::   WE:  _a  [REFERENCE] - Wskazanie instancji czynności (BI_PREL).
::       [_b] [STRING]    - Typ / symbol klucza grupującego [GRPKEY*/GGRPKEY].
::   WY: Tabela tymczasowa z elementami klucza grupującego.
::       ~~ - w przypadku błędu parametrów wywołania.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=BI_PREL
|| _bi_prel:=_a
|| return()
?};
_name:={? var_pres('_b')=type_of('') & ',GRPKEY,GGRPKEY,'*',%1,' [_b] || _b || 'GRPKEY' ?};

_grpkey:=exec('valueBiPort','#b__box',_bi_prel,exec('kind_out','#b_port'),_name);
_RET:=tab_tmp(1,'ITEM','STRING[255]','Pozycja');
B_GRPKEY.cntx_psh();
B_GRPKEY.index('ITEM1');
B_GRPKEY.prefix(_grpkey,);
{? B_GRPKEY.first()
|| _lp:=1;
   {!
   |? _RET.blank();
      _RET.ITEM:=B_GRPKEY.ITEM;
      _RET.add();
      B_GRPKEY.next()
   !}
?};
B_GRPKEY.cntx_pop();
_RET


\autoAkc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [23.25]
:: OPIS: Kontrola czy automatycznie zaakceptować dokument
::   WE: _a - wskazanie na menedżera procesu
::       _b - numer parametru
::       [_c] - kod czynności
::   WY: 1-tak 0-nie
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_isMicro:={? var_pres('_a')>=type_of(obj_new('obj')) || _a.isMicro() || 1 ?};
_par:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_act:={? var_pres('_c')=type_of('') || _c || '' ?};

{? _par>0
|| _par:=exec('get','#params',_par,2)='T';
   {? _par & (_act='' | exec('chk_role','#b__box',OPERATOR.USER,_act)) & _isMicro
   || _res:=1
   ?}
?};
_res


\todo_rebuild
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Odtwarza zapisy TODO dla przekazanych czynności uwzględniając aktualne uprawnienia do ról i danych.
::       Aby odtworzenie zadziałało instancja elementu procesu musi mieć status:
::       1. Uruchomiony
::       2. Oczekujący
::       3. Zawieszony
::       Dodatkowo do zadań TODO nie mogą być zgłoszone żadne problemy
::       UWAGA!!! Formuła nie uwzględnia zastępstw!!!
::   WE: _a - STRING - lista symboli czynności którym odbudować TODO separowana ','
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_actions:=_a;

{? _actions*','>0
|| _split:=spli_str(_actions,',');
   {! _it:=1..obj_len(_split)
   |! _act_uid:=_split[_it];
      {? _act_uid<>''
      || exec('rebuild4uid','#bi_todo',_act_uid)
      ?}
   !}
|| exec('rebuild4uid','#bi_todo',_actions)
?};
~~


:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 0733771f572d1faef9f192edd0b5569c24203d55451f1d448daf8b2d35a8ba487e5f6eaf7ba88411d5f00816388cfd56c2e21fdba5145ff547a5359d29f19c387c2b3ae00705cd470b56623c0a6d9eea3b82e753824eb70826677476e6d049940e7f15ea875cda499d96bd434857ac91769b9f69855936802c13fa8d6f5f8b6a
