:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #bi_proc.fml [17.00]
:: Utworzony: 08.07.2013
:: Autor: TMR
::======================================================================================================================
:: Zawartosc: Formuły do obsługi tabeli BI_PROC
::======================================================================================================================


\buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Zwraca obiekt nazwany - bufor tabeli BI_PROC
::   WY: obj_new()
::----------------------------------------------------------------------------------------------------------------------
exec('BI_PROC','#buffer')


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Wyświetla tabelę BI_PROC
::----------------------------------------------------------------------------------------------------------------------
BI_PROC.cntx_psh();
BI_PROC.prefix();
BI_PROC.select();
BI_PROC.cntx_pop()


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Funkcja dodająca wpis do tabeli BI_PROC
::   WE: _a - obj_new - tablica nazwana będąca buforem tabeli exec('buffer','#bi_proc')
::   WY:      [REFERENCE]  - wskazanie na dodany rekord (lub już istniejący)
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100 || _a || return(null) ?};
_nomask:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_res:=0;
BI_PROC.cntx_psh();
{? ~_nomask || BI_PROC.use('bi_p____') ?};
BI_PROC.index('UID');
BI_PROC.prefix(_buffer.UID,);
{? BI_PROC.first()
|| _buffer.get();
   _res:=1
|| BI_PROC.blank(1);
   _buffer.set();
   {? BI_PROC.add()
   || _buffer.get();
      _res:=1
   ?}
?};
BI_PROC.cntx_pop();
_res


\put
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Funkcja poprawiająca wpis do tabeli BI_PROC
::   WE: _a - obj_new - tablica nazwana będąca buforem tabeli exec('buffer','#bi_proc')
::   WY:      [REFERENCE]  - wskazanie na dodany rekord (lub już istniejący)
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100 || _a || return(null) ?};

_res:=0;
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('UID'); BI_PROC.prefix(_buffer.UID);
{? BI_PROC.first()
|| _buffer.set();
   _res:=BI_PROC.put()
?};
BI_PROC.cntx_pop();
_res


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Kasuje podany rekord tabeli BI_PROC
::   WE: _a - [REFERENCE]  - BI_PROC.ref()
::   WY: >0 -wyczyszczone,
::      <=0 -niewyczyszczone
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};

:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_result:=0;
_can_continue:=1;
_code:='';

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('UID'); BI_PROC.clear();
{? BI_PROC.seek(_ref)
|| {? exec('clean','#bi_proc',_ref)>0
   || {? BI_PROC.del(,1)>0
      || _result:=1
      || undo();
         _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=-1
?};
BI_PROC.cntx_pop();
{? _result<0 || undo() ?};
{? _mydo || end() ?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Czyści powiązania do rekordu tabeli BI_PROC
::   WE: _a - [REFERENCE] - BI_PROC.ref()
::   WY: >0 -wyczyszczone,
::       <=0 -niewyczyszczone
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};

:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania ---

BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('UID'); BI_PROC.clear();
{? BI_PROC.seek(_ref)
||
:: 1. Usuwam instancje elementów
   BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?};
   BI_PREL.index('PREL');
   BI_PREL.prefix(_ref);
   {? BI_PREL.first()
   || {!
      |? _can_continue:=exec('delete','#bi_prel',BI_PREL.ref());
         BI_PREL.first() & _can_continue>0
      !}
   ?};
   BI_PREL.cntx_pop();

:: 2. usuwam instancje kluczowych elementów (są usuwane w triggerze po zmianie statusu BI_PRELa i BI_PROCa ale...)
   {? _can_continue>0
   || B_KEYREF.cntx_psh();
      B_KEYREF.index('BI_PROC');
      B_KEYREF.prefix(ref_name(_ref),_ref);
      {? B_KEYREF.first()
      || {!
         |? _can_continue:=exec('delete','#b_keyref',B_KEYREF.ref());
            B_KEYREF.first() & _can_continue>0
         !}
      ?};
      B_KEYREF.cntx_pop()
   ?};

:: Usuwam powiązania pomiędzy instancjami elementów
   BI_CONN.cntx_psh(); {? BI_CONN.name()='' || BI_CONN.use('bi_c____') ?};
   BI_CONN.index('BI_PROC'); BI_CONN.prefix(BI_PROC.ref());
   {? BI_CONN.first()
   || {!
      |? _can_continue:=exec('delete','#bi_conn',BI_CONN.ref());
         BI_CONN.first() & _can_continue>0
      !}
   ?};
   BI_CONN.cntx_pop();

:: Błędne porty (powinny być usunięte razem z BI_PRELami)
   BI_PORT.cntx_psh(); {? BI_PORT.name()='' || BI_PORT.use('bi_o____') ?};
   BI_PORT.index('BI_PROC');
   BI_PORT.prefix(BI_PROC.ref());
   {? BI_PORT.first()
   || {!
      |? _can_continue:=exec('delete','#bi_port',BI_PORT.ref());
         BI_PORT.first() & _can_continue>0
      !}
   ?};
   BI_PORT.cntx_pop();

:: Błędne TODO (powinny być usunięte razem z BI_PRELami)
   BI_TODO.cntx_psh(); {? BI_TODO.name()='' || BI_TODO.use('bi_t____') ?};
   BI_TODO.index('BI_PROC');
   BI_TODO.prefix(BI_PROC.ref());
   {? BI_TODO.first()
   || {!
      |? _can_continue:=exec('delete','#bi_todo',BI_TODO.ref());
         BI_TODO.first() & _can_continue>0
      !}
   ?};
   BI_TODO.cntx_pop();

   ~~
?};
BI_PROC.cntx_pop();

:: --- wszystkie powiązania usuniete? ---
{? _can_continue>0
|| _result:=1
|| undo()
?};
{? _mydo || _result:=end() ?};
_result


\fillAndAdd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Wypełnia bufor tabeli BI_PROC danymi
::   WE: _a - [REFERENCE]  - wskazanie na proces
::   WY: bufor tabeli BI_PROC
::----------------------------------------------------------------------------------------------------------------------
_b_proc:={? var_pres('_a')=type_of(null) || _a || return(null) ?};

B_PROC.cntx_psh();
B_PROC.prefix();
{? B_PROC.seek(_b_proc)
|| _buffer:=exec('buffer','#bi_proc');
   _buffer.UID:=exec('uid','#blank');
   _buffer.B_PROC:=_b_proc;
   _buffer.TM_BORN:=B_PROC.tm_stamp();
   _buffer.STOP:=0;
   _buffer.BI_STAT:=__Status.URUCHOMIONY;
   _buffer.CODE:=exec('new_code','#b_design','BI_PROC',_buffer.UID);

   {? B_PROC.TR_MODE='U'
   || _buffer.START:=BI_PROC.tm_stamp();
      _buffer.PL_END:=exec('get_pl_end','#b_proc',B_PROC.ref(),_buffer.START)
   ?};
   exec('add','#bi_proc',_buffer)
?};
B_PROC.cntx_pop();
_buffer


\setStatus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Ustawia status instancji procesu
::   WE: _a - [REFERENCE] - wskazanie na instancję procesu (BI_PROC)
::       _b - [REFERENCE] - status
::   WY: 0 lub 1
::----------------------------------------------------------------------------------------------------------------------
_bi_proc:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
_bi_stat:={? var_pres('_b')=type_of(null) || _b || return(0) ?};

_buffer:=exec('buffer','#bi_proc');
_buffer.cntx_get(_bi_proc);
_buffer.BI_STAT:=_bi_stat;
_buffer.STOP:=BI_PROC.tm_stamp();
{? _bi_stat=__Status.ZAKONCZONY
|| _buffer.DURATION:=exec('duration','#bi_prel','BI_PROC',_bi_proc,_buffer.STOP)
?};
exec('put','#bi_proc',_buffer)


\getInstProc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Pobiera wszystkie instancje procesu
::   WE: _a - [REFERENCE] - wskazanie na proces
::       _b - [REFERENCE] - status procesu
::       [_c] - INTEGER - [0]/1 - zawsze pokazywać wybór instancji procesu, nawet jak jest tylko jedna
::   WY:      [obj_new]   - obiekt z refami instancji procesów
::----------------------------------------------------------------------------------------------------------------------
_inst:=obj_new(1); _inst[1]:=null();
_b_proc:={? var_pres('_a')=type_of(null) || _a || return(_inst) ?};
_status:={? var_pres('_b')=type_of(null) || _b || return(_inst) ?};
_always_select:={? var_pres('_c')=type_of(0) || _c || 0 ?};

_buffer:=exec('buffer','#bi_proc');

_tab_proc:=tab_tmp(,'BI_PROC','STRING[16]','SQL ref proc'@,
                    'CODE','STRING[13]','KOD instancji procesu'@,
                    'SYMBOL','STRING[200]','UID instancji procesu'@);

_win:=_tab_proc.mk_sel('(TYMCZASOWE) Wybór instancji procesu'@,,1,'201309191217ass');
_tab_proc.win_act(_win,,'Formuła','Wybierz'@@,,,,"sel_exit()",1,,,,'W');
_tab_proc.win_sel(_win);

BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('PROSTAN'); BI_PROC.prefix(_b_proc,_status);
{? BI_PROC.first()
|| _size:=BI_PROC.size();
   {? _size
   || {? var_pres('_inst') > 100 || obj_del(_inst) ?};
      _inst:=obj_new(_size);
      _ind:=1;
      {!
      |? _inst[_ind]:=BI_PROC.ref();
         _ind+=1;

         _tab_proc.SYMBOL:=BI_PROC.UID;
         _tab_proc.CODE:=BI_PROC.CODE;
         _tab_proc.BI_PROC:=$BI_PROC.ref();
         _tab_proc.add();

         BI_PROC.next()
      !}
   ?}
?};

_res:=null();
BI_PROC.clear();
{? _tab_proc.size()>1 | _always_select>0
|| {? _tab_proc.select()
   || {? BI_PROC.seek(_tab_proc.BI_PROC,form(8+_tab_proc.BI_PROC))
      || _res:=BI_PROC.ref()
      ?}
   ?}
|? _tab_proc.size()=1
|| {? BI_PROC.seek(_tab_proc.BI_PROC,form(8+_tab_proc.BI_PROC))
   || _res:=BI_PROC.ref()
   ?}
?};
BI_PROC.cntx_pop();
_inst;
_res


\inst_test
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy są instancje procesu
::   WE: _a - $B_PROC.ref()
::       [_b] - INTEGER - 0/[1] - badać instancje nie będące w archiwum
::       [_c] - INTEGER - 0/[1] - badać instancje w archiwum
::   WY: 1 - są instancje, 0 - nie ma
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;
_chk_current:=1;
{? var_pres('_b')=type_of(0)
|| _chk_current:=_b
?};
_chk_arch:=1;
{? var_pres('_c')=type_of(0)
|| _chk_arch:=_c
?};
_res:=0;
_ref:=exec('FindAndGet','#table',B_PROC,_b_proc);
{? _chk_current>0
|| BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
   BI_PROC.index('PROSTAN'); BI_PROC.prefix(_ref);
   _res:=BI_PROC.size()>0;
   BI_PROC.cntx_pop()
?};

{? _chk_arch>0
||
   {? ~_res
   || {? exec('is_archived','#b_proc',_ref)
      || _res:=1
      ?}
   ?}
?};
_res


\canDelete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Sprawdza czy można usunąć instancje procesu
::   WE: _a - BI_PROC.ref()
::       _b - BI_PREL.ref()
::   WY: 0-nie można usunąć, 1-można usunąć
::----------------------------------------------------------------------------------------------------------------------
_bi_proc:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
_bi_prel:={? var_pres('_b')=type_of(null) || _b || return(0) ?};

_res:=1;
B_PREL.cntx_psh();
BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?};
BI_PREL.index('PREL'); BI_PREL.prefix(_bi_proc);
_loop:=BI_PREL.first();
{!
|? _loop
|!
   {? BI_PREL.B_PREL().CLASS='B_ACTION'
      & BI_PREL.ref()<>_bi_prel
   ||
::    czynność _bi_prel nie jest startowa bo jest inna instancja czynność w procesie
      _res:=0

   |? exec('is_event','#b_event',BI_PREL.B_PREL().B_ELE,exec('type_start','#b_event'),exec('kind_signal','#b_event'))=1
   ||
::    zdarzenie startowe sygnałowe
      _res:=0;
      B_TYPE.cntx_psh();
      B_PORT.cntx_psh();
      BI_PORT.cntx_psh();
      BI_PORT.index('PRELRODZ');
      BI_PORT.prefix(_bi_prel,exec('kind_in','#b_port'));
      _loop:=BI_PORT.first();
      {!
      |? _loop
      |!
         {? BI_PORT.B_PORT().KEYREF='T'
         ||
            {? B_PORT.B_TYPE().TYPE='złączeniowy'
               & BI_PORT.VALUE<>''
            ||
::             jeśli _res=1 tzn. że czynność ma parametr wejściowy tworzący keyref, który nie ma odpowiednika w tabeli
::             pozwalamy wtedy usunąć proces przy spełnieniu pozostałych warunków
               _res:=exec('value','#bi_port')=~~
            ?}
         ?};
         _loop:=_res=0 & BI_PORT.next()
      !};
      BI_PORT.cntx_pop();
      B_PORT.cntx_pop();
      B_TYPE.cntx_pop()

   |? ~exec('is_event','#b_event',BI_PREL.B_PREL().B_ELE,exec('type_start','#b_event'),exec('kind_none','#b_event'))
   ||
::    jest w procesie zdarzenie startowe inne niż nieokreślone
      _res:=0
   ?};
   _loop:=_res & BI_PREL.next()
!};
BI_PREL.cntx_pop(); B_PREL.cntx_pop();

_res


\isEndStatus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Sprawdza czy dany status oznacza koniec
::   WE: _a - BI_STAT.ref()
::   WY: 1-tak, 0-nie
::---------------------------------------------------------------------------------------------------------------------
_res:=0;

_end:=__Status.ZAKONCZONA;
_break:=__Status.AWARYJNA;
_end2:=__Status.ZAKONCZONY;
_break2:=__Status.AWARYJNIE;

_res:=(_a=_end) | (_a=_break) | (_a=_end2) | (_a=_break2);
_res


\break
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Zatrzymuje awaryjnie dana instancje procesu
::   WE: _a - [REFERENCE]  - BI_PROC.ref()
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};

:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_result:=0;
_can_continue:=1;
_break:=exec('AWARYJNIE','#bi_stat');

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('UID'); BI_PROC.prefix();
BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?};
BI_PREL.index('UID'); BI_PREL.prefix();
BI_PROC.clear();
{? BI_PROC.seek(_ref)
|| {? exec('breakBiPrel','#bi_proc',_ref) & exec('breakTodo','#bi_proc',_ref)
   || {? exec('setStatus','#bi_proc',BI_PROC.ref(),_break)
      || _result:=1
      || undo()
      ?}
   || undo()
   ?}
?};
BI_PROC.cntx_pop();
BI_PREL.cntx_pop();
{? _mydo || end() ?};
_result


\breakTodo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Zatrzymuje awaryjnie zadania dla danej instancji procesu
::   WE: _a - [REFERENCE]  - BI_PROC.ref()
::   WY: 1/0
::---------------------------------------------------------------------------------------------------------------------

_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};

_res:=1;
_break:=exec('TODO_BREAK','#bi_stat');

BI_TODO.cntx_psh(); {? BI_TODO.name()='' || BI_TODO.use('bi_t____') ?};
BI_TODO.index('BI_PROC');
BI_TODO.prefix(_ref);
{? BI_TODO.first()
|| {!
   |? {? ~exec('statEndTodo','#bi_todo',BI_TODO.BI_STAT,1)
      || BI_TODO.BI_STAT:=_break;
         BI_TODO.TM_LANG:=0;
         {? ~BI_TODO.put(1) || _res:=0 ?}
      ?};
      _res & BI_TODO.next()
   !}
?};
BI_TODO.cntx_pop();
_res


\breakBiPrel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Zatrzymuje awaryjnie elementy instancji procesu
::   WE: _a - [REFERENCE]  - BI_PROC.ref()
::   WY: 1/0
::---------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};

_res:=1;

BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?};
BI_PREL.index('PREL');
BI_PREL.prefix(_ref);
{? BI_PREL.first()
|| {!
   |? {? ~exec('isEndStatus','#bi_proc',BI_PREL.BI_STAT)
      || _res:=exec('setStatus','#bi_prel',BI_PREL.ref(),exec('AWARYJNA','#bi_stat'));
         {? _res || exec('delParses','#bi_prel',BI_PREL.ref()) ?}
      ?};
      _res & BI_PREL.next()
   !}
?};
BI_PREL.cntx_pop();
_res


\inst_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Informacja o niedostępności opcji ponieważ definicja procesu ma powiązane instancje
::   WE: _a - $B_PROC.ref()
::       _b - INTEGER - 0/1/2 - czy wyswietlac komunikaty, czy na ekran, czy do komma
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;

_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

B_PROC.cntx_psh();
B_PROC.clear();
{? B_PROC.seek(_b_proc)
||
   _msg:='Proces: %1 posiada już jakieś instancje (uruchomienia). Operacja niedostępna.'@[B_PROC.SYMBOL];
   {? _dialog=1
   ||
      _choice:=FUN.choice(_msg,,'Wyświetl instancje');

      {? _choice>0
      || {? exec('inst_test','#bi_proc',B_PROC.ref(),1,0)>0
         ||
::       Jeżeli są aktywne instancje nie w archiwum to pokazuję normalne okno
            exec('select','#bi_inst',B_PROC.ref())
         |? exec('inst_test','#bi_proc',B_PROC.ref(),0,1)>0
         ||
::       Jeżeli są instancje tylko w archiwum to od razu odpalam archiwum
            exec('select','#bi_arch',B_PROC.ref())
         ||
::       Coś się zepsuło, bo tu nie powinno dojść
            FUN.wdrerror('Błąd w formule inst_info/#bi_proc.fml')
         ?}
      ?}
   |? _dialog=2
   || KOMM.add(_msg,2,,1)
   ?}
?};
B_PROC.cntx_pop();
~~


\chk_ended
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy proces został zakończony i jeśli tak, to wyświetla komunikat
::   WE: [_a] - BI_PROC.ref - instancja procesu lub aktualny rekord
::       [_b] - ''(domyślnie)-komunikat napis-zapis do KOMM-a
::   WY: 0 - proces zakończony
::       1 - proces niezakończony
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_dialog:={? var_pres('_b')=type_of('') || _b || '' ?};

_result:=1;
_can_continue:=1;

BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('UID'); BI_PROC.prefix();
{? _ref<>null()
|| BI_PROC.clear();
   {? BI_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0 & _ref
||
   {? BI_PROC.BI_STAT=__Status.ZAKONCZONY
   || _result:=0;
      _msg:='Proces: %1 (instancja: %2) został zakończony. Akcja niedozwolona.'@[BI_PROC.B_PROC().SYMBOL,BI_PROC.CODE];
      {? _dialog=''
      || FUN.info(_msg)
      || exec('add_kom','#message',_msg,4,_b,__lp+=1)
      ?}
   ?}
?};
BI_PROC.cntx_pop();
_result


\get_pl_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Na podstawie planowanego czasu trwania procesu wyznacza planowany czas zakończenia
::       uwzględniając podany kalendarz
::   WE: _a - BI_PROC.ref() - instancja procesu
::       _b - REAL - moment startu procesu
::       [_c] - STRING - nazwa kalendarza który ma zostać użyty do wyznaczenia końca
::   WY: REAL - tm_stamp - planowany koniec
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_bi_proc:=_a;
_start:=_b;

_kalendarz:='';
{? var_pres('_c')=type_of('')
|| _kalendarz:=_c
?};

_result:=0;

:: Na razie bez uwzględnienia kalendarza, bo nie mamy takich metod w obiekcie kalendarza
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('UID'); BI_PROC.clear();
B_PROC.cntx_psh();
{? BI_PROC.seek(_bi_proc)
||
   {? BI_PROC.B_PROC<>null()
   ||
::    Podczytuję definicję
      BI_PROC.B_PROC();

      {? B_PROC.IVAL_DEF<>null()
      || _result:=exec('add_to_point','#interval',_start,B_PROC.IVAL_DEF)
      ?}
   ?}
?};
B_PROC.cntx_pop();
BI_PROC.cntx_pop();
_result


\icon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ikona przedstawiająca stan procesu
::   WE: _a - BI_PROC.ref()
::   WY: ikona
::----------------------------------------------------------------------------------------------------------------------
_bi_proc:=_a;
{? exec('FindInSet','#table','BI_TODO','ERROR','E',_bi_proc)<>null()
|| 'xwin16.png:3'
|? exec('isProblemsProc','#bi_msg',_bi_proc)>0
|| 'xwin16.png:4'
|| exec('pusta','#icon')
?}


\trigger_add_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Triger 'po' add BI_PREL
::----------------------------------------------------------------------------------------------------------------------
exec('trigger_before','#bi_proc')


\trigger_put_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Triger 'po' put BI_PREL
::----------------------------------------------------------------------------------------------------------------------
exec('trigger_before','#bi_proc')


\trigger_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Triger 'po' BI_PREL
::----------------------------------------------------------------------------------------------------------------------
BI_PROC.BORN_D:={? BI_PROC.TM_BORN<>0 || exec('tm_stamp2date','#tm_stamp',BI_PROC.TM_BORN) || date(0,0,0) ?};
BI_PROC.BORN_T:=exec('tm_stamp2time','#tm_stamp',BI_PROC.TM_BORN);
BI_PROC.START_D:={? BI_PROC.START<>0 || exec('tm_stamp2date','#tm_stamp',BI_PROC.START) || date(0,0,0) ?};
BI_PROC.START_T:=exec('tm_stamp2time','#tm_stamp',BI_PROC.START);
BI_PROC.PL_END_D:={? BI_PROC.PL_END<>0 || exec('tm_stamp2date','#tm_stamp',BI_PROC.PL_END) || date(0,0,0) ?};
BI_PROC.PL_END_T:=exec('tm_stamp2time','#tm_stamp',BI_PROC.PL_END);
BI_PROC.STOP_D:={? BI_PROC.STOP<>0 || exec('tm_stamp2date','#tm_stamp',BI_PROC.STOP) || date(0,0,0) ?};
BI_PROC.STOP_T:=exec('tm_stamp2time','#tm_stamp',BI_PROC.STOP);
1


\is_archivized
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Sprawdza czy proces jest w archiwum
::   WE: _a - BI_PROC.ref()
::   WY: 0 - nie jest
::       1 - jest
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_bi_proc:=_a;

_result:=0;
:: Na razie można poznać tylko po masce
_mask:=ref_name(_bi_proc);
{? _mask+4<>'____'
|| _result:=1
?};
_result


\problem_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Aktualizuje BI_PROC.PROBLEM na podstawie wszystkich BI_MSGów zgłoszonych do danej instancji procesu
::   WE: [_a] - BI_PROC.ref lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(BI_PROC.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

BI_PROC.cntx_psh();
{? _ref<>null()
|| BI_PROC.prefix();
   {? BI_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   BI_PROC.PROBLEM:='N';
   BI_MSG.cntx_psh();
   BI_MSG.index('BI_PROC');
   BI_MSG.prefix(BI_PROC.ref());
   {? BI_MSG.first()
   || {!
      |? {? BI_MSG.STAT_ANS<>__Status.RETURN
         || BI_PROC.PROBLEM:='T'
         ?};
         BI_MSG.next() & BI_PROC.PROBLEM='N'
      !}
   ?};
   _can_continue:=BI_PROC.put();
   BI_MSG.cntx_pop()
?};
BI_PROC.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\problem_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Ustawia pole BI_PROC.PROBLEM
::   WE: [_a] - BI_PROC.ref lub bieżący rekord
::       [_b]  - STRING - 'T'/['N']
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(BI_PROC.ref())
|| _ref:=_a
?};
_problem:='N';
{? var_pres('_b')=type_of('')
|| _problem:=_b
?};

_result:=0;
_can_continue:=1;

BI_PROC.cntx_psh();
{? _ref<>null()
|| BI_PROC.prefix();
   {? BI_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| BI_PROC.PROBLEM:=_problem;
   _can_continue:=BI_PROC.put()
?};
BI_PROC.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\count_problemed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zlicza ile instancji procesów się wykrzaczyło lub ma zgłoszone problemy
::   WE: [_a] - INTEGER - [0]/1 - czy wyświetlać tylko procesy własne
::       [_b] - USERS.ref() - użytkownik dla którego sprawdzać procesy własne
::   WY: REAL - wynik
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_only_mine:=0;
{? var_pres('_a')=type_of(0)
|| _only_mine:=_a
?};
_user:=OPERATOR.USER;
{? var_pres('_b')=type_of(USERS.ref())
|| _user:=_b
?};

_result:=0;

BI_MSG.cntx_psh();
BI_PROC.cntx_psh();
{? _only_mine>0
|| BI_PROC.index('PROB_OWN');
   BI_PROC.prefix(REF.FIRMA,_user,'T')
|| BI_PROC.index('PROB_ALL');
   BI_PROC.prefix(REF.FIRMA,'T')
?};

{? BI_PROC.first()
|| _result:=BI_PROC.size()
?};

BI_PROC.cntx_pop();
BI_MSG.cntx_pop();
_result


\fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Format wyświetlania dla pól tabeli BI_PROC
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? app_info('web_sesid')=''
||
   _fld:=cur_afld();
   {? _fld='STOP_D' | _fld='START_D' | _fld='BORN_D'
   || _val:=fld();
      {? _val=date(0,0,0)
      || _result:='empty=1'
      ?}
   |? _fld='BORN_T'
   || {? BI_PROC.BORN_D=date(0,0,0)
      || _result:='empty=1'
      ?}
   |? _fld='START_T'
   || {? BI_PROC.START_D=date(0,0,0)
      || _result:='empty=1'
      ?}
   |? _fld='STOP_T'
   || {? BI_PROC.STOP_D=date(0,0,0)
      || _result:='empty=1'
      ?}
   ?}
?};
_result


\fld_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Format redagowania dla pól tabeli BI_PROC
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? app_info('web_sesid')=''
|| _fld:=cur_afld();
   ~~
?};
_result


:Sign Version 2.0 jowisz:1045 2023/07/03 09:07:18 3bedf176af668520a56fa7281c988c01fae800c3d2cd6f548fb047312ab0a1bf53b3b26353bf35f55b75a11f8b5f6e67f0176228e59063781a94c48590d0d502e0f98a7ad8d6a442b6e301bf99bbfc5beaa7934b4c9f3db0ebfb7857de867c4b3b78cad9cce770301ff52c5deda536319374eb34cc13b236f9005ba7ff024a89
