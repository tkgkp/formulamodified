:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b_proc.fml
:: Utworzony: 04.07.2013 [17.00]
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Formuły do obsługi tabeli B_PROC
::======================================================================================================================


\buffer
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: [rr] [17.00]
:: OPIS: Tworzy bufor tabeli B_PROC
::   WY: obj_new() - tablica nazwana - reprezentacja rekordu B_PROC
::----------------------------------------------------------------------------------------------------------------------
exec('B_PROC','#buffer')


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Dołącza nowy proces
::   WE: _a - [REFERENCE]  - wskazanie na firmę
::       _b - [STRING]     - symbol procesu
::       _c - [STRING]     - nazwa procesu
::       _d - [STRING]     - wersja procesu
::       _e - [STRING]     - czy proces aktywny
::       _f - [STRING]     - ID diagramu
::       _g - [STRING]     - czy jest to mikroproces (domyślnie 'N')
::   WY:      [REFERENCE]  - wskazanie na dodany proces
::----------------------------------------------------------------------------------------------------------------------
  _firma:={? var_pres('_a')=type_of(null()) || _a || null() ?};
 _symbol:={? var_pres('_b')=type_of('')     || _b || ''     ?};
   _name:={? var_pres('_c')=type_of('')     || _c || ''     ?};
    _ver:={? var_pres('_d')=type_of('')     || _d || ''     ?};
 _active:={? var_pres('_e')=type_of('')     || _e || ''     ?};
_diagram:={? var_pres('_f')=type_of('')     || _f || ''     ?};
  _micro:={? var_pres('_g')=type_of('')     || _g || ''     ?};

_result:=null();
B_PROC.cntx_psh();
B_PROC.index('SYM');
B_PROC.prefix(_micro,_firma,_symbol,_ver,);
{? B_PROC.first()
|| _result:=B_PROC.ref()
|| B_PROC.blank();
   B_PROC.FIRMA:=_firma;
   B_PROC.SYMBOL:=_symbol;
   B_PROC.NAME:=_name;
   B_PROC.VER:=_ver;
   B_PROC.ACTIVE:=_active;
   B_PROC.DIAGRAM:=_diagram;
   B_PROC.MICRO:=_micro;
   {? B_PROC.add()
   || _result:=B_PROC.ref()
   ?}
?};
B_PROC.cntx_pop();
_result


\add_action
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Dołącza nowy proces
::   WY: 0 / 1 - wynik add()
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_result:=0;
_ref_added:=null();
USERS.cntx_psh();
B_PROC.cntx_psh(); B_PROC.clear();
IVAL_DEF.cntx_psh();
IVAL_DEF.blank();
USERS.index('USR_AKOD');
B_PROC.blank();
_win:=exec('win_edit','#b_proc',,1);
B_PROC.win_edit(_win);
B_PROC.memo_set('','TARGET');
B_PROC.memo_set('','DESC');

:: Zakładam filtr na użytkowników, do obsługi pola właściciel procesu
exec('filter_upr','users','ZPR_PRO_MODE.ZPR_PRO_MODW');

{? B_PROC.edit("exec('validate','#b_proc',0)")
||
:: Sprawdzam czy nalezy dodać rekord definicji zakresu planowanego czasu procesu
   _plan_diff:=exec('buffer_compare','#interval');
   {? _plan_diff=0
   || B_PROC.IVAL_DEF:=exec('ival_add_act','#interval',0)
   ?};

   _result:=B_PROC.add();
   {? _result>0
   || _ref_added:=B_PROC.ref();
      B_PROC.memo_put(,'TARGET');
      B_PROC.memo_put(,'DESC')
   ?}
?};
B_PROC.cntx_pop();
IVAL_DEF.cntx_pop();
{? _ref_added<>null()
|| {? B_PROC.f_active()
   || B_PROC.f_rfresh();
      B_PROC.f_seek(_ref_added)
   || B_PROC.seek(_ref_added)
   ?}
?};
{? _result>0
|| {? _env.ZAKRES='N'
   || FUN.info('Dodany proces trafił do procesów aktywnych. Aby go zobaczyć należy zmienić zakres wyświetlanych procesów.'@)
   ?}
?};
USERS.cntx_pop();
USERS.f_clear();
_result


\win_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tymczasowe okno edycyjne procesu
::   WE: [_a] - INTEGER - 0/1/2 - jakie okienko tworzyć: 0 - pełne
::                                                       1 - uproszczone dla zaakceptowanego procesu
::                                                       2 - uproszczone do nadawania wyłącznie planowanego czasu
::                              jeśli nie podane, to określane na podstawie pola B_PROC.ACCEPTED
::       [_b] - INTEGER - [0]/1 - czy dodawać przyciski Ok, Anuluj
::   WY: STRING - akronim utworzonego okna
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_win:='';

_mode:=0;
{? var_pres('_a')=type_of(0)
|| _mode:=_a
|| {? B_PROC.ACCEPTED='T'
   || _mode:=1
   ?}
?};

_btn_ok:=0;
{? var_pres('_b')=type_of(0)
|| _btn_ok:=_b
?};

_win:=B_PROC.mk_edit('Nagłówek procesu'@,0,'#b_proc_red');
{? _mode<>2
|| B_PROC.win_ewin(_win,B_PROC,'RED')
?};
B_PROC.win_ewin(_win,IVAL_DEF,'RED','Planowany czas trwania'@);
B_PROC.win_ewin(_win,B_PROC,'TR_MODE','Termin realizacji'@);

:: Przyciski
{? _btn_ok>0
|| B_PROC.win_ebtn(_win,'text=%1,panel=bottom,align=end'['&Zapisz'@],'key:F2');
   B_PROC.win_ebtn(_win,'text=%1,panel=bottom,align=end'['&Anuluj'@],'key:Esc')
?};

:: Importuje nazwy interwałów
exec('import_names','#interval');

exec('edit_enablator','#interval',_win,B_PROC);
_win


\mod_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Modyfikuje naglowek procesu
::       Kontekst wywolania - rekord tabeli B_PROC
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
_result:=0;
_can_continue:=1;

USERS.cntx_psh();
USERS.index('USR_AKOD');
IVAL_DEF.cntx_psh();
{? B_PROC.IVAL_DEF<>null()
|| B_PROC.IVAL_DEF()
|| IVAL_DEF.blank()
?};
:: 1. Sprawdzam czy sa uruchomione jakies instancje procesu
::{? exec('inst_test','#bi_proc',$B_PROC.ref())
::||
::   exec('inst_info','#bi_proc',$B_PROC.ref());
::   _can_continue:=0
::?};

{? _can_continue>0
||
   _what:=exec('B_PROC','#to_string');
   _win:=exec('win_edit','#b_proc',,1);
   B_PROC.win_edit(_win);
   B_PROC.memo_get(,'TARGET');
   B_PROC.memo_get(,'DESC');

:: Zakładam filtr na użytkowników, do obsługi pola właściciel procesu
   exec('filter_upr','users','ZPR_PRO_MODE.ZPR_PRO_MODW');

:: Sprawdzam czy można zablokować proces do edycji
   _b_proc:=B_PROC.ref();
   _locked:=0;
   {? _can_continue>0
   ||
      _msg:='Proces \'%1\' jest redagowany'@[_what];
      _locked:=exec('blk_lock','#table','B_PROC',_b_proc,,1,_msg,,0);
      {? _locked=0
      || _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   ||
      {? B_PROC.edit("exec('validate','#b_proc',1)")
      || B_PROC.memo_put(,'TARGET');
         B_PROC.memo_put(,'DESC');
         B_PROC.cntx_psh();
         B_PROC.prefix();
         _can_continue:=B_PROC.put();
         B_PROC.cntx_pop()
      || _can_continue:=0
      ?}
   ?};
   {? _locked>0
   || exec('blk_unlock','#table','B_PROC',_b_proc)
   ?};

   {? _can_continue>0
   || _can_continue:=exec('interval_update','#b_design','B_PROC')
   ?}
?};
IVAL_DEF.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
USERS.cntx_pop();
USERS.f_clear();
_result


\validate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza poprawność wypełnienia pól w oknie redagowania tabeli B_PROC
::   WE: [_a] - INTEGER - 0 - obsługa na dołącz
::                        1 - obsługa na popraw
::   WY: STRING - akronim pola do którego powrócić lub '' jeśli wszystko ok
::  TAG: <PUBLICZNA><MODELER><PROCES><CHK>
::----------------------------------------------------------------------------------------------------------------------
_mode:=_a;
_result:=__CHK.record(B_PROC,,'FIRMA','SYMBOL','NAME','VER');
{? _result=''
|| {? __CHK.index(B_PROC,-menu_txt()='popraw')=''
   || _result:=''
   || _result:='SYMBOL'
   ?}
?};
{? _result=''
||
:: Sprawdzam czy nalezy sprawdzic bufor planowanego czasu pracy
   _plan_diff:=exec('buffer_compare','#interval');
   {? _plan_diff=0
   || _result:=exec('validate','#interval')
   ?}
?};
{? _result=''
|| _banned:='\\;/';
   _split:=spli_str(_banned,';');
   {! _it:=1..obj_len(_split)
   |? _result=''
   |! _sign:=_split[_it];
      {? _sign<>''
      || {? B_PROC.SYMBOL*_sign>0
         || _result:='SYMBOL';
            FUN.emsg('Symbol procesu zawiera niedozwolony znak: %1'@[_sign])
         |? B_PROC.NAME*_sign>0
         || _result:='NAME';
            FUN.emsg('Nazwa procesu zawiera niedozwolony znak: %1'@[_sign])
         |? B_PROC.VER*_sign>0
         || _result:='VER';
            FUN.emsg('Wersja procesu zawiera niedozwolony znak: %1'@[_sign])
         ?}
      ?}
   !}
?};
{? _result=''
|| {? B_PROC.MAX_INS<0
   || _result:='MAX_INS';
      FUN.emsg('Maksymalna ilość instancji nie może być ujemna.'@)
   ?}
?};
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Kasuje podany rekord tabeli B_PROC (wykonywane w transakcji!!!)
::   WE: _a - B_PROC.ref()
::       [_b] - INTEGER - 0/[1] - czy wyswietlac komunikaty na ekran
::   WY: >0 -wyczyszczone,
::      <=0 -niewyczyszczone
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};
_result:=0;
_ref:=_a;

_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_can_continue:=1;
:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;

{? _mydo=0
|| _dialog:=0
?};

:: 1. Sprawdzam czy jest sens w ogole usuwac
_can_continue:=exec('can_delete','#b_proc',_ref,_dialog);

{? _can_continue>0
||

:: Na czas usuwania blokuję wszystkie B_PRELE
   {? _dialog>0
   || KOMM.init(200,,'Usuwanie procesu.')
   ?};
   _locked:=exec('ref_table','#table');
   B_PREL.cntx_psh();
   B_PREL.index('PROC');
   B_PREL.prefix(_ref);
   {? B_PREL.first()
   || {!
      |? {? exec('lock','#b_prel',B_PREL.ref(),2)
         || _locked.add(B_PREL.ref())
         || _can_continue:=0
         ?};
         B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop();

   {? _can_continue>0
   ||
      {? _mydo || do() ?};
      B_PROC.cntx_psh(); B_PROC.clear();
      {? B_PROC.seek(_ref)
      ||
         {? exec('clean','#b_proc',_ref,0)>0
         || {? B_PROC.del(,1)>0
            || _result:=1
            || undo();
               _result:=-3
            ?}
         || _result:=-2
         ?}
      || _result:=0
      ?};
      B_PROC.cntx_pop();
      {? _result<0
      || undo()
      ?};
      {? _mydo || end() ?}
   ?};

   _tab:=_locked.tab;
   _tab.clear();
   {? _tab.first()
   || {!
      |? _b_prel:=exec('FindAndGet','#table',B_PREL,_tab.SQL,,,null());
         exec('unlock','#b_prel',_b_prel);
         _tab.next()
      !}
   ?};
   {? _dialog>0
   || KOMM.select()
   ?}
?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
:: UTW: WH [17.00]
:: OPIS: Czysci powiazania do rekordu tabeli B_PROC
:: WE: _a - B_PROC.ref()
::     [_b] - INTEGER - 0/[1] - czy blokować B_PRELe przed usunięciem
:: WY: >0 -wyczyszczone,
:: <=0 -niewyczyszczone
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_lock_prel:=1;
{? var_pres('_b')=type_of(0)
|| _lock_prel:=_b
?};

_result:=1;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---

:: 1. Elementy procesu
B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_ref);
{? B_PREL.first()
|| {!
   |? _can_continue:=exec('delete','#b_prel',B_PREL.ref,1,,_lock_prel);
      B_PREL.first() & _can_continue>0
   !}
?};
:: 2. Definicja planowanego zakresu pracy
{? _can_continue>0 & B_PROC.IVAL_DEF<>null()
|| _ival:=B_PROC.IVAL_DEF;
   B_PROC.IVAL_DEF:=null();
   _can_continue:=B_PROC.put();
   {? _can_continue>0
   || exec('delete','#interval',_ival,0)
   ?}
?};

B_PREL.cntx_pop();

:: 3. Zapisy w archiwum o ile wszystkie są nieaktywne
{? _can_continue
|| BI_ARCH.cntx_psh();
   BI_ARCH.index('NUM_PROC');
   BI_ARCH.prefix(B_PROC.FIRMA,B_PROC.ref());
   {? BI_ARCH.first()
   || {!
      |? _next:=0;
         _ref_nxt:=null();
         BI_ARCH.cntx_psh();
         {? BI_ARCH.next()
         || _ref_nxt:=BI_ARCH.ref()
         ?};
         BI_ARCH.cntx_pop();

         {? BI_ARCH.NUM_PROC=0
         || _can_continue:=BI_ARCH.del(,1)
         || _can_continue:=0;
            undo('Proces posiada instancje w archiwum, usunięcie niemożliwe'@)
         ?};

         {? _ref_nxt<>null()
         || _next:=BI_ARCH.seek(_ref_nxt)
         ?};
         _next>0 & _can_continue>0
      !}
   ?};
   BI_ARCH.cntx_pop()
?};

:: --- wszystkie powiazania usuniete? ---
{? _can_continue>0
|| _result:=1
|| undo()
?};

{? _mydo || end()?};
_result


\can_delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza mozliwosc usuniecia procesu
::   WE: _a - B_PROC.ref()
::       _b - INTEGER - 0/1/2 - czy wyswietlac komunikaty, czy na ekran, czy do komma
::   WY: 1 - mozna usunac
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;
_dialog:=_b;

_result:=1;
_can_continue:=1;

B_PROC.cntx_psh();
B_PROC.clear();
{? B_PROC.seek(_b_proc)
||
:: 1. Sprawdzam czy proces jest zaakceptowany
   {? B_PROC.ACCEPTED='T' & B_PROC.ACTIVE='T'
   || exec('akc_info','#b_design',B_PROC.SYMBOL,_dialog);
      _result:=0;
      _can_continue:=0
   ?};
:: 2. Sprawdzam czy sa jakies instancje uruchomione procesu
   {? _can_continue>0 & exec('inst_test','#bi_proc',$B_PROC.ref())
   || _can_continue:=0;
      _result:=0;
      exec('inst_info','#bi_proc',$B_PROC.ref(),_dialog)
   ?};
   ~~
?};
B_PROC.cntx_pop();
_result


\chk_conns
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza czy wszystkie elementy (czynności, zdarzenia, bramy) w procesie mają wymagane ilości
::       poprzedników i następników
::   WE: _a - B_PROC.ref()
::       _b - INTEGER - 0/[1] - czy inicjować i pokazywać KOMMa
::       [_c] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - są jakieś problemy
::       1 - wszystko jest ok
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_b_proc:=_a;

_komm_init:=0;
{? var_pres('_b')=type_of(0)
|| _komm_init:=_b
?};

_args:=~~;
{? var_pres('_c')>100
|| _args:=exec('obj_ntab_set','#array',_c)
|| _args:=exec('komm_args','#b_proc')
?};

_result:=1;
_can_continue:=0;

_sect:='Weryfikacja powiązań między elementami procesu'@;
{? _komm_init>0
|| KOMM.init(250,,_sect)
?};

Cntx.psh(B_PROC,B_CONN,B_PREL,B_GATE);
Cntx.clr(B_PROC                     );

{? B_PROC.seek(_b_proc)
||
:: Iteruje po elementach procesu
   B_PREL.index('PROC');
   B_PREL.prefix(B_PROC.ref());
   {? B_PREL.first()
   || {!
      |?
::       KONTROLA CZYNNOSCI
         {? B_PREL.CLASS='B_ACTION'
         ||
::          Kontrola poprzedników czynności
            B_CONN.index('TO');
            B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
            {? B_CONN.size()=0
            ||
               _sect:='Brak wymaganego poprzednika'@;
               _msg:='Element: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

               _args.SECT:=_sect;
               _args.MSG:=_msg;
               _args.GRAPH_UID:=B_PREL.UID;
               exec('komm_add','#b_proc',_args);
               _result:=0
            ?};

::          Kontrola następników czynności
            B_CONN.index('FROM');
            B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
            {? B_CONN.size()=0
            ||
               _sect:='Brak wymaganego następnika'@;
               _msg:='Element: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

               _args.SECT:=_sect;
               _args.MSG:=_msg;
               _args.GRAPH_UID:=B_PREL.UID;
               exec('komm_add','#b_proc',_args);
               _result:=0
            ?}

::       KONTROLA ZDARZEN
         |? B_PREL.CLASS='B_EVENT'
         ||
            {? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_end','#b_event'))>0
            ||
::             Kontrola poprzedników zdarzenia końcowego
               B_CONN.index('TO');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? ~B_CONN.first()
               ||
                  _sect:='Brak wymaganego poprzednika'@;
                  _msg:='Zdarzenie: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?};
::             Kontrola następników zdarzenia końcowego
               B_CONN.index('FROM');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? B_CONN.first()
               ||
                  _sect:='Niedozwolone następniki dla zdarzeń'@;
                  _msg:='Zdarzenie: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?}
            |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_start','#b_event'))>0
            ||
::             Kontrola poprzednikow zdarzenia startowego
               B_CONN.index('TO');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? B_CONN.first()
               ||
                  _sect:='Niedozwolone poprzedniki dla zdarzeń';
                  _msg:='Zdarzenie: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?};
::             Kontrola następników zdarzenia startowego
               B_CONN.index('FROM');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? ~B_CONN.first()
               ||
                  _sect:='Brak wymaganego następnika'@;
                  _msg:='Zdarzenie: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?}
            |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_intermed','#b_event'))>0
            ||
::             Kontrola poprzedników zdarzenia pośredniego
               B_CONN.index('TO');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? ~B_CONN.first()
               ||
                  _sect:='Brak wymaganego poprzednika'@;
                  _msg:='Zdarzenie: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?};
::             Kontrola następników zdarzenia pośredniego
               B_CONN.index('FROM');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? ~B_CONN.first()
               ||
                  _sect:='Brak wymaganego następnika'@;
                  _msg:='Zdarzenie: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?}
            ||
               _sect:='Nieobsługiwany typ zdarzenia'@;
               _msg:='Element: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

               _args.SECT:=_sect;
               _args.MSG:=_msg;
               _args.GRAPH_UID:=B_PREL.UID;
               exec('komm_add','#b_proc',_args);
               _result:=0
            ?}

::       KONTROLA BRAM
         |? B_PREL.CLASS='B_GATE'
         ||
::          Następnikami bramy nie mogą być zdarzenia początkowe
            _can_continue:=1;
            B_CONN.index('FROM');
            B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
            {? B_CONN.first()
            || {!
               |? B_PREL.cntx_psh();
                  _is_ev:=exec('is_event','#b_event',B_CONN.TO().B_ELE,exec('type_start','#b_event'))>0;
                  B_PREL.cntx_pop();

                  {? _is_ev>0
                  || B_PREL.cntx_psh();

                     _sect:='Niedozwolone następniki bramy'@;
                     _msg:='Brama: %1 [%2] (niedozwolony następnik: %3 [%4])'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL,B_CONN.TO().SYMBOL,B_CONN.TO().B_ELE().SYMBOL];

                     _args.SECT:=_sect;
                     _args.MSG:=_msg;
                     _args.GRAPH_UID:=B_PREL.UID;
                     exec('komm_add','#b_proc',_args);
                     _result:=0;
                     _can_continue:=0;
                     B_PREL.cntx_pop()
                  ?};
                  B_CONN.next()
               !}
            ?};

            {? exec('is_gate','#b_gate',B_PREL.B_ELE,,exec('kind_split','#b_gate'))>0
            ||
::             Brama rozdzielająca może mieć tylko jednego poprzednika
               B_CONN.index('TO');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? B_CONN.size()<>1
               ||
                  _sect:='Bramy rozdzielajace o nieprawidłowej liczbie poprzedników (różna od 1)'@;
                  _msg:='Brama: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?};

::             Brama rozdzielająca musi mieć co najmniej dwa następniki
               B_CONN.index('FROM');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? B_CONN.size()<2
               ||
                  _sect:='Bramy rozdzielające o nieprawidłowej liczbie następników (min. 2)'@;
                  _msg:='Brama: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?}
            |? exec('is_gate','#b_gate',B_PREL.B_ELE,,exec('kind_merge','#b_gate'))>0
            ||
::             Brama zbierająca może mieć tylko jednego następnika
               B_CONN.index('FROM');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? B_CONN.size()<>1
               ||
                  _sect:='Bramy zbierające o nieprawidłowej liczbie następników (różna od 1)'@;
                  _msg:='Brama: %1'@[B_PREL.SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?};
::             Brama zbierająca musi mieć co najmniej dwa poprzedniki
               B_CONN.index('TO');
               B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
               {? B_CONN.size()<2
               ||
                  _sect:='Bramy zbierające o nieprawidłowej liczbie poprzedników (min. 2)'@;
                  _msg:='Brama: %1'@[B_PREL.SYMBOL];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?}

            ?};
            ~~
         ?};
         B_PREL.next()
      !}
   ?}
|| _result:=0
?};

:: Następnik nie może się powtarzać
B_CONN.cntx_psh();
B_CONN.index('PROC');
B_CONN.prefix(B_PROC.ref());
{? B_CONN.first()
|| {!
   |?
      B_CONN.cntx_psh();
      B_CONN.prefix(B_PROC.ref(),B_CONN.FROM,B_CONN.TO);
      {? B_CONN.size()>1
      ||
         _sect:='Powtórzone połączenia'@;
         _msg:='Źródło: %1, cel: %2'@[B_CONN.FROM().SYMBOL,B_CONN.TO().SYMBOL];

         _args.SECT:=_sect;
         _args.MSG:=_msg;
         _args.GRAPH_UID:=B_CONN.UID;
         _args.GRAPH_TYPE:='EDGE';
         exec('komm_add','#b_proc',_args);
         _result:=0
      ?};
      B_CONN.cntx_pop();
      B_CONN.next()
   !}
?};
B_CONN.cntx_pop();


{? _komm_init>0
|| KOMM.select()
?};

Cntx.pop(B_PROC,B_CONN,B_PREL,B_GATE);
_result


\chk_events
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza czy proces ma co najmniej jedno zdarzenie początkowe i co najmniej jedno końcowe.
::       Sprawdza, czy zdarzenia wymagające ustawienia własności mają je ustawione
::   WE: _a - B_PROC.ref()
::       _b - INTEGER - 0/[1] - czy inicjować i pokazywać KOMMa
::       [_c] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - są jakieś problemy
::       1 - wszystko jest ok
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_b_proc:=_a;

_komm_init:=0;
{? var_pres('_b')=type_of(0)
|| _komm_init:=_b
?};

_args:=~~;
{? var_pres('_c')>100
|| _args:=exec('obj_ntab_set','#array',_c)
|| _args:=exec('komm_args','#b_proc')
?};

_result:=1;
_can_continue:=0;

_sect:='Weryfikacja listy zdarzeń'@;
{? _komm_init>0
|| KOMM.init(250,,_sect)
?};

:: ilość zdarzeń początkowych i końcowych w procesie
_start:=0;
_start_active:=0;
_end:=0;
:: ilość zdarzeń bez ustawionych własności
_no_property:=0;

B_CONN.cntx_psh();
B_PROC.cntx_psh(); B_PROC.clear();
{? B_PROC.seek(_b_proc)
||
:: Iteruje po zdarzeniach procesu
   B_PREL.cntx_psh();
   B_PREL.index('PROC');
   B_PREL.prefix(B_PROC.ref(),'B_EVENT');
   _sect:='Kontrola powiązań dla zdarzeń'@;
   {? B_PREL.first()
   || {!
      |?
         {? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_start','#b_event'))>0
         || _start+=1;
            {? B_PREL.ENABLED='T' || _start_active+=1 ?}
         |? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_end','#b_event'))>0
         || _end+=1
         ?};
         {? exec('is_event','#b_event',B_PREL.B_ELE,,exec('kind_timer','#b_event'))>0
            & ~exec('valid_property','#b_timer',B_PREL.ref())
         ||
            _sect:='Brak ustawionych własności dla zdarzeń czasowych w procesie'@;
            _msg:='Element: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

            _args.SECT:=_sect;
            _args.MSG:=_msg;
            _args.GRAPH_UID:=B_PREL.UID;
            exec('komm_add','#b_proc',_args);
            _no_property+=1
         ?};
         {? exec('is_event','#b_event',B_PREL.B_ELE,,exec('kind_signal','#b_event'))>0
            & ~exec('valid_property','#b_signal',B_PREL.ref())
         ||
            _sect:='Brak ustawionych własności dla zdarzeń sygnałowych w procesie'@;
            _msg:='Element: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

            _args.SECT:=_sect;
            _args.MSG:=_msg;
            _args.GRAPH_UID:=B_PREL.UID;
            exec('komm_add','#b_proc',_args);
            _no_property+=1
         ?};
         {? exec('is_event','#b_event',B_PREL.B_ELE,,exec('kind_message','#b_event'),exec('category_throw','#b_event'))>0
            & ~exec('valid_property','#b_msg',B_PREL.ref())
         ||
            _sect:='Brak ustawionych własności dla zdarzeń wysłania komunikatu w procesie'@;
            _msg:='Element: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

            _args.SECT:=_sect;
            _args.MSG:=_msg;
            _args.GRAPH_UID:=B_PREL.UID;
            exec('komm_add','#b_proc',_args);
            _no_property+=1
         ?};
         {? exec('is_event','#b_event',B_PREL.B_ELE,,exec('kind_condition','#b_event'))>0
            & ~exec('valid_property','#b_econd',B_PREL.ref())
         ||
            _sect:='Brak ustawionych własności dla zdarzeń warunkowych w procesie'@;
            _msg:='Element: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

            _args.SECT:=_sect;
            _args.MSG:=_msg;
            _args.GRAPH_UID:=B_PREL.UID;
            exec('komm_add','#b_proc',_args);
            _no_property+=1
         ?};
         B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop()
|| _result:=0
?};

{? _start=0
||
   _sect:='Braki dotyczące zdarzeń'@;
   _msg:='Brak zdarzenia startowego w procesie'@;

   _args.SECT:=_sect;
   _args.MSG:=_msg;
   _args.GRAPH_UID:='';
   exec('komm_add','#b_proc',_args);
   _result:=0
|? _start_active=0
|| _sect:='Braki dotyczące zdarzeń'@;
   _msg:='Brak aktywnego zdarzenia startowego w procesie'@;

   _args.SECT:=_sect;
   _args.MSG:=_msg;
   _args.GRAPH_UID:='';
   exec('komm_add','#b_proc',_args);
   _result:=0
?};

{? _end=0
||
   _sect:='Braki dotyczące zdarzeń'@;
   _msg:='Brak zdarzenia końcowego w procesie'@;

   _args.SECT:=_sect;
   _args.MSG:=_msg;
   _args.GRAPH_UID:='';
   exec('komm_add','#b_proc',_args);
   _result:=0
?};

{? _no_property>0
||
   _result:=0
?};

{? _komm_init>0
|| KOMM.select()
?};

B_CONN.cntx_pop();
B_PROC.cntx_pop();
_result


\chk_gates
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy wszystkie bramy w procesie są prawidłowo zdefiniowane
::   WE: _a - B_PROC.ref()
::       _b - INTEGER - 0/[1] - czy inicjować i pokazywać KOMMa
::       [_c] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY:
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_b_proc:=_a;

_komm_init:=0;
{? var_pres('_b')=type_of(0)
|| _komm_init:=_b
?};

_args:=~~;
{? var_pres('_c')>100
|| _args:=exec('obj_ntab_set','#array',_c)
|| _args:=exec('komm_args','#b_proc')
?};

_result:=1;
_can_continue:=0;

_sect:='Weryfikacja bram w procesie'@;
{? _komm_init>0
|| KOMM.init(250,,_sect)
?};

B_PREL.cntx_psh();
:: Iteruje po elementach procesu
B_PREL.index('PROC');
B_PREL.prefix(_b_proc);

B_CHOICE.cntx_psh();
B_CHOICE.index('B_CONN');

B_CONN.cntx_psh();

{? B_PREL.first()
|| {!
   |?
      {? B_PREL.CLASS='B_GATE'
      ||
::       BRAMY ROZDZIELAJĄCE "<"
         {? exec('is_gate','#b_gate',B_PREL.B_ELE,,exec('kind_split','#b_gate'))>0
         ||
::          1. Brama rozdzielająca dla każdego połączenia które z niej wychodzi
::             musi mieć zdefiniowane wybory (oprócz wyjścia domyślnego)
::          2. Brama rozdzielająca OR albo XOR może mieć conajwyzej jedno wyjście domyślne
::          3. Brama sterowana zdarzeniami musi mieć po sobie wyłącznie zdarzenia
            _default:=0;
            _chk_names:=exec('chk_out_names','#b_gate');
            B_CONN.index('FROM');
            B_CONN.prefix(_b_proc,B_PREL.ref());
            {? B_CONN.first()
            || {!
               |? {? B_CONN.DEFAULT='T'
                        &
                     (exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_or','#b_gate'))>0 |
                      exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_xor','#b_gate'))>0 |
                      exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_complex','#b_gate'))>0
                     )
                  ||
                     _default+=1
                  ||
                     B_CHOICE.prefix(B_CONN.ref());
                     {? B_CHOICE.size()=0
                     ||
                        B_PREL.cntx_psh();

                        _sect:='Braki warunków dla bram rozdzielających'@;

                        _prel:=B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']';
                        _conn:=B_CONN.TO().SYMBOL+' ['+B_CONN.TO().B_ELE().SYMBOL+']';
                        _msg:='Brama: %1, połączenie z: %2'@[_prel,_conn];

                        _args.SECT:=_sect;
                        _args.MSG:=_msg;
                        _args.GRAPH_UID:=B_PREL.UID;
                        exec('komm_add','#b_proc',_args);
                        _result:=0;
                        B_PREL.cntx_pop()
                     ?}
                  ?};

                  {? _chk_names>0 & B_CONN.DEFAULT<>'T' & B_CONN.NAME=''
                  ||
                     _sect:='Brak opisów wszystkich wyjść z bramy'@;
                     _msg:='Brama: %1'@[B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']'];

                     _args.SECT:=_sect;
                     _args.MSG:=_msg;
                     _args.GRAPH_UID:=B_PREL.UID;
                     exec('komm_add','#b_proc',_args);
                     _result:=0
                  ?};

                  {? exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_event','#b_gate'))
                  || B_PREL.cntx_psh();
::                   W poniższym warunku podczytywany jest element docelowy
                     _type_intermed:=exec('type_intermed','#b_event');
                     _category_catch:=exec('category_catch','#b_event');
                     {? exec('is_event','#b_event',B_CONN.TO().B_ELE,_type_intermed,,_category_catch)<1
                     ||
                        _sect:='Następnik bramy sterowanej zdarzeniami nie jest zdarzeniem pośrednim przechwytującym'@;
                        _msg:='Element: %1'@[B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']'];

                        _args.SECT:=_sect;
                        _args.MSG:=_msg;
                        _args.GRAPH_UID:=B_PREL.UID;
                        exec('komm_add','#b_proc',_args);
                        _result:=0
                     ?};
                     B_PREL.cntx_pop()
                  ?};

                  B_CONN.next()
               !}
            ?};

            {? _default>1
            ||
               _sect:='Nieprawidłowa liczba wyjść domyślnych (max 1)'@;
               _msg:='Brama: %1'@[B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']'];

               _args.SECT:=_sect;
               _args.MSG:=_msg;
               _args.GRAPH_UID:=B_PREL.UID;
               exec('komm_add','#b_proc',_args);
               _result:=0
            ?}

::       BRAMY ZBIERAJĄCE ">"
         |? exec('is_gate','#b_gate',B_PREL.B_ELE,,exec('kind_merge','#b_gate'))>0
         ||
            {? exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_xor_event','#b_gate'))
            ||
::             1. Brama sterowana zdarzeniami musi mieć przed sobą wyłącznie zdarzenia
               B_CONN.index('TO');
               B_CONN.prefix(_b_proc,B_PREL.ref());
               {? B_CONN.first()
               || {!
                  |?
                     B_PREL.cntx_psh();
::                   W poniższym warunku podczytywany jest element źródłowy
                     {? exec('is_event','#b_event',B_CONN.FROM().B_ELE,exec('type_start','#b_event'))<1
                     ||
                        _sect:='Poprzednik bramy sterowanej zdarzeniami nie jest zdarzeniem startowym'@;
                        _msg:='Element: %1'@[B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']'];

                        _args.SECT:=_sect;
                        _args.MSG:=_msg;
                        _args.GRAPH_UID:=B_PREL.UID;
                        exec('komm_add','#b_proc',_args);
                        _result:=0
                     ?};
                     B_PREL.cntx_pop();
                     B_CONN.next()
                  !}
               ?}
            |? exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_complex','#b_gate'))
            ||
               {? B_PREL.FMANMAIN=''
::             Brama COMPLEX musi mieć podaną formułę warunku
               ||
                  _sect:='Wymagana jest formuła warunku bramy'@;
                  _msg:='Element: %1'@[B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']'];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_PREL.UID;
                  exec('komm_add','#b_proc',_args);
                  _result:=0
               ?}
            ?}
         ?}
      ?};
      B_PREL.next()
   !}
?};

:: Weryfikuje wszystkie B_CHOICEy
B_CHOICE.index('B_PROC');
B_CHOICE.prefix(_b_proc);
{? B_CHOICE.first()
|| {!
   |?
::    Weryfikuje B_CHOICEa
      {? exec('verify','#b_choice',B_CHOICE.ref(),1,,_args)=0
      || _result:=0
      ?};
      B_CHOICE.next()
   !}
?};

B_CONN.cntx_pop();
B_CHOICE.cntx_pop();
B_PREL.cntx_pop();

{? _komm_init>0
|| KOMM.select()
?};
_result


\treeTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Drzewo procesu odzwierciedlajace role, zdarzenia startowe, czynnosci - tabela
::   WE: _a - obj_new('TAB','WER')
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_obj.TAB:=tab_tmp(2
   ,'TREE'     ,'TREE_REF'    ,'TREE_REF'
   ,'DESC'     ,'STRING[100]' ,'Opis'
   ,'B_ROLE'   ,'STRING[16]'  ,'$B_ROLE.ref')


\treeTabAdd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Drzewo procesu odzwierciedlajace role, zdarzenia startowe, czynnosci - dodanie rekordu
::   WE: _a - uchwyt do tabeli tworzonej w exec('treeTab','#b_proc')
::       _b - ref rekordu tabeli tworzonej w exec('treeTab','#b_proc')
::       _c - opis
::       _d - B_ROLE.ref()
::   WY: null() lub ref rekordu tabeli tworzonej w exec('treeTab','#b_proc')
::----------------------------------------------------------------------------------------------------------------------
_Tab:=_a;
_parent:=_b;
_desc:=_c;
_b_role:=_d;

_Tab.blank();
_Tab.TREE:=_parent;
_Tab.DESC:=_desc;
_Tab.B_ROLE:=$_b_role;
{? _Tab.add()
|| _Tab.ref()
|| null()
?}


\treeTabFill
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Drzewo procesu odzwierciedlajace role, zdarzenia startowe, czynnosci - uzupelnienie tabeli
::   WE: _a - uchwyt do tabeli tworzonej w exec('treeTab','#b_proc')
::       _b - B_PROC.ref()
::       _c - B_PROC.UID
::       _d - ref rekordu tabeli tworzonej w exec('treeTab','#b_proc')
::----------------------------------------------------------------------------------------------------------------------
_Tab:=_a;
_b_proc:=_b;
_uid:=_c;
_parent:=_d;

B_ELE.cntx_psh();
B_PREL.cntx_psh();
B_PREL.index('TREE');
B_PREL.prefix(_b_proc,_uid,);
_loop:=B_PREL.first();
{!
|? _loop
|!
   _parent1:=_parent;
   {? B_PREL.B_ELE().CLASS='B_LANE'
   || _parent1:=exec('treeTabAdd','#b_proc',_Tab,_parent,B_PREL.SYMBOL,B_PREL.B_ROLE)
   |? B_PREL.B_ELE().CLASS='B_EVENT'
   || {? exec('FindInSet','#table','B_EVENT','ELEMENT',B_PREL.B_ELE,,"B_EVENT.TYPE",,,'')=exec('type_start','#b_event')
         & exec('FindInSet','#table','B_EVENT','ELEMENT',B_PREL.B_ELE,,"B_EVENT.KIND",,,'')=exec('kind_none','#b_event')
      || _parent1:=exec('treeTabAdd','#b_proc',_Tab,_parent,{? B_PREL.SYMBOL<>'' || B_PREL.SYMBOL || B_PREL.B_ELE().SYMBOL ?},B_PREL.B_ROLE)
      ?}
   |? B_PREL.B_ELE().CLASS='B_ACTION'
   || _parent1:=exec('treeTabAdd','#b_proc',_Tab,_parent,B_PREL.SYMBOL,B_PREL.B_ROLE)
   ?};
   exec('treeTabFill','#b_proc',_Tab,_b_proc,B_PREL.UID,_parent1);
   _loop:=B_PREL.next()
!};
B_PREL.cntx_pop();
B_ELE.cntx_pop()


\stack
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Tworzy tabele tymczasowa typu stos ktorego elementami sa refy sql
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new('STACK','IND_TMS','IND_REF');

_obj.STACK:=tab_tmp(1
      ,'TMS'   ,'REAL'        ,'tm_stamp'
      ,'REF'   ,'STRING[16]'  ,'$B_PREL.ref bramy zbierajacej OR');

_obj.IND_TMS:=_obj.STACK.index('?');
_obj.IND_REF:=_obj.STACK.ndx_tmp(,,'REF',,);
_obj


\stack_psh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wlozenie elementu na stos
::   WE: _a - Stos (obj_new('TAB','IND_TMS','IND_REF'))
::       _b - Referenc elementu wkladanego na stos
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_ref:=$_b;

_Stack:=_obj.STACK;

_Stack.TMS:=FIRMA.tm_stamp();
_Stack.REF:=_ref;
_Stack.add()


\stack_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Zdjecie elementu ze stosu
::   WE: _a - Stos (obj_new('TAB','IND_TMS','IND_REF'))
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_Stack:=_obj.STACK;
_ind_tms:=_obj.IND_TMS;

_Stack.cntx_psh();
_Stack.index(_ind_tms);
_Stack.prefix();
_wyn:={? _Stack.last() || _Stack.del(1,1)>0 ?};
_Stack.cntx_pop();

_wyn


\stack_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wyszukanie elementu w stosie
::   WE: _a - Stos (obj_new('TAB','IND_TMS','IND_REF'))
::       _b - Referenc elementu wkladanego na stos
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_ref:={? var_pres('_b')=type_of(null()) || $_b || _b ?};

_Stack:=_obj.STACK;
_ind_ref:=_obj.IND_REF;

_Stack.cntx_psh();
_Stack.index(_ind_ref);
_Stack.prefix();
_wyn:=_Stack.find_key(_ref);
_Stack.cntx_pop();

_wyn


\sync_ele
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Tabela synchronizatorow z bramy do elementu z dokladnosica sciezki
::   WY: uchwyt do tabeli
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(4
   ,'GATE'     ,'STRING[16]'  ,'$B_PREL.ref() - brama zbierająca OR'
   ,'ELE'      ,'STRING[16]'  ,'$B_PREL.ref() - element z ktorego mozna dotrzec do GATE'
   ,'SYNC_NR'  ,'INTEGER'     ,'Numer ścieżki'@
   ,'SYNC_ELE' ,'STRING[16]'  ,'$B_PREL.ref() - ele. synchronizujacy na drodze z ELE do GATE'
   ,'SGATE'    ,'STRING[30]'  ,'Bramka'@
   ,'SELE'     ,'STRING[30]'  ,'Element'@
   ,'SSELE'    ,'STRING[30]'  ,'Synchronizator'@
   )


\sync_ele_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Dodanie rekordu w tabeli synchronizatorow
::   WE: _a - Tabela synchronizatorow
::       _b - brama (B_PREL.ref())
::       _c - element (B_PREL.ref())
::       _d - nr sciezki
::       _e - element synchronizujacy ($B.ref())
::----------------------------------------------------------------------------------------------------------------------
_SyncEle:=_a;
_gate:=$_b;
_ele:=$_c;
_sync_nr:=_d;
_sync_ele:=_e;

_SyncEle.GATE:=_gate;
_SyncEle.ELE:=_ele;
_SyncEle.SYNC_NR:=_sync_nr;
_SyncEle.SYNC_ELE:=_sync_ele;
_SyncEle.SGATE:=exec('FindAndGet','#table',B_PREL,_SyncEle.GATE,,"B_PREL.SYMBOL",'');
_SyncEle.SELE:=exec('FindAndGet','#table',B_PREL,_SyncEle.ELE,,"B_PREL.SYMBOL",'');
_SyncEle.SSELE:=exec('FindAndGet','#table',B_PREL,_SyncEle.SYNC_ELE,,"B_PREL.SYMBOL",'');
_SyncEle.add()


\chk_idadd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy wszystkie czynności w procesie używające parametrów złączeniowych mają w tych tabelach
:::      pola typu IDADD
::   WE: [_a] - B_PROC.ref
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};

_result:=1;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.clear();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   B_PREL.cntx_psh();
   B_PREL.index('PROC');
   B_PREL.prefix(B_PROC.ref(),'B_ACTION');
   {? B_PREL.first()
   || {!
      |?
         {? var_pres('_buf_act')>100
         || obj_del(_buf_act)
         ?};
         _buf_act:=exec('findAction4Ele','#b_proman',B_PREL.B_ELE);
         {? _buf_act.Ref<>null()
         ||
            {? exec('valid_idadd','#b_action',_buf_act.Ref,,2,,_args)=0
            || _result:=0
            ?}
         ?};
         B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop()
?};
B_PROC.cntx_pop();
_result


\prelFindEle_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Parametry exec('prelFindEle','#b_proc')
::----------------------------------------------------------------------------------------------------------------------
_atr:=obj_new('PROC','BEGIN','CURRENT','GATES','SYNC_PTH','SPLI_PTH','SYNC_ELE','STA_ELE','STA_GAT','FIRSTRUN'
   ,'ISENDELE','WARNING','ERROR','BEG_ELE');
:: Definicja procesu (B_PROC.ref)
_atr.PROC:=null();
:: Element poczatkowy (B_PREL.ref)
_atr.BEGIN:=null();
:: Sprawdzany element (B_PREL.ref)
_atr.CURRENT:=null();
:: Tabela z bramkami zbierajacymi OR procesu
_atr.GATES:=~~;
:: Czy sciezka synchronizowana [T/N]?
_atr.SYNC_PTH:='N';
:: Czy sciezka rozchodzi sie [T/N]?
_atr.SPLI_PTH:='N';
:: Tabela synchronizatorow dla par element, brama zbierajaca OR do ktorej mozna dotrzec z elementu
_atr.SYNC_ELE:=~~;
:: Stos sprawdzonych elementow
_atr.STA_ELE:=exec('stack','#b_proc');
:: Stos bramek synchronizujacych
_atr.STA_GAT:=exec('stack','#b_proc');
:: Pierwsze uruchomienie
_atr.FIRSTRUN:=1;
:: Jest element koncowy
_atr.ISENDELE:=0;
:: Ilosc ostrzezen
_atr.WARNING:=0;
:: Ilosc blendow
_atr.ERROR:=0;
:: Tabela elementow osiaganych z elementu startowego
_atr.BEG_ELE:=~~;
:: Pierwsze wywolanie
_atr


\prelFindEle
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Szukanie elementow do ktorych dochodzimy z elementu _b w procesie _a
::   WE: _a - exec('prelFindEle_a','#b_proc')
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_atr:=_a;

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};

_wyn:=1;

_proc:=_atr.PROC;
_begin:=_atr.BEGIN;
_current:=_atr.CURRENT;
_Gates:=_atr.GATES;
_syncPth:=_atr.SYNC_PTH;
_spliPth:=_atr.SPLI_PTH;
_Sta_Ele:=_atr.STA_ELE;
_Sta_Gat:=_atr.STA_GAT;
_SyncEle:=_atr.SYNC_ELE;
_firstRun:=_atr.FIRSTRUN;
_Beg_Ele:=_atr.BEG_ELE;

:: Pominięcie torów
_class:=exec('FindAndGet','#table',B_PREL,$_current,,"B_PREL.CLASS",null());
{? _class='B_LANE'
|| return(_wyn)
?};

:: Sprawdzenie czy element był już analizowany
{? exec('stack_find','#b_proc',_Sta_Ele,_current)
|| {? _current=_begin
   || _ele:=exec('FindAndGet','#table',B_PREL,$_current,,"SYMBOL+' ['+B_ELE().SYMBOL+']'",'');
      _error:={? _Sta_Ele.STACK.size()=1 || 1 || _spliPth='N' ?};
      _sect:={? _error || 'Błędy'@ || 'Ostrzeżenia'@ ?};
      _msg:='Element: %1'@[_ele];

      _old_kind:=_args.KIND;
      _kind:={? _error || 'error' || 'warning' ?};
      _args.KIND:=_kind;
      _args.MSG:=_msg;
      _args.ICON:=3;
      _args.GRAPH_UID:=exec('FindAndGet','#table',B_PREL,_current,,"UID",'');

      _can_continue:=1;

      {? _can_continue>0
      ||
         {? _Sta_Ele.STACK.size()=1
         || _sect:='Elementy wewnątrz cyklu własnego'@;

            _args.SECT:=_sect;
            _added:=exec('komm_add','#b_proc',_args);

            {? _added>0
            || _atr.ERROR+=1
            ?};
            ~~
         |? _error
         || _sect:='Elementy wewnątrz cyklu zamkniętego'@;

            _args.SECT:=_sect;
            _added:=exec('komm_add','#b_proc',_args);

            {? _added>0
            || _atr.ERROR+=1
            ?};
            ~~
         || _sect:='Elementy wewnątrz cyklu'@;

            _args.SECT:=_sect;
            _added:=exec('komm_add','#b_proc',_args);

            {? _added>0
            || _atr.WARNING+=1
            ?};
            ~~
         ?}
      ?};
      _args.KIND:=_old_kind
   ?};
   return(_wyn)
?};

:: Element na stos
exec('stack_psh','#b_proc',_Sta_Ele,_current);

:: Element na stos elementow osiaganych z elementu startowego
{? var_pres('_Beg_Ele')<>type_of(~~) & ~exec('stack_find','#b_proc',_Beg_Ele,_current)
|| exec('stack_psh','#b_proc',_Beg_Ele,_current)
?};

:: Synchronizator na stos (_cntx)
:: Zapamietnie przejscia przez brame rozdzielajaca (_cntxSplit)
_cntxMerge:=_cntxSplit:=0;
{? _atr.ISENDELE=0 & _class='B_EVENT'
|| _b_ele:=exec('FindAndGet','#table',B_PREL,$_current,,"B_PREL.B_ELE",null());
   _atr.ISENDELE:=exec('FindInSet','#table','B_EVENT','ELEMENT',_b_ele,,"B_EVENT.TYPE",,,'')=exec('type_end','#b_event')
?};
{? _class='B_GATE'
|| _b_ele:=exec('FindAndGet','#table',B_PREL,$_current,,"B_PREL.B_ELE",null());
   _type:=exec('get_type','#b_gate',_b_ele);
   {? (_type=exec('type_or','#b_gate') | _type=exec('type_and','#b_gate') | _type=exec('type_complex','#b_gate'))
      & exec('get_kind','#b_gate',_b_ele)=exec('kind_merge','#b_gate')
   || _cntxMerge:=exec('stack_psh','#b_proc',_Sta_Gat,_current)
   |? (_type=exec('type_or','#b_gate') | _type=exec('type_xor','#b_gate') | _type=exec('type_event','#b_gate'))
      & exec('get_kind','#b_gate',_b_ele)=exec('kind_split','#b_gate')
   || _cntxSplit:=1
   ?}
?};

:: debug
::{? exec('FindAndGet','#table',B_PREL,$_current,,"B_PREL.SYMBOL",'')='08 - OR>'
::   & exec('FindAndGet','#table',B_PREL,$_begin,,"B_PREL.SYMBOL",'')='06'
::|| msg
::?};

:: Sprawdzenie czy _current zawiera sie w _Gates.
:: Jesli tak, znaczy, ze mozna dotrzec do bramy _current z _begin.
:: Dlatego dopisujemy element _begin dla bramy _current do tablicy B_GATELE.
{? exec('stack_find','#b_proc',_Gates,_current)
|| B_GATELE.cntx_psh();
   B_GATELE.index('UNIK');
   B_GATELE.prefix(_proc,_current,_begin);
   {? _current<>_begin
   || {? B_GATELE.first()
::    Para _current, _begin jest juz w B_GATELE
      || {? _syncPth='N'
::       Wykluczenie drog z synchronizatorami jesli istnieje choc jedna bez nich.
::       Oznacza to, ze brama zbierajaca OR musi czekac na _begin do czasu jego zakonczenia.
         || B_GATELE.SYNC_PTH:='N';
            B_GATELE.put();
            exec('sync_ele_add','#b_proc',_SyncEle,_current,_begin,1,'')
         || _SyncEle.cntx_psh();
            _SyncEle.prefix($_current,$_begin);
            _sync_nr:={? _SyncEle.last() || _SyncEle.SYNC_NR+1 || 1 ?};
            _Stack:=_Sta_Gat.STACK;
            _loop:=_Stack.first();
            _size:=_Stack.size();
            {!
            |? _loop
            |!
               {? _Stack.REF=$_current
               || {? _size=1 || exec('sync_ele_add','#b_proc',_SyncEle,_current,_begin,_sync_nr,'') ?}
               || exec('sync_ele_add','#b_proc',_SyncEle,_current,_begin,_sync_nr,_Stack.REF)
               ?};
               _loop:=_Stack.next()
            !};
            _SyncEle.cntx_pop()
         ?}
::    Dopisanie _begin do B_GATELE
      || B_GATELE.B_PROC:=_proc;
         B_GATELE.GATE:=_current;
         B_GATELE.ELE:=_begin;
         B_GATELE.SYNC_PTH:=_syncPth;
         B_GATELE.add();
         _SyncEle.cntx_psh();
         _SyncEle.prefix($_current,$_begin);
         _sync_nr:={? _SyncEle.last() || _SyncEle.SYNC_NR+1 || 1 ?};
         _Stack:=_Sta_Gat.STACK;
         _loop:=_Stack.first();
         _size:=_Stack.size();
         {!
         |? _loop
         |!
            {? _Stack.REF=$_current
            || {? _size=1 || exec('sync_ele_add','#b_proc',_SyncEle,_current,_begin,_sync_nr,'') ?}
            || exec('sync_ele_add','#b_proc',_SyncEle,_current,_begin,_sync_nr,_Stack.REF)
            ?};
            _loop:=_Stack.next()
         !};
         _SyncEle.cntx_pop()
      ?}
   ?};
   B_GATELE.cntx_pop()
?};

:: Sciezka przechodzi przez synchronizator
{? _cntxMerge || _syncPth:='T' ?};
{? _cntxSplit || _spliPth:='T' ?};

:: Analiza powiazan
B_CONN.cntx_psh();
B_CONN.index('FROM');
B_CONN.prefix(_proc,_current);
_loop:=B_CONN.first();
{!
|? _loop
|!
:: debug
::   {? exec('FindAndGet','#table',B_PREL,$_begin,,"B_PREL.SYMBOL",'')='05'
::      & exec('FindAndGet','#table',B_PREL,$_current,,"B_PREL.SYMBOL",'')='08b - OR<'
::   || msg('Start')
::   ?};
   _atr.CURRENT:=B_CONN.TO;
   _atr.SYNC_PTH:=_syncPth;
   _atr.SPLI_PTH:=_spliPth;
   _atr.FIRSTRUN:=0;
   exec('prelFindEle','#b_proc',_atr,_args);
:: debug
::   {? exec('FindAndGet','#table',B_PREL,$_begin,,"B_PREL.SYMBOL",'')='05'
::      & exec('FindAndGet','#table',B_PREL,$_current,,"B_PREL.SYMBOL",'')='08b - OR<'
::   || msg('Stop')
::   ?};
   _loop:=B_CONN.next()
!};
B_CONN.cntx_pop();

:: Synchronizator ze stosu
{? _cntxMerge || exec('stack_pop','#b_proc',_Sta_Gat) ?};

:: Element ze stosu
exec('stack_pop','#b_proc',_Sta_Ele);

:: Sprawdzenie czy dotarto do koncowego elementu z poczatkowego
{? _firstRun
|| {? ~_atr.ISENDELE
   || _ele:=exec('FindAndGet','#table',B_PREL,$_current,,"SYMBOL+' ['+B_ELE().SYMBOL+']'",'');
      _sect:='Nie osiąga elementu końcowego'@;
      _msg:='Element: %1'@[_ele];

      _args.KIND:='error';
      _args.MSG:=_msg;
      _args.ICON:=14;
      _args.GRAPH_UID:=exec('FindAndGet','#table',B_PREL,_current,,"UID",'');
      exec('komm_add','#b_proc',_args);
      _wyn:=0
   |? _atr.ERROR
   || _wyn:=0
   |? _atr.WARNING
   || _wyn:=-1
   ?}
?};
_wyn


\syncGate2Ele_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Parametry exec('syncGate2Ele','#b_proc')
::----------------------------------------------------------------------------------------------------------------------
_atr:=obj_new('PROC','BEGIN','END','CURRENT','SYNC_ELE','STA_ELE','STA_GAT');
:: Definicja procesu (B_PROC.ref)
_atr.PROC:=null();
:: Element poczatkowy (B_PREL.ref)
_atr.BEGIN:=null();
:: Element koncowy (B_PREL.ref)
_atr.END:=null();
:: Sprawdzany element (B_PREL.ref)
_atr.CURRENT:=null();
:: Tabela synchronizatorow dla par element, brama zbierajaca OR do ktorej mozna dotrzec z elementu
_atr.SYNC_ELE:=exec('sync_ele','#b_proc');
:: Stos sprawdzonych elementow
_atr.STA_ELE:=exec('stack','#b_proc');
:: Stos bramek synchronizujacych
_atr.STA_GAT:=exec('stack','#b_proc');
:: Tablica parametrow
_atr


\syncGate2Ele
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wyznacza synchronizatory z dokladnoscia sciezeki z bramki do elementu
::   WE: _a - exec('syncGate2Ele_a','#b_proc')
::----------------------------------------------------------------------------------------------------------------------
_atr:=_a;

_proc:=_atr.PROC;
_begin:=_atr.BEGIN;
_end:=_atr.END;
_current:=_atr.CURRENT;
_SyncEle:=_atr.SYNC_ELE;
_Sta_Ele:=_atr.STA_ELE;
_Sta_Gat:=_atr.STA_GAT;

:: debug
::{? exec('FindAndGet','#table',B_PREL,$_begin,,"B_PREL.SYMBOL",'')='08 - OR>'
::   & exec('FindAndGet','#table',B_PREL,$_end,,"B_PREL.SYMBOL",'')='07'
::|| msg(exec('FindAndGet','#table',B_PREL,$_current,,"B_PREL.SYMBOL",''))
::?};

:: Sprawdzenie czy element byl juz analizowany
{? exec('stack_find','#b_proc',_Sta_Ele,_current) || return() ?};

:: Element na stos
exec('stack_psh','#b_proc',_Sta_Ele,_current);

:: Synchronizator na stos
_cntx:=0;
_class:=exec('FindAndGet','#table',B_PREL,$_current,,"B_PREL.CLASS",null());
{? _class='B_GATE'
|| _b_ele:=exec('FindAndGet','#table',B_PREL,$_current,,"B_PREL.B_ELE",null());
   _type:=exec('get_type','#b_gate',_b_ele);
   {? _current<>_begin & (_current<>_end | _type=exec('type_and','#b_gate'))
      & (_type=exec('type_or','#b_gate') | _type=exec('type_and','#b_gate') | _type=exec('type_complex','#b_gate'))
      & exec('get_kind','#b_gate',_b_ele)=exec('kind_merge','#b_gate')
   || _cntx:=exec('stack_psh','#b_proc',_Sta_Gat,_current)
   ?}
?};

:: Zapisanie synchronizatorow dla sciezki
{? _current=_end
||
   _SyncEle.cntx_psh();
   _sync_nr:={? _SyncEle.last() || _SyncEle.SYNC_NR+1 || 1 ?};
   _Stack:=_Sta_Gat.STACK;
   _loop:=_Stack.first();
   {? ~_loop
   || exec('sync_ele_add','#b_proc',_SyncEle,_begin,_end,_sync_nr,'')
   ?};
   {!
   |? _loop
   |!
      exec('sync_ele_add','#b_proc',_SyncEle,_begin,_end,_sync_nr,_Stack.REF);
      _loop:=_Stack.next()
   !};
   _SyncEle.cntx_pop()
?};

:: Analiza powiazan
B_CONN.cntx_psh();
B_CONN.index('FROM');
B_CONN.prefix(_proc,_current);
_loop:=B_CONN.first();
{!
|? _loop
|!
   _atr.CURRENT:=B_CONN.TO;
   exec('syncGate2Ele','#b_proc',_atr);
   _loop:=B_CONN.next()
!};
B_CONN.cntx_pop();

:: Synchronizator ze stosu
{? _cntx || exec('stack_pop','#b_proc',_Sta_Gat) ?};

:: Element ze stosu
exec('stack_pop','#b_proc',_Sta_Ele);
~~


\gateleChk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Sprawdzenie elementow z sychronizatorami na sciezce bramek zbierajacych procesu _a
::   WE: _a - B_PROC.ref() - definicja procesu
::       _b - Tabela synchronizatorow dla par element, brama zbierajaca OR do ktorej mozna dotrzec z elementu
::----------------------------------------------------------------------------------------------------------------------
_proc:=_a;
_SyncEle:=_b;

B_GATELE.cntx_psh();
B_GATELE.index('UNIK');
B_GATELE.prefix(_proc);
_loop:=B_GATELE.first();
{!
|? _loop
|!
   {? B_GATELE.SYNC_PTH='T'
   ||
      _atr:=exec('syncGate2Ele_a','#b_proc');
      _atr.PROC:=_proc;
      _atr.BEGIN:=B_GATELE.GATE;
      _atr.END:=B_GATELE.ELE;
      _atr.CURRENT:=B_GATELE.GATE;
      exec('syncGate2Ele','#b_proc',_atr);
      exec('gateleChkOne','#b_proc',_atr,_SyncEle);
      obj_del(_atr)
   ?};
   _loop:=B_GATELE.next()
!};
B_GATELE.cntx_pop()


\gateleChkOne
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Analiza drog
::   WE: _a - Tabela synchronizatorow dla par element, brama zbierajaca OR do ktorej mozna dotrzec z elementu
::            Caly proces
::       _b - Tabela synchronizatorow dla par element, brama zbierajaca OR do ktorej mozna dotrzec z elementu
::            Z bramki do elementu
::----------------------------------------------------------------------------------------------------------------------
_atr:=_a;
_SyncEle:=_b;

_proc:=_atr.PROC;
_begin:=_atr.BEGIN;
_end:=_atr.END;
_current:=_atr.CURRENT;
_SyncGate:=_atr.SYNC_ELE;

:: Wyswietlenie tabeli drog synchronizatorow
::{? exec('FindAndGet','#table',B_PREL,$_begin,,"B_PREL.SYMBOL",'')='09 - OR>'
::   & exec('FindAndGet','#table',B_PREL,$_end,,"B_PREL.SYMBOL",'')='10 - AND>'
::|| _wer:=_SyncGate.mk_sel('Drogi synchronizatorów');
::   _SyncGate.win_fld(_wer,,'SGATE','SYMBOL',,30,,,'Bramka zbierająca OR');
::   _SyncGate.win_fld(_wer,,'SELE','SYMBOL',,30,,,'Element bramki');
::   _SyncGate.win_fld(_wer,,'SYNC_NR',,,1,,,'Nr');
::   _SyncGate.win_fld(_wer,,'SSELE',,,30,,,'Synchronizator');
::   _SyncGate.win_sel(_wer);
::   _SyncGate.select()
::?};

_SyncEle.cntx_psh();
_SyncEle.prefix($_begin,$_end);
_size:={? _SyncEle.last() || _SyncEle.SYNC_NR || 0 ?};

_syncPth:=obj_new(_size);
{! _ii:=1.._size |! _syncPth[_ii]:='' !};

_loop:=_SyncGate.first();
{!
|? _loop
|!
   {! _ii:=1.._size
   |!
      {? _SyncGate.SYNC_ELE<>''
      || _SyncEle.prefix($_begin,$_end,_ii);
         {? _syncPth[_ii]<>'T'
         || {? _SyncEle.find_key(_SyncGate.SYNC_ELE)
            || _syncPth[_ii]:='T'
            ?}
         ?}
      ?}
   !};
   _loop:=_SyncGate.next()
!};

_SyncEle.cntx_pop();

:: Sprawdzenie czy element jest elementem koncowym
_skip:=1;
{! _ii:=1.._size |! {? _skip || _skip:=_syncPth[_ii]='T' ?} !};
{? _skip
|| B_GATELE.cntx_psh();
   B_GATELE.index('UNIK');
   B_GATELE.prefix(_proc,_begin,_end);
   {? B_GATELE.first()
   || B_GATELE.SYNC_PTH:='D';
      B_GATELE.put()
   ?};
   B_GATELE.cntx_pop()
?};
~~


\chk_poconns
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy wszystkie elementy w procesie maja wymagane powiazania miedzyargumentowe
::       oraz czy utworzone powiazania maja zgodne typy
::   WE: _a - B_PROC.ref()
::       _b - INTEGER - 0/[1] - czy inicjowac i pokazywac KOMMa
::       [_c] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - sa jakies problemy
::       1 - wszystko jest ok
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_b_proc:=_a;

_komm_init:=0;
{? var_pres('_b')=type_of(0)
|| _komm_init:=_b
?};
_args:=~~;
{? var_pres('_c')>100
|| _args:=exec('obj_ntab_set','#array',_c)
|| _args:=exec('komm_args','#b_proc')
?};

_result:=1;
_can_continue:=0;

_sect:='Weryfikacja powiązań międzyargumentowych dla procesu'@;
{? _komm_init>0
|| KOMM.init(250,,_sect)
?};
B_POCONN.cntx_psh();
B_PORT.cntx_psh();
B_PORT.index('REQ');
B_PROC.cntx_psh(); B_PROC.clear();
{? B_PROC.seek(_b_proc)
||
:: Iteruje po elementach procesu
   B_PREL.cntx_psh();
   B_PREL.index('SYMBOL');
   B_PREL.prefix(B_PROC.ref());
   {? B_PREL.first()
   || {!
      |?
::       Iteruje po aktywnych i wymaganych portach elementu procesu
         B_PORT.prefix('T',B_PREL.B_ELE,'T');
         {? B_PORT.first()
         ||
            {!
            |?
::             Portow wewnetrznych nie analizujemy
               {? B_PORT.KIND<>exec('kind_internal','#b_port')
               ||
::                Sprawdzam czy port ma określoną wartość ręczną w procesie, jeśli tak to dalej nie sprawdzam
                  _manual_val:=exec('has_manual_val','#b_port',B_PREL.ref());

                  {? _manual_val=0
                  ||
::                   Sprawdzam czy port jest powiązany
                     _connected:=0;
                     _err:=0;
                     {? B_PORT.KIND=exec('kind_in','#b_port')
                     ||
::                      Port wejsciowy powinien miec polaczenia 'do'
                        B_CONN.cntx_psh();
                        B_CONN.index('TO');
                        B_CONN.prefix(B_PROC.ref(),B_PREL.ref());
                        _loop:=B_CONN.first();
                        {!
                        |? _loop
                        |!
                           _connected:=0;
                           B_POCONN.index('TO');
                           B_POCONN.prefix(B_PORT.ref(),B_PROC.ref(),B_PREL.ref());
                           B_PORT.cntx_psh();
                           _loop:=B_POCONN.first();
                           {!
                           |? _loop
                           |!
                              _connected:=B_POCONN.B_CONN=B_CONN.ref();
                              _loop:=_connected=0 & B_POCONN.next()
                           !};
                           B_PORT.cntx_pop();

                           {? _connected=0
                           || _err:=1;
                              {? var_pres('ctr_bpmn',_env)=type_of('')
                              || exec('komm_add','#b_design',B_CONN.UID,'Brak powiązanego argumentu: '@+B_PORT.NAME,'EDGE')
                              ?}
                           ?};
                           _loop:=B_CONN.next()
                        !};
                        B_CONN.cntx_pop()
                     |? B_PORT.KIND=exec('kind_out','#b_port')
                     ||
::                      Port wyjsciowy powinien miec polaczenia 'z'
                        B_POCONN.index('FROM');
                        B_POCONN.prefix(B_PORT.ref(),B_PROC.ref(),B_PREL.ref());
                        B_PORT.cntx_psh();
                        {? B_POCONN.first()
                        || _connected:=1
                        || _err:=1
                        ?};
                        B_PORT.cntx_pop()
                     ?};

                     {? _err>0
                     || _result:=0;
                        _sect:='Brak wymaganych powiązań dla argumentów'@;
                        _ele:=B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+'])';
                        _port:=B_PORT.SYMBOL+' '+B_PORT.NAME;
                        _type:=exec('kind_opis','#b_port',B_PORT.KIND).M;
                        _msg:='Argument: %1 typu: %2 (element procesu: %3)'@[_port,_type,_ele];

                        _args.SECT:=_sect;
                        _args.MSG:=_msg;
                        _added:=exec('komm_add','#b_proc',_args);
                        ~~
                     ?}
                  ?}
               ?};
               B_PORT.next()
            !}
         ?};
         B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop();

:: Weryfikuje wszystkie B_POCONNy
   B_POCONN.index('PROC');
   B_POCONN.prefix(_b_proc);
   {? B_POCONN.first()
   || {!
      |?
::       Weryfikuje B_POCONNa
         {? exec('verify','#b_poconn',B_POCONN.ref(),_args)=0
         || _result:=0
         ?};
         B_POCONN.next()
      !}
   ?};
   ~~
|| _result:=0
?};

{? _komm_init>0
|| KOMM.select()
?};

B_POCONN.cntx_pop();
B_PROC.cntx_pop();
B_PORT.cntx_pop();
_result


\gatele
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wyznaczenie elementow na ktore czekaja bramy zbierajace OR lub COMPLEX procesu _a
::   WE: _a - B_PROC.ref()
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: -1 - do definicji zgloszono uwagi
::        0 - błędna definicja procesu
::        1 - prawidłowa definicja procesu
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_b_proc:=_a;

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};

_wyn:=1;

:: Tablica bram zbierajacych OR procesu _b_proc
_Gates:=exec('stack','#b_proc');

:: Zapamietanie bram zbierajacych OR procesu _b_proc
B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_b_proc,'B_GATE');
_loop:=B_PREL.first();
{!
|? _loop
|!
   {? (exec('get_type','#b_gate',B_PREL.B_ELE)=exec('type_or','#b_gate')
       | exec('get_type','#b_gate',B_PREL.B_ELE)=exec('type_complex','#b_gate'))
      & exec('get_kind','#b_gate',B_PREL.B_ELE)=exec('kind_merge','#b_gate')
   || exec('stack_psh','#b_proc',_Gates,B_PREL.ref())
   ?};
   _loop:=B_PREL.next()
!};
B_PREL.cntx_pop();

:: Usuniecie zapisow z B_GATELE dotyczacych procesu _b_proc
exec('delete','#b_gatele',_b_proc);

:: Analiza elementow
:: Tabela synchronizatorow dla par element, brama zbierajaca OR do ktorej mozna dotrzec z elementu
_SyncEle:=exec('sync_ele','#b_proc');

:: Tabela elementow osiaganych z elementow startowych
B_PREL.cntx_psh();
B_PREL.index('PROCSTAR');
B_PREL.prefix(_b_proc,'T');
_il_beg:={? B_PREL.first() || B_PREL.size() ?};
{? _il_beg ||  _Beg_Ele:=obj_new(_il_beg) ?};
{! _ii:=1.._il_beg |! _Beg_Ele[_ii]:=exec('stack','#b_proc') !};
B_PREL.cntx_pop();

_ii:=0;
B_PREL.cntx_psh();
B_PREL.index('PROCSTAR');
B_PREL.prefix(_b_proc);
_loop:=B_PREL.last();
{!
|? _loop
|!
   _atr:=exec('prelFindEle_a','#b_proc');
   _atr.PROC:=_b_proc;
   _atr.BEGIN:=B_PREL.ref();
   _atr.CURRENT:=B_PREL.ref();
   _atr.GATES:=_Gates;
   _atr.SYNC_ELE:=_SyncEle;
   {? B_PREL.START='T' || _ii+=1; _atr.BEG_ELE:=_Beg_Ele[_ii] ?};
   _res:=exec('prelFindEle','#b_proc',_atr,_args);
   {? _wyn=1 & _res<0 || _wyn:=_res
   |? _res=0 || _wyn:=0
   ?};
   obj_del(_atr);
   _loop:=B_PREL.prev()
!};
B_PREL.cntx_pop();

:: Wyswietlenie tabeli drog synchronizatorow
::_SyncEle.prefix();
::_wer:=_SyncEle.mk_sel('Drogi synchronizatorów');
::_SyncEle.win_fld(_wer,,'SGATE','SYMBOL',,30,,,'Bramka zbierająca OR');
::_SyncEle.win_fld(_wer,,'SELE','SYMBOL',,30,,,'Element bramki');
::_SyncEle.win_fld(_wer,,'SYNC_NR',,,1,,,'Nr');
::_SyncEle.win_fld(_wer,,'SSELE',,,30,,,'Synchronizator');
::_SyncEle.win_sel(_wer);
::_SyncEle.select();

exec('gateleChk','#b_proc',_b_proc,_SyncEle);

:: Sprawdzenie osiagalnosci elementow z elementow startowych
B_PREL.cntx_psh();
B_PREL.index('PROCSTAR');
B_PREL.prefix(_b_proc);
_loop:=B_PREL.first();
{!
|? _loop
|!
   {? B_PREL.CLASS<>'B_LANE'
   || _is:=0;
      {! _ii:=1.._il_beg
      |! {? _is=0 & exec('stack_find','#b_proc',_Beg_Ele[_ii],B_PREL.ref()) || _is:=1 ?}
      !};
      {? _is=0
      || _ele:=B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']';
         _sect:='Elementy nieosiągalne z elementu startowego'@;
         _msg:='Element: %1'@[_ele];

         _args.SECT:=_sect;
         _args.MSG:=_msg;
         _args.GRAPH_UID:=B_PREL.UID;
         exec('komm_add','#b_proc',_args);
         _wyn:=0
      ?}
   ?};
   _loop:=B_PREL.next()
!};
B_PREL.cntx_pop();

:: Sprawdzenie rozlacznosci zbiorow elementow osiaganych z elementow startowych
{? _il_beg>0
|| _conn:=obj_new(_il_beg);
   {! _ii:=1.._il_beg-1
   |!
      {! _kk:=1.._il_beg |! _conn[_kk]:=0 !};
      _Stack:=_Beg_Ele[_ii].STACK;
      _Stack.cntx_psh();
      _Stack.prefix();
      _loop:=_Stack.first();
      _beg_ele:={? _loop || _Stack.REF || null() ?};
      {!
      |? _loop
      |!
         {! _jj:=_ii.._il_beg
         |!
            {? _conn[_jj]=0
            || _conn[_jj]:=exec('stack_find','#b_proc',_Beg_Ele[_jj],_Stack.REF)
            ?}
         !};
         _loop:=_Stack.next()
      !};
      _Stack.cntx_pop();
      {? _beg_ele<>''
      || _ele:=exec('FindAndGet','#table',B_PREL,_beg_ele,,"SYMBOL+' ['+B_ELE().SYMBOL+']'",'');
         {! _jj:=_ii.._il_beg
         |!
            {? _conn[_jj]=0
            ||
               _sect:='Rozłączne przebiegi elementu startowego %1'@[_ele];
               _Stack1:=_Beg_Ele[_jj].STACK;
               _Stack1.cntx_psh();
               _Stack1.prefix();
               _loop:=_Stack1.first();
               _beg_ele1:={? _loop || _Stack1.REF || null() ?};
               _Stack1.cntx_pop();
               obj_del(_Stack1);
               _ele1:=exec('FindAndGet','#table',B_PREL,_beg_ele1,,"SYMBOL+' ['+B_ELE().SYMBOL+']'",'');

               _msg:='Przebieg rozpoczynajacy się z: %1'@[_ele1];
               _args.SECT:=_sect;
               _args.MSG:=_msg;
               _args.GRAPH_UID:=exec('FindAndGet','#table',B_PREL,_beg_ele1,,"UID",'');
               exec('komm_add','#b_proc',_args);
               _wyn:=0
            ?}
         !}
      ?};
      obj_del(_Stack)
   !}
?};

:: Sprawdzenie wzajemnego oczekiwania bram
B_GATELE.cntx_psh();
B_GATELE.index('UNIK');
B_GATELE.prefix(_b_proc);
_Stack:=_Gates.STACK;
_Stack.cntx_psh();
_Stack.prefix();
_Stack.first();
_size:=_Stack.size();
{? _size>1
|| {! _ii:=1.._size-1
   |!
      _gate1:=exec('FindAndGet','#table',B_PREL,_Stack.REF);
      _Stack.cntx_psh();
      _loop:=_Stack.next();
      {!
      |? _loop
      |!
         _gate2:=exec('FindAndGet','#table',B_PREL,_Stack.REF);
         {? B_GATELE.find_key(_gate1,_gate2) & B_GATELE.SYNC_PTH<>'D'
            & B_GATELE.find_key(_gate2,_gate1) & B_GATELE.SYNC_PTH<>'D'
         ||
            {? _args.WARN_SHOW>0
            ||
               _sect:='Wzajemnie oczekujące bramy zbierające OR'@;
               {? var_pres('ctr_bpmn',_env)=type_of('')
               || _uid:=exec('FindAndGet','#table',B_PREL,_gate1,,"UID",'');
::                Naniesienie błędu na diagram
                  exec('komm_add','#b_design',_uid,_sect);

                  _uid:=exec('FindAndGet','#table',B_PREL,_gate2,,"UID",'');
::                Naniesienie błędu na diagram
                  exec('komm_add','#b_design',_uid,_sect)
               ?};
               _ele1:=exec('FindAndGet','#table',B_PREL,$_gate1,,"B_PREL.SYMBOL",'');
               _ele2:=exec('FindAndGet','#table',B_PREL,$_gate2,,"B_PREL.SYMBOL",'');
               _msg:='Brama: %1, brama: %2'@[_ele1,_ele2];

               _args.SECT:=_sect;
               _args.MSG:=_msg;
               _args.GRAPH_UID:='';
               exec('komm_add','#b_proc',_args)
            ?};
            {? _wyn<>0 || _wyn:=-1 ?}
         ?};
         _loop:=_Stack.next()
      !};
      _Stack.cntx_pop();
      _Stack.next()
   !}
?};
_Stack.cntx_pop();
B_GATELE.cntx_pop();

:: Wyswietlenie tabeli elementow na ktore czekaja bramy zbierajace
::B_GATELE.index('UNIK');
::B_GATELE.prefix(_b_proc);
::_wer:=B_GATELE.mk_sel('Elementy na które czekają bramki zbierające OR');
::B_GATELE.win_fld(_wer,,'GATE','SYMBOL',,30,,,'Bramka zbierająca OR');
::B_GATELE.win_fld(_wer,,'ELE','SYMBOL',,30,,,'Element bramki');
::B_GATELE.win_fld(_wer,,'SYNC_PTH',,,1,,,'Ścieżka synchronizowana');
::B_GATELE.win_sel(_wer);
::B_GATELE.select();
_wyn


\chk_lic
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: MLAK [17.00]
:: OPIS: Sprawdzenie licencji dla czynności
::   WE: [_a] - B_PROC.ref
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::       [_c] - tab_tmp - tabela z licencjonowanymi dziedzinami
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};
_domain_lic:=~~;
{? var_pres('_c')>100
|| _domain_lic:=_c
?};

_result:=1;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.clear();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   B_PREL.cntx_psh();
   B_PREL.index('PROC');
   B_PREL.prefix(B_PROC.ref(),'B_ACTION');
   {? B_PREL.first()
   || {!
      |?
         {? var_pres('_buf_act')>100
         || obj_del(_buf_act)
         ?};
         _buf_act:=exec('findAction4Ele','#b_proman',B_PREL.B_ELE);
         {? _buf_act.Ref<>null()
         ||
            {? exec('lic','#b_action',_buf_act.Ref,_domain_lic)=0
            ||
               _sect:='Brak licencji na czynność.'@;
               _msg:='Czynność: %1'@[B_PREL.SYMBOL];

               _args.SECT:=_sect;
               _args.MSG:=_msg;
               _args.GRAPH_UID:=B_PREL.UID;
               exec('komm_add','#b_proc',_args);
              _result:=0
            ?}
         ?};
         B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop()
?};
B_PROC.cntx_pop();
_result


\chk_akt
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [18.22]
:: OPIS: Sprawdzenie aktywności czynności
::   WE: [_a] - B_PROC.ref
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};

_result:=1;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.clear();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   B_PREL.cntx_psh();
   B_PREL.index('PROC');
   B_PREL.prefix(B_PROC.ref(),'B_ACTION');
   {? B_PREL.first()
   || {!
      |?
         {? var_pres('_buf_act')>100
         || obj_del(_buf_act)
         ?};
         _buf_act:=exec('findAction4Ele','#b_proman',B_PREL.B_ELE);
         {? _buf_act.AKT<>'T'
         || _result:=0;
            _sect:='Brak czynności w definicji systemu.'@;
            _msg:='Czynność: %1'@[_buf_act.UID+' '+_buf_act.NAME];

            _args.SECT:=_sect;
            _args.MSG:=_msg;
            _args.GRAPH_UID:=B_PREL.UID;
            exec('komm_add','#b_proc',_args)
         ?};
         B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop()
?};
B_PROC.cntx_pop();
_result


\chk_proutes
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: AWI [17.00]
:: OPIS: Sprawdzenie ciągłości tras portów wyjściowych dla procesu _a
::   WE: _a - B_PROC.ref
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: -1 - do definicji zgloszono uwagi
::        0 - błędna definicja procesu
::        1 - prawidłowa definicja procesu
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};

exec('route_create4bproc','#b_proute',0,_a,_args)


\komm_args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Zwraca argumenty dla funkcji exec('komm_add','#b_proc')
::   WY: obj_new
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
::UWAGA: _fld, i _mth to formułki pomocnicze, zeby wygodniej tworzyć tablicę i komentować poszczególne jej elementy
::       powiedzmy, że to będzie pole
         _fld:="31+form(_a)";
::       powiedzmy, że to będzie metoda
         _mth:="31+form(_a)";

_env:=obj_new(
    _fld('KIND','Rodzaj komunikatu: error/warning/empty')
   ,_fld('SECT','Nazwa sekcji')
   ,_fld('MSG','Treść komunikatu')
   ,_fld('ICON','Numer ikony, jeśli nie podany to 14')
   ,_fld('GRAPH_TYPE','Typ elementu na grafie: NODE, EDGE')
   ,_fld('GRAPH_UID','Identyfikator elementu na grafie')
   ,_fld('GRAPH_SEND','Czy wysyłać komunikat na graf')
   ,_fld('WARN_SHOW','Czy dodawać ostrzeżenia do komunikatów')
);
_env.KIND:='error';
_env.SECT:='';
_env.MSG:='';
_env.ICON:=14;
_env.GRAPH_TYPE:='NODE';
_env.GRAPH_UID:='';
_env.GRAPH_SEND:=1;
_env.WARN_SHOW:=1;
_env


\komm_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Odpisanie komunikatu podczas akceptacji, weryfikacji procesu
::   WE: _a - obj_new - argumenty funkcji - wynik exec('komm_args','#b_proc')
::   WY: 0/1 - czy komunikat został dodany
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_args:=_a;

_result:=0;

_kind:=_args.KIND;

_sect:={? _kind='warning'
       || 'Ostrzeżenia'@
       |? _kind='empty'
       || ''
       || 'Błędy'@
       ?};

_sub_sect:=_args.SECT;
_msg:=_args.MSG;

_uid:=_args.GRAPH_UID;
_graph_type:=_args.GRAPH_TYPE;
_warn_show:=_args.WARN_SHOW;
_icon:=_args.ICON;
_graph_send:=_args.GRAPH_SEND;

{? _sect='Ostrzeżenia'@ & _warn_show=0
|| return(1)
?};

_proc_str:='';
_sect_proc:=0;
_root:=0;

{? _env.KOMM_PROC<>null()
|| _proc_str:=exec('record','#to_string',_env.KOMM_PROC);
   _sect_proc:=KOMM.find_msg(_proc_str);
   {? _sect_proc
   || KOMM.set_root(_proc_str)
   || _sect_proc:=KOMM.sect_beg(_proc_str)
   ?};
   _root:=_sect_proc
?};
_sect_kind:=0;
{? _sect<>''
||
   _sect_kind:=KOMM.find_msg(_sect,_root);
   {? _sect_kind
   || KOMM.set_root(_sect,_root)
   || _sect_kind:=KOMM.sect_beg(_sect)
   ?};
   _root:=_sect_kind
?};

_sect_sub:=0;
{? _sub_sect<>''
||
   _sect_sub:=KOMM.find_msg(_sub_sect,_root);
   {? _sect_sub
   || KOMM.set_root(_sub_sect,_root)
   || _sect_sub:=KOMM.sect_beg(_sub_sect)
   ?};
   _root:=_sect_sub
?};

{? KOMM.find_msg(_msg,_root)=0
|| KOMM.add(_msg,_icon,,1);
   _result:=1
?};

{? _graph_send>0 & var_pres('ctr_bpmn',_env)=type_of('') & _uid<>''
||
:: Naniesienie błędu na diagram
   _kind:=0;
   {? _sect='Ostrzeżenia'@
   || _kind:=1
   ?};
   exec('komm_add','#b_design',_uid,_sub_sect,_graph_type,_kind)
?};

{? _sect_sub>0
|| KOMM.sect_end()
?};

{? _sect_kind>0
|| KOMM.sect_end()
?};

{? _sect_proc>0
|| KOMM.sect_end()
?};
_result


\chk_lanes
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy wszystkie elementy procesu są osadzone na torach (są powiązane z rolami)
::   WE: [_a] - B_PROC.ref
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLIC><PROCES><MODELER><KONTROLA><TORY>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};

_result:=1;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.clear();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   B_PREL.cntx_psh();
   B_PREL.index('PROC');
   B_PREL.prefix(B_PROC.ref());
   _sect:='Elementy nie znajdujące się na torach'@;
   {? B_PREL.first()
   || {!
      |?
         _chk:=0;
         {? B_PREL.CLASS='B_ACTION' | B_PREL.CLASS='B_EVENT' | B_PREL.CLASS='B_GATE'
         || _chk:=1
         ?};
         {? _chk>0
         ||
            {? B_PREL.B_ROLE=null()
            || _result:=0;
               _ele:=B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']';
               _msg:='Element z nieokreśloną rolą: %1'@[_ele];

               _args.SECT:=_sect;
               _args.MSG:=_msg;
               _args.GRAPH_UID:=B_PREL.UID;
               exec('komm_add','#b_proc',_args)
            ?}
         ?};
         B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop()
?};
B_PROC.cntx_pop();
_result


\set_active
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Aktywuje lub dezaktywuje dany proces
::   WE: [_a] - B_PROC.ref lub aktualny rekord
::       [_b] - STRING - [T]/N - aktywować czy dezaktywować
::       [_c] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA><MODELER><PROCES>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_active:='T';
{? var_pres('_b')=type_of('')
|| _active:=_b
?};
_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

_result:=0;
_can_continue:=1;

B_PROC.cntx_psh();
B_PROC.clear();
{? _ref<>null()
|| {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _what:=exec('to_string','#b_proc');
   _tab:=cur_tab(1,1);
   _group:=0;
   {? _tab.sel_size()>0
   || _group:=1;
      _dialog:=0
   ?};

   {? _dialog>0
   || {? _active='T'
      || _can_continue:=FUN.ask('Czy aktywować proces: %1?'@[_what])
      |? _active='N'
      || _can_continue:=FUN.ask('Czy dezaktywować proces: %1?'@[_what])
      ?}
   ?};

   {? _can_continue>0 & _active='T'
   ||
      {? B_PROC.ACTIVE='T'
      || _can_continue:=0;
         _msg:='Proces: %1 jest już aktywny.'@[_what];
         {? _dialog>0
         || FUN.info(_msg)
         |? _group>0
         || KOMM.add(_msg,7)
         ?}
      ?}
   |? _can_continue>0 & _active='N'
   ||
      {? B_PROC.ACTIVE='N'
      || _can_continue:=0;
         _msg:='Proces: %1 jest już nieaktywny.'@[_what];
         {? _dialog>0
         || FUN.info(_msg)
         |? _group>0
         || KOMM.add(_msg,7)
         ?}
      ?};
      {? B_PROC.ACCEPTED='N'
      || _can_continue:=0;
         _msg:='Proces: %1 nie jest zaakceptowany. Tylko zaakceptowane procesy można dezaktywować.'@[_what];
         {? _dialog>0
         || FUN.info(_msg)
         |? _group>0
         || KOMM.add(_msg,7)
         ?}
      ?}
   ?};
   {? _can_continue>0
   || {? exec('chk_nproc','#b_proc')=0
      || _can_continue:=0;
         _msg:='Proces: %1 zawiera czynność skonfigurowaną do uruchamiana poza menadżerem procesów.'@[_what];
         {? _dialog>0
         || FUN.info(_msg)
         |? _group>0
         || KOMM.add(_msg,7)
         ?}
      ?}
   ?};
   {? _can_continue>0
   || B_PROC.ACTIVE:=_active;
      _can_continue:=B_PROC.put();

      {? _can_continue>0 & B_PROC.ACTIVE='N'
      ||
::       Jeśli proces został dezaktywowany to usuwam mu niepotrzebne rzeczy
         exec('del_b_proc','#b_harm',B_PROC.ref());
         exec('proc_actrol_del','#b_role',B_PROC.ref())

      |? _can_continue>0 & B_PROC.ACTIVE='T'
      ||
::       Jeśli proces został aktywowany to przywracam mu potrzebne rzeczy
         exec('add_b_proc','#b_harm',B_PROC.ref());
         exec('procrol2actrol','#b_design',B_PROC.ref(),'')
      ?};
      {? _can_continue=0
      || _msg:='Zmiana aktywności procesu: %1 zakończona niepowodzeniem'@[_what];
         {? _dialog>0
         || FUN.info(_msg)
         |? _group>0
         || KOMM.add(_msg,2)
         ?}
      ?}
   ?}
?};
B_PROC.cntx_pop();
B_PROC.get();
{? _can_continue>0
|| _result:=1
?};
_result


\can_run
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy proces można uruchomić
::   WE: [_a] - B_PROC.ref lub bieżący rekord
::       [_b] - INTEGER - sposób wyświetlania komunikatów o nieprawidłowościach:
::                            [1] - na ekran
::                             2 - do KOMMa
::   WY: 0 - procesu nie można uruchomić
::       1 - proces można uruchomić
::  TAG: <PUBLICZNA><MODELER><PROCES><CHK>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_result:=0;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.clear();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
_what:='';
{? _can_continue>0
|| _what:=exec('to_string','#b_proc');
   {? (B_PROC.ACTIVE='T' & B_PROC.ACCEPTED='T') | B_PROC.MICRO='T'
   || _can_continue:=1
   || _can_continue:=0;
      {? B_PROC.ACTIVE<>'T'
      || _msg:='Proces: %1 jest nieaktywny, jego uruchomienie jest niemożliwe.'@[_what];
         {? _dialog=1
         || FUN.emsg(_msg)
         || KOMM.add(_msg,2)
         ?}
      ?};
      {? B_PROC.ACCEPTED<>'T'
      || _msg:='Proces: %1 jest niezaakceptowany, jego uruchomienie jest niemożliwe.'@[_what];
         {? _dialog=1
         || FUN.emsg(_msg)
         || KOMM.add(_msg,2)
         ?}
      ?}
   ?}
?};

:: Zabezpieczenie przed przepełnieniem się tabel
{? _can_continue>0 & BPMN.MAX_INS>0
|| BI_PROC.cntx_psh();
   BI_PROC.index('PROBORN');
   BI_PROC.prefix(B_PROC.ref());
   {? BI_PROC.size()>=BPMN.MAX_INS
   || _can_continue:=0;
      _msg:='Proces: %1 przekroczył maksymalną liczbę instancji: %2.'@[_what,$BPMN.MAX_INS];
      {? _dialog=1
      || FUN.emsg(_msg)
      || KOMM.add(_msg,2)
      ?}
   ?};
   BI_PROC.cntx_pop();
   ~~
?};
{? _can_continue>0
|| _result:=1
?};
B_PROC.cntx_pop();
_result


\to_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca tekstową reprezentację procesu
::       KONTEKST - rekord B_PROC
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
B_PROC.SYMBOL+' (wersja: '+B_PROC.VER+')'


\display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja wyświetl przed w oknie wertowania B_PROC
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
B_PROC.IVAL_DEF();
_win:=exec('win_edit','#b_proc',0);
B_PROC.win_edit(_win);
B_PROC.display();
~~


\chk_domain
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Sprawdzenie czy elementy startowe nieokreślone są oznaczone domeną
::       i automatyczne wyznaczenie domeny dla elementów bez niej
::   WE: _a - B_PROC.ref()
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - są elementy startowe nieokreślone bez domeny
::       >0 - wszystkie elementy startowe nieokreślone mają przypisaną domenę
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_proc:=_a;

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};

_wyn:=1;

B_PREL.cntx_psh();
B_PREL.index('PROCSTAR');
B_PREL.prefix(_proc,'T');
_loop:=B_PREL.first();
{!
|? _loop
|!
   _isEventStartNone:=exec('FindInSet','#table','B_EVENT','ELEMENT',B_PREL.B_ELE,
      ,"exec('kind_none','#b_event')=B_EVENT.KIND",,,0);
   {? _isEventStartNone & (B_PREL.B_DOMAIN=null() | B_PREL.B_DOMAUT='T')
   || _wyn:=exec('fillDomain4start','#b_proc',B_PREL.ref(),_args)
   ?};
   _loop:=B_PREL.next()
!};
B_PREL.cntx_pop();

_wyn


\fillDomain4start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wypełnia _a.B_DOMAIN podstawie elementu znajdującego się za _a
::   WE: _a - B_PREL.ref()
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - nie powiodło się wypełnienie domeny dla _a
::       1 - wypełniono domenę dla _a
::       2 - element _a miał już domenę
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_prel:=_a;

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};

_wyn:=0;

B_PREL.cntx_psh();
B_PREL.prefix();
{? B_PREL.seek(_prel)
|| {? B_PREL.B_DOMAIN & B_PREL.B_DOMAUT='N'
   || _wyn:=2
   || B_PREL.B_DOMAIN:=exec('findDomain','#b_proc',_prel);
      {? B_PREL.B_DOMAIN & B_PREL.B_DOMAIN().SYMBOL<>'ZWS'
      || B_PREL.B_DOMAUT:='T';
         _wyn:=B_PREL.put()
      || _sect:='Elementy startowe bez przypisanej dziedziny produktowej'@;
         _msg:='Element: %1 [%2]'@[B_PREL.SYMBOL,B_PREL.B_ELE().SYMBOL];

         _args.SECT:=_sect;
         _args.MSG:=_msg;
         _args.GRAPH_UID:=B_PREL.UID;
         exec('komm_add','#b_proc',_args)
      ?}
   ?}
?};
B_PREL.cntx_pop();
_wyn


\findDomain
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Szuka domeny analizując połączenia za elementem startowym _a.
::       Pierwsze czynności znajdujące się za elementem startowym muszą mieć tą samą domenę w przeciwnym przypadku
::       zwrócona zostanie wartość null.
::   WE: _a - B_PREL.ref()
::   WY: null - nie udało się ustalić domeny
::       B_DOMAIN.ref() - znaleziona domena
::----------------------------------------------------------------------------------------------------------------------
_prel:=_a;

_wyn:=null();

B_PREL.cntx_psh();
B_PREL.prefix();
{? B_PREL.seek(_prel)
|| {? B_PREL.CLASS='B_ACTION'
   || _wyn:=exec('FindInSet','#table','B_ACTION','B_ELE',B_PREL.B_ELE,,"B_ACTION.B_DOMAIN",,,null())
   || _wyn1:=null();
      B_CONN.cntx_psh();
      B_CONN.index('FROM');
      B_CONN.prefix(B_PREL.B_PROC,B_PREL.ref());
      _loop:=B_CONN.first();
      {!
      |? _loop
      |!
::       Omijam połączenia do samego siebie bo się zapętli
         {? B_CONN.TO<>B_PREL.ref()
         ||
            _wyn1:=exec('findDomain','#b_proc',B_CONN.TO);
            {? _wyn=null() || _wyn:=_wyn1 ?}
         ?};
         _loop:=(_wyn=null() | _wyn1 & _wyn=_wyn1) & B_CONN.next()
      !};
      B_CONN.cntx_pop();
      {? _wyn<>_wyn1 || _wyn:=null() ?}
   ?}
?};
B_PREL.cntx_pop();
_wyn


\fields_blank
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuły na blank pół w tabeli B_PROC
::   WY: ANY
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_fld:=fld();
_result:=~~;
{? _fld='TR_MODE'
|| _result:=exec('tr_mode','#b_prel')
?};
_result


\get_pl_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Na podstawie planowanego czasu trwania procesu wyznacza planowany czas zakończenia
::       uwzględniając podany kalendarz
::   WE: _a - B_PROC.ref() - definicja procesu
::       _b - REAL - moment startu procesu
::       [_c] - STRING - nazwa kalendarza który ma zostać użyty do wyznaczenia końca
::   WY: REAL - tm_stamp - planowany koniec
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;
_start:=_b;

_kalendarz:='';
{? var_pres('_c')=type_of('')
|| _kalendarz:=_c
?};

_result:=0;

:: Na razie bez uwzględnienia kalendarza, bo nie mamy takich metod w obiekcie kalendarza
B_PROC.cntx_psh();
B_PROC.clear();
{? B_PROC.seek(_b_proc)
||
   {? B_PROC.IVAL_DEF<>null()
   || _result:=exec('add_to_point','#interval',_start,B_PROC.IVAL_DEF)
   ?}
?};
B_PROC.cntx_pop();
_result


\mod_status_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Aktualizuje na procesie pole B_PROC.MODIFIED w oparciu o znaczniki czasowe TM_SAVE i TM_IMP
::   WE: [_a] - B_PROC.ref() lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(B_PROC.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.prefix();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? B_PROC.TM_IMP=0
   || B_PROC.MODIFIED:='N'
   || {? B_PROC.TM_SAVE>B_PROC.TM_IMP
      || B_PROC.MODIFIED:='T'
      || B_PROC.MODIFIED:='N'
      ?}
   ?};
   _can_continue:=B_PROC.put()
?};
B_PROC.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\mod_status_reset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Wszystkim procesom w systemie resetuje status modyfikalności, ustawiając im pola B_PROC.TM_IMP oraz
::       B_PROC.MODIFIED tak jakby były to standardowe procesy
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;
_result:=0;

B_PROC.cntx_psh();
B_PROC.index('AKT');
B_PROC.prefix('N');
{? B_PROC.first()
|| {!
   |? B_PROC.TM_IMP:=1;
      B_PROC.MODIFIED:='N';
      _can_continue:=B_PROC.put();
      B_PROC.next() & _can_continue>0
   !}
?};
B_PROC.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\chk_grp_firm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.28]
:: OPIS: Sprawdza czy w firmie 000 w definicji procesu użyto tylko czynności typu GRP_FIRM
::   WE: _a - B_PROC.ref()
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - są czynności innego typu niż GRP_FIRM
::       >0 - wszystkie czynności są typu GRP_FIRM
::----------------------------------------------------------------------------------------------------------------------
_return:=1;
{? REF.FIRMA().SYMBOL<>'000' || return(_return) ?};

params_set(params_get());
_b_proc:=_a;

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
|| _args:=exec('komm_args','#b_proc')
?};

_sect:='Czynności niedostępne w firmie 000'@;
B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_b_proc,'B_ACTION');
_loop:=B_PREL.first();
{!
|? _loop
|!
   _return:=exec('FindInSet','#table','B_ACTION','B_ELE',B_PREL.B_ELE,,"B_ACTION.GRP_FIRM='T'",,,0);
   {? _return=0
   || _ele:=B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']';
      _msg:='Czynność: %1'@[_ele];

      _args.SECT:=_sect;
      _args.MSG:=_msg;
      _args.GRAPH_UID:=B_PREL.UID;
      exec('komm_add','#b_proc',_args)
   ?};
   _loop:=_return & B_PREL.next()
!};
B_PREL.cntx_pop();
_return


\delete_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Akcja w oknie - usunięcie rekordu
::   WE: [_a] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

_result:=0;
_can_continue:=1;

_tab:=cur_tab(1,1);

_ref_next:=null();
_tab.cntx_psh();
{? _tab.next()
|| _ref_next:=_tab.ref()
?};
_tab.cntx_pop();

_ref_prev:=null();
_tab.cntx_psh();
{? _tab.prev()
|| _ref_prev:=_tab.ref()
?};
_tab.cntx_pop();

_group:=0;
{? _tab.sel_size()>0
|| _group:=1;
   _dialog:=0
?};

_what:=exec('B_PROC','#to_string');

:: Sprawdzam czy można usunąć
{? _group>0
|| _can_continue:=exec('can_delete','#b_proc',_tab.ref(),2)
|| _can_continue:=exec('can_delete','#b_proc',_tab.ref(),1)
?};

{? _dialog>0 & _can_continue>0
|| _can_continue:=FUN.ask('Czy na pewno usunąć proces \'%1\'?'@[_what])
?};
{? _can_continue>0
||
:: Sprawdzam czy można zablokować proces do edycji
   _b_proc:=_tab.ref();
   _locked:=0;
   {? _can_continue>0
   ||
      _msg:='Proces \'%1\' niemożliwy do usunięcia ponieważ jest redagowany'@[_what];
      _locked:=exec('blk_lock','#table','B_PROC',_b_proc,,1,_msg,,_group);
      {? _locked=0
      || _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   || _result:=exec('delete','#b_proc',_b_proc,_dialog)
   ?};
   {? _locked>0
   || exec('blk_unlock','#table','B_PROC',_b_proc)
   ?}
?};

{? _group=0
||
:: Staję na następnym rekordzie
   {? _result>0 & _ref_next<>null()
   || _tab.seek(_ref_next)
:: Staję na poprzednim rekordzie
   |? _result>0 & _ref_prev<>null()
   || _tab.seek(_ref_prev)
   ?}
?};
_result


\delete_act_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Akcja usuń grupa przed w oknie wertowania tabeli B_PROC
::   WY: 0 - porazka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tab:=cur_tab(1,1);
{? FUN.ask('Zaznaczonych procesów: %1. Czy usunąć je wszystkie?'@[$_tab.sel_size()])
|| _result:=1;
   sel_nchk();
   KOMM.init(200,,'Usuwanie procesów'@,'')
?};
_result


\delete_act_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Akcja usuń grupa po w oknie wertowania tabeli B_PROC
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
KOMM.select(,,,,,0);
~~


\ap_trig_b_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MP [20.42]
:: OPIS: Triger after put dla tabeli B_PROC
::----------------------------------------------------------------------------------------------------------------------
{? ~_a | do_state()<>1 || return() ?};
:: synchronizacja tabeli etypproc
{? bfld('SYMBOL')<>B_PROC.SYMBOL | bfld('VER')<>B_PROC.VER
|| exec('put_etypproc','#b_proc',bfld('SYMBOL'),bfld('VER'))
|? (B_PROC.ACTIVE='N' & B_PROC.ACTIVE<>bfld('ACTIVE')) | (B_PROC.ACCEPTED<>'T' & B_PROC.ACCEPTED<>bfld('ACCEPTED'))
|| {? ~exec('put_act_b_proc','obiegi2',bfld('SYMBOL'),bfld('VER'))
   || exec('putVer_etypproc','#b_proc',bfld('SYMBOL'),bfld('VER'),'')
   ?}
|? (B_PROC.ACTIVE<>bfld('ACTIVE') & B_PROC.ACTIVE='T' & B_PROC.ACCEPTED='T') |
   (B_PROC.ACCEPTED<>bfld('ACCEPTED') & B_PROC.ACCEPTED='T' & B_PROC.ACTIVE='T')
|| exec('put_act_b_proc','obiegi2',bfld('SYMBOL'),bfld('VER'))
?};
~~


\ad_trig_b_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MP [20.42]
:: OPIS: Triger after del dla tabeli B_PROC
::----------------------------------------------------------------------------------------------------------------------
{? ~_a | do_state()<>1 || return() ?};
:: synchronizacja tabeli etypproc
{? ~exec('put_act_b_proc','obiegi2',bfld('SYMBOL'),bfld('VER'))
|| exec('del_etypproc','#b_proc',bfld('SYMBOL'),bfld('VER'))
?};
~~


\del_etypproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MP [20.42]
:: OPIS: funkcja usuwająca powiązane z procesem powiązania wniosek - proces
::   WE: _a - PROC_SYM
::       _b - PROC_VER
::---------------------------------------------------------------------------------------------------------------------
_sym:=_a;
_ver:=_b;
ETYPPROC.cntx_psh();
ETYPPROC.index('PROC');
ETYPPROC.prefix(_sym,_ver);
{? ETYPPROC.first()
|| {! |?
   ETYPPROC.del()
   !}
?};
ETYPPROC.cntx_pop()


\put_etypproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MP [20.42]
:: OPIS: funkcja poprawiająca rekordy ETYPPROC po drobnych zmianach w procesach
::   WE: _a - PROC_SYM przed użyciem put
::       _b - PROC_VER przed użyciem put
::---------------------------------------------------------------------------------------------------------------------
_sym:=_a;
_ver:=_b;
_result:=0;
ETYPPROC.cntx_psh();
ETYPPROC.index('PROC');
ETYPPROC.prefix(_sym,_ver);
{? ETYPPROC.first()
|| {! |?
   ETYPPROC.cntx_psh();
   ETYPPROC.prefix();
   ETYPPROC.PROC_SYM:=B_PROC.SYMBOL;
   ETYPPROC.PROC_VER:=B_PROC.VER;
   _result:=ETYPPROC.put();
   ETYPPROC.cntx_pop();
   ETYPPROC.next()
   !}
?};
ETYPPROC.cntx_pop();
_result


\putVer_etypproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JK [22.26]
:: OPIS: funkcja czyszcząca wersj rekordy ETYPPROC, gdy nie można uruchomić procesu
::   WE: _a - PROC_SYM przed użyciem put
::       _b - PROC_VER przed użyciem put
::       _c - nowy PROC_VER
::---------------------------------------------------------------------------------------------------------------------
_sym:=_a;
_ver:=_b;
_result:=0;
ETYPPROC.cntx_psh();
ETYPPROC.index('PROC');
{? _c<>''
|| ETYPPROC.prefix(_sym,)
|| ETYPPROC.prefix(_sym,_ver)
?};
{? ETYPPROC.first()
|| {!
   |? ETYPPROC.cntx_psh();
      ETYPPROC.prefix();
      ETYPPROC.PROC_VER:=_c;
      _result:=ETYPPROC.put();
      ETYPPROC.cntx_pop();
      ETYPPROC.next()
   !}
?};
ETYPPROC.cntx_pop();
_result


\has_instances
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Sprawdza, czy dany proces ma czynne instancje
::       Analizowane są instancje, które zostały utworzone wcześniej niż 24 godziny od bieżącej chwili
::       (zgodnie z ustawieniem parametru 100937)
::   WE: _a - B_PROC.ref()
::   WY: 0 nie ma instancji / 1 są insancje / -1 są instancje, ale mimo wszytko uruchomić kolejną
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;

_result:=0;
_p100937:=exec('get','#params',100937,type_of(0));
{? _p100937<1 || _p100937:=24 ?};
_tm:=exec('create','#tm_stamp')-(_p100937*exec('hour','#tm_stamp'));

BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('PROSTAN');
BI_PROC.prefix(_b_proc,__Status.URUCHOMIONY);
{? BI_PROC.first()
|| _result:=-1;
   {!
   |? {? exec('create','#tm_stamp',BI_PROC.BORN_D,BI_PROC.BORN_T)>_tm || _result:=1 ?};
      _result<1 & BI_PROC.next()
   !}
?};
BI_PROC.cntx_pop();

_result


\fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Formuła na format wyświetlania
::   WY: STRING
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:='';
{? _fld='MAX_INS'
|| _result:='out_prec=0'
?};
_result


\fld_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Formuła na format redagowania
::   WY: STRING
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:='';
{? _fld='MAX_INS'
|| _result:='in_prec=0'
?};
_result


\is_archived
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Sprawdza czy jakakolwiek instancja procesu znajduje się w archiwum
::   WE: [_a] - B_PROC.ref lub bieżący rekord
::   WY: 0 - brak procesu w archiwum
::       1 - jest proces w archiwum
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(B_PROC.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.prefix();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| BI_ARCH.cntx_psh();
   BI_ARCH.index('NUM_PROC');
   BI_ARCH.prefix(REF.FIRMA,B_PROC.ref());
   {? BI_ARCH.find_ge(1)
   || _result:=1
   ?};
   BI_ARCH.cntx_pop()
?};
B_PROC.cntx_pop();
_result


\chk_nproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Sprawdzenie sposobu uruchamiania czynności
::   WE: [_a] - B_PROC.ref
::       [_b] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_args:=~~;
{? var_pres('_b')>100
|| _args:=exec('obj_ntab_set','#array',_b)
?};

_result:=1;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.clear();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   B_PREL.cntx_psh();
   B_PREL.index('PROC');
   B_PREL.prefix(B_PROC.ref(),'B_ACTION');
   {? B_PREL.first()
   || {!
      |?
         {? var_pres('_buf_act')>100
         || obj_del(_buf_act)
         ?};
         _buf_act:=exec('findAction4Ele','#b_proman',B_PREL.B_ELE);
         {? exec('FindInSet','#table','B_ACTPRO','FIRMA',_buf_act.UID,REF.FIRMA,"B_ACTPRO.RUNNPROC",1,,'')='T'
         || _result:=0;
            _sect:='Czynność skonfigurowana do uruchamiana poza menadżerem procesów.'@;
            _msg:='Czynność: %1'@[_buf_act.UID+' '+_buf_act.NAME];

            {? type_of(_args)>0
            || _args.SECT:=_sect;
               _args.MSG:=_msg;
               _args.GRAPH_UID:=B_PREL.UID;
               exec('komm_add','#b_proc',_args)
            ?}
         ?};
         B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop()
?};
B_PROC.cntx_pop();
_result


\copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [RR.xx]
:: OPIS: Jądro kopiowania procesu
::   WE: _a - B_PROC.ref() - proces źródłowy
::       _b - obj_new() - tablica z właściwościami procesu docelowego, wynik działania exec('buffer','#b_proc')
::       [_c] - INTEGER - tryb komunikatów: 0 - brak, [1] - na ekran, 2 - do KOMM
::   WY: B_PROC.ref() - nowy proces lub null jeżeli się nie udało skopiować
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_proc_src:=_a;
_buf_dest:=_b;
_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

_can_continue:=1;
_result:=null();

_proc_des:=null();

:: Bufor B_PREL
_buf_proc:=exec('buffer','#b_proc');
:: Bufor B_PREL
_buf_prel:=exec('buffer','#b_prel');
:: Bufor B_CONN
_buf_conn:=exec('buffer','#b_conn');
:: Bufor B_POCONN
_buf_poconn:=exec('buffer','#b_poconn');
:: Bufor B_CHOICE
_buf_choice:=exec('buffer','#b_choice');
:: Bufor B_VALPRT
_buf_valprt:=exec('buffer','#b_valprt');
:: Bufor B_TIMER
_buf_timer:=exec('buffer','#b_timer');
:: Bufor B_MSG
_buf_msg:=exec('buffer','#b_msg');
:: Bufor B_SIGPRT
_buf_sigprt:=exec('buffer','#b_sigprt');
:: Tabela asocjacji
_Asoc:=tab_tmp(1
   ,'OLD'   ,'STRING[16]', 'Stary ref'
   ,'NEW'   ,'STRING[16]', 'Nowy ref');

_buf_proc.cntx_get(_proc_src);
_buf_proc.ACCEPTED:='N';
_buf_proc.ACTIVE:='T';
_buf_proc.set();

IVAL_DEF.cntx_psh();
B_PROC.cntx_psh(); B_PROC.clear();

B_ACTION.cntx_psh();
B_ACTION.index('B_ELE');

B_PROC.memo_get(,'TARGET');
B_PROC.memo_get(,'DESC');

B_PROC.index('SYM');
B_PROC.prefix('N',_buf_dest.FIRMA,_buf_dest.SYMBOL,_buf_dest.VER,);
{? B_PROC.first()
|| _firm_sym:=exec('record','#to_string',_buf_dest.FIRMA);
   _msg:='Proces: %1 w wersji: %2 już istnieje w firmie: %3 .'@[_buf_dest.SYMBOL,_buf_dest.VER,_firm_sym];
   {? _dialog=1
   || FUN.emsg(_msg)
   |? _dialog=2
   || _args:=exec('komm_args','#b_proc');
      _args.MSG:=_msg;
      _args.SECT:='';
      exec('komm_add','#b_proc',_args)
   ?}
|| B_PROC.clear();
   _buf_dest.ACCEPTED:='N';
   _buf_dest.ACTIVE:='T';
   _change_firm:=0;
   {? B_PROC.FIRMA<>_buf_dest.FIRMA
   || _change_firm:=1
   ?};

   _buf_dest.set();
   B_PROC.DIAGRAM:='';
   {? B_PROC.add()
   || B_PROC.memo_put(,'TARGET');
      B_PROC.memo_put(,'DESC');
      _proc_des:=B_PROC.ref();
::    B_PREL
      B_PREL.cntx_psh();
      B_PREL.index('SYMBOL');
      B_PREL.prefix(_proc_src);
      _loop:=B_PREL.first();
      {!
      |? _loop
      |!
         _buf_prel.cntx_get(B_PREL.ref(),,1);
         _buf_prel.B_PROC:=_proc_des;
         _buf_prel.CODE:=exec('new_code','#b_design','B_PREL',_buf_prel.UID);
         {? _change_firm>0 & _buf_prel.B_ROLE<>null()
         || _prel_firma:=exec('FindAndGet','#table',B_ROLE,_buf_prel.B_ROLE,,"FIRMA",null());
            {? _prel_firma<>B_PROC.FIRMA
            || B_ROLE.cntx_psh();
               B_ROLE.prefix();
               {? B_ROLE.seek(_buf_prel.B_ROLE)
               ||
::                Jeżeli proces jest kopiowany z firmy do firmy to podmieniam role
::                na elementach procesu na rolę w docelowej firmie. Jeżeli w docelowej
::                firmie nie było takiej roli to ją zakładam
                  _buf_prel.B_ROLE:=exec('copy_from_firm','#b_role',_buf_prel.B_ROLE)
               ?};
               B_ROLE.cntx_pop()
            ?}
         ?};

         {? B_PREL.CLASS='B_ACTION'
         ||
            B_ACTION.prefix(B_PREL.B_ELE);
            {? B_ACTION.first()
            || _buf_prel.USER:=B_ACTION.USER;
               _buf_prel.SERVICE:=B_ACTION.SERVICE
            ?}
         ?};

         _b_prel:=exec('add','#b_prel',_buf_prel);
::       B_PORT
         B_PORT.cntx_psh();
         B_PORT.index('UNIK');
         B_PORT.prefix(null(),B_PREL.ref());
         _loop:=B_PORT.first();
         {!
         |? _loop
         |!
            _port:=B_PORT.ref();
            B_PORT.cntx_psh();
            B_PORT.prefix();
            B_PORT.B_PREL:=_b_prel;
            {? B_PORT.add()
            || _Asoc.OLD:=$_port;
               _Asoc.NEW:=$B_PORT.ref();
               _Asoc.add()
            ?};
            B_PORT.cntx_pop();
            _loop:=B_PORT.next()
         !};
         B_PORT.cntx_pop();
         _Asoc.OLD:=$B_PREL.ref();
         _Asoc.NEW:=$_b_prel;
         {? _Asoc.add()
         || _Asoc.OLD:=B_PREL.UID;
            _Asoc.NEW:=_buf_prel.UID;
            _Asoc.add()
         ?};
         _loop:=B_PREL.next()
      !};
      B_PREL.prefix(_proc_des);

::    Aktualizacja rodziców
      _loop:=B_PREL.first();
      {!
      |? _loop
      |!
         {? _Asoc.find_key(B_PREL.UID_PAR,)
         || B_PREL.UID_PAR:=_Asoc.NEW;
            B_PREL.put()
         ?};
         _loop:=B_PREL.next()
      !};
      B_PREL.cntx_pop();

::    B_CONN
      B_CONN.cntx_psh();
      B_CONN.index('PROC');
      B_CONN.prefix(_proc_src);
      _loop:=B_CONN.first();
      {!
      |? _loop
      |!
         _buf_conn.cntx_get(B_CONN.ref(),,1);
         _buf_conn.B_PROC:=_proc_des;
         _buf_conn.FROM:={? _Asoc.find_key($_buf_conn.FROM) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         _buf_conn.TO:={? _Asoc.find_key($_buf_conn.TO) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         _b_conn:=exec('add','#b_conn',_buf_conn);
         _Asoc.OLD:=$B_CONN.ref();
         _Asoc.NEW:=$_b_conn;
         _loop:=_Asoc.add() & B_CONN.next()
      !};
      B_CONN.cntx_pop();

::    B_POCONN
      B_POCONN.cntx_psh();
      B_POCONN.index('PROC');
      B_POCONN.prefix(_proc_src);
      _loop:=B_POCONN.first();
      {!
      |? _loop
      |!
         _buf_poconn.cntx_get(B_POCONN.ref(),,1);
         _buf_poconn.B_PROC:=_proc_des;
         _buf_poconn.B_CONN:={? _Asoc.find_key($_buf_poconn.B_CONN) || exec('FindAndGet','#table',B_CONN,_Asoc.NEW) || null() ?};
         _buf_poconn.PREL_SRC:={? _Asoc.find_key($_buf_poconn.PREL_SRC) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         _buf_poconn.PREL_DST:={? _Asoc.find_key($_buf_poconn.PREL_DST) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         {? exec('FindAndGet','#table',B_PORT,$_buf_poconn.FROM,,"B_PORT.B_PREL",null())
         || _buf_poconn.FROM:={? _Asoc.find_key($_buf_poconn.FROM) || exec('FindAndGet','#table',B_PORT,_Asoc.NEW) || null() ?}
         ?};
         {? exec('FindAndGet','#table',B_PORT,$_buf_poconn.TO,,"B_PORT.B_PREL",null())
         || _buf_poconn.TO:={? _Asoc.find_key($_buf_poconn.TO) || exec('FindAndGet','#table',B_PORT,_Asoc.NEW) || null() ?}
         ?};
         exec('add','#b_poconn',_buf_poconn);
         _loop:=B_POCONN.next()
      !};
      B_POCONN.cntx_pop();

::    B_CHOICE
      B_CHOICE.cntx_psh();
      B_CHOICE.index('B_PROC');
      B_CHOICE.prefix(_proc_src);
      _loop:=B_CHOICE.first();
      {!
      |? _loop
      |!
         _buf_choice.cntx_get(B_CHOICE.ref(),,1);
         _buf_choice.B_PREL:={? _Asoc.find_key($_buf_choice.B_PREL) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         _buf_choice.B_CONN:={? _Asoc.find_key($_buf_choice.B_CONN) || exec('FindAndGet','#table',B_CONN,_Asoc.NEW) || null() ?};
         {? _buf_choice.PREL_SRC<>null()
         || _buf_choice.PREL_SRC:={? _Asoc.find_key($_buf_choice.PREL_SRC) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?}
         ?};
         _buf_choice.PREL_DST:={? _Asoc.find_key($_buf_choice.PREL_DST) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         {? _buf_choice.B_PORT<>null()
         || B_PORT.cntx_psh();
            B_PORT.prefix();
            {? B_PORT.seek(_buf_choice.B_PORT) & B_PORT.B_ELE=null() & B_PORT.B_PREL<>null()
            ||
::             Podmianę B_PORTa robimy tylko dla portów dynamicznych, dla stałych nie trzeba
               _buf_choice.B_PORT:={?  _Asoc.find_key($_buf_choice.B_PORT) || exec('FindAndGet','#table',B_PORT,_Asoc.NEW) || null() ?}
            ?};
            B_PORT.cntx_pop()
         ?};
         exec('add','#b_choice',_buf_choice);
         _loop:=B_CHOICE.next()
      !};
      B_CHOICE.cntx_pop();

::    B_VALPRT
      B_VALPRT.cntx_psh();
      B_VALPRT.index('PROC');
      B_VALPRT.prefix(_proc_src);
      _loop:=B_VALPRT.first();
      {!
      |? _loop
      |!
         _buf_valprt.cntx_get(B_VALPRT.ref(),,1);
         _buf_valprt.B_PREL:={? _Asoc.find_key($_buf_valprt.B_PREL) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         {? B_VALPRT.BI_BLOB<>null()
         || _buf_valprt.BI_BLOB:=exec('copy','#bi_blob',B_VALPRT.BI_BLOB);
            _buf_valprt.FORMULA:=exec('val2fml','#convert',_buf_valprt.BI_BLOB,type_of(null()),'BI_BLOB')
         ?};
         exec('add','#b_valprt',_buf_valprt);
         _loop:=B_VALPRT.next()
      !};
      B_VALPRT.cntx_pop();

::    B_TIMER
      B_TIMER.cntx_psh();
      B_TIMER.index('B_PROC');
      B_TIMER.prefix(_proc_src);
      _loop:=B_TIMER.first();
      {!
      |? _loop
      |!
         _buf_timer.cntx_get(B_TIMER.ref(),,1);
         _buf_timer.B_PREL:={? _Asoc.find_key($_buf_timer.B_PREL) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         exec('add','#b_timer',_buf_timer);
         _loop:=B_TIMER.next()
      !};
      B_TIMER.cntx_pop();

::    B_MSG
      B_MSG.cntx_psh();
      B_MSG.index('B_PROC');
      B_MSG.prefix(_proc_src);
      _loop:=B_MSG.first();
      {!
      |? _loop
      |!
         _buf_msg.cntx_get(B_MSG.ref(),,1);
         _buf_msg.B_PREL:={? _Asoc.find_key($_buf_msg.B_PREL) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         {? B_MSG.BI_BLOBA<>null()
         || _buf_msg.BI_BLOBA:=exec('copy','#bi_blob',B_MSG.BI_BLOBA)
         ?};
         {? B_MSG.BI_BLOBE<>null()
         || _buf_msg.BI_BLOBE:=exec('copy','#bi_blob',B_MSG.BI_BLOBE)
         ?};
         exec('add','#b_msg',_buf_msg);
         _loop:=B_MSG.next()
      !};
      B_MSG.cntx_pop();

::    B_SIGPRT
      B_SIGPRT.cntx_psh();
      B_SIGPRT.index('B_PROC');
      B_SIGPRT.prefix(_proc_src);
      _loop:=B_SIGPRT.first();
      {!
      |? _loop
      |!
         _buf_sigprt.cntx_get(B_SIGPRT.ref(),,1);
         _buf_sigprt.B_PREL:={? _Asoc.find_key($_buf_sigprt.B_PREL) || exec('FindAndGet','#table',B_PREL,_Asoc.NEW) || null() ?};
         {? _buf_sigprt.B_PORT<>null()
         || _buf_sigprt.B_PORT:={?  _Asoc.find_key($_buf_sigprt.B_PORT) || exec('FindAndGet','#table',B_PORT,_Asoc.NEW) || null() ?}
         ?};
         exec('add','#b_sigprt',_buf_sigprt);
         _loop:=B_SIGPRT.next()
      !};
      B_SIGPRT.cntx_pop();

      exec('interval_update','#b_design','B_PROC');

::    usunięcie portów wyjściowych zdarzeń startowych nieoznaczonych
      exec('port4event','#b_actsta',_proc_des,'remove');
::    Utworzenie tras pośrednich portów wyjściowych
      exec('route_create4bproc','#b_proute',1,_proc_des)
   ?}
?};
B_PROC.cntx_pop();
IVAL_DEF.cntx_pop();
B_ACTION.cntx_pop();
{? B_PROC.f_active()
|| B_PROC.f_rfresh()
?};
{? _can_continue>0
|| _result:=_proc_des
?};
_result


\copy_from_firm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [RR.xx]
:: OPIS: Kopiowanie procesów z innej firmy do bieżącej
::   WE: [_a] - FIRMA.ref - firma źródłowa z której procesy kopiować, jeżeli nie podana
::                          to pojawi się okno z wyborem
::       [_b] - INTEGER - 0/[1] - czy wyświetlać okno z selekcją procesów? Jeżeli nie to będą kopiowane
::                              wszystkie procesy
::       [_c] - INTEGER - 0/[1] - czy inicjować nowego KOMMa
::       [_d] - INTEGER - 0/[1] - czy wyświetlać KOMMa
::       [_e] - INTEGER - [0]/1 - czy akceptować procesy
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_firma:=null();
{? var_pres('_a')=type_of(FIRMA.ref())
|| _firma:=_a
?};
_select:=1;
{? var_pres('_b')=type_of(0)
|| _select:=_b
?};
_komm_init:=1;
{? var_pres('_c')=type_of(0)
|| _komm_init:=_c
?};
_komm_select:=1;
{? var_pres('_d')=type_of(0)
|| _komm_select:=_d
?};
_accept:=0;
{? var_pres('_e')=type_of(0)
|| _accept:=_e
?};
B_PROC.cntx_psh();

_can_continue:=1;
{? _firma=null()
||
   FIRMA.cntx_psh();
   FIRMA.index('SYMBOL2');
   FIRMA.prefix('S',);
   FIRMA.win_sel('WYB');
   {? FIRMA.select()>0
   || _firma:=FIRMA.ref();
      {? _firma=REF.FIRMA
      || FUN.emsg('Firma źródłowa z której kopiować procesy, nie może być taka sama jak bieżąca.'@);
         _can_continue:=0
      ?}
   ?};
   FIRMA.cntx_pop()
?};
_env:=exec('env','#b_design');
_env.ctr_bpmn:=~~;
params_set('env',_env);
{? _can_continue>0 & _firma<>null()
|| B_PROC.cntx_psh();
   B_PROC.index('FIRMA');
   B_PROC.prefix(_firma,'T');
:: Wybór procesów do kopiowania
   _selected:=exec('select','#b_proc',_select);
   B_PROC.cntx_pop();

   {? _selected.first()
   || _args:=exec('komm_args','#b_proc');
      {? _komm_init>0
      || KOMM.init(250,,'Kopiowanie procesów z innej firmy'@)
      ?};
      _buf_dest:=exec('buffer','#b_proc');
      {!
      |? B_PROC.prefix();
         {? B_PROC.seek(_selected.REF)
         || _env.KOMM_PROC:=B_PROC.ref();
            _buf_dest.get();
            _buf_dest.FIRMA:=REF.FIRMA;

::          Najważniejsza część - kopiowanie z firmy do firmy
            _copy:=exec('copy','#b_proc',B_PROC.ref(),_buf_dest,2);
            {? _copy<>null()
            || _selected.NEWREF:=$_copy;
               _selected.put()
            ||
               _msg:='Kopiowanie procesu zakończone niepowodzeniem.'@;
               _args.MSG:=_msg;
               _args.SECT:='';
               exec('komm_add','#b_proc',_args);
               _args.KIND:=''
            ?}
         ?};
         _selected.next()
      !};
      {? _accept>0
      ||
::       Akceptacja tych, które były zaakceptowane
         _tab:=tab_tmp(1
               ,'REF','STRING[16]','SQL Ref procesu'
         );
         _ndx_akc:=_selected.ndx_tmp(,,'ACCEPTED',,,'SYMBOL',,,'VER',,);
         _selected.index(_ndx_akc);
         _selected.prefix('T');
         {? _selected.first()
         || {!
            |? {? _selected.NEWREF<>''
               || _tab.blank();
                  _tab.REF:=_selected.NEWREF;
                  _tab.add()
               ?};
               _selected.next()
            !}
         ?};
         {? _tab.size()>0
         ||
            _domain_lic:=exec('domain_lic','#b_domain',0);
            exec('proc_akc_act','#b_design',0,_tab,0,_domain_lic,0,0)
         ?}
      ?};
      {? _komm_select>0
      || KOMM.select()
      ?}
   ?}
?};
B_PROC.cntx_pop();
~~


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [RR.xx]
:: OPIS: Uniwersalny wybór procesów
::       Kontekst pracy - bieżąca dziedzina B_PROC
::   WE: [_a] - INTEGER - czy wyświetlać monit z wyborem, jeżeli nie to zostaną zaznaczone wszystkie procesy
::   WY: tab_tmp z wybranymi rekordami
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};
_tab:=tab_tmp(3
      ,'SELECTED','STRING[1]','Wybrano?'
      ,'SYMBOL','STRING[100]','Symbol'@
      ,'NAME','STRING[100]','Nazwa'@
      ,'VER','STRING[30]','Wersja'@
      ,'FIRMA','STRING[30]','Firma'@
      ,'REF','STRING[16]','SQL Ref procesu'
      ,'NEWREF','STRING[16]','SQL Ref nowego procesu'
      ,'ACCEPTED','STRING[1]','Zaakceptowany?'@
      ,'OPIS','STRING[255]','Symbol, nazwa, wersja'
      ,'FILE','STRING[255]','Plik'
      ,'TARGET','SYS_MEMO'   ,'Cel'@
      ,'DESC'  ,'SYS_MEMO'   ,'Opis'@
      ,'UIDREF','STRING[48]' ,'Identyfikator rekordu'
);
_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'SYMBOL',,,'NAME',,);
_ndx2:=_tab.ndx_tmp(,,'SYMBOL',,,'VER',,);

FIRMA.cntx_psh();
{? B_PROC.first()
|| {!
   |?
      {? B_PROC.GRAPHMLZ<>null()
      ||
         _tab.blank();
         _tab.REF:=$B_PROC.ref();
         _tab.SYMBOL:=B_PROC.SYMBOL;
         _tab.NAME:=B_PROC.NAME;
         _tab.VER:=B_PROC.VER;
         _tab.FIRMA:=B_PROC.FIRMA().SYMBOL;
         _tab.ACCEPTED:=B_PROC.ACCEPTED;
         _memo:=B_PROC.memo_txt(,1,'TARGET');
         _tab.memo_set(_memo,'TARGET');
         _memo:=B_PROC.memo_txt(,1,'DESC');
         _tab.memo_set(_memo,'DESC');
         _tab.OPIS:=exec('B_PROC','#to_string');
         _tab.UIDREF:=B_PROC.uidref();
         {? _dialog=0
         || _tab.SELECTED:='T'
         ?};
         {? _tab.add()>0
         || _tab.memo_put(,'TARGET');
            _tab.memo_put(,'DESC')
         ?}
      ?};
      B_PROC.next()
   !}
?};
_result:=1;
_can_continue:=1;
_tab.index(_ndx2);
{? _dialog>0
|| _result:=exec('select_action','#table',_tab
                                         ,'ACCEPTED[TN],FIRMA,SYMBOL,NAME,VER'
                                         ,30
                                         ,'Wybór procesów do skopiowania'@
                                         ,
                                         ,'&Podgląd procesu=exec(\'select4proc\',\'#b_design\',_a,0,,0)')
?};
{? _result>0
|| _tab.index(_ndx);
   {? _tab.first()
   || {!
      |? _next:=0;
         _ref_nxt:=null();
         _tab.cntx_psh();
         {? _tab.next()
         || _ref_nxt:=_tab.ref()
         ?};
         _tab.cntx_pop();

         {? _tab.SELECTED<>'T'
         || _can_continue:=_tab.del(,1)
         ?};

         {? _ref_nxt<>null()
         || _next:=_tab.seek(_ref_nxt)
         ?};
         _next>0 & _can_continue>0
      !}
   ?}
|| _tab.erase()
?};
FIRMA.cntx_pop();
_tab






:Sign Version 2.0 jowisz:1045 2023/08/23 10:46:47 417e1d2367f3811f5bec837eea220cdd50502719c4d0995d2ac44bb00e9b51beef6f548edc2fa9606457eaf4015ee375c55a480fbe8db8f95d0705e2078c45e691c515449cd98bdc060baefc7082857560d5abb88034b4b7e9fd46118bcd23b0ccecdb82dbc4ac294eff9a5d8b9b92e18a3c7b520fe1466b49ea8d3b26724910
