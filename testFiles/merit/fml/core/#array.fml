:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #array.fml [17.00]
:: Utworzony: 17.12.2014
:: Autor: AK
::======================================================================================================================
:: Zawartość: Uniwersalne formuły do obsługi tablic
::======================================================================================================================


\dekl_sarray
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Deklaracja klasy SARRAY - samosortującej się tablicy.
::  OLD: \define/sarray.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('SARRAY',@.CLASS)>=100
|| return()
?};

obj_decl('SARRAY',

   obj_fld('Array',~~),

   obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Tworzy obiekt implementujący samosortującą tablicę.
::   WE: _a - formuła porównująca zawartości komórek
::       _b - formuła zamieniająca zawartość komórek
::----------------------------------------------------------------------------------------------------------------------
      set_virt(_a,'Compare',{? var_pres('_b')=3 || _b || $'0' ?});
      set_virt(_a,'Change',{? var_pres('_c')=3 || _c || $'0' ?});
      _a.Array:=~~
   "),

   obj_virt('Compare',""),

   obj_virt('Change',""),

   obj_meth('Add',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Umieszcza informację w tablicy.
::----------------------------------------------------------------------------------------------------------------------
      {? ~type_of(.Array)
      || .Array:=obj_new(1);
         .Array[1]:=_a
      || {? var_pres('_a')=.#1
         || _TArray:=obj_new(.Size()+1);
            {! _i:=1...Size()
            |! _TArray[_i]:=.Array[_i]
            !};
            _TArray[.Size()+1]:=_a;
            obj_del(.Array);
            .Array:=_TArray;
            {! _i:=.Size() // (-1)..2
            |? _cmp:=.Compare(.Array[_i],.Array[_i-1])
            |! {? _cmp<=(-1)
               || {? type_of(.Array[_i])>100
                  || .Change(.Array[_i],.Array[_i-1])
                  || .Array[_i]==.Array[_i-1]
                  ?}
               ?}
            !}
         ?}
      ?}
   "),

   obj_meth('<=',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Operator wstawienia informacji do tablicy.
::----------------------------------------------------------------------------------------------------------------------
      _a.Add(_b)
   "),

   obj_meth('Size',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Zwraca rozmiar tablicy
::   WY: rozmiar tablicy
::----------------------------------------------------------------------------------------------------------------------
      {? type_of(.Array)>=100
      || obj_len(.Array)
      ?}
   "),

   obj_meth('Last',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Zwraca ostatni element tablicy
::   WY: informacja zapisana w ostatniej komórce
::----------------------------------------------------------------------------------------------------------------------
      .Array[.Size()]
   ",-1),

   obj_meth('First',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Zwraca pierszy element tablicy
::   WY: informacja zapisana w pierwszej komórce
::----------------------------------------------------------------------------------------------------------------------
      .Array[1]
   ",-1),

   obj_meth('Find',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Ustala, czy tablica zawiera podany element.
::   WE: _a - informacja do wyszukania
::   WY: indeks komórki zawierającej określoną informację lub 0 jeśli informacja nie została znaleziona
::----------------------------------------------------------------------------------------------------------------------
      {? .Compare(_a,.First())<=(-1) || 0
      |? .Compare(_a,.Last())>=1 || 0
      || .__Search(1,.Size(),_a)
      ?}
   "),

   obj_meth('__Search',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Przeszukuje rekurencyjnie zawartość tablicy w zadanym zakresie.
::   WE: _a - indeks początku zakresu przeszukiwania
::       _b - indeks końca zakresu przeszukiwania
::       _c - informacja do wyszukania
::   WY: indeks komórki zawierającej określoną informację lub 0 jeśli informacja nie została znaleziona
::----------------------------------------------------------------------------------------------------------------------
      {? (_b-_a)<=1
      || {? ~.Compare(.Array[_a],_c) || _a
         |? ~.Compare(.Array[_b],_c) || _b
         || 0
         ?}
      || _cmp:=.Compare(.Array[_div:=_a+((_b-_a)%2)],_c);
         {? _cmp<=(-1) || .__Search(_div,_b,_c)
         |? _cmp>=1 || .__Search(_a,_div,_c)
         || _div
         ?}
      ?}
   ",type_of(0),type_of(0)),

   obj_meth('Clear',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Zwalnia pamięć przydzieloną na wewnętrzną tablicę.
::----------------------------------------------------------------------------------------------------------------------
      {? type_of(.Array)>=100
      || obj_del(.Array);
         .Array:=~~
      ?}
   ",-1),

   obj_meth('#',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Zwraca typ elementu zapisanego w podanej komórce.
::   WE: _a - wskazanie obiektu
::       _b - numer komórki
::   WY: numer typu elementu
::----------------------------------------------------------------------------------------------------------------------
      var_pres('['+$_b+']',_a.Array)
   ",THIS,type_of(0))
)


\array_sum
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Oblicza sumę elementów tablicy
::   WE: _a - obj_new(1)
::   WY: REAL - suma
::  OLD: \array_sum/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? var_pres('_a')=type_of(obj_new(1))
|| _array:=_a;
   _size:=obj_len(_array);
   {! _it:=1.._size
   |! _value:=_array[_it];
      {? type_of(_value)=type_of(0)
      || _result+=_value
      ?}
   !}
?};
_result


\arrays_div
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca tablicę w której znajdują sie ilorazy (proporcje) elementów dwóch tablic
::   WE: _a - obj_new(x)
::       _b - obj_new(x)
::   WY: obj_new(x) - tablica zawierająca proporcje elementów w ujęciu _a[1]/_b[1]
::  OLD: \arrays_div/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new(1);
_result[1]:=0;

{? var_pres('_a')=type_of(obj_new(1)) & var_pres('_b')=type_of(obj_new(1))
||
   _tab1:=_a;
   _tab2:=_b;

   _size:=obj_len(_tab1);

   obj_del(_result);
   _result:=obj_new(_size);

   {! _it:=1.._size
   |! _val1:=_tab1[_it];
      _val2:=_tab2[_it];
      {? _val2<>0
      || _result[_it]:=_val1/_val2
      || _result[_it]:=0
      ?}
   !}
?};
_result


\array_divide
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dzieli każdy element tablicy przez przekazany argument
::   WE: _a - obj_new(x)
::       _b - REAL - przez co podzielić
::  OLD: \array_divide/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_value:=_b;
_result:=obj_new(1);

{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);

   {! _it:=1.._size
   |! _val1:=_tab[_it];
      _tab[_it]:=_val1/_value
   !}
?};
~~


\arrays_multiply
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca tablicę w której znajdują się iloczyny elementów dwóch tablic
::   WE: _a - obj_new(x)
::       _b - obj_new(x)
::   WY: obj_new(x) - tablica zawierajaca iloczyny elementów w ujęciu _a[1]*_b[1]
::  OLD: \arrays_multiply/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new(1);
_result[1]:=0;

{? var_pres('_a')=type_of(obj_new(1)) & var_pres('_b')=type_of(obj_new(1))
||
   _tab1:=_a;
   _tab2:=_b;

   _size:=obj_len(_tab1);

   obj_del(_result);
   _result:=obj_new(_size);

   {! _it:=1.._size
   |! _val1:=_tab1[_it];
      _val2:=_tab2[_it];
      {? _val2<>0
      || _result[_it]:=_val1*_val2
      || _result[_it]:=0
      ?}
   !}
?};
_result


\array_multiply
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Mnoży każdy element tablicy przez przekazany argument
::   WE: _a - obj_new(x)
::       _b - REAL - przez co pomnożyć
::  OLD: \array_multiply/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_value:=_b;
_result:=obj_new(1);

{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);

   {! _it:=1.._size
   |! _val1:=_tab[_it];
      _tab[_it]:=_val1*_value
   !}
?};
~~


\arrays_subtract
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca tablicę w której znajdują sie różnice elementów dwóch tablic
::   WE: _a - obj_new(x)
::       _b - obj_new(x)
::   WY: obj_new(x) - tablica zawierająca różnice elementów w ujęciu _a[1]-_b[1]
::  OLD: \arrays_subtract/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new(1);
_result[1]:=0;

{? var_pres('_a')=type_of(obj_new(1)) & var_pres('_b')=type_of(obj_new(1))
||
   _tab1:=_a;
   _tab2:=_b;

   _size:=obj_len(_tab1);

   obj_del(_result);
   _result:=obj_new(_size);

   {! _it:=1.._size
   |! _val1:=_tab1[_it];
      _val2:=_tab2[_it];
      _result[_it]:=_val1-_val2
   !}
?};
_result


\arrays_sub_mod
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Modyfikuje tablicę przekazaną w _a odejmując każdemu jej elementowi analogiczny element z _b
::   WE: _a - obj_new(x)
::       _b - obj_new(x)
::  OLD: \arrays_sub_mod/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(obj_new(1)) & var_pres('_b')=type_of(obj_new(1))
||
   _tab1:=_a;
   _tab2:=_b;

   _size:=obj_len(_tab1);

   {! _it:=1.._size
   |! _val1:=_tab1[_it];
      _val2:=_tab2[_it];
      _tab1[_it]:=_val1-_val2
   !}
?};
~~


\arrays_add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca tablicę w której znajdują sie sumy elementów dwóch tablic
::   WE: _a - obj_new(x)
::       _b - obj_new(x)
::   WY: obj_new(x) - tablica zawierająca sumy elementów w ujęciu _a[1]+_b[1]
::  OLD: \arrays_add/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new(1);
_result[1]:=0;

{? var_pres('_a')=type_of(obj_new(1)) & var_pres('_b')=type_of(obj_new(1))
||
   _tab1:=_a;
   _tab2:=_b;

   _size:=obj_len(_tab1);

   obj_del(_result);
   _result:=obj_new(_size);

   {! _it:=1.._size
   |! _val1:=_tab1[_it];
      _val2:=_tab2[_it];
      _result[_it]:=_val1+_val2
   !}
?};
_result


\arrays_add_mod
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Modyfikuje tablice przekazaną w _a dodając każdemu jej elementowi analogiczny element z _b
::   WE: _a - obj_new(x)
::       _b - obj_new(x)
::  OLD: \arrays_add_mod/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(obj_new(1)) & var_pres('_b')=type_of(obj_new(1))
||
   _tab1:=_a;
   _tab2:=_b;

   _size:=obj_len(_tab1);

   {! _it:=1.._size
   |! _val1:=_tab1[_it];
      _val2:=_tab2[_it];
      _tab1[_it]:=_val1+_val2
   !}
?};
~~


\array_has_minus
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w przekazanej tablicy znajduje się jakiś element o wartości poniżej zera
::   WE: _a - obj_new(x)
::   WY: 0 - tablica nie zawiera elementów ujemnych
::       1 - przynajmniej jeden element jest ujemny
::  OLD: \array_has_minus/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);

   _can_continue:=1;
   {! _it:=1.._size
   |? _can_continue>0
   |! {? _tab[_it]<0
      || _can_continue:=0;
         _result:=1
      ?}
   !}
?};
_result


\array_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Kopiuje tablice
::   WE: _a - obj_new(x)
::   WY: obj_new(x) - kopia tablicy przekazanej w argumencie
::  OLD: \array_copy/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new(1);
_result[1]:=0;

{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);

   obj_del(_result);
   _result:=obj_new(_size);

   {! _it:=1.._size
   |! _result[_it]:=_tab[_it]
   !}
?};
_result


\array_max
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca największy element tablicy
::   WE: _a - obj_new(x)
::   WY: REAL - największy element tablicy
::  OLD: \array_max/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);
   _result:=_tab[1];
   {! _it:=1.._size
   |! {? _tab[_it]>_result
      || _result:=_tab[_it]
      ?}
   !}
?};
_result


\array_min
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca najmniejszy element tablicy (lub najmniejszy nie zerowy element tablicy)
::   WE: _a - obj_new(x)
::   WY: REAL - największy element tablicy
::  OLD: \array_min/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);
   _result:=_tab[1];
   {! _it:=1.._size
   |! {? _tab[_it]<_result
      || _result:=_tab[_it]
      ?}
   !}
?};
_result


\array_min2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca najmniejszy element tablicy, ale większy niż podane minimum
::   WE: _a - obj_new(x)
::       _b - REAL: znaleziony element ma być większy niż ta wartość
::   WY: REAL - najmniejszy element tablicy lub 0 jeśli nie ma żadnego większego niz podane minimum
::  OLD: \array_min2/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_min:=_b;

{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);
   _flaga:=0;
   {! _it:=1.._size
   |! _val:=_tab[_it];

      {? _flaga=0
      || {? _val>_min
         || _result:=_val;
            _flaga:=1
         ?}
      || {? _val>_min & _val<_result
         || _result:=_val
         ?}
      ?}
   !}
?};
_result


\array_round_mod
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zaokrągla elementy tablicy do podanej dokładności
::   WE: _a - obj_new(x) - tablica której elementy zaokrąglać
::       _b - obj_new(x) - tablica do ilu miejsc po przecinku zaokrąglać
::  OLD: \array_round_mod/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(obj_new(1)) & var_pres('_b')=type_of(obj_new(1))
||
   _tab1:=_a;
   _tab2:=_b;

   _size:=obj_len(_tab1);

   {! _it:=1.._size
   |! _val1:=_tab1[_it];
      _val2:=_tab2[_it];
      _tab1[_it]:=_val1$_val2
   !}
?};
~~


\array_del_minus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zeruje wszystkie ujemne elementy tablicy
::   WE: _a - obj_new(x)
::  OLD: \array_del_minus/px_logix.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);

   {! _it:=1.._size
   |! {? _tab[_it]<0
      || _tab[_it]:=0
      ?}
   !}
?};
~~


\array_blank
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Czyści zawartość tablicy/obiektu _arr wartością _val
::   WE: DICT _arr - czyszczona tablica
::       ANY  _val - wartość blankowana
::       NUMBER [_start] - pozycja początkowa (domyślnie 1)
::       NUMBER [_length] - liczba elementów do przekopiowania (domyślnie większa liczba elementów)
::   WY: 1/0
::  OLD: \array_blank/libfml.fml
::UWAGA: brak kontroli typow
::----------------------------------------------------------------------------------------------------------------------
_arr:=_a;
_val:=_b;
_start:={? _>2 & type_of(_c)=2 || _c || 1 ?};
_length:={? _>3 & type_of(_d)=1 || _d || obj_len(_arr) ?};
_stop:=_start+_length-1;
{? _stop<_start || return(0) ?};
{! _pos:=_start.._stop |! _arr[_pos]:=_val !}


\obj_ntab_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Funkcja zwraca kopię tablicy z nazwanymi elementami przekazanej przez pierwszy argument z dodanymi na końcu
::       elementami o nazwach przekazanych przez kolejne argumenty. Nowym argumentom zostaną nadane przekazane wartości.
::   WE: [_a] [ARRAY]  - Tablica z elementami nazwanymi.
::        _b  [STRING] - Nazwa dodawanego elementu 1.
::       [_c] [ANY]    - Wartość dodawanego elementu 1.
::       [_d] [STRING] - Nazwa dodawanego elementu 2.
::       [_e] [ANY]    - Wartość dodawanego elementu 2.
::       [_f] [STRING] - Nazwa dodawanego elementu 3.
::       [_g] [ANY]    - Wartość dodawanego elementu 3.
::   WY: Tablica z nowymi elementami o wskazanych wartościach.
::----------------------------------------------------------------------------------------------------------------------
_array:={? _>0 || _a || ~~ ?};

_ts:=type_of('');
{! _lp:=2 //2 .. _
|! _name:=_[_lp];
   {? type_of(_[_lp])=_ts
   || _new:=
         {? ~obj_ntab(_array)
::          Jeżeli _array nie jest tablicą nazwaną, totworzymy nową tablicę z jednym (pierwszym) elementem określonym
::          przez parametr. Taka sytuacja może mieć miejsce tylko przy pierwszym obrocie pętli.
::          Warto zwrócić uwagę, że np. params_get() może zwrócić ~~, a więc nie tablicę nazwaną.
         || obj_new(_name)

         |? var_pres(_name,_array)<0
::          Już wiemy, że _array jest tablicą nazwaną. Jeżeli nie zawiera elementu o nazwie _name, to dodajemy go.
         || obj_ntab_add(_array,_name)

::          _array jest tablicą nazwaną i zawiera element o nazwie _name. Nie musimy więc tworzyć nowego elementu.
         || {? var_pres(_name,_array)>100
::             Jeżeli jednak była to tablica - usuwamy ją.
            || ($('obj_del(_a.%1)' [_name]))(_array)
::             W przeciwnym przypadku (nie tablica) nadajemy wartość ~~.
            || ($('_a.%1:=~~' [_name]))(_array)
            ?};
            _array
         ?};
      {? _lp+1<=_
::       Jeżeli do funkcji przekazany został parametr z wartością (następny po nazwie), to nadajemy ją.
      || ($('_a.%1:=_b' [_name]))(_new,_[_lp+1])
      ?};
::    Zamiana tablic.
      {? type_of(_array)>100
::       _array może nie być tablicą wyłącznie w pierwszym przebiegu pętli.
      || obj_del(_array)
      ?};
      _array:=_new;
      obj_del(_new)
   ?}
!};
_array


\array_index_of
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PS] [17.14]
:: OPIS: Zwraca indeks pierwszego wystąpienia elementu w tablicy.
::       Pierwszy element tablicy _a posiada indeks równy 1, ostatni - równy obj_len(_a).
::   WE: _a - DICT - tablica
::       _b - ANY - element
::   WY: indeks elementu, lub -1 jeżeli elementu nie znaleziono, lub -2 jeżeli przekazano błędne argumenty
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<0 | var_pres('_b')<0 | type_of(_a)<100 || return(-2) ?};
{! _it:=1..obj_len(_a)
|! {? var_pres('[%1]'[$_it],_a)>0 & type_of(_a[_it])=type_of(_b) & _a[_it]=_b
   || return(_it)
   ?}
!};
return(-1)


\create_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.42]
:: OPIS: Tworzy zbiór danych wskazanego typu
::   WE: _a - typ elementu (typ pola tabeli tymczasowej)
::----------------------------------------------------------------------------------------------------------------------
_tab:=obj_new('TAB','addIfNotExists','clear','contains');
_tab.TAB:=($('tab_tmp(1,\'E\',\''+_a+'\',)'))();
_tab.addIfNotExists:="
   {? ~.contains(_a)
   || .TAB.E:=_a;
      .TAB.add()
   ?}
";
_tab.clear:="
  .TAB.erase()
";
_tab.contains:="
   type_of(.TAB.E)=type_of('') & .TAB.find_key(_a,) |
   type_of(.TAB.E)<>type_of('') & .TAB.find_key(_a)
";
_tab


\create_hash
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.42]
:: OPIS: Tworzy tablice typu klucz wartość wskazanych typów
::   WE: _a - typ klucza elementu (typ pola tabeli tymczasowej)
::       _b - typ wartości elementu (typ pola tabeli tymczasowej)
::----------------------------------------------------------------------------------------------------------------------
_tab:=obj_new('TAB','put','get');
_tab.TAB:=($('tab_tmp(1,\'K\',\''+_a+'\',,\'V\',\''+_b+'\',)'))();
_tab.put:="
   {? type_of(.TAB.K)=type_of('') & ~.TAB.find_key(_a,) |
      type_of(.TAB.K)<>type_of('') & ~.TAB.find_key(_a)
   || .TAB.K:=_a;
      .TAB.V:=_b;
      .TAB.add()
   || .TAB.V:=_b;
      .TAB.put()
   ?}
";
_tab.get:="
   {? type_of(.TAB.K)=type_of('') & .TAB.find_key(_a,) |
      type_of(.TAB.K)<>type_of('') & .TAB.find_key(_a)
   || .TAB.V
   || ~~
   ?}
";
_tab


\array2fml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51]
:: OPIS: Procedura zamienia tablicę elementów nazwanych na napis, który zinterpretowany jako formuła zwróci tę samą
::       tablicę. Zakłada się, że elementy są typu prostego (liczba, napis, formuła, data czas).
::       Uwagi:
::          * Jeżeli tablica zawiera elementy innych typów, to ich warrtości NIE zostaną "przeniesione".
::          * Procedura zachowuje typy elementów - po wykonaniu napisu wynikowego, elementy powstałej tablicy mają
::            typy identyczne z typami elementów tablicy _a.
::   WE: _a [ARRAY] - Tablica elementów nazwanych.
::   WY: Napis, który po konwersji na typ formułowy zwróci tablicę _a lub '!!!' w przypadku błędu wywołania.
::  OLD: \array2fml/util.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<1 | ~obj_ntab(_a)
|| return('!!!')
?};

_new:='';
_val:='';
_tn:=obj_ntab_names(_a);
{! _lp:=1 .. obj_len(_tn)
|! _acr:=_tn[_lp];
   _vp:=var_pres(_acr,_a);
   _vs:=_a[_lp];
   _new+=',\''+_acr+'\'';
   _val+='_ret.'+_acr+':='+
      {? _vp=1
      || form(_vs,,,'9.')
      |? _vp=2
      || '\''+gsub(_vs,'\'','\\\'')+'\''
      |? _vp=3
      || '"'+gsub($_vs,'"','""')+'"'
      |? _vp=4
      || 'date('+$(_vs~1)+','+$(_vs~2)+','+$(_vs~3)+')'
      |? _vp=5
      || 'time('+$(_vs~1)+','+$(_vs~2)+','+$(_vs~3)+')'
      || '~~'
      ?}+'; '
!};
'_ret:=obj_new('+(1-_new)+'); '+_val+' _ret'


\array_cmptype
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Formuła porównuje strukturę przekazanych tablic i typy ich elementów.
::   WE: _a [ARRAY] - Tablica 1.
::       _b [ARRAY] - Tablica 2.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _<2
|| return(0)
?};
_tARRAY:=type_of(obj_new(1));
{? type_of(_a)<>_tARRAY | type_of(_b)<>_tARRAY
|| return(0)
?};
_nta:=obj_ntab(_a);
_ntb:=obj_ntab(_b);
{? _nta<>_ntb
|| return(0)
?};
_lena:=obj_len(_a);
_lenb:=obj_len(_b);
{? _lena<>_lenb
|| return(0)
?};
{? _nta
|| _namesa:=obj_ntab_names(_a);
   _namesb:=obj_ntab_names(_b)
?};
{! _lp:=1 .. _lena
|! {? _nta & _namesa[_lp]<>_namesb[_lp]
   || return(0)
   ?};
   _ta:=type_of(_a[_lp]);
   _tb:=type_of(_b[_lp]);
   {? _ta<>_tb
   || return(0)
   ?};
   {? _ta=_tARRAY & ~exec('array_cmptype','#array',_a[_lp],_b[_lp])
   || return(0)
   ?}
!};

1


\array_round
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Zaokrągla każdy element tablicy przez przekazany argument
::   WE: _a - obj_new(x)
::       _b - REAL - przez co zaokrąglić
::----------------------------------------------------------------------------------------------------------------------
_value:=_b;
_result:=obj_new(1);

{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);

   {! _it:=1.._size
   |! _val1:=_tab[_it];
      _tab[_it]:=_val1$_value
   !}
?};
~~


\array_force_numbers
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Wymusza w tablicy elementy typu NUMBER, elementy innych typów niż numeryczny zamienia na 0
::   WE: _a - obj_new(x)
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new(1);

{? var_pres('_a')=type_of(obj_new(1))
||
   _tab:=_a;
   _size:=obj_len(_tab);

   {! _it:=1.._size
   |! _val1:=_tab[_it];
      _tab[_it]:={? type_of(_val1)=type_of(0) || _val1 || 0 ?}
   !}
?};
~~


\obj_has_field
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy tablica nazwana ma pole o przekazanej nazwie
::   WE: _a - obj_new - tablica nazwana
::       _b - STRING - nazwa pola
::   WY: 0 - pola nie ma w tablicy albo nie jest to tablica nazwana
::       1 - pole o przekazanej nazwie jest w tablicy nazwanej
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_field:=_b;

_result:=0;
{? obj_ntab(_obj)>0 & var_pres(_field,_obj)>=0
|| _result:=1
?};
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 03a4ba0826e573ea7f186e01780002d2070c3e98db90adbb67d43c487a202ac91985c96e325dc8d526bcbb2addbd065834d51ffb6fde955c534f4620dd3cf1f8c04c32b46ca473d697d7272b6fb5786ad3a8291bedeba34ef0a7d16bb5e7bb4fade2f94858b585cfa5f3698fd30f6f320fb7747421d06849339a949047ee8f38
