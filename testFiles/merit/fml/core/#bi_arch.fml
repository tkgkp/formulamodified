:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #bi_arch.fml []
:: Utworzony: 27.10.2014 []
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły do obsługi archiwum procesowości
::======================================================================================================================


\params
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca stałe wartości parametrów potrzebne do mechanizmu archiwizacji:
::       - Rozmiary buforow maskowalnych tabel, po to by użyć ich w obliczeniach ile
::         rekordów można jeszcze w pliku maski zmieścić
::       - Akronimy tabel archiwizowanych
::       - Początki nazw masek tabel archiwizowanych
::       - Maksymalny rozmiar pliku *.mdb
::       - Procent wolnego miejsca jaki powinien zostać w masce (po to żeby po dodaniu
::          pola w przyszlej wersji rozmiar pliki mdb sie nie przekroczył i udał się transfer)
::
::       Aby dodać nową tabele do mechanizmu archiwizacji należy wypelnić jej tutaj
::       parametry oraz dopisać do formuły exec('get_arch_tables','#bi_arch')
::   WY: obj_new
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('BI_ARCH_PAR')<100
||
   BI_ARCH_PAR:=obj_new(

::    Rozmiary buforów tabel maskowalnych w bajtach
      'buffers'

::    Akronimy tabel maskowalnych
      ,'tables'

::    Poczatki nazw masek
      ,'msk_prefix'

::    Maksymalny rozmiar maski w bajtach
      ,'FILESIZE'

::    Maksymalna liczba rekordów w masce
      ,'REC_MAX'

::    Procent wolnego miejsca jaki powinien zostać jeszcze w masce
      ,'FREE_PROC'
   );

   _ff:=exec('get_arch_tables','#bi_arch');
:: Tworze tablice nazwane o polach nazywajacych się tak jak wszystkie nazwane tablice
   BI_ARCH_PAR.buffers:=_ff();
   BI_ARCH_PAR.tables:=_ff();
   BI_ARCH_PAR.msk_prefix:=_ff();

:: Przypisuje aliasy tabel
   BI_ARCH_PAR.tables.BI_PROC:=BI_PROC;
   BI_ARCH_PAR.tables.BI_PREL:=BI_PREL;
   BI_ARCH_PAR.tables.BI_PORT:=BI_PORT;
   BI_ARCH_PAR.tables.BI_CONN:=BI_CONN;
   BI_ARCH_PAR.tables.BI_TODO:=BI_TODO;
   BI_ARCH_PAR.tables.BI_MSG:=BI_MSG;
   BI_ARCH_PAR.tables.BI_BLOB:=BI_BLOB;
   BI_ARCH_PAR.tables.BI_BLOP:=BI_BLOP;

:: Przypisuje początki nazw masek
   BI_ARCH_PAR.msk_prefix.BI_PROC:='bi_p';
   BI_ARCH_PAR.msk_prefix.BI_PREL:='bi_e';
   BI_ARCH_PAR.msk_prefix.BI_PORT:='bi_o';
   BI_ARCH_PAR.msk_prefix.BI_CONN:='bi_c';
   BI_ARCH_PAR.msk_prefix.BI_TODO:='bi_t';
   BI_ARCH_PAR.msk_prefix.BI_MSG:='bi_m';
   BI_ARCH_PAR.msk_prefix.BI_BLOB:='bi_b';
   BI_ARCH_PAR.msk_prefix.BI_BLOP:='bi_l';

:: Dla każdej tableli obliczam rozmiar bufora
   {! _it:=1..obj_len(BI_ARCH_PAR.tables)
   |! BI_ARCH_PAR.buffers[_it]:=exec('tab_buffer_size','#table',BI_ARCH_PAR.tables[_it])
   !};

::----------------GB--MB---KB---B--
   BI_ARCH_PAR.FILESIZE:=28*1024*1024*1024;

:: póki co 30 mln
   BI_ARCH_PAR.REC_MAX:=30000000;

:: Dopełniamy maski do 60% - 40% zostaje wolnego na poczet przyszłych transferów i rozrostu tabel
   BI_ARCH_PAR.FREE_PROC:=40
?};
BI_ARCH_PAR


\open
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Otwiera maski archiwizowanych tabel
::   WE: [_a] - STRING - maska która otworzyć, jeśli nie podane to otwierana jest maska '____'
::       [_b] - czy sprawdzać istnienie obiektu parametrów i go ewentualnie inicjować (domyślnie 1 - tak)
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _msk:=_a || _msk:='____' ?};
{? var_pres('_b')=type_of(0) || _spr_par:=_b || _spr_par:=1 ?};

_params:={? _spr_par || exec('params','#bi_arch') || BI_ARCH_PAR ?};
{! _it:=1..obj_len(_params.tables)
|! _params.tables[_it].use(_params.msk_prefix[_it]+_msk)
!};
~~


\cntx_psh
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Odkłada kontekst w archiwizowanych tabelach
::   WE: [_a] - czy sprawdzać istnienie obiektu parametrów i go ewentualnie inicjować (domyślnie 1 - tak)
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _spr_par:=_a || _spr_par:=1 ?};

_params:={? _spr_par || exec('params','#bi_arch') || BI_ARCH_PAR ?};
{! _it:=1..obj_len(_params.tables)
|! _params.tables[_it].cntx_psh()
!};
~~


\cntx_pop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Przywraca kontekst w archiwizowanych tabelach
::   WE: _a - czy sprawdzać istnienie obiektu parametrów i go ewentualnie inicjować (domyślnie 1 - tak)
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _spr_par:=_a || _spr_par:=1 ?};

_params:={? _spr_par || exec('params','#bi_arch') || BI_ARCH_PAR ?};
{! _it:=1..obj_len(_params.tables)
|! _params.tables[_it].cntx_pop()
!};
~~


\buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Zwraca obiekt nazwany - bufor tabeli BI_ARCH
::   WY: obj_new()
::----------------------------------------------------------------------------------------------------------------------
exec('BI_ARCH','#buffer')


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Funkcja dodająca wpis do tabeli BI_ARCH
::   WE: _a - obj_new - tablica nazwana bedaca buforem tabeli exec('buffer','#bi_arch')
::   WY:      [REFERENCE]  - wskazanie na dodany rekord (lub już istniejący)
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100 || _a || return(null) ?};

_res:=0;
BI_ARCH.cntx_psh();
BI_ARCH.prefix();
_buffer.set();
{? BI_ARCH.add()
|| _buffer.get();
   _res:=1
?};
BI_ARCH.cntx_pop();
_res


\declGenMask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: Deklaracja klasy generujące maski i powołanie obiektu
::----------------------------------------------------------------------------------------------------------------------

{? var_pres('GENMASK',@.CLASS)<=0
||
   obj_decl('GENMASK',
:: --POLA---------------------------------------------------------------------------------------------------------------
    obj_fld('VOL' ,'liczba znakow maski';                  0),
    obj_fld('CHR' ,'ciag znakow wykorzystywanych w masce'; ''),
    obj_fld('LEN' ,'wielkość bufora znakow';               0),
    obj_fld('MAX' ,'maksymalna liczba do konwersji';       0),
:: --KONSTRUKTOR/DESTRUKTOR---------------------------------------------------------------------------------------------
   obj_meth('__init','inicjalizacja obiektu';
            "{? _>=2 & type_of(_b)=type_of(0) & _b>0 || _err:=0 || _err:=1 ?};
             {? ~_err & _>=3 & type_of(_c)=type_of('') & (+_c)>0 || _err:=0 || _err:=1 ?};
             {? ~_err
             || .init(_b,_c)
             || FUN.info('Podano nieprawidłowe parametry dla obiektu generującego maski.'@);
                0
             ?}"),

:: --METODY-------------------------------------------------------------------------------------------------------------
   obj_meth('init','zainicjowanie pol';
            ".VOL:=_a;
             .CHR:=_b;
             .LEN:=+_b;
             .MAX:=1; {! _i:=1...VOL |! .MAX*=.LEN !};
             1"),
   obj_meth('newVolChr','zmienia liczbe znakow maski i znaki wykorzystywane w masce';
            "{? _>=1 & type_of(_a)=type_of(0) & _a>0 || .VOL:=_a ?};
             {? _>=2 & type_of(_b)=type_of('') & (+_b)>0 || .CHR:=_b ?};
             .LEN:=+_b;
             .MAX:=1; {! _i:=1...VOL |! .MAX*=.LEN !};
             1"),
   obj_meth('maskNum','konwersja podanej maski na liczbe';
            "_res:=0;
             {? _a<>''
             || _wsp:=1;
                _ln:=+_a;
                {! _i:=1.._ln
                |! _ch:=(_a-(_i-1))+1;
                   _nr:=.CHR*_ch;
                   {? _i>1 || _wsp*=.LEN ?};
                   _res+=(_nr-1)*_wsp
                !}
             ?};
             _res"),
   obj_meth('numMask','konwersja podanej liczby na maske';
            "_res:='';
             {? _a>=0 & _a<=.MAX
             || _akt:=_a;
                {!
                |? _frac:=(_akt%*.LEN)+1;
                   _akt:=_akt%.LEN;
                   _res:=(1+((_frac-1)-.CHR))+_res;
                   _akt>0
                !};
                {? +_res<.VOL || _dod:=''; {! _i:=1...VOL |! _dod+=(1+.CHR) !}; _res:=(_dod+_res)+.VOL ?}
             |? _a=0
             || {! _i:=1...LEN |! _res+=(1+.CHR) !}
             ?};
             _res")

   )
?};
~~


\newBiArch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: Nadaje nową maske tabeli BI_ARCH i dodaje nowe archiwum
::   WE: _a - ref firmy
::   WY: ref BI_ARCH lub null()
::----------------------------------------------------------------------------------------------------------------------

_res:=null();

_firma:={? var_pres('_a')=type_of(null()) || _a || null() ?};

:: ciag znakowy - znaki dostępne w masce (kolejność ich jest isotna)
_chars:=''; {! _i:=48..57 |! _chars+=%_i !}; {! _i:=97..122 |! _chars+=%_i !};

:: powołanie obiektu generującego maski
exec('declGenMask','#bi_arch');
_mask:=obj_new(@.CLASS.GENMASK,4,_chars);

BI_ARCH.cntx_psh();
BI_ARCH.index('MASKFIRM');
BI_ARCH.prefix();
{? BI_ARCH.last()
|| _num:=_mask.maskNum(BI_ARCH.MASK)+1
|| _num:=1
?};
BI_ARCH.cntx_pop();

_buffer:=exec('buffer','#bi_arch');
_buffer.blank();
_buffer.ACTIVE:='T';
_buffer.MASK:=_mask.numMask(_num);
_buffer.B_PROC:=null();
_buffer.TREE:=0;
_buffer.FIRMA:=_firma;
_buffer.TM_ADD:=BI_ARCH.tm_stamp();
_buffer.ADD_DATE:=date();
_buffer.ADD_TIME:=time();
_buffer.DESC:='ARCHIWUM: <'+_buffer.MASK+'>';
exec('add','#bi_arch',_buffer);
_res:=_buffer.Ref;

obj_del(_mask);
obj_del(_buffer);
_res


\newBiArchProc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: nadaje nowa maske tabeli BI_ARCH
::   WE: _a - maska BI_ARCH
::       _b - wskazanie na proces
::   WY: ref BI_ARCH lub null()
::----------------------------------------------------------------------------------------------------------------------

_res:=null();

  _mask:={? var_pres('_a')=type_of('') || _a || '' ?};
_b_proc:={? var_pres('_b')=type_of(null()) || _b || null() ?};
 _firma:={? _b_proc<>null() || exec('FindAndGet','#table',B_PROC,$_b_proc,,"B_PROC.FIRMA") || null() ?};

{? _mask<>'' & _b_proc<>null()
|| BI_ARCH.cntx_psh();
   BI_ARCH.index('MASK');
   BI_ARCH.prefix(_firma,_mask,null());
   {? ~BI_ARCH.first()
   || _tree:=exec('newBiArch','#bi_arch',_firma)
   || _tree:=BI_ARCH.ref()
   ?};
   BI_ARCH.prefix(_firma,_mask,_b_proc);
   {? BI_ARCH.first() || _res:=BI_ARCH.ref() ?};
   BI_ARCH.cntx_pop();
   {? _res=null() & _tree<>null()
   || _buffer:=exec('buffer','#bi_arch');
      _buffer.blank();
      _buffer.ACTIVE:='T';
      _buffer.MASK:=exec('FindAndGet','#table',BI_ARCH,$_tree,,"BI_ARCH.MASK");
      _buffer.B_PROC:=_b_proc;
      _buffer.TREE:=_tree;
      _buffer.FIRMA:=_firma;
      _buffer.TM_ADD:=BI_ARCH.tm_stamp();
      _buffer.ADD_DATE:=date();
      _buffer.ADD_TIME:=time();
      _buffer.DESC:=exec('FindAndGet','#table',B_PROC,$_b_proc,,"B_PROC.SYMBOL");
      exec('add','#bi_arch',_buffer);
      _res:=_buffer.Ref;
      obj_del(_buffer)
   ?}
?};
_res


\get_arch_tables
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca formułę która utworzy tablicę nazwaną, której pola nazywają się tak jak
::       wszystkie archiwizowane tabele
::   WY: FORMULA
::----------------------------------------------------------------------------------------------------------------------
_ff:="
   obj_new('BI_PROC','BI_PREL','BI_BLOB','BI_BLOP','BI_PORT','BI_CONN','BI_TODO','BI_MSG')
";
_ff


\left
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza ile rekordów zmieści się jeszcze w archiwum (w najbardziej obciążanej tabeli archiwizowanej)
::   WE: [_a] - STRING - maska archiwum, jeśli nie podana to robocza czyli '____'
::   WY: REAL - liczba rekordów które jeszcze się zmieszcza w masce
::----------------------------------------------------------------------------------------------------------------------
_msk:='____';
{? var_pres('_a')=type_of('')
|| _msk:=_a
?};

_result:=0;

:: Zwracam ile zostało w każdej tabeli archiwizowanej w podanej masce
_left_all:=exec('left_all','#bi_arch',_msk);

:: Najmniejsza wartość jest moim wynikiem
_result:=exec('array_min2','#array',_left_all,0);
_result


\left_all
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza ile rekordów zmieści się jeszcze w archiwum (we wszystkich tabelach archiwizowanej)
::   WE: [_a] - STRING - maska archiwum, jeśli nie podana to robocza czyli '____'
::   WY: obj_new - tablica nazwana z liczbą rekordów które jeszcze sie zmieszcza w masce każdej tabeli
::----------------------------------------------------------------------------------------------------------------------
_msk:='____';
{? var_pres('_a')=type_of('')
|| _msk:=_a
?};

_ff:=exec('get_arch_tables','#bi_arch');
_result:=_ff();
_can_continue:=1;

:: Pobieram parametry [stałe wartości]
_params:=exec('params','#bi_arch');

exec('cntx_psh','#bi_arch');
:: Otwieram archiwum
exec('open','#bi_arch',_msk);

{! _it:=1..obj_len(_params.tables)
|!
:: Pobieram liczbe rekordów
   {? var_pres('_tab')>100
   || obj_del(_tab)
   ?};
   _tab:=_params.tables[_it];
   _tab.clear();
   _size:=_tab.size();

:: Pobieram rozmiar bufora
   _buf_size:=_params.buffers[_it];

:: Obliczam ile rekordów zmiesci sie w maksymalnym rozmiarze pliku mdb
   _max_recs:=floor(_params.FILESIZE/_buf_size);
   _max_recs:=exec('min','#math',_max_recs,_params.REC_MAX);

:: Obliczam ile nowych rekordów można dodać zanim zostanie osiagniety maksymalny rozmiaru pliku
   _left:=_max_recs-_size;
   _left:=exec('max','#math',0,_left);

:: Uwzględniam margines bezpieczeństwa
   _left:=_left-(_max_recs*_params.FREE_PROC/100);
   _left:=floor(_left);
   _left:=exec('max','#math',0,_left);

   _result[_it]:=_left
!};
exec('cntx_pop','#bi_arch');
_result


\check_arch
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy dana instancja procesu zmieści się w podanej masce archiwum
::   WE: _a - STRING - maska docelowa
::       [_b] - BI_PROC.ref - instancja procesu lub bieżący rekord
::   WY: 0 - nie zmieści sie
::       1 - zmiesci sie
::----------------------------------------------------------------------------------------------------------------------
_msk:=_a;
_ref:=null();
{? var_pres('_b')=type_of(SYSLOG.ref())
|| _ref:=_b
?};

_result:=1;
_can_continue:=1;

BI_PROC.cntx_psh();
{? BI_PROC.name()='' ||  BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID');
{? _ref<>null()
|| BI_PROC.clear();
   {? BI_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: Obliczam ile jest wolnego w danej masce
   _left:=exec('left_all','#bi_arch',_msk);

:: Obliczam ile zajmuje proces

   exec('cntx_psh','#bi_arch');
   _ff:=exec('get_arch_tables','#bi_arch');
   _size:=_ff();

   _size.BI_PROC:=1;

   BI_PREL.index('PREL');
   BI_PREL.prefix(BI_PROC.ref());
   _size.BI_PREL:=BI_PREL.size();

   BI_PORT.index('BI_PROC');
   BI_PORT.prefix(BI_PROC.ref());
   _size.BI_PORT:=BI_PORT.size();

   BI_CONN.index('BI_PROC');
   BI_CONN.prefix(BI_PROC.ref());
   _size.BI_CONN:=BI_CONN.size();

   BI_TODO.index('BI_PROC');
   BI_TODO.prefix(BI_PROC.ref());
   _size.BI_TODO:=BI_TODO.size();

:: Sprawdzam czy proces zmieści się w wolnym miejscu
   {! _it:=1..obj_len(_left)
   |? _result>0
   |!
      {? _left[_it]<_size[_it]
      ||
::       Jeśli w jakiejś tabeli ilość wolnego miejsca w masce mniejsza niż liczba rekordów
::       to zwracam info że nie zmieści się i przerywam dalszą analizę
         _result:=0
      ?}
   !};
   exec('cntx_pop','#bi_arch')
?};
BI_PROC.cntx_pop();
_result


\archive_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Argument funkcji exec('archive','#bi_arch')
::   WY: obj_new() - tablica nazwana
::----------------------------------------------------------------------------------------------------------------------
_params:=obj_new('BI_PROC','MASK','TABSTAT');
_tabstat:=tab_tmp(2
   ,'MASK','STRING[4]',''
   ,'B_PROC','STRING[16]',''
   ,'TM_MIN','REAL',''
   ,'TM_MAX','REAL',''
   ,'NUM_ACT','INTEGER',''
);
_params.TABSTAT:=_tabstat;
_params


\archive
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: przenoszenie do archiwum
::   WE: _a - tablica nazwana parametrów - wynik funkcji exec('archive_a','#bi_arch')
::   WY: 1-przeniesiono 0-nie
::----------------------------------------------------------------------------------------------------------------------
    _res:=0;
 _params:=_a;

   _mask:=_params.MASK;
_bi_proc:=_params.BI_PROC;
_tabstat:=_params.TABSTAT;

_refs:=tab_tmp(1,'OLD','STRING[16]',''
        ,'NEW','STRING[16]',''
        ,'TAB','STRING[8]','');
_tabs:=tab_tmp(2,'REF','STRING[8]',''
        ,'LP','INTEGER',''
        ,'TAB','STRING[8]',''
        ,'NDX','STRING[8]',''
        ,'FLD','STRING[255]',''
        ,'REJ','INTEGER','');

_tabs.blank();
_tabs.REF:='BI_PROC'; _tabs.LP:=1; _tabs.TAB:='BI_PREL'; _tabs.NDX:='PREL';
_tabs.FLD:='BI_PROC#BI_PROC;'; _tabs.REJ:=1;
_tabs.add(1);
_tabs.blank();
_tabs.REF:='BI_PROC'; _tabs.LP:=2; _tabs.TAB:='BI_CONN'; _tabs.NDX:='BI_PROC';
_tabs.FLD:='BI_PROC#BI_PROC;FROM#BI_PREL;TO#BI_PREL;'; _tabs.REJ:=1;
_tabs.add(1);
_tabs.blank();
_tabs.REF:='BI_PROC'; _tabs.LP:=3; _tabs.TAB:='BI_TODO'; _tabs.NDX:='BI_PROC';
_tabs.FLD:='BI_PROC#BI_PROC;BI_PREL#BI_PREL;'; _tabs.REJ:=1;
_tabs.add(1);
_tabs.blank();
_tabs.REF:='BI_PROC'; _tabs.LP:=4; _tabs.TAB:='BI_MSG';  _tabs.NDX:='BI_PROC';
_tabs.FLD:='BI_PROC#BI_PROC;BI_PREL#BI_PREL;BI_TODO#BI_TODO;'; _tabs.REJ:=0;
_tabs.add(1);
_tabs.blank();
_tabs.REF:='BI_PROC'; _tabs.LP:=5; _tabs.TAB:='BI_PORT'; _tabs.NDX:='BI_PROC';
_tabs.FLD:='BI_PREL#BI_PREL;SOURCE#BI_PREL;BI_PROC#BI_PROC;BI_BLOB#BI_BLOB;';
_tabs.REJ:=0;
_tabs.add(1);

params_set('BI_PROC',_bi_proc,'REF2REF',_refs,'MASK',_mask,'TAB2NDX',_tabs,'TABSTAT',_tabstat);

_res:=exec('biProc2biArch','#bi_arch');

_res


\biProc2biArch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: przenosi jedną instancje procesu do archiwum
::   WY: 1-udalo sie 0-nie
::----------------------------------------------------------------------------------------------------------------------
_par:=params_get();
params_set(_par);

_bi_proc:=_par.BI_PROC;
_tabs   :=_par.TAB2NDX;
_mask   :=_par.MASK;
_refs   :=_par.REF2REF;
_error  :=0;

do();
exec('triggerOff','#bi_todo');
exec('usun_trigger','#b_trig');
exec('cntx_psh','#bi_arch',1);
{? _bi_proc<>null() & (BI_PROC.clear(); BI_PROC.seek(_bi_proc))
||
:: najpierw kluczowe BI_PROC
   _rsql:=$BI_PROC.ref();
   _buffer:=exec('buffer','#bi_proc');
   _buffer.get();
   exec('open','#bi_arch',_mask,0);
   {? ~exec('add','#bi_proc',_buffer,1) || _error:=1; undo() ?};
   _buffer.set();
   {? ~_error & _buffer.Ref<>null()
   || _refs.clear();
      _refs.blank();
      _refs.OLD:=_rsql;
      _refs.NEW:=$_buffer.Ref;
      _refs.TAB:='BI_PROC';
      _refs.add(1)
   ?};
   obj_del(_buffer);
   exec('open','#bi_arch',,0);

   {? ~_error
   || _tabs.prefix('BI_PROC');
      {? _tabs.first()
      || {!
         |? {? ~exec('copyWithTab','#bi_arch',_tabs.TAB,_tabs.NDX,_bi_proc,_tabs.FLD,_tabs.REJ) || _error:=1 ?};
            ~_error & _tabs.next()
         !}
      ?};
      _tabs.prefix('BI_PROC');
      {? ~_error & _tabs.last()
      || {!
         |? {? ~exec('delWithTab','#bi_arch',_tabs.TAB,_tabs.NDX,_bi_proc) || _error:=1 ?};
            ~_error & _tabs.prev()
         !}
      ?};
      {? ~_error
      || {? (BI_PROC.clear(); BI_PROC.seek(_bi_proc))
         || _del:=BI_PROC.del(1,1);
            {? ~_del || _error:=1; undo() ?}
         ?}
      ?}
   ?}
|| _error:=1
?};
exec('cntx_pop','#bi_arch',0);
exec('triggerOn','#bi_todo');
exec('ustaw_trigger','#b_trig');
end();
~_error


\copyWithTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: kopiuje kolejne rekordy danej tabeli
::   WE: _a - akronim tabeli
::       _b - akronim indeksu
::       _c - wartość prefiksu
::       _d - pola do podmiany
::       _e - czy zapisywac ref-y do konwersji
::   WY: 1-przepisano wszystkie rekordy 0-nie udało sie
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
_par:=params_get();
_tabs:=_par.TAB2NDX;
_refs:=_par.REF2REF;
_mask:=_par.MASK;
_stats:=_par.TABSTAT;

_tab:=$(_a);
_ndx:=$(_a+'.index('''+_b+''')');
_ref:=_c;
_rej:=_e;

_b_proc:='';

_acr:=tab_tmp(1,'FLD','STRING[8]','','TAB','STRING[8]','','WAR','STRING[16]','');
_fld:=_d;
{? _fld<>''
|| {!
   |? _wsk:=_fld*';';
      _buf:=(_wsk-1)+_fld;
      _fld:=_wsk-_fld;
      {? _buf<>''
      || _wbt:=_buf*'#';
         _btb:=_wbt-_buf;
         _buf:=(_wbt-1)+_buf;
         _acr.blank();
         _acr.FLD:=_buf;
         _acr.TAB:=_btb;
         _acr.WAR:='';
         _acr.add(1)
      ?};
      {? _fld='' | _wsk<=0 || 0 || 1 ?}
   !}
?};

{| _tab()
|! _ndx();
   prefix(_ref);
   {? first()
   || {? _a='BI_TODO'
      || _b_proc:=$B_PROC;
         _stats.prefix(_mask,_b_proc);
         {? _stats.first()
         || _stats.NUM_ACT:=size();
            _stats.put(1)
         ?}
      ?};
      {!
      |?
::       Ustalanie znaczników czasowych przeniesione do BI_PREL, żeby brało także zdarzenia oraz czynności usługowe
::         {? _a='BI_TODO' & _b_proc<>''
::         ||
::            _min:=@.tm_stamp(DT~1,DT~2,DT~3,TM~1,TM~2,TM~3);
::            _max:=@.tm_stamp(D_END~1,D_END~2,D_END~3,T_END~1,T_END~2,T_END~3);
::            _stats.prefix(_mask,_b_proc);
::            {? _stats.first()
::            || _put:=0;
::               {? _stats.TM_MIN>_min | _stats.TM_MIN=0 || _stats.TM_MIN:=_min; _put:=1 ?};
::               {? _stats.TM_MAX<_max | _stats.TM_MAX=0 || _stats.TM_MAX:=_max; _put:=1 ?};
::               {? _put || _stats.put(1) ?}
::            ?};
::            ~~
::         ?};
         {? _a='BI_MSG'
         || _memoerr:=memo_get('r','TR_ERR');
            _memoans:=memo_get('r','TR_ANS');
            memo_get(,'TR_ERR');
            memo_get(,'TR_ANS')
         ?};
         {? _a='BI_PREL'
         ||
            _stats.clear();

::          Ustalanie znaczników czasowych początku i końca archiwum
            _min:=START;
            _max:=STOP;
            _stats.prefix(_mask,_b_proc);
            {? _stats.first()
            || _put:=0;
               {? _stats.TM_MIN>_min | _stats.TM_MIN=0 || _stats.TM_MIN:=_min; _put:=1 ?};
               {? _stats.TM_MAX<_max | _stats.TM_MAX=0 || _stats.TM_MAX:=_max; _put:=1 ?};
               {? _put || _stats.put(1) ?}
            ?}

         ?};
         _old:=$ref();
         _acr.clear();
         {? _acr.first()
         || {!
            |? _fld:=_a+'.'+_acr.FLD;
               _acr.WAR:=$(($_fld)());
               _acr.put(1);
               _acr.next()
            !}
         ?};
::       przepisanie BI-BLOB-ów - wyłączone z powodu RODO
::         {? _a='BI_PORT' & BI_BLOB<>null()
::         || _bi_blob:=$exec('copy','#bi_blob',BI_BLOB,_mask);
::            {? _bi_blob<>''
::            || _refs.clear();
::               _refs.blank();
::               _refs.OLD:=$BI_BLOB;
::               _refs.NEW:=_bi_blob;
::               _refs.TAB:='BI_BLOB';
::               _refs.add(1)
::            || _res:=0; undo()
::            ?}
::         ?};
         {? _res
         ||
            exec('cntx_psh','#bi_arch');
            exec('open','#bi_arch',_mask);
            clear();
            _acr.clear();
            {? _acr.first()
            || {!
               |? _fld:=_a+'.'+_acr.FLD;
                  _refs.clear();
                  {? _acr.WAR<>'' & _refs.find_key(_acr.WAR,)
                  || ($_fld)():=exec('FindAndGet','#table',_acr.TAB,_refs.NEW)
                  ?};
                  _acr.WAR:='';
                  _acr.put(1);
                  _acr.next()
               !}
            ?};
            {? _a='BI_PORT' & BI_BLOB<>null()
            ||
::             Przed dodaniem BI_PORTa w nowej masce aktualizuje pola BI_PORT.VALUE
::             żeby odwoływały się do nowego BI_BLOBA
               VALUE:=$BI_BLOB
            ?};

            {? ~add()
            || _res:=0;
               undo()
            || {? _a='BI_MSG'
               || {? _memoerr.is_open || memo_put(_memoerr,'TR_ERR') ?};
                  {? _memoans.is_open || memo_put(_memoans,'TR_ANS') ?};
                  obj_del(_memoerr);
                  obj_del(_memoans)
               ?}
            ?};
            {? _res & _rej
            || _refs.clear();
               _refs.blank();
               _refs.OLD:=_old;
               _refs.NEW:=$ref();
               _refs.TAB:=_a;
               _refs.add(1)
            ?};
            exec('cntx_pop','#bi_arch')
         ?};
         _res & next()
      !}
   ?}
|};
 obj_del(_acr);
_res


\delWithTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: usuwa kolejne rekordy danej tabeli
::   WE: _a - akronim tabeli
::       [_b] - akronim indeksu
::       [_c] - wartość prefiksu
::   WY: 1-usunieto rekordy 0-nie udało sie
::----------------------------------------------------------------------------------------------------------------------

_res:=1;
_tab:=$(_a);

{? var_pres('_b')=type_of('')
|| _ndx:=$(_a+'.index('''+_b+''')')
|| _ndx:=$(_a+'.clear()')
?};
{? var_pres('_c')=type_of(SYSLOG.ref())
|| _ref:=_c
|| _ref:=null()
?};

{| _tab()
|! _ndx();
   {? _ref<>null() || prefix(_ref) ?};
   {? first()
   || {!
      |?
::       usunięcie BI_BLOB-a
         {? _a='BI_PORT' & BI_BLOB<>null()
         || _bi_blob:=BI_BLOB;
            BI_BLOB:=null();
            put(1);
            exec('delete','#bi_blob',_bi_blob)
         ?};
         {? _a='BI_PREL'
         || exec('delKeyRef','#b_keyref',ref());
            exec('del_bi_prel','#b_harm',ref());
            exec('del_b_wrkhst','#b_worker',ref());
            exec('delete4biprel','#bi_queue',ref())
         ?};
         _del:=del(1,1);
         {? ~_del || _res:=0; undo() ?};
         _res & _del>1
      !}
   ?}
|};
_res


\statArch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: Sprawdza czy podana instancja procesu może być przeniesiona do archiwum
::   WE: _a - BI_PROC.ref
::   WY: 1-tak 0-nie
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(BI_PROC.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

BI_PROC.cntx_psh();
{? _ref<>null()
|| BI_PROC.prefix();
   {? BI_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _status:=BI_PROC.BI_STAT;
   _result:=0;
   _ending:=exec('ZAKONCZONY','#bi_stat');
   _break:=exec('AWARYJNIE','#bi_stat');

:: Sprawdzam czy są jakieś problemy albo błędy. Jeżeli tak, to umożliwiam przesunięcie do archiwum
   {? _result=0 & exec('FindInSet','#table','BI_TODO','ERROR','E',BI_PROC.ref())<>null()
   || _result:=1
   ?};
   {? _result=0 & exec('isProblemsProc','#bi_msg',BI_PROC.ref())>0
   || _result:=1
   ?};
:: Sprawdzam czy status jest odpowiedni
   {? _result=0
   || _result:=_status=_ending | _status=_break
   ?};
   ~~
?};
BI_PROC.cntx_pop();
_result


\infoArch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: Inicjuje tablice do informacji statystyczne dla gałęzi
::   WE: _a - BI_ARCH.ref
::       _b - tablica
::----------------------------------------------------------------------------------------------------------------------

_tab:=_b;
BI_ARCH.cntx_psh();
BI_ARCH.clear();
{? BI_ARCH.seek(_a)
|| _tab.clear();
   {? _tab.first() || {! |? _tab.del() !} ?};
   _tab.blank();
   _tab.MASK:=BI_ARCH.MASK;
   _tab.B_PROC:=$BI_ARCH.B_PROC;
   _tab.TM_MIN:=0;
   _tab.TM_MAX:=0;
   _tab.NUM_ACT:=0;
   _tab.add(1)
?};
BI_ARCH.cntx_pop();
~~


\actuArch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: Aktualizuje informacje statystyczne dla gałęzi
::   WE: _a - tablica
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_tab.clear();
{? _tab.first()
|| _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.B_PROC);
    _firma:=exec('FindAndGet','#table',B_PROC,_tab.B_PROC,,"B_PROC.FIRMA");
   BI_ARCH.cntx_psh();
   BI_ARCH.index('MASK');
   BI_ARCH.prefix(_firma,_tab.MASK,_b_proc);
   {? BI_ARCH.first()
   || exec('update_counters','#bi_arch')
   ?};
   BI_ARCH.cntx_pop()
?}


\sumArch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: Aktualizuje informacje statystyczne dla gałęzi nadrzędnej
::   WE: _a - BI_ARCH.TREE
::       _b - FIRMA.ref()
::----------------------------------------------------------------------------------------------------------------------
_tree:=_a;
_firma:=_b;

_num_proc:=0;
_num_act:=0;
_tm_min:=0;
_tm_max:=0;
_min_date:=date(0,0,0);
_max_date:=date(0,0,0);
BI_ARCH.cntx_psh();
BI_ARCH.index('TREE');
BI_ARCH.prefix(_firma,_tree);
{? BI_ARCH.first()
|| {!
   |? _num_proc+=BI_ARCH.NUM_PROC;
      _num_act+=BI_ARCH.NUM_ACT;
      {? BI_ARCH.TM_MIN<_tm_min | _tm_min=0 || _tm_min:=BI_ARCH.TM_MIN ?};
      {? BI_ARCH.TM_MAX>_tm_max | _tm_max=0 || _tm_max:=BI_ARCH.TM_MAX ?};
      {? BI_ARCH.MIN_DATE<_min_date | _min_date=date(0,0,0) || _min_date:=BI_ARCH.MIN_DATE ?};
      {? BI_ARCH.MAX_DATE>_max_date | _max_date=date(0,0,0) || _max_date:=BI_ARCH.MIN_DATE ?};
      BI_ARCH.next()
   !}
?};
BI_ARCH.clear();
{? BI_ARCH.seek(_tree,)
|| BI_ARCH.TM_MIN:=_tm_min;
   BI_ARCH.TM_MAX:=_tm_max;
   BI_ARCH.MIN_DATE:=_min_date;
   BI_ARCH.MAX_DATE:=_max_date;
   BI_ARCH.NUM_PROC:=_num_proc;
   BI_ARCH.NUM_ACT:=_num_act;
   BI_ARCH.MIN_TIME:=*((BI_ARCH.TM_MIN/1000000)/60);
   BI_ARCH.MAX_TIME:=*((BI_ARCH.TM_MAX/1000000)/60);
   BI_ARCH.put(1)
?};
BI_ARCH.cntx_pop();
~~


\update_counters
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Aktualizuje dane na BI_ARCH na podstawie instancji procesów które zawiera
::   WE: [_a] - BI_ARCH.ref lub #BI_ARCH.ref lub bieżący rekord
::       [_b] - INTEGER - czy możliwa rekurencja w górę?
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(BI_ARCH.ref())
|| _ref:=_a
?};
_nr:=0;
{? var_pres('_a')=type_of(0)
|| _nr:=_a
?};
_can_rec:=1;
{? var_pres('_b')=type_of(0)
|| _can_rec:=_b
?};

_result:=0;
_can_continue:=1;

BI_ARCH.cntx_psh();
{? _ref<>null()
|| BI_ARCH.prefix();
   {? BI_ARCH.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
|? _nr>0
|| BI_ARCH.prefix();
   {? BI_ARCH.seek(_nr,)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0 & BI_ARCH.ref()<>null()
|| exec('cntx_psh','#bi_arch');
   exec('open','#bi_arch',BI_ARCH.MASK);
   BI_PROC.index('PROBORN');
   BI_PREL.index('B_PROC');
   {? BI_ARCH.B_PROC<>null()
   || BI_PROC.prefix(BI_ARCH.B_PROC);
      BI_PREL.prefix(BI_ARCH.B_PROC)
   || BI_PROC.prefix();
      BI_PREL.prefix()
   ?};
   BI_ARCH.NUM_PROC:=BI_PROC.size();
   BI_ARCH.NUM_ACT:=BI_PREL.size();

   BI_ARCH.TM_MIN:=0;
   BI_ARCH.TM_MAX:=0;
   BI_ARCH.MIN_DATE:=date(0,0,0);
   BI_ARCH.MAX_DATE:=date(0,0,0);
   BI_ARCH.MIN_TIME:=time(0,0,0);
   BI_ARCH.MAX_TIME:=time(0,0,0);
   {? BI_PROC.first()
   || BI_ARCH.TM_MIN:=BI_PROC.TM_BORN
   ?};
   {? BI_PROC.last()
   || BI_ARCH.TM_MAX:=BI_PROC.TM_BORN
   ?};
   {? BI_ARCH.TM_MIN>0
   || BI_ARCH.MIN_DATE:=exec('tm_stamp2date','#tm_stamp',BI_ARCH.TM_MIN);
      BI_ARCH.MIN_TIME:=exec('tm_stamp2time','#tm_stamp',BI_ARCH.TM_MIN)
   ?};
   {? BI_ARCH.TM_MAX>0
   || BI_ARCH.MAX_DATE:=exec('tm_stamp2date','#tm_stamp',BI_ARCH.TM_MAX);
      BI_ARCH.MAX_TIME:=exec('tm_stamp2time','#tm_stamp',BI_ARCH.TM_MAX)
   ?};
   _can_continue:=BI_ARCH.put();

   {? _can_continue>0 & _can_rec>0 & BI_ARCH.TREE>0
   ||
::    !!! REKURENCJA !!!
      _can_continue:=exec('update_counters','#bi_arch',BI_ARCH.TREE,_can_rec)
   ?};

   exec('cntx_pop','#bi_arch');
   ~~
?};
BI_ARCH.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\deleteArch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: Usunięcie zawartości archiwum
::----------------------------------------------------------------------------------------------------------------------

_tab:=BI_ARCH.sel_aget();
BI_ARCH.sel_adel();
BI_ARCH.cntx_psh();
{? _tab.first()
|| _mask:=tab_tmp(1,'MASK','STRING[4]','');
   _resdel:=0;
   _resund:=0;
   {? FUN.ask('Czy usunąć zawartość zaznaczonych archiwów?'
           '\nArchiwa nieaktywne zostaną pominięte.'
           '\n\nUwaga. Usuwane są wszystkie pozycje w archiwum wraz z kompresją bazy na dysku.\n'
           'Zachowana zostanie informacja o tym, że archiwum zostało utworzone i dezaktywowane.'@)
   || {!
      |? {? (BI_ARCH.clear(); BI_ARCH.seek(_tab.REF,)) & (_mask.clear(); ~_mask.find_key(BI_ARCH.MASK))
         || _mask.blank();
            _mask.MASK:=BI_ARCH.MASK;
            _mask.add(1);
            {? BI_ARCH.ACTIVE='N'
            || _resund+=1
            || {? exec('delOneArch','#bi_arch',BI_ARCH.ref())
               || _resdel+=1
               || _resund+=1
               ?}
            ?}
         ?};
         _tab.next()
      !}
   ?};
   {? _resdel | _resund
   || FUN.info({? _resdel || 'Usunięto dane w '+form(_resdel,,0,'99')+' archiwach.\n' || '' ?}+
               {? _resund || 'Pominięto lub nie udało się usunąć danych w '+form(_resund,,0,'99')+' archiwach.' || '' ?})
   ?};
   obj_del(_mask)
|? BI_ARCH.ACTIVE='N'
|| FUN.info('Archiwum nie jest aktywne.\nUsunięcie niemożliwe.'@)
|? FUN.ask('Czy usunąć zawartość archiwum o masce: %1?'
           '\n\nUwaga. Usuwane są wszystkie pozycje w archiwum wraz z kompresją bazy na dysku.\n'
           'Zachowana zostanie informacja o tym, że archiwum zostało utworzone i dezaktywowane.'@[BI_ARCH.MASK])
|| {? exec('delOneArch','#bi_arch',BI_ARCH.ref())
   || FUN.info('Usunięto dane z archiwum: %1.'@[BI_ARCH.MASK])
   || FUN.info('Nie udało się usunąć danych z archiwum: %1.'@[BI_ARCH.MASK])
   ?}
?};
BI_ARCH.cntx_pop();
obj_del(_tab);
~~


\delOneArch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr][17.00]
:: OPIS: Usunięcie zawartości danego archiwum
::   WE: [_a] - BI_ARCH.ref lub domyślnie dany rekord tabeli BI_ARCH
::   WY: 1-usunięto i dezaktywowano 0-błąd
::----------------------------------------------------------------------------------------------------------------------

_ref:=0;
{? var_pres('_a')=type_of(SYSLOG.ref()) || _ref:=_a || _ref:=BI_ARCH.ref() ?};

exec('triggerOff','#bi_todo');
exec('usun_trigger','#b_trig');
_params:=exec('params','#bi_arch');
_len:=obj_len(_params.tables);
exec('cntx_psh','#bi_arch');
BI_ARCH.cntx_psh();
_ok:=0;
BI_ARCH.clear();
{? _ref<>null() & BI_ARCH.seek(_ref)
|| {? ~BI_ARCH.TREE
   || _ok:=1
   || _ok:=BI_ARCH.seek(BI_ARCH.TREE,)
   ?}
?};
B_PROC.blank(1);
{? _ok
|| _mask:=BI_ARCH.MASK;
   exec('open','#bi_arch',_mask);
   do();
   _res:=1;
   {! _it:=_len // -1 ..1
   |! {? var_pres('_tab')>100 || obj_del(_tab) ?};
      _tab:=_params.tables[_it];
      _tab.clear();
      {? _tab.first()
      || {!
         |? _del:=_tab.del(1,1);
            {? ~_del || _res:=0; undo() ?};
            _res & _del>1
         !}
      ?}
   !};
   {? _res
   || BI_ARCH.ACTIVE:='N';
      {? BI_ARCH.put(1)
      || _tree:=BI_ARCH.ref();
         BI_ARCH.index('TREE');
         BI_ARCH.prefix(BI_ARCH.FIRMA,_tree);
         {? BI_ARCH.first()
         || {!
            |? BI_ARCH.ACTIVE:='N';
               BI_ARCH.put(1);
               BI_ARCH.next()
            !}
         ?}
      ?}
   ?};
   end();
   {? _res
   || {! _it:=_len // -1 .. 1
      |! {? var_pres('_tab')>100 || obj_del(_tab) ?};
         _tab:=_params.tables[_it];
         _tab.blank(1);
         _tab.clear();
         _tab.erase()
      !}
   ?}
?};
BI_ARCH.cntx_pop();
exec('cntx_pop','#bi_arch');
obj_del(_params);
exec('triggerOn','#bi_todo');
exec('ustaw_trigger','#b_trig');
_res


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH & TMR [17.00]
:: OPIS: Wyświetla archiwum
::   WE: [_a] - B_PROC.ref() - dla podanego procesu, lub jeśli nie podane to
::                             dla wszystkich procesów (widok z drzewem)
:: DOST: PUBLIC
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.clear();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| BI_ARCH.cntx_psh();
   {? _ref=null()
   || BI_ARCH.index('TREE');
      BI_ARCH.prefix(REF.FIRMA)
   || BI_ARCH.index('B_PROC');
      BI_ARCH.prefix(B_PROC.FIRMA,'T',B_PROC.ref())
   ?};
   BI_ARCH.first();
   exec('cntx_psh','#bi_arch');

   _czysc:="VAR_DEL.delete('__ARCH_BPROC1')";
   _czysc();

   __ARCH_BPROC1:=obj_new('B_PROC','BI_PROC','IPR_DETA','B_KEYREF','BI_ARCH');
   __ARCH_BPROC1.B_PROC:=obj_new('TAB','REF','WERT','WERN','WER');
   __ARCH_BPROC1.BI_PROC:=obj_new('TAB','REF','WER','BTN1','BTN2','PREV');
   __ARCH_BPROC1.IPR_DETA:=obj_new('TAB','WER');
   __ARCH_BPROC1.B_KEYREF:=obj_new('TAB','WER');
   __ARCH_BPROC1.BI_ARCH:=obj_new('TAB','REF','WER','REFTABLE');

   {? _ref=null()
   || __ARCH_BPROC1.B_PROC.REF:=null()
   || __ARCH_BPROC1.B_PROC.REF:=B_PROC.ref()
   ?};
   __ARCH_BPROC1.B_PROC.TAB:=B_PROC;

:: tabela instancji procesu
   __ARCH_BPROC1.BI_PROC.TAB:=BI_PROC;

:: tabela archiwum
   _werBiArch:='WER';
   {? _ref=null()
   || _werBiArch:=BI_ARCH.mk_sel('Archiwa'@,'P',0,'aswdfwqwjcbcawx',,,,1);
      BI_ARCH.win_fld(_werBiArch,,'DESC',,,22,,,'Opis'@);
      BI_ARCH.win_fld(_werBiArch,,'FIRMA','SYMBOL',,10,,,'Firma'@);
      BI_ARCH.win_fld(_werBiArch,,'MIN_DATE',,,10,,,'Procesy od'@);
      BI_ARCH.win_fld(_werBiArch,,'MAX_DATE',,,10,,,'Procesy do'@);
      BI_ARCH.win_fld(_werBiArch,,'NUM_PROC',,,5,,,'Liczba instancji procesów'@);
      BI_ARCH.win_fld(_werBiArch,,'NUM_ACT',,,5,,,'Liczba instancji elementów'@);
      BI_ARCH.win_act(_werBiArch,,'Formuła','Zwiń/rozwiń'@@,,,"
                        exec('zwrw_all','#tree',BI_ARCH,'TREE',__ARCH_BPROC1.BI_ARCH.WER)
                     ",,,,,,'Z');
      BI_ARCH.win_act(_werBiArch,,'Formuła','Usuń archiwum'@@,,,"exec('deleteArch','#bi_arch')",,,1
                     ,"exec('deleteArch','#bi_arch')",,'U');
      BI_ARCH.win_act(_werBiArch,,'Szukaj');
      BI_ARCH.win_act(_werBiArch,,'Kolejność');
      BI_ARCH.win_act(_werBiArch,,'Formuła','Legenda'@@,,,"exec('legenda','color','BI_ARCH#01')",,,,,,'L');
      BI_ARCH.win_fml(_werBiArch,,'DESC',,'ICON_BEFORE',"
                        {? BI_ARCH.ACTIVE='T' & BI_ARCH.TREE=null()
                        || 'xwin16.png:145'
                        |? BI_ARCH.ACTIVE='N' & BI_ARCH.TREE=null()
                        || 'xwin16.png:8'
                        |? BI_ARCH.ACTIVE='T' & BI_ARCH.TREE<>null()
                        || 'xwin16.png:156'
                        |? BI_ARCH.ACTIVE='N' & BI_ARCH.TREE<>null()
                        || 'xwin16.png:157'
                        || ''
                        ?}
                    ");
      BI_ARCH.win_sel(_werBiArch)
   ?};
   __ARCH_BPROC1.BI_ARCH.TAB:=BI_ARCH;
   __ARCH_BPROC1.BI_ARCH.WER:=_werBiArch;
   __ARCH_BPROC1.BI_ARCH.REF:=null();
   __ARCH_BPROC1.BI_ARCH.REFTABLE:=exec('ref_table','#table');

:: okno instacji procesu
   exec('bi_proc_wer','#bi_inst',__ARCH_BPROC1.BI_PROC,2,(_ref=null()));

:: tabela szczegółów uruchomienia
   exec('ipr_deta_tab','#bi_inst',__ARCH_BPROC1.IPR_DETA);

:: okno szczegółów uruchomienia
   exec('ipr_deta_wer','#bi_inst',__ARCH_BPROC1.IPR_DETA);

:: tabela kluczowych rekordów instancji procesu
   exec('b_keyref_tab','#bi_inst',__ARCH_BPROC1.B_KEYREF);

:: okno kluczowych rekordów instancji procesu
::   exec('b_keyref_wer','#bi_inst',__ARCH_BPROC1.B_KEYREF);

:: okno grupowe
   _Tab:=__ARCH_BPROC1.BI_ARCH.TAB;
   _wer:=_Tab.grp_make('Archiwum'@,,'#b_proc_archive');
   _far:="
      _obj:=__ARCH_BPROC1.BI_ARCH;
      _Tab:=_obj.TAB;

      {? BI_ARCH.size()>0
      || _obj.REF:=BI_ARCH.ref();
         exec('open','#bi_arch',BI_ARCH.MASK)
      || _obj.REF:=null()
      ?};

      {? _obj.REF<>null()
      || B_PROC.clear();
         {? B_PROC.seek(BI_ARCH.B_PROC)
         || __ARCH_BPROC1.B_PROC.REF:=B_PROC.ref()
         || __ARCH_BPROC1.B_PROC.REF:=null()
         ?}
      ?};

      _obj1:=__ARCH_BPROC1.BI_PROC; grp_disp(_obj1.TAB,_obj1.WER);
      _obj2:=__ARCH_BPROC1.IPR_DETA; grp_disp(_obj2.TAB,_obj2.WER);

      exec('update_counters','#bi_arch');
      ~~
      ";
   _before:="

   ";

   _Tab.grp_sel(_wer,,__ARCH_BPROC1.BI_ARCH.WER,'Archiwa'@,_far,,,,_before,,,,'maximized');

:: dodajemy okienko z instancjami
   _Tab.grp_splt(_wer,,'vertical','inst');

   _fb:="
      _biarch:=__ARCH_BPROC1.BI_ARCH;
      BI_PROC.index('PROSTAN');
      {? _biarch.REF<>null()
      || _bproc:=__ARCH_BPROC1.B_PROC;
         {? _bproc.REF=null()
         || BI_PROC.prefix()
         || BI_PROC.prefix(_bproc.REF)
         ?}
      || BI_PROC.prefix(null)
      ?};
      BI_PROC.first()
      ";
   _fa:=
      "
      _obj:=__ARCH_BPROC1.BI_PROC;
      _Tab:=_obj.TAB;
      _btn1:=_obj.BTN1;
      _obj.REF:=BI_PROC.ref();
      BI_PROC.cntx_psh();
      {? BI_PROC.size()=0
      || _obj.REF:=null()
      ?};
      BI_PROC.cntx_pop();
      {? _obj.REF
      || _Tab.btn_opt(_btn1,'state=normal')
      || _Tab.btn_opt(_btn1,'state=grayed')
      ?}
      ";
   _far:=$(_fa+";
      _obj1:=__ARCH_BPROC1.IPR_DETA; grp_disp(_obj1.TAB,_obj1.WER)
      ");
   _Tab.grp_sel(_wer,BI_PROC,__ARCH_BPROC1.BI_PROC.WER,,_far,,,22,_fb,_fa,,,'maximized_with_title');

:: dodajemy okienko ze szczegółami
   _Tab.grp_splt(_wer,'inst','horizontal','inst_szcz');

   _fb:="
      exec('ipr_deta_tab_u','#bi_inst',__ARCH_BPROC1.IPR_DETA.TAB,__ARCH_BPROC1.BI_PROC.REF,__ARCH_BPROC1.B_PROC.TAB.MICRO);
      cur_tab(1,1).first()
      ";
   _fa:="
      cur_tab(1,1).first()
      ";
   _Tab.grp_sel(_wer,__ARCH_BPROC1.IPR_DETA.TAB,__ARCH_BPROC1.IPR_DETA.WER,'Szczegóły uruchomienia'@,,,,,_fb,_fa,,,'maximized');

:: select
   _Tab.win_sel(_wer);
   _Tab.select();

   exec('cntx_pop','#bi_arch');
   BI_ARCH.cntx_pop();
   _czysc();
   ~~

?};
B_PROC.cntx_pop();
::win_activate('<');
''


\bi_arch_sel_all
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [17.00]
:: OPIS: Wyświetla archiwum globalne - dla wszystkich procesów
::----------------------------------------------------------------------------------------------------------------------
exec('select','#bi_arch');
~~


\get_mask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca maskę dostępnego archiwum
::   WE: _a - BI_PROC.ref()
::       _b - FIRMA.ref()
::----------------------------------------------------------------------------------------------------------------------
_bi_proc:=_a;
_firma:=_b;

_mask:='';

BI_ARCH.index('MASK');
BI_ARCH.prefix(_firma);
{? BI_ARCH.last() & BI_ARCH.ACTIVE='T'
|| {? exec('check_arch','#bi_arch',BI_ARCH.MASK,_bi_proc)
   || _mask:=BI_ARCH.MASK
   || _ref:=exec('newBiArch','#bi_arch',_firma);
      {? _ref<>null() & (BI_ARCH.clear(); BI_ARCH.seek(_ref)) || _mask:=BI_ARCH.MASK ?}
   ?}
|| _ref:=exec('newBiArch','#bi_arch',_firma);
   {? _ref<>null() & (BI_ARCH.clear(); BI_ARCH.seek(_ref)) || _mask:=BI_ARCH.MASK ?}
?};

_mask


\check_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Sprawdza czy podany ref jest w masce archiwalnej
::   WE: _a - BI_*.ref - ref tabeli BI_xxxx
::   WY: 0 - ref w jest w masce bieżącej
::       1 - ref jest w masce archiwalnej
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;

_result:=0;

{? _ref<>null()
|| _mask:=ref_name(_ref);
   {? _mask+4<>'____'
   || _result:=1
   ?}
?};
_result


\act_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [19.02]
:: OPIS: Informacja o niedostępności opcji ponieważ istnieją aktywne archiwa dla procesu
::   WE: _a - Symbol procesu
::       _b - INTEGER - 0/1/2 - czy wyswietlac komunikaty, czy na ekran, czy do komma
::----------------------------------------------------------------------------------------------------------------------
_symbol:=_a;
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};
_msg:='Istnieją aktywne archiwa procesu %1.\nOperacja niedostępna.'@[_symbol];
{? _dialog=1
|| FUN.info(_msg)
|? _dialog=2
|| KOMM.add(_msg,2,,1)
?};
~~

:Sign Version 2.0 jowisz:1045 2023/07/14 12:03:44 9add1d3d74a77a19ca58da572eceec744d23f9bdd7e1a357d3a5150906f4d66bb91b104712a021d5998d1e06fcabb1d425c86a36b6e73a461d2c61aa9f45286bb2f4f753379b7dfff0bc8527e18699f351cc9bf9ad839c585d06ad3ac87393b1c767d8af408d2c68cc61956f1b6f742a38c4be942e132defbb97292c5c30bfc1
