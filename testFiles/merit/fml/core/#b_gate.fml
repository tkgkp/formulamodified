:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b_gate.fml
:: Utworzony: 18.12.2014 [17.00]
:: Autor: AWI
::======================================================================================================================
:: Zawartość: Formuły do obsługi tabeli B_GATE
::======================================================================================================================


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Funkcja dodająca wpis do tabeli B_GATE
::   WE: _a - [STRING]     - typ bramy ('OR', 'XOR', 'AND', 'EVENT', 'XOR_EVENT', 'AND_EVENT')
::       _b - [STRING]     - rodzaj bramy ('>' - zbierająca, '<' - rozdzielająca)
::       _c - [STRING]     - symbol bramy
::   WY:      [REFERENCE]  - wskazanie na dodany rekord (lub już istniejący)
::----------------------------------------------------------------------------------------------------------------------
   _typ:={? var_pres('_a')=type_of('') || _a || return(null) ?};
_rodzaj:={? var_pres('_b')=type_of('') || _b || return(null) ?};
_symbol:={? var_pres('_c')=type_of('') || _c || return(null) ?};
_res:=null();
B_GATE.cntx_psh();
B_GATE.index('TYP');
B_GATE.prefix();
_b_chain:=exec('add','#b_chain','B_GATE','Brama');
{? _b_chain<>null()
|| _b_ele:=exec('add','#b_ele',_b_chain,_symbol);
   {? _b_ele<>null()
   || B_GATE.blank(1);
      B_GATE.B_ELE:=_b_ele;
      B_GATE.SYMBOL:=_symbol;
      B_GATE.TYPE:=_typ;
      B_GATE.KIND:=_rodzaj;
      {? B_GATE.find_rec()
      || _res:=B_GATE.ref()
      || {? B_GATE.add()
         || _res:=B_GATE.ref()
         ?}
      ?}
   ?}
?};
B_GATE.cntx_pop();
_res


\fill_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Funkcja wypełnia tabelę B_GATE danymi
::----------------------------------------------------------------------------------------------------------------------
exec('add','#b_gate',exec('type_or','#b_gate'),exec('kind_merge','#b_gate'),'Brama zbierająca - OR');
exec('add','#b_gate',exec('type_or','#b_gate'),exec('kind_split','#b_gate'),'Brama rozdzielająca - OR');
exec('add','#b_gate',exec('type_xor','#b_gate'),exec('kind_merge','#b_gate'),'Brama zbierająca - XOR');
exec('add','#b_gate',exec('type_xor','#b_gate'),exec('kind_split','#b_gate'),'Brama rozdzielająca - XOR');
exec('add','#b_gate',exec('type_and','#b_gate'),exec('kind_merge','#b_gate'),'Brama zbierająca - AND');
exec('add','#b_gate',exec('type_and','#b_gate'),exec('kind_split','#b_gate'),'Brama rozdzielająca - AND');
exec('add','#b_gate',exec('type_event','#b_gate'),exec('kind_split','#b_gate'),'Brama sterowana zdarzeniami pośrednimi');
exec('add','#b_gate',exec('type_xor_event','#b_gate'),exec('kind_merge','#b_gate'),'Brama wykluczająca sterowana zdarzeniami startowymi');
exec('add','#b_gate',exec('type_complex','#b_gate'),exec('kind_merge','#b_gate'),'Brama zbierająca - złożona');
~~


\type_or
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Typ bramy - OR (inclusive)
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'OR'


\type_xor
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Typ bramy - XOR (exclusive)
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'XOR'


\type_and
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Typ bramy - AND (paralell)
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'AND'


\type_event
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Typ bramy - sterowana zdarzeniemi pośrednimi (event-based)
::----------------------------------------------------------------------------------------------------------------------
'EVENT'


\type_xor_event
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Typ bramy - wykluczająca sterowana zdarzeniami startowymi (exclusive event-based)
::----------------------------------------------------------------------------------------------------------------------
'XOR_EVENT'


\type_and_event
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Typ bramy - równoległa sterowana zdarzeniami startowymi (paralell event-based)
::----------------------------------------------------------------------------------------------------------------------
'AND_EVENT'


\type_complex
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Typ bramy - złożona
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'COMPLEX'


\kind_split
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Rodzaj bramy - rozdzielająca
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'<'


\kind_merge
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Rodzaj bramy - zbierająca
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'>'


\get_kind
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca rodzaj bramy
::   WE: _a - B_ELE.ref()
::   WY: STRING - rodzaj bramy: >,< lub '' jeśli element nie jest bramą
::----------------------------------------------------------------------------------------------------------------------
_b_ele:=_a;

_result:='';

{? exec('is_gate','#b_gate',_b_ele)>0
|| B_GATE.cntx_psh();
   B_GATE.index('ELEMENT');
   B_GATE.prefix(_b_ele);
   {? B_GATE.first()
   || _result:=B_GATE.KIND
   ?};
   B_GATE.cntx_pop()
?};
_result


\get_kind_prel
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca rodzaj bramy
::   WE: _a - B_PREL.ref()
::   WY: STRING - rodzaj bramy: >,< lub '' jeśli element nie jest bramą
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;

_result:='';

B_PREL.cntx_psh(); B_PREL.clear();
{? B_PREL.seek(_b_prel)
|| _result:=exec('get_kind','#b_gate',B_PREL.B_ELE)
?};
B_PREL.cntx_pop();
_result


\get_type
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca typ bramy
::   WE: _a - B_ELE.ref()
::   WY: STRING - typ bramy: AND,OR,XOR,EVENT,XOR_EVENT,AND_EVENT lub '' jeśli element nie jest bramą
::----------------------------------------------------------------------------------------------------------------------
_b_ele:=_a;

_result:='';

{? exec('is_gate','#b_gate',_b_ele)>0
|| B_GATE.cntx_psh();
   B_GATE.index('ELEMENT');
   B_GATE.prefix(_b_ele);
   {? B_GATE.first()
   || _result:=B_GATE.TYPE
   ?};
   B_GATE.cntx_pop()
?};
_result


\get_type_prel
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca typ bramy
::   WE: _a - B_PREL.ref()
::   WY: STRING - typ bramy: AND,OR,XOR,EVENT,XOR_EVENT,AND_EVENT lub '' jeśli element nie jest bramą
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;

_result:='';

B_PREL.cntx_psh(); B_PREL.clear();
{? B_PREL.seek(_b_prel)
|| _result:=exec('get_type','#b_gate',B_PREL.B_ELE)
?};
B_PREL.cntx_pop();
_result


\is_gate
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza, czy element jest bramą o określonych cechach (typ, rodzaj)
::   WE: _a - B_ELE.ref()
::       [_b] - STRING - typ bramy (OR,XOR,AND,EVENT,XOR_EVENT,AND_EVENT)
::       [_c] - STRING - rodzaj bramy (>,<)
::   WY: -1 - element nie jest brama
::       0 - element jest bramą ale niewłaściwego typu, rodzaju
::       1 - element jest bramą właściwego typu i rodzaju
::----------------------------------------------------------------------------------------------------------------------
_b_ele:=_a;
{? var_pres('_b')=type_of('') || _type:=_b || _type:='' ?};
{? var_pres('_c')=type_of('') || _kind:=_c || _kind:='' ?};

_result:=1;

B_GATE.cntx_psh();
B_GATE.index('ELEMENT');
B_GATE.prefix(_b_ele);
{? B_GATE.first()
|| {? _type='' | B_GATE.TYPE=_type
   || _result*=1
   || _result*=0
   ?};
   {? _kind='' | B_GATE.KIND=_kind
   || _result*=1
   || _result*=0
   ?}
|| _result:=-1
?};
B_GATE.cntx_pop();
_result


\is_gate_prel
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza, czy element jest bramą o określonych cechach (typ, rodzaj)
::   WE: _a - B_PREL.ref()
::       [_b] - STRING - typ bramy (OR,XOR,AND,EVENT,XOR_EVENT,AND_EVENT)
::       [_c] - STRING - rodzaj bramy (>,<)
::   WY: -1 - element nie jest bramą
::       0 - element jest bramą ale niewłaściwego typu, rodzaju
::       1 - element jest bramą właściwego typu i rodzaju
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;
{? var_pres('_b')=type_of('') || _type:=_b || _type:='' ?};
{? var_pres('_c')=type_of('') || _kind:=_c || _kind:='' ?};

_result:=1;

B_PREL.cntx_psh(); B_PREL.clear();
{? B_PREL.seek(_b_prel)
||
   {? B_PREL.GATEKIND<>'' & B_PREL.GATETYPE<>''
   || {? _type='' | B_PREL.GATETYPE=_type
      || _result*=1
      || _result*=0
      ?};
      {? _kind='' | B_PREL.GATEKIND=_kind
      || _result*=1
      || _result*=0
      ?}
   || _result:=-1
   ?}
?};
B_PREL.cntx_pop();
_result


\merging_nojoin
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy przekazany element procesu jest bramą zbierajacą, ale nie czekajacą na wszystkie
::       aż wszystko dotrze
::   WE: _a - B_PREL.ref()
::   WY: -1 - wystapił jakiś błąd
::       0  - element procesu nie jest bramą, jest brama rozdzielajacaą lub zbierajacą i czekajacą
::       1  - element procesu jest bramą zbierajacą ale nie czekajacą
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;

_result:=-1;

B_GATE.cntx_psh();
B_ELE.cntx_psh();
B_PREL.cntx_psh(); B_PREL.clear();
{? B_PREL.seek(_b_prel)
||
:: Najpierw sprawdzam czy element procesu jest w ogóle bramą zbierajacą
   _type_merge:=exec('is_gate','#b_gate',B_PREL.B_ELE,,exec('kind_merge','#b_gate'));

   {? _type_merge>0
   ||
::    Jeśli jest brama zbierajacą, to sprawdzam czy jest czekajacą
      _kind_and:=exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_and','#b_gate'),exec('kind_merge','#b_gate'));
      {? _kind_and>0
      || _result:=0
      || _result:=1
      ?}
   || _result:=0
   ?}
?};
B_GATE.cntx_pop();
B_ELE.cntx_pop();
B_PREL.cntx_pop();
_result


\actions_tab
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca tabele tymczasową która zawiera liste B_PRELi
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_actions_tab:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'B_PREL','STRING[16]','SQL ref B_PREL',
   'SYMBOL','STRING[100]','Symbol B_PREL'
);
_actions_tab


\has_gate_before
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy przed podanym elementem znajduje się brama podanego typu i rodzaju
::   WE: _a - B_PREL.ref()
::       [_b] - STRING - typ bramy (OR,XOR,AND,EVENT,XOR_EVENT,AND_EVENT)
::       [_c] - STRING - rodzaj bramy (>,<)
::       [_d] - ref_table - tablica odwiedzonych elementów
::   WY: 0 - w poprzednikach brak bramy podanego typu i rodzaju
::       1 - w poprzednikach jest brama podanego typu i rodzaju
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;
{? var_pres('_b')=type_of('') || _type:=_b || _type:='' ?};
{? var_pres('_c')=type_of('') || _kind:=_c || _kind:='' ?};

_visited:=~~;
{? var_pres('_d')>100
|| _visited:=_d
|| _visited:=exec('ref_table','#table')
?};

_result:=0;

B_PREL.cntx_psh(); B_PREL.clear();

B_CONN.cntx_psh();
B_CONN.index('TO');

{? B_PREL.seek(_b_prel)
||
   {? _visited.r_find(_b_prel)=0
   || _visited.add(_b_prel);
      B_CONN.prefix(B_PREL.B_PROC,B_PREL.ref());
      {? B_CONN.first()
      || {!
         |?
            {? exec('is_gate_prel','#b_gate',B_CONN.FROM,_type,_kind)>0
            || _result:=1
            ||
::          Jeśli poprzednik jest bramą innego typu niz poszukiwany to sprawdzam czy przed
::          nim nie ma przypadkiem poszukiwanej bramy
               B_PREL.cntx_psh();
               {? B_CONN.FROM().CLASS='B_GATE'
               ||
::                !!! REKURENCJA !!!
                  {? $_b_prel<>$B_CONN.FROM
                  || _result:=exec('has_gate_before','#b_gate',B_CONN.FROM,_type,_kind,_visited)
                  ?}
               ?};
               B_PREL.cntx_pop()
            ?};
            B_CONN.next() & _result=0
         !}
      ?}
   ?}
?};
B_CONN.cntx_pop();
B_PREL.cntx_pop();
_result


\lock
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Blokuje brame
::   WE: _a - B_PREL.ref - jeśli nie będzie bramą to nie zablokuje sie
::       [_b] - INTEGER - czy wyświetlac dialogi (domyślnie 1 - wyświetlac)
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;

{? var_pres('_b')=type_of(0)
|| _display:=_b
|| _display:=1
?};

_result:=0;

B_PREL.cntx_psh(); B_PREL.clear();
{? B_PREL.seek(_b_prel)
||
   {? exec('is_gate','#b_gate',B_PREL.B_ELE)>0
   ||
      _ses_id:=exec('blk_lock','#table','B_PREL',B_PREL.ref(),,2);
      {? _ses_id=SYSLOG.ses_id()
      || _result:=1
      || {? _display>0
         || FUN.emsg(
            'Brama jest redagowana przez użytkownika \''+B_PREL.ses_info(_ses_id,'log_name')+'\' '+
            'na terminalu \''+B_PREL.ses_info(_ses_id,'log_tty')+'\''
            )
         ?}
      ?}
   ?}
?};
B_PREL.cntx_pop();
_result


\unlock
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Odblokowuje brame
::   WE: _a - B_PREL.ref - jeśli nie będzie bramą to nie odblokuje się
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;

B_PREL.cntx_psh(); B_PREL.clear();
{? B_PREL.seek(_b_prel)
|| {? exec('is_gate','#b_gate',B_PREL.B_ELE)>0
   || exec('blk_unlock','#table','B_PREL',B_PREL.ref())
   ?}
?};
B_PREL.cntx_pop();
~~


\run_all_gates
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Dodaje do kolejki uruchomień wszystkie 'URUCHOMIONE' bramy zbierające aby ponownie wykonać analizę
::       czy mogą ruszyć czy nie
::   WE: _a - BI_PROC.ref() - instacja procesu
::       _b - STRING - identyfikator instancji Menadżera
::----------------------------------------------------------------------------------------------------------------------
_bi_proc:=_a;
_mp_uid:=_b;

BI_QUEUE.cntx_psh();
BI_QUEUE.index('BI_PREL');
BI_QUEUE.prefix();
B_PREL.cntx_psh();
BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?};
BI_PREL.index('BISTATUS');
BI_PREL.prefix(_bi_proc,__Status.URUCHOMIONA);
{? BI_PREL.first()
|| _buf_que:=exec('buffer','#bi_queue');
   {!
   |?
::    Sprawdzam czy element jest bramą zbierajacą
      {? exec('is_gate','#b_gate',BI_PREL.B_PREL().B_ELE,exec('type_or','#b_gate'),exec('kind_merge','#b_gate'))>0
      ||
         {? BI_QUEUE.find_key(BI_PREL.ref(),BI_PREL.ses_id(),_mp_uid)
::       Aktualizuje znacznik czasowy
         || BI_QUEUE.TM_STAMP:=BI_PREL.tm_stamp();
            BI_QUEUE.put()
::       Dodaje do kolejki przetwarzania
         || _buf_que.blank();
            _buf_que.BI_PREL:=BI_PREL.ref();
            _buf_que.TM_STAMP:=BI_PREL.tm_stamp();
            _buf_que.SES_ID:=BI_PREL.ses_id();
            _buf_que.TCID:='';
            _buf_que.ALERT:='N';
            _buf_que.UID:=_mp_uid;
            exec('add','#bi_queue',_buf_que)
         ?}
      ?};
      BI_PREL.next()
   !}
?};
BI_QUEUE.cntx_pop();
B_PREL.cntx_pop();
BI_PREL.cntx_pop();
~~


\chk_out_names
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy brama powinna mieć nazwy na strzałkach wychodzących.
::   WE: [_a] - B_PREL.ref lub bieżący rekord
::   WY: 0 - brama nie musi mieć nazw połączeń wychodzących
::       1 - musi
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(B_PREL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

B_PREL.cntx_psh();
{? _ref<>null()
|| B_PREL.clear();
   {? B_PREL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   B_GATE.cntx_psh();
   B_GATE.index('ELEMENT');
   B_GATE.prefix(B_PREL.B_ELE);
   {? B_GATE.first()
   ||
      {? B_GATE.KIND=exec('kind_split','#b_gate') &
         B_GATE.TYPE<>exec('type_and','#b_gate') &
         B_GATE.TYPE<>exec('type_event','#b_gate')
      || _result:=1
      ?}
   ?};
   B_GATE.cntx_pop()
?};
B_PREL.cntx_pop();
_result


\gate_choice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Wyświetla dialog o wybór typu bramy
::   WE: _a - STRING - komunikat
::       _b - INTEGER - numer wyróżnionego przycisku - domyślnie ostatni 'Anuluj'
::       _c - STRING - lista wykluczeń otoczone pałkami | np. '|AND||OR|'
::       _d - opcjonalna nazwa dla przycisku 'Anuluj'
::       _e - tytuł okna
::       zawsze ostatnim przyciskiem będzie 'Anuluj'
::       funkcja zwraca '' dla ESC i przycisku 'Anuluj' bądź nazwę wybranej bramy 'AND','OR','XOR','COMPLEX'
::----------------------------------------------------------------------------------------------------------------------
_default:={? var_pres('_b')=type_of(0) || _b || 5 ?};
_exceptions:='';
{? var_pres('_c')=type_of('')
|| _exceptions:=_c
?};
_ctr_id:=exec('create','#desktop',SYSLOG,'gate_choice',,20,130,_e,,,0,,);
_win_id:='gate_choice';
_gate_num:=5;
_id:=obj_new(_gate_num);
{! _it:=1.._gate_num
|! _id[_it]:='button'+$_it+'@buttons'
!};

_btn:=obj_new(_gate_num);
_gatetype:=obj_new(_gate_num);
_visible:=obj_new(_gate_num);

_it:=1;
_btn[_it]:='Brama XOR'@;
_gatetype[_it]:='|XOR|';
{? _exceptions*_gatetype[_it]>0
|| _visible[_it]:=0
|| _visible[_it]:=1
?};
_it:=2;
_btn[_it]:='Brama OR'@;
_gatetype[_it]:='|OR|';
{? _exceptions*_gatetype[_it]>0
|| _visible[_it]:=0
|| _visible[_it]:=1
?};
_it:=3;
_btn[_it]:='Brama AND'@;
_gatetype[_it]:='|AND|';
{? _exceptions*_gatetype[_it]>0
|| _visible[_it]:=0
|| _visible[_it]:=1
?};
_it:=4;
_btn[_it]:='Brama złożona'@;
_gatetype[_it]:='|COMPLEX|';
{? _exceptions*_gatetype[_it]>0
|| _visible[_it]:=0
|| _visible[_it]:=1
?};
_it:=5;
{? var_pres('_d')=type_of('')
|| _btn[_it]:=_d
|| _btn[_it]:='Anuluj'@
?};
_visible[_it]:=1;

SYSLOG.win_ctr(_ctr_id);
_before:=$("
   exec('load','#desktop','gate_choice','#gate_choice.dsk',,,,,,0);
   exec('set_value','#desktop','','gate_choice','txt@choice','"+gsub(gsub(_a,%92,2*%92),%39,2*%39)+"');
   exec('set_value','#desktop','','gate_choice','"+_id[1]+"','"+gsub(gsub(_btn[1],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','gate_choice','"+_id[1]+"',"+$_visible[1]+");
   exec('set_value','#desktop','','gate_choice','"+_id[2]+"','"+gsub(gsub(_btn[2],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','gate_choice','"+_id[2]+"',"+$_visible[2]+");
   exec('set_value','#desktop','','gate_choice','"+_id[3]+"','"+gsub(gsub(_btn[3],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','gate_choice','"+_id[3]+"',"+$_visible[3]+");
   exec('set_value','#desktop','','gate_choice','"+_id[4]+"','"+gsub(gsub(_btn[4],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','gate_choice','"+_id[4]+"',"+$_visible[4]+");
   exec('set_value','#desktop','','gate_choice','"+_id[5]+"','"+gsub(gsub(_btn[5],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','gate_choice','"+_id[5]+"',"+$_visible[5]+");
   exec('grab_focus','#desktop','','gate_choice','"+_id[_default]+"');
   ctr_ret('');
   1
");
SYSLOG.control(_win_id,'modal=true',_before)

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:09 29b70396fd75c2d7453932695b8e7c8f74fb6c37390af9ba2df3c93bf8a374b8618df4b392d2ec74ebb3eeab13c9e5a26a611e07bd1a5213774e80cbe1a7819c1697924675993054aa81f6c217915ed10df74a2b9951134cedb57f59a6709bfbc9abda29818f41b9652d75e149ea663868e8407059cc57c99652d9e7c7a3e933
