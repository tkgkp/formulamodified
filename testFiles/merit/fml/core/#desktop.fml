:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: #desktop.fml [17.00]
:: Utworzony: 17.12.2014
:: Autor: AK
::======================================================================================================================
:: Zawartość: Uniwersalne formuły do wypełnienia pulpitu
::======================================================================================================================


\create
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla danej tabeli i okna przypisuje kontrolkę pulpitu
::   WE: _a - alias tabeli np. SYSLOG
::       _b - STRING - identyfikator okienka z kontrolką np 'kontrolka1'
::       [_c] - STRING - akronim okna grupowego do którego ma zostać dodana kontrolka
::       [_d] - INTEGER - wysokość okna z kontrolką (domyślnie 10)
::       [_e] - INTEGER - szerokość okna z kontrolką (domyślnie 0 - czyli maksimum)
::       [_f] - STRING - tytuł okna (domyślnie 'PanelPlus')
::       [_g] - STRING - tytuł zakładki na którą zostanie dodana kontrolka
::       [_h] - STRING — sposób, w jaki będzie wyświetlane okienko (tak jak parametr mode metody grp_sel)
::                        domyślnie przyjmowane jest 'maximized'
::       [_i] - INTEGER - 0/1 - czy tworzonemu oknu z kontrolka przypisać identyfikator i zapamiętywać mu ustawienia
::                        (domyślnie 1, czyli zapamiętywanie)
::       [_j] - INTEGER - współrzędnia pozioma okna (domyślnie 0, czyli centrowanie)
::       [_k] - INTEGER - współrzędnia pionowa okna (domyślnie 0, czyli centrowanie)
::       [_l] - RULE - formuła 'przed'
::       [_m] - RULE - formuła 'po'
::       [_n] - STRING - nazwa klasy
::   WY: STRING - akronim okna z kontrolką - wynik mk_ctr
::  OLD: \create/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_win_id:=_b;
_grp:='';
{? var_pres('_c')=type_of('')
|| _grp:=_c
?};
_height:=10;
{? var_pres('_d')=type_of(0)
|| _height:=_d
|? var_pres('_d')=type_of('')
|| _height:=_d
?};
_width:=0;
{? var_pres('_e')=type_of(0)
|| _width:=_e
|? var_pres('_e')=type_of('')
|| _width:=_e
?};
_title:='PanelPlus';
{? var_pres('_f')=type_of('')
|| _title:=_f
?};
_win_tab:=~~;
{? var_pres('_g')=type_of('')
|| _win_tab:=_g
?};
{? var_pres('_h')=type_of('') || _mode:=_h || _mode:='maximized' ?};
_save_win:=1;
{? var_pres('_i')=type_of(0)
|| _save_win:=_i
?};
_wsp_x:=0;
{? var_pres('_j')=type_of(0)
|| _wsp_x:=_j
?};
_wsp_y:=0;
{? var_pres('_k')=type_of(0)
|| _wsp_y:=_k
?};
_before:="";
{? var_pres('_l')=type_of("")
|| _before:=_l
?};
_after:="";
{? var_pres('_m')=type_of("")
|| _after:=_m
?};
_desc_name:='panelplus';

{? var_pres('_n')=type_of('') & _n<>''
|| _class_name:=_n+':'+_desc_name
|| _class_name:='org.mcl.czest.xdesk.core.app.DesktopControl:'+_desc_name;
   {? exec('interm','#system')>0
   || _class_name:='org.mcl.czest.xdesk.interm.app.DesktopControlIn:'+_desc_name
   |? user(11)>'18.14'
   || _class_name:='org.mcl.czest.xdesk.core.app.DesktopControlAT:'+_desc_name
   ?}
?};

:: utworzenie okna z kontrolką
_id:='';
{? _save_win>0
|| _id:='#'+_win_id
?};
_mode_mk:=_mode;
{? _mode_mk='maximized_with_title'
|| _mode_mk:='maximized'
?};
_ctr:=_table.mk_ctr(_title,_id,_wsp_x,_wsp_y,_width,_height,_mode_mk);

:: przypisanie do tabeli okna z kontrolką - uwaga może być tylko jedna kontrolka dla tabeli
_table.win_cctr(_ctr,_win_id,_class_name);

{? _grp<>''
|| {? _win_tab<>~~
   || _table.grp_ctr(_grp,,_ctr,_win_id,_win_tab,,,,,_height,_before,_after,,_mode)
   || _table.grp_ctr(_grp,,_ctr,_win_id,        ,,,,,_height,_before,_after,,_mode)
   ?}
?};

:: kontrolka w javie z pulpitem będzie wywoływała tę formułę do komunikacji z mbase
_table.win_cfml(_ctr,_win_id,'CONTROL_CALLBACK',"params_set(params_get());exec('bridge','#desktop')");

_ctr


\create_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Tworzy okno grupowe i osadza kontrolkę z pulpitem wewnątrz niego
::   WE: _a - STRING - identyfikator okienka z kontrolką np 'kontrolka1'
::       _b - formula - formula inicjująca okno (musi zawierać exec('load','#desktop'...))
::       [_c] - INTEGER - wysokość okna z kontrolką (domyślnie 10)
::       [_d] - INTEGER - szerokość okna z kontrolką (domyślnie 0 - czyli maksimum)
::       [_e] - STRING - tytuł okna (domyślnie 'PanelPlus')
::       [_f] - INTEGER - współrzędna pionowa okienka (domyślnie 20)
::       [_g] - INTEGER - współrzędna pozioma okienka (domyślnie 5)
::       [_h] - FORMULA - formuła na zamkniecie okienka
::       [_i] - STRING - layout - lumen/jterm
::   WY: STRING - uchwyt do tabeli wertowanej (obecnie zawsze SYSLOG)
::  OLD: \create_grp/desktop
::----------------------------------------------------------------------------------------------------------------------
_win_id:=_a;
_init:=_b;

_grp:='';
_height:=10;
{? var_pres('_c')=type_of(0)
|| _height:=_c
?};
_width:=0;
{? var_pres('_d')=type_of(0)
|| _width:=_d
?};
_title:='PanelPlus';
{? var_pres('_e')=type_of('')
|| _title:=_e
?};
_wsp_x:=20;
{? var_pres('_f')=type_of(0)
|| _wsp_x:=_f
?};
_wsp_y:=5;
{? var_pres('_g')=type_of(0)
|| _wsp_y:=_g
?};
_close:="";
{? var_pres('_h')=type_of("")
|| _close:=_h
?};
_layout:='';
{? var_pres('_i')=type_of('')
|| _layout:=_i
?};

:: tworzę okno grupowe
{? _layout<>''
|| _grp:=SYSLOG.grp_make(_title,_init,'#'+_win_id,_wsp_x,_wsp_y,_close,,'normal',_layout)
|| _grp:=SYSLOG.grp_make(_title,_init,'#'+_win_id,_wsp_x,_wsp_y,_close,,'normal')
?};
SYSLOG.win_sel(_grp);

:: tworzę kontrolkę i dodaję do okna grupowego
_ctr:=exec('create','#desktop',SYSLOG,_win_id,_grp,_height,_width,_title);

:: przypisuję okno z kontrolką do tabeli SYSLOG
SYSLOG.win_ctr(_ctr);
SYSLOG


\load
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Wczytuje do kontrolki PanelPlus o danej nazwie plik z pulpitem
::   WE: _a - nazwa kontrolki w oknie
::       _b - nazwa pliku z pulpitem np. 'desktop.dsk'
::       [_c] - obj_new - tablica nazwana z opcjami które przekazać kontrolce pulpitu
::       [_d] - STRING - jeśli okno pulptitu z zakładkami, to nazwa zakładki na której zostanie
::                       załadowany pulpit
::       [_e] - STRING - '0'/['1']/'2' - pozwalaj na załadowanie pliku użytkownika zamiast normalnej definicji
::       [_f] - STRING - ścieżka do pliku dsku po stronie serwera, jeżeli podana to kopiowanie do katalogu
::                       work nie jest robione za pomocą pth i bloba, tylko za pomocą tej ścieżki. Jest to zrobione po to
::                       aby admin mógł modyfikować pliki dsku innych użytkowników
::       [_g] - tab_tmp - tabela - wynik formuły exec('elements_table','#desktop')
::       [_h] - czy wykonać update elementów pulpitu
::       [_i] - czy użyć pliku z definicją pulpitu wg wskazanej nazwy, nawet jak jest plik z warstwy modified
::       [_j] - INTEGER - [0]/1 - czy ładować standardowy zestaw ikon
::  OLD: \load/desktop.fml
:: ~OST: INFCOPY,INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=_a;

{? var_pres('_i')=type_of(0)
|| _forced:=_i
|| _forced:=0
?};
_desk_name:={? _forced || _b || __FileLayer.real_name(_b-4,_b+3) ?};

_orginal_name:=_desk_name;

_options:=~~;
{? var_pres('_c')>100
|| _options:=_c
::|| _options:=exec('set_options_a','#desktop')
?};

_zakladka:='';
{? var_pres('_d')=type_of('')
|| _zakladka:=_d
?};

_allow_user:='1';
{? var_pres('_e')=type_of('')
|| _allow_user:=_e
?};

_dsku_admin_path:='';
{? var_pres('_f')=type_of('')
|| _dsku_admin_path:=_f
?};

_tab:=~~;
{? var_pres('_g')=type_of(SYSLOG)
|| _tab:=_g;
   _update:=1;
   {? var_pres('_h')=type_of(0)
   || _update:=_h
   ?}
|| _update:=1;
   {? var_pres('_h')=type_of(0)
   || _update:=_h
   ?};
   {? _update>0
   || FUN.wdrerror('Desktop: %1 — należy dodać tłumaczenia.'[_desk_name]);
      _update:=0
   ?}
?};

_icons:=0;
{? var_pres('_j')=type_of(0)
|| _icons:=_j
?};

{? exec('interm','#system')>0
|| exec('load_interm','#desktop',_ctr_id,_desk_name,_options,_tab,_update,_forced);
   return()
?};

_window_id:='';
{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_separator:=exec('sep','#file');

:: wywołanie funkcji z kontrolki - ustawienie trybu pracy
{? sec_superuser()>0
||
:: tryb projektowania możliwy tylko dla użytkowników specjalnych
   ctr_set(_window_id,_ctr_id,'setDesignerAllowed','true')
?};

:: ustawiam id kontrolki żeby java też wiedziała (potrzebne do wymiany danych)
ctr_set(_window_id,_ctr_id,'setControlID',_ctr_id);

_blob_refresh:=1;

{? _allow_user='1'
||
:: Najpierw sprawdzam czy istnieje plik użytkownika dla tego pulpitu, jeżeli tak to będę wczytywał go
   {? exec('interm','#system')=0
   ||
      _files:=files(exec('get_user_name','#desktop',_desk_name));
      {? _files.first()
      || _desk_name:=_files.FILENAME;

         _usr_m_date:=exec('info','#blob',_desk_name,'MODIFY_DATE');
         _usr_m_time:=exec('info','#blob',_desk_name,'MODIFY_TIME');

         _def_m_date:=exec('info','#blob',_orginal_name,'MODIFY_DATE');
         _def_m_time:=exec('info','#blob',_orginal_name,'MODIFY_TIME');

         _tm_user:=exec('create','#tm_stamp',_usr_m_date,_usr_m_time);
         _tm_def:=exec('create','#tm_stamp',_def_m_date,_def_m_time);

         {? _tm_def>_tm_user;0
         ||
::          Jeżeli definicja ogólna została zapisana później niż zmiany uzytkownika to znak że zmiany
::          użytkownika są już nieaktualne i trzeba wyczyścić plik użytkownika
            {? ferase(_desk_name,1)
            ||
::             Usuwam plik z bloba
               exec('add','#blob',_desk_name,1,1)
            ?};
            _desk_name:=_orginal_name
         ?}
      ?}
   ?}
|? _allow_user='2'
||
:: Ładujemy na siłę plik użytkownika, bez kontroli i sprawdzania czy istnieje
   _desk_name:=_orginal_name;
   _blob_refresh:=0
?};

{? _dsku_admin_path<>''
|| ctr_set(_window_id,_ctr_id,'setAdminPath',_dsku_admin_path)
?};

:: odświeżam plik w blobie lub usuwam go jeśli nie ma go już na dysku
{? _blob_refresh>0
|| exec('add','#blob',_desk_name,1,1)
?};

:: przekazuje kontrolce opcje
{? type_of(_options)>100
|| exec('set_options','#desktop',_options,_window_id,_ctr_id)
?};

_desk_file:=tmp_dir()+_separator+_desk_name;
{? exec('get','#blob',_desk_name,0)>0
|| _hash:='';
   {? fexists(_desk_name,1)
   || _file:=fopen(_desk_name,'br',1,,1);
      {? _file.is_open()
      || _hash:=hash(_file,'sha512');
         _file.fclose();
         &_file
      ?}
   ?};
:: wywołanie funkcji z kontrolki - ładowanie pulpitu
   ctr_set(_window_id,_ctr_id,'loadDesktop',_desk_file,_zakladka,_orginal_name,_hash)
||
:: jesli pliku jeszcze nie ma to kontrolce w javie mówię gdzie powinien być i jak się powinien nazywać
   ctr_set(_window_id,_ctr_id,'designDesktop',_desk_file,_zakladka,_orginal_name)
?};

{? _update
|| exec('update','#desktop',_tab,_ctr_id)
?};

{? _icons>0
||
:: Ładowanie ikon
   _file_icon:='xwin16.png';
   _filepath:=tmp_dir()+_separator+_file_icon;

   exec('add','#blob',_file_icon,1,1);
   {? exec('get','#blob',_file_icon,0)>0
   ||
::   fcopy(_file,'@'+_filepath,1,0,1);
      exec('set_icons','#desktop','',_ctr_id,_filepath)
   ?};
   ~~
?};
~~


\load_interm
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [22.26]
:: OPIS: Wczytuje do kontrolki PanelPlus plik z pulpitem na interm
::   WE: _a - nazwa kontrolki w oknie
::       _b - nazwa pliku z pulpitem np. 'desktop.dsk'
::       [_c] - obj_new - tablica nazwana z opcjami które przekazać kontrolce pulpitu
::       [_d] - tab_tmp - tabela - wynik formuły exec('elements_table','#desktop')
::       [_e] - czy wykonać update elementów pulpitu
::       [_f] - czy użyć pliku z definicją pulpitu wg wskazanej nazwy, nawet jak jest plik z warstwy modified
::  OLD: \load/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=_a;

{? var_pres('_f')=type_of(0)
|| _forced:=_f
|| _forced:=0
?};
_desk_name:={? _forced || _b || __FileLayer.real_name(_b-4,_b+3) ?};

_orginal_name:=_desk_name;

_options:=~~;
{? var_pres('_c')>100
|| _options:=_c
?};

_tab:=~~;
{? var_pres('_d')=type_of(SYSLOG)
|| _tab:=_d;
   _update:=1;
   {? var_pres('_e')=type_of(0)
   || _update:=_e
   ?}
|| _update:=1;
   {? var_pres('_e')=type_of(0)
   || _update:=_e
   ?};
   {? _update>0
   || FUN.wdrerror('Desktop: %1 — należy dodać tłumaczenia.'[_desk_name]);
      _update:=0
   ?}
?};

_window_id:='';
{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_separator:=exec('sep','#file');

:: wywołanie funkcji z kontrolki - ustawienie trybu pracy
{? sec_superuser()>0
||
:: tryb projektowania możliwy tylko dla użytkowników specjalnych
   ctr_set(_window_id,_ctr_id,'setDesignerAllowed','true')
?};

:: ustawiam id kontrolki żeby java też wiedziała (potrzebne do wymiany danych)
ctr_set(_window_id,_ctr_id,'setControlID',_ctr_id);

_blob_refresh:=1;

:: odświeżam plik w blobie lub usuwam go jeśli nie ma go już na dysku
{? _blob_refresh>0
|| exec('add','#blob',_desk_name,1,1)
?};

:: przekazuje kontrolce opcje
{? type_of(_options)>100
|| exec('set_options','#desktop',_options,_window_id,_ctr_id)
?};

_desk_file:=exec('tmp_filepath','#file',_desk_name);
{? exec('get','#blob',_desk_name,0)>0
||
   _hash:='';
   {? fexists(_desk_name,1)
   || _file:=fopen(_desk_name,'b',1,,1);
      {? _file.is_open()
      || _hash:=hash(_file,'sha512');
         _file.fclose();
         &_file
      ?}
   ?};
:: wywołanie funkcji z kontrolki - ładowanie pulpitu
   ctr_set(_window_id,_ctr_id,'loadDesktop',_desk_file,'',_orginal_name,_hash)
|| FUN.emsg('Brak pliku: %1. Projektowanie w %2 niedostępne.'@[_desk_name,'inTerm'])
?};

{? _update
|| exec('update','#desktop',_tab,_ctr_id)
?};
~~


\save
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zapisuje pulpit w bazie (SYSBLOB) i umieszcza go na serwerze zgodnie z pth
::   WE: _a - STRING - nazwa pliku w katalogu tymczasowym !@Tmp
::       _b - STRING - tryb zapisu: 'DSK'  - normalna definicja
::                                  'DSKU' - plik uzytkownika
::       [_c] - STRING - ścieżka do pliku dsku po stronie serwera, jeżeli podana to kopiowanie do katalogu
::                       work nie jest robione za pomocą pth i bloba, tylko za pomocą tej ścieżki. Jest to zrobione po to
::                       aby admin mógł modyfikować pliki dsku innych użytkowników
::   WY: STRING - '0' - porażka
::                '1' - sukces
::  OLD: \save/desktop
:: ~OST: INFCOPY,INFERASE,INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_filename:=_a;
_mode:=_b;

{? exec('interm','#system')>0
|| return('0')
?};

_dsku_admin_path:='';
{? var_pres('_c')=type_of('')
|| _dsku_admin_path:=_c
?};
_result:='0';
_can_continue:=1;

_sep:=exec('sep','#file');

{? _mode='DSKU'
||
:: Jeśli zapisywany jest plik użytkownika to zamieniam mu nazwę
   _newfilename:=exec('get_user_name','#desktop',_filename);
   {? _filename<>_newfilename
   ||
      {? fcopy('@'+tmp_dir()+_sep+_filename,'@'+tmp_dir()+_sep+_newfilename,0,0,1)>0
      ||
::       Kasuję plik dsk bez inicjałów użytkownika po stronie terminalu, bo będzie on niepotrzebny
         ferase('@'+tmp_dir()+_sep+_filename,0);
         _filename:=_newfilename
      ?}
   ?}
||
:: Jeżeli zapamiętywany jest plik ogólny to sprawdzam czy są jakieś pliki użytkowników
   _files:=files(exec('get_user_name','#desktop',_filename));
   {? _files.first()
   ||
      _loop:=1;
      {!
      |?
         _msg:='Użytkownicy nanieśli swoje zmiany na zapisywane okno. Zdecyduj co zrobić ze zmianami użytkowników.'@;
         _choice:=FUN.choice(_msg,,'Szczegóły'@+'…','Usuń zmiany'@,'Pozostaw zmiany'@);

         {? _choice=1
         ||
::          Wyświetlam szczegóły
            exec('select','#desktop',_filename)
         |? _choice=2
         || _loop:=0;
            {!
            |?
               {? ferase(_files.FILENAME,1)
               ||
::                Usuwam plik z bloba
                  exec('add','#blob',_files.FILENAME,1,1)
               ?};
               _files.next()
            !}
         |? _choice=3
         || _loop:=0;
            _can_continue:=1
         || _loop:=0;
            _can_continue:=0
         ?};
         _loop>0
      !}
   ?};

   {? _can_continue>0
   ||
      {? _filename+6='.m.dsk'
      || _can_continue:=FUN.ask('Definicja pulpitu w wersji zmodyfikowanej.\n\nCzy zapisać plik?'@)
      ||
::         FUN.STANDARD:=1;
         _choice:=FUN.choice(
            'Definicja pulpitu w wersji standardowej.\n\nCzy zapisać plik w wersji:'@,,
            '&standardowej'@,'z&modyfikowanej'@
         );
         {? _choice=0
         || _can_continue:=0
::       Kopia pliku .dsk -> .m.dsk
         |? _choice=2
         || _old_filename:=_filename;
            _filename:=(_filename-4)+'.m.dsk';
            _can_continue:=fcopy('@'+tmp_dir()+_sep+_old_filename,'@'+tmp_dir()+_sep+_filename,0,0,1)
         ?}
      ?}
   ?}
?};

{? _can_continue>0
||
:: wciągam plik do bloba
   _can_continue:=exec('add','#blob',_filename,1,0);

   {? _can_continue>0
   ||
      {? _dsku_admin_path<>''
      ||
::       wrzucam bezpośrednio do katalogu work
         _can_continue:=fcopy('@'+tmp_dir()+_sep+_filename,_dsku_admin_path,0,0,1)
      ||
::       z bloba wrzucam plik na serwer do katalogu work
         _can_continue:=exec('get','#blob',_filename,1)
      ?}
   ?};

   {? _can_continue>0
   || _result:='1'
   || _msg0:='';
      _msg1:='Zapisanie zmian nie powiodło się!'@;
      _msg2:='Lokalny plik zawierający definicję pulpitu, nie został poprawnie zapisany na serwerze.'@;
      _msg3:='Po zamknięciu okna z pulpitem, wszystkie dokonane zmiany zostaną utracone!'@;
      _msg4:='Plik definicji pulpitu: %1'@[_filename];
      _msg_glued:=exec('form','#string','L',_msg1
                                          ,_msg0
                                          ,_msg2
                                          ,_msg3
                                          ,_msg0
                                          ,_msg4);
      FUN.error(_msg_glued)
   ?}
?};
_result


\get_user_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Z nazwy pliku .dsk tworzy nazwę dla użytkownika, lub maskę nazw dla użytkownika
::   WE: _a - STRING - nazwa pliku .dsk
::       [_b] - INTEGER - 0/[1] - czy doklejać rozszerzenie
::   WY: STRING - nowa nazwa dla użytkownika
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_filename:=_a;

USERS.cntx_psh();
_extension:=1;
{? var_pres('_b')=type_of(0)
|| _extension:=_b
?};

_sep:='~~';

{? _filename*'.dsku'>0
|| _desk_name:=gsub(_filename,'.dsku','')
|? _filename*'.dsk'>0
|| _desk_name:=gsub(_filename,'.dsk','')
?};

:: Sprawdzam czy nazwa pliku ma już w sobie użytkownika
_has_user:=0;
_split:=spli_str(_desk_name,_sep);
{? obj_len(_split)>1
||
   USERS.cntx_psh();
   USERS.index('USR_KKOD');
   {! _it:=1..obj_len(_split)
   |! _str:=_split[_it];
      USERS.prefix(_str,_str);
      {? USERS.size()>0
      || _has_user:=1
      ?}
   !};
   USERS.cntx_pop();
   ~~
?};

{? _has_user=0
|| _newfilename:=_desk_name+_sep+OPERATOR.USER().KOD+_sep+SYSLOG.ses_info(SYSLOG.ses_id,'log_tty')
|| _newfilename:=_desk_name
?};

{? _extension>0
|| _newfilename+='.dsku'
?};
USERS.cntx_pop();
_newfilename


\bridge
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Formula wywolywana z javy po wykonaniu akcji na elemencie pulpitu
::       W niej muszą się znależć wszystkie dowiązania akcji pulpitu do rzeczywistych formuł
::   WE: _a - STRING - id akcji dla elementu pulpitu
::  OLD: \bridge/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_action_id:=ctr_info('action_id');

:: uruchamianie formuł
_formula:=ctr_info('formula');
_nazwa:=ctr_info('element_name');
_type:=ctr_info('element_type');

_arg_count:=ctr_info('argFCount');
{? _arg_count=''
|| _arg_count:='0'
?};
:: zapis pulpitu
_save_file:=ctr_info('save_file');

:: przesyłanie danych
_data_id:=ctr_info('data_id');
_table:=ctr_info('data_table');
_fields:=ctr_info('data_fields');
_ctr_id:=ctr_info('ctr_id');
_prefix:=ctr_info('prefix');
_pref_ref:=ctr_info('prefix_ref');
_file_location:=ctr_info('file_location');
_element_id:=ctr_info('element_id');

_result:=~~;
{? _ctr_id*'desktop:'>0
||
:: obługa kontrolki na pulpicie, jeśli jest niewidoczna, to nie ma sensu uruchamiać akcji
   {? exec('pulpit_visible','#desktop','',_ctr_id)=0 & exec('pulpit_hidden_executor','#desktop','',_ctr_id)=0
   || return(_result)
   ?}
?};

:: obsługa zapisywania definicji pulpitu w bazie
{? _save_file<>''
|| _result:=exec('save','#desktop',_save_file,ctr_info('formula_arg1'),ctr_info('formula_arg2'));
   return(_result)
?};

:: jeśli formuła podana bezpośrednio to ją wykonuję
{? _formula<>''
|| _formula:='params_set(params_get());'+_formula;
   _fml:='(params_set(params_get());$_a)(';
   {? #_arg_count>0
   || {! _it:=1..#_arg_count
      |! _fml+='ctr_info(\'formula_arg'+$_it+'\'),'
      !};
      _fml:=_fml-1;
      _fml+=')'
   || _fml+=')'
   ?};
   _result:=($_fml)(_formula);
   return(_result)
?};

:: jeśli mechanizm przesyłania danych to wywołuje wystawienie danych
{? _data_id<>''
|| {? _type='TextPanePanel'
   || _result:=exec('fetch_sysmemo','#desktop',_table,_fields,_prefix,_pref_ref)
   || _result:=exec('fetch_data','#desktop',_data_id,_ctr_id,_table,_fields,_prefix)
   ?};
   return(_result)
?};
_result


\fetch_data
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Wystawia dane do pobrania przez kontrolkę pulpitu
::   WE: _a - STRING - identyfikator przesyłania danych
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - akronim (albo alias) tabeli której dane wystawić
::       _d - STRING - kolejne pola tabeli które wystawić - separowane znakiem ','
::       _e - STRING - formuła wykonywana przed wystawieniem danych - np w celu prefixowania danych
::  OLD: \fetch_data/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_data_id:=_a;
_ctr_id:=_b;
_table:={? var_pres('_c')=2 || ($_c)()
        |? var_pres('_c')=3 || _c()
        |? var_pres('_c')=type_of(SYSLOG) || _c
        || return(0)
        ?};
_fields:=gsub(_d,',,',',');
_fields:=gsub(_fields,',',''',''');
_prefix:=_e;

_table.cntx_psh();
($_prefix)();

{? _ctr_id*'desktop:'>0
||
:: Jeżeli kontrolka na pulpicie, to specjalna obsługa wystawiania danych dla pulpitu
   {? type_of(_table)=type_of(SYSLOG)
   || _rule:=$("ctr_tab('"+_data_id+"','!desktop','"+_ctr_id+"',,_a,'"+_fields+"')");
      _rule(_table)
   ?}
||
   {? type_of(_table)=type_of(SYSLOG)
   || _rule:=$("ctr_tab('"+_data_id+"',,'"+_ctr_id+"',,_a,'"+_fields+"')");
      _rule(_table)
   ?}
?};
_table.cntx_pop();
~~


\track_file
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: [WH] [18.22]
:: OPIS: Formuła śledząca plik, która w przypadku wykrycia zmian w jego rozmiarze,
::       tworzy jego lokalną kopię w katalogu tymczasowym na końcówce
::   WE:  _a  - STRING - nazwa/ścieżka śledzonego pliku
::        _b -  STRING - ostatnio odczytany przez kontrolkę po stronie javy rozmiar śledzonego pliku
::        _c -  STRING - login usera którego plik wycztać, jeśli nie podane to aktualnego
::       [_d] - STRING -  '1' - kopia zawiera wyłącznie fragment dopisany do pliku
::                        '0' - (wartość domyślna) kopia zawiera cały plik
::       [_e] - STRING - ścieżka do folderu tymczasowego do którego zostanie skopiowany log (domyślnie '@'+tmp_dir())
::   WY: STRING - lokalizacja wykonanej kopii pliku, lub pusty napis w przypadku
::                problemów z otworzeniem pliku źródłowego.
:: ~OST: INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_filename:=_a;
_lastjavasize:=#_b;
_user:='';
{? var_pres('_c')=type_of('')
|| _user:=_c
?};

{? var_pres('_d')=type_of('')
|| _only_changes:=#_d
|| _only_changes:=0
?};

{? var_pres('_e')=type_of('')
|| _tmp_pth:=_e
|| _tmp_pth:='@'+tmp_dir()
?};

_can_continue:=1;

_separator:='';
{? 1+_tmp_pth='@'
|| _separator:=exec('sep','#file')
|| _separator:=exec('sep','#file',2)
?};

_temp:='';
{? _tmp_pth<>''
|| {? _only_changes>0
   || _temp:=_tmp_pth+_separator+'part_'+_filename
   || _temp:=_tmp_pth+_separator+_filename
   ?}
?};

_filepath_user:='';
{? _user<>''
|| _separator:=exec('sep','#file',1);
   _dir:=pth_dir(_filename)-(+OPERATOR.USER().KOD);
   _filepath_user:=_dir+_separator+_user+_separator+_filename;
   _handle_server:=fopen(_filepath_user,'br',0)
|| _handle_server:=fopen(_filename,'br',1)
?};

:: Najpierw sprawdzam, czy plik da się otworzyć. Jeżeli tak, to zapamiętuję jego rozmiar.
:: Jeżeli zmienna globalna __tracked jeszcze nie istnieje, to ją inicjalizuję.

{? _can_continue>0 & _handle_server>0
|| _size:=fgetsize(_handle_server);
   {? _size<>_lastjavasize
   ||
::    Plik od ostatniego odczytu go przez kontrolkę po stronie javy zmienił rozmiar więc
::    ciągnę go z serwera na terminal
      {? _only_changes>0
      ||
         {? _lastjavasize=0
         ||
::          Jeżeli z javy przyszło -1 to znak, że to pierwszy odczyt, więc ustawiam się na końcu
::          pliku
            _lastjavasize:=_size
         ?};

::       Tryb przyrostowo - otwieram plik oryginalnego loga na serwerze
         {? _lastjavasize>=0
         || fseek(_handle_server,_lastjavasize)
         ?};

         _file_server:=$SYSLOG.tm_stamp()+'.part';
         _temp_server:=fopen(_file_server,'bw',1);
         {? _temp_server>0
         || _buf:=obj_new(1024);
            {!
            |? _count:=fread(_handle_server,,_buf);
               {? _count>0
               || fwrite(_temp_server,_buf,_count)
               ?};
               _count>0
            !};
            fclose(_temp_server)
         || _can_continue:=0
         ?};

         {? _can_continue>0
         || {? fcopy(_file_server,_temp,1,0,1)
            || _result:=_temp+'###'+$_size;
               ferase(_file_server,1)
            ?}
         ?};
         ~~
      ||
::       Tryb całego pliku - kopiuje go na terminal
         {? _filepath_user<>''
         || {? fcopy(_filepath_user,_temp,0,0,1)
            || _result:=_temp+'###'+$_size
            ?}
         || {? fcopy(_filename,_temp,1,0,1)
            || _result:=_temp+'###'+$_size
            ?}
         ?}
      ?}
   ?};
   fclose(_handle_server)
|| FUN.info('Nie udało się otworzyć pliku: %1'@[_filename]);
   _can_continue:=0
?};
{? _can_continue=0
|| _result:='error'
?};
_result


\test
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Formuła testowa
::  OLD: \test/desktop
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=exec('create','#desktop',SYSLOG,'test1',,40);
_win_id:='kontrolka1';
SYSLOG.win_ctr(_ctr_id);
_before:="
::            exec('set_value','#desktop','','test1','1337083212539','material00000004');
::            exec('set_enabled','#desktop','','test1','',0);
::            exec('set_visible','#desktop','','test1','',0);

            exec('set_foreground','#desktop','','test1','i83el09f0ng2h8062b02e99h781g','255:0:0');
            exec('set_background','#desktop','','test1','i83el09f0ng2h8062b02e99h781g','255:200:0');
            exec('set_name','#desktop','','test1','i83el09f0ng2h8062b02e99h781g','Zmiana');

            exec('set_foreground','#desktop','','test1','23k8kigml9k2hanldbll5ggm9eba6','255:0:0');
            exec('set_background','#desktop','','test1','23k8kigml9k2hanldbll5ggm9eba6','255:200:0');
            exec('set_name','#desktop','','test1','23k8kigml9k2hanldbll5ggm9eba6','Zmiana');


            exec('set_foreground','#desktop','','test1','1l9ecmn2n805mif4hh5h5ngged27j','255:0:0');
            exec('set_background','#desktop','','test1','1l9ecmn2n805mif4hh5h5ngged27j','255:200:0');
            exec('set_name','#desktop','','test1','1l9ecmn2n805mif4hh5h5ngged27j','Zmiana');

            exec('set_foreground','#desktop','','test1','jdhghb35b50i23jd6hm6mdd1ng52','255:0:0');
            exec('set_background','#desktop','','test1','jdhghb35b50i23jd6hm6mdd1ng52','255:200:0');
            exec('set_name','#desktop','','test1','jdhghb35b50i23jd6hm6mdd1ng52','Zmiana');

            exec('set_foreground','#desktop','','test1','2hfbl9fe4nni0b3ii5n013b2nbfmf','255:0:0');
            exec('set_background','#desktop','','test1','2hfbl9fe4nni0b3ii5n013b2nbfmf','255:200:0');
            exec('set_name','#desktop','','test1','2hfbl9fe4nni0b3ii5n013b2nbfmf','Zmiana');

            exec('set_foreground','#desktop','','test1','2a5llngacbl86li0fibdd100ckg13','255:0:0');
            exec('set_background','#desktop','','test1','2a5llngacbl86li0fibdd100ckg13','255:200:0');
            exec('set_name','#desktop','','test1','2a5llngacbl86li0fibdd100ckg13','Zmiana');

            exec('set_foreground','#desktop','','test1','g5jhf38b0mkgd4cclddgiah0eah9','255:0:0');
            exec('set_background','#desktop','','test1','g5jhf38b0mkgd4cclddgiah0eah9','255:200:0');
            exec('set_name','#desktop','','test1','g5jhf38b0mkgd4cclddgiah0eah9','Zmiana');

            exec('set_foreground','#desktop','','test1','g35mh67a7db4j3nflda850mn0d4b','255:0:0');
            exec('set_background','#desktop','','test1','g35mh67a7db4j3nflda850mn0d4b','255:200:0');
            exec('set_name','#desktop','','test1','g35mh67a7db4j3nflda850mn0d4b','Zmiana');

            exec('set_foreground','#desktop','','test1','bg540c70aecfaffm18edfn663ija','255:0:0');
            exec('set_background','#desktop','','test1','bg540c70aecfaffm18edfn663ija','255:200:0');
            exec('set_name','#desktop','','test1','bg540c70aecfaffm18edfn663ija','Zmiana');

            exec('set_foreground','#desktop','','test1','13jg69gjaiim61akl89jnld412na4','255:0:0');
            exec('set_background','#desktop','','test1','13jg69gjaiim61akl89jnld412na4','255:200:0');
            exec('set_name','#desktop','','test1','13jg69gjaiim61akl89jnld412na4','Zmiana');

            exec('set_foreground','#desktop','','test1','1jn5fhe86m1g043m2fdj6g2j159a6','255:0:0');
            exec('set_background','#desktop','','test1','1jn5fhe86m1g043m2fdj6g2j159a6','255:200:0');
            exec('set_name','#desktop','','test1','1jn5fhe86m1g043m2fdj6g2j159a6','Zmiana');

            exec('set_foreground','#desktop','','test1','2deb8edjn8mj7blm925fka8l13699','255:0:0');
            exec('set_background','#desktop','','test1','2deb8edjn8mj7blm925fka8l13699','255:200:0');
            exec('set_name','#desktop','','test1','2deb8edjn8mj7blm925fka8l13699','Zmiana');

            exec('set_foreground','#desktop','','test1','13mdn2n48mcl653h56mbii4a7bjjn','255:0:0');
            exec('set_background','#desktop','','test1','13mdn2n48mcl653h56mbii4a7bjjn','255:200:0');
            exec('set_name','#desktop','','test1','13mdn2n48mcl653h56mbii4a7bjjn','Zmiana');

            exec('set_foreground','#desktop','','test1','kc3134nndhc81hgbffjkh54ii7bm','255:0:0');
            exec('set_background','#desktop','','test1','kc3134nndhc81hgbffjkh54ii7bm','255:200:0');
            exec('set_name','#desktop','','test1','kc3134nndhc81hgbffjkh54ii7bm','Zmiana');

            exec('set_foreground','#desktop','','test1','15jif137nd073lc58fja3d3g0l7k5','255:0:0');
            exec('set_background','#desktop','','test1','15jif137nd073lc58fja3d3g0l7k5','255:200:0');
            exec('set_name','#desktop','','test1','15jif137nd073lc58fja3d3g0l7k5','Zmiana');

            exec('set_foreground','#desktop','','test1','19df07hf7nbbin9f7d95bad0j9f96','255:0:0');
            exec('set_background','#desktop','','test1','19df07hf7nbbin9f7d95bad0j9f96','255:200:0');
            exec('set_name','#desktop','','test1','19df07hf7nbbin9f7d95bad0j9f96','Zmiana');

            exec('set_value','#desktop','','test1','edytor@desktop','file='+'p:/edytor.html');

            exec('load','#desktop','test1','test.dsk',,,,,,0);
            exec('set_value','#desktop','','test1','b0d77bndfhnnj091m0g5cefm1e3m','true');
::            exec('set_value','#desktop','','test1','1337083173446','200');
            exec('clip_set_txt','#desktop','','test1','qweqweiuyi');
            1";

SYSLOG.control(_win_id,'modal=false',_before);
~~


\test_interm
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Formuła testowa
::  OLD: \test/desktop
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=exec('create','#desktop',SYSLOG,'test1',,30,70,,,'normal');
_win_id:='kontrolka1';
SYSLOG.win_ctr(_ctr_id);
_before:="
   exec('load','#desktop','test1','test_interm.dsk',,,,,,0);
   1
";

SYSLOG.control(_win_id,'modal=false',_before);
~~


\test_parses
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Formuła testowa
::  OLD: \test/desktop
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=exec('create','#desktop',SYSLOG,'test1',,33,,,,'normal');
_win_id:='kontrolka1';
SYSLOG.win_ctr(_ctr_id);
_before:="
   exec('load','#desktop','test1','widget_parses.dsk',,,,,,0);
   1
";

SYSLOG.control(_win_id,'modal=false',_before);
~~


\test_timer
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Formuła testowa
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=exec('create','#desktop',SYSLOG,'test_timer',,40);
_win_id:='kontrolka1';
SYSLOG.win_ctr(_ctr_id);
_before:="
            exec('load','#desktop','test_timer','test_timer.dsk',,,,,,0);
            1";

SYSLOG.control(_win_id,'modal=false',_before);
~~



\test_calendar
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Formuła testowa
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=exec('create','#desktop',SYSLOG,'test_calendar',,40);
_win_id:='kontrolka1';
SYSLOG.win_ctr(_ctr_id);

_env:=obj_new(
               'DATY'
               ,'POS'
               ,'WEEKS'
               ,'ROW_COUNT'
               ,'ctr_id'
);

_env.DATY:=tab_tmp(1
:: 'POLE','TYP','Nazwa w oknie',
   ,'ID','STRING[20]','Nazwa pola 2'
   ,'DESC','STRING[255]','Nazwa pola 1'
   ,'TOOLTIP','STRING[255]','Nazwa pola 1'
   ,'COL_BCK','STRING[20]','Nazwa pola 1'
   ,'COL_TXT','STRING[20]','Nazwa pola 1'
   ,'BOR_SIZE','INTEGER','Nazwa pola 1'
   ,'BOR_COL','STRING[20]','Nazwa pola 1'
);
_env.WEEKS:=tab_tmp(1
:: 'POLE','TYP','Nazwa w oknie',
   ,'ID','STRING[20]','Nazwa pola 2'
   ,'DESC','STRING[255]','Nazwa pola 1'
   ,'TOOLTIP','STRING[255]','Nazwa pola 1'
   ,'COL_BCK','STRING[20]','Nazwa pola 1'
   ,'COL_TXT','STRING[20]','Nazwa pola 1'
   ,'BOR_SIZE','INTEGER','Nazwa pola 1'
   ,'BOR_COL','STRING[20]','Nazwa pola 1'
);

_env.POS:=tab_tmp(1
:: 'POLE','TYP','Nazwa w oknie',
   ,'ID','STRING[20]','Nazwa pola 2'
   ,'PARENT','STRING[20]','Nazwa pola 2'
   ,'DESC','STRING[255]','Nazwa pola 1'
   ,'TOOLTIP','STRING[255]','Nazwa pola 1'
   ,'COL_BCK','STRING[20]','Nazwa pola 1'
   ,'COL_TXT','STRING[20]','Nazwa pola 1'
   ,'BOR_SIZE','INTEGER','Nazwa pola 1'
   ,'BOR_COL','STRING[20]','Nazwa pola 1'
);



_env.ctr_id:='test_calendar';

DATY.cntx_psh();
DATY.index('ROKMIE');
DATY.prefix(date()~1);

_tab:=_env.DATY;
_tab_pos:=_env.POS;
_weeks:=_env.WEEKS;
{? DATY.first()
||
   {! _it:=1..(DATY.DZIEN_T-1)
   |! _tab.blank();
::      _tab.DESC:='pusty first %1'@[$_it];
      _tab.ID:='0'+$DATY.DATA+'_'+$_it;
      _tab.add()
   !};

   {!
   |? _tab.blank();
      _tab.ID:=$DATY.DATA;
      _tab.DESC:=$DATY.DATA;
      _tab.BOR_SIZE:=1;
      _tab.BOR_COL:='0:0:0';
      {? DATY.DZIEN_T=6
      ||
         _tab.COL_BCK:='255:204:51';
         _tab.TOOLTIP:='Sobota'
      ?};
      {? DATY.DZIEN_T=7
      ||
         _tab.COL_BCK:='255:51:51';
         _tab.TOOLTIP:='Niedziela'
      ?};
      _tab.add();

      _weeks.cntx_psh();
      _week_id:=$DATY.ROK+'_'+$form(DATY.TYDZIEN,-2);
      _weeks.prefix(_week_id,);
      {? _weeks.first()=0
      || _weeks.blank();
         _weeks.ID:=_week_id;
         _weeks.DESC:=$DATY.TYDZIEN;
::         _weeks.BOR_SIZE:=1;
::         _weeks.BOR_COL:='0:0:0';
         _weeks.add()
      ?};
      _weeks.cntx_pop();

      _size:=(rand()*10)#0;
      {! _it:=1.._size
      |! _tab_pos.blank();
         _tab_pos.ID:=$DATY.DATA+'_'+$_it;
         _tab_pos.PARENT:=$DATY.DATA;
         _tab_pos.DESC:=$time(_it,0,0);
         _tab_pos.COL_BCK:=exec('kolor_rand','#color');
         _tab_pos.BOR_SIZE:=1;
         _tab_pos.BOR_COL:='0:0:0';
         _tab_pos.TOOLTIP:='Pozycja kalendarza: %1'@[_tab_pos.DESC];
         _tab_pos.add()
      !};
      DATY.next()
   !}
?};

{? DATY.last()
|| {! _it:=(DATY.DZIEN_T+1)..7
   |! _tab.blank();
::      _tab.DESC:='pusty last %1'@[$_it];
      _tab.ID:='999'+$DATY.DATA+'_'+$_it;
      _tab.add()
   !}
?};
DATY.cntx_pop();
_tab.prefix();
_env.ROW_COUNT:=_tab.size()/7;
_weeks.prefix();

_before:="
            _env:=params_get().env;
            exec('load','#desktop','test_calendar','test_calendar.dsk',,,,,,0);

            exec('set_value','#desktop','',_env.ctr_id,'calendar@desktop','rowCount='+$_env.ROW_COUNT);
            exec('set_value','#desktop','',_env.ctr_id,'calendar@desktop','cellW=128');
            exec('set_value','#desktop','',_env.ctr_id,'calendar@desktop','cellH=128');

            exec('set_value','#desktop','',_env.ctr_id,'weeks@desktop','cellW=64');
            exec('set_value','#desktop','',_env.ctr_id,'weeks@desktop','cellH=128');
            exec('set_value','#desktop','',_env.ctr_id,'weeks@desktop','rowCount='+$_env.WEEKS.size());
            1";

params_set('env',_env);
SYSLOG.control(_win_id,'modal=false',_before);
~~

\test_cal_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Zwraca tabelkę dla listy
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
_env.DATY


\test_cal_pos
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Zwraca tabelkę dla listy
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
_env.POS


\test_cal_weeks
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Zwraca tabelkę dla listy
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
_env.WEEKS


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Konfigurowanie pulpitów
::   WE: [_a] - STRING - plik .dsk do którego ograniczyć widok
::  OLD: \select/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_filter_dsk:='';
{? var_pres('_a')=type_of('')
|| _filter_dsk:=_a
?};

:: Odświeżenie plików .dsk - wciąganie ich do bloba
_pliki:=files('*.dsk');
{? var_pres('_pliki')>100
|| {? _pliki.first()
   || {!
      |? exec('add','#blob',_pliki.FILENAME,1,1);
         _pliki.next()
      !}
   ?}
?};

_env:=obj_new(
               'WER'
               ,'WER_USR'
               ,'TAB_USR'
               ,'SEL_DSK'
               ,'FILTER_DSK');
_env.SEL_DSK:='';
_env.FILTER_DSK:=_filter_dsk;

params_set('env',_env);

_pliki_usr:=exec('dsku_files','#desktop');
_env.TAB_USR:=_pliki_usr;

SKID_BLB.cntx_psh();
SKID_BLB.clear();
SKID_BLB.f_set('ID',,' SKID_BLB.ID like ''%.dsku''');

_can_continue:=1;
{? SKID_BLB.f_first()
|| {!
   |? _can_continue:=SKID_BLB.del(,1);
      SKID_BLB.f_first() & _can_continue>0
   !}
?};

SKID_BLB.f_clear();

:: Odświeżenie plików .dsku - wciąganie ich do bloba

{? var_pres('_pliki_usr')>100
|| {? _pliki_usr.first()
   || {!
      |? exec('add','#blob',_pliki_usr.FILEPATH,1,0,0,_pliki_usr.FILENAME);
         _pliki_usr.next()
      !}
   ?}
?};
SKID_BLB.cntx_pop();

_grp:=SKID_BLB.grp_make('Konfigurowanie pulpitów'@,,'desktop_cfg');

_wer:=SKID_BLB.mk_sel('Definicje pulpitów'@,'N',0,'#desktopy',,,20,,'U');
SKID_BLB.win_fld(_wer,,'ID',,,20,,,'Identyfikator'@);
SKID_BLB.win_fld(_wer,,'BLOB',,,30,,,'Zawartość'@);

_env.WER:=_wer;

_wer_usr:=_env.TAB_USR.mk_sel('Definicje użytkowników'@,'N',0,'#desktopy_usr',,,20,,'U');
_env.TAB_USR.win_fld(_wer_usr,,'FILENAME',,,30,,,'Nazwa pliku'@);
_env.TAB_USR.win_fld(_wer_usr,,'USERS',,,30,,,'Użytkownik'@);

_load:="
   exec('enable_comm','#desktop','','redagowanie',0);
   exec('load','#desktop','redagowanie',cur_tab(1,1).FILENAME,,,'2',cur_tab(1,1).FILEPATH,,0,1);
   ~~
";

_env.TAB_USR.win_act(_wer_usr,,'Formuła','Załaduj'@@,,,_load,,1,,,,'Z');

_del:="
   _tab:=cur_tab(1,1);
   _can_continue:=FUN.ask('Czy usunąć plik: %1 z serwera?'@[_tab.FILEPATH]);
   {? _can_continue>0
   || {? ferase(_tab.FILEPATH,0)
      || _tab.del(,1);
         {? _tab.f_active()
         || _tab.f_rfresh()
         ?}
      ?}
   ?};
   ~~
";

_env.TAB_USR.win_act(_wer_usr,,'Formuła','Usuń'@@,,,_del,,,,,,'U');

_env.TAB_USR.win_act(_wer_usr,,'Wyświetl',,,,"exec('display','#blob',cur_tab(1,1).SQL_REF)");

_env.TAB_USR.win_btn(_wer_usr,'text=%1'['Załaduj kontrolkę'@],'menu:Z',,,,,,'noempty');

_env.WER_USR:=_wer_usr;


_load:="
   exec('enable_comm','#desktop','','redagowanie',0);
   exec('load','#desktop','redagowanie',cur_tab(1,1).ID,,,'0',,,0,1);
   ~~
";
SKID_BLB.win_act(_wer,,'Formuła','Załaduj'@@,,,_load,,1,,,,'Z');
SKID_BLB.win_act(_wer,,'Wyświetl',,,,"exec('display','#blob')");

SKID_BLB.win_btn(_wer,'text=%1'['Załaduj kontrolkę'@],'menu:Z',,,,,,'noempty');

_fb:="
   params_set(params_get());
   _env:=params_get().env;
   {? _env.FILTER_DSK<>''
   || SKID_BLB.f_set('ID',,' SKID_BLB.ID='':_a''',_env.FILTER_DSK)
   || SKID_BLB.f_set('ID',,' SKID_BLB.ID like ''%.dsk''')
   ?};
   ~~
";

_far:="
   params_set(params_get());
   _env:=params_get().env;

   _env.SEL_DSK:=SKID_BLB.ID;

   _dsku:=_env.SEL_DSK-4;
   _dsku+='%.dsku';
   _env.TAB_USR.f_set('FILENAME',,':_a.FILENAME like '':_b''',_env.TAB_USR,_dsku);
   _env.TAB_USR.f_first();
   grp_disp(_env.TAB_USR,_env.WER_USR,1);
   ~~
";
SKID_BLB.grp_sel(_grp,,_wer,,_far,,,,_fb,,,,'maximized_with_title');

SKID_BLB.grp_splt(_grp,,'horizontal','view',10);
exec('create','#desktop',SKID_BLB,'redagowanie',_grp,0);

SKID_BLB.grp_splt(_grp,'panel0','vertical','users');

_fb:="
   _env:=params_get().env;
   ~~
";
SKID_BLB.grp_sel(_grp,_env.TAB_USR,_wer_usr,,,,,,_fb,,,,'maximized_with_title');

SKID_BLB.win_sel(_grp);

SKID_BLB.clear();

SKID_BLB.select();
~~


\get_value
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca wartość dla podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::      [_d] - STRING - argument funkcji get_value;
::   WY: STRING - wartość elementu (pusty napis dla elementów ktore nie zwracają nic)
::  OLD: \get_value/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;

_args:='';
{? var_pres('_d')=type_of('')
|| _args:=_d
?};

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
?};

_result:='';
{? _args=''
|| _result:=ctr_call(_window_id,_ctr_id,'getValueOf',_element_id)
|| _result:=ctr_call(_window_id,_ctr_id,'getValueOfArgs',_element_id,_args)
?};
_result


\set_value
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia wartość dla podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - wartość dla elementu
::       [_e] - INTEGER - 0/[1] - czy po nadaniu wartości przerysować element
::       [_f] - INTEGER - 0/[1] - czy po nadaniu wartości wykonać formułę na obsługę
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::  OLD: \set_value/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_value:=_d;
_repaint:=1;
{? var_pres('_e')=type_of(0)
|| _repaint:=_e
?};
_action:=0;
{? var_pres('_f')=type_of(0)
|| _action:=_f
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'setValueOf',_element_id,_value,_repaint,_action);
_result


\set_value_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [18.22]
:: OPIS: Ustawia wartość dla podanego elementu pulpitu - wersja grupowa operująca na tabelce przesyłanej do kontrolki
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - wartość dla elementu
::       [_e] - INTEGER - 0/[1] - czy po nadaniu wartości przerysować element
::       _f - tab_tmp - tabelka tymczasowa do zasilenia
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::  OLD: \set_value/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_value:=_d;
_repaint:=1;
{? var_pres('_e')=type_of(0)
|| _repaint:=_e
?};
_tab:=_f;

_result:='';

_tab.cntx_psh();
_tab.prefix(_element_id,);
{? _tab.first()
||
   {? _value=''
   || _value:='~~empty~~'
   ?};
   _tab.VALUE:=_value;
   {? _tab.put()>0
   || _result:=_value
   ?}
||
   _tab.blank();
   _tab.ID_SYS:=_element_id;
   {? _value=''
   || _value:='~~empty~~'
   ?};
   _tab.VALUE:=_value;
   {? _tab.add()>0
   || _result:=_value
   ?}
?};
_tab.cntx_pop();
_result


\set_enabled
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia aktywność dla podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub
::                     string w formacie 'id elementu (użytkownika)@nazwa pulpitu' lub
::                     nazwa pulpitu w pulpicie dla którego ustawić aktywność dla wszystkich elementów lub
::                     pusty string - wtedy działa na wszystkich elementach pulpitu
::       _d - INTEGER - 0 - element nieaktywny, 1 - element aktywny
::  OLD: \set_enabled/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_value:=_d;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'setEnabled',_element_id,_value);
~~


\set_enabled_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [18.22]
:: OPIS: Ustawia aktywność dla podanego elementu pulpitu - wersja grupowa operująca na tabelce przesyłanej do kontrolki
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub
::                     string w formacie 'id elementu (użytkownika)@nazwa pulpitu' lub
::                     nazwa pulpitu w pulpicie dla którego ustawić aktywność dla wszystkich elementów lub
::                     pusty string - wtedy działa na wszystkich elementach pulpitu
::       _d - INTEGER - 0 - element nieaktywny, 1 - element aktywny
::       _e - tab_tmp - tabelka tymczasowa do zasilenia
::  OLD: \set_enabled/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_value:=_d;
_tab:=_e;

_tab.cntx_psh();
_tab.prefix(_element_id);
{? _tab.first()=0
||
   _tab.blank();
   _tab.ID_SYS:=_element_id;
   {? _value>0
   || _tab.ENABLED:='true'
   || _tab.ENABLED:='false'
   ?};
   _tab.add()
?};
_tab.cntx_pop();
~~


\set_visible
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia widoczność dla podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub
::                     string w formacie 'id elementu (użytkownika)@nazwa pulpitu' lub
::                     nazwa pulpitu w pulpicie dla którego ustawić widoczność dla wszystkich elementów lub
::                     pusty string - wtedy działa na wszystkich elementach pulpitu
::       _d - INTEGER - 0 - element niewidoczny, 1 - element widoczny
::       [_e] - INTEGER - [0]/1 - czy zapisywać widoczność w content (po zapisaniu pulpitu znajdzie się w pliku dsk)
::  OLD: \set_visible/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_value:=_d;

_content:=0;
{? var_pres('_e')=type_of(0)
|| _content:=_e
?};


{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'setVisible',_element_id,_value,_content);
~~


\set_visible_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [18.22]
:: OPIS: Ustawia widoczność dla podanego elementu pulpitu - wersja grupowa operująca na tabelce przesyłanej do kontrolki
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub
::                     string w formacie 'id elementu (użytkownika)@nazwa pulpitu' lub
::                     nazwa pulpitu w pulpicie dla którego ustawić widoczność dla wszystkich elementów lub
::                     pusty string - wtedy działa na wszystkich elementach pulpitu
::       _d - INTEGER - 0 - element niewidoczny, 1 - element widoczny
::       _e - tab_tmp - tabelka tymczasowa do zasilenia
::  OLD: \set_visible/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_value:=_d;
_tab:=_e;

_tab.cntx_psh();
_tab.prefix(_element_id,);
{? _tab.first()
|| {? _value>0
   || _tab.VISIBLE:='true'
   || _tab.VISIBLE:='false'
   ?};
   _tab.put()
||
   _tab.blank();
   _tab.ID_SYS:=_element_id;
   {? _value>0
   || _tab.VISIBLE:='true'
   || _tab.VISIBLE:='false'
   ?};
   _tab.add()
?};
_tab.cntx_pop();
~~


\set_foreground
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia kolor czcionki dla podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - kolor w formacie '255:255:255'
::       [_e] - INTEGER - [0/1] - czy zapisywać kolor w content (po zapisaniu pulpitu znajdzie się w pliku dsk)
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_color:=_d;
_content:=0;
{? var_pres('_e')=type_of(0)
|| _content:=_e
?};

_result:='';

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:=ctr_call(_window_id,_ctr_id,'setForeground',_element_id,_color,_content);
_result


\set_background
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia kolor tła dla podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - kolor w formacie '255:255:255'
::       [_e] - INTEGER - [0]/1 - czy zapisywać kolor w content (po zapisaniu pulpitu znajdzie się w pliku dsk)
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_color:=_d;

_content:=0;
{? var_pres('_e')=type_of(0)
|| _content:=_e
?};

_result:='';

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:=ctr_call(_window_id,_ctr_id,'setBackground',_element_id,_color,_content);
_result


\set_name
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia nazwę dla podanego elementu pulpitu, czyli tekst w etykiecie
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - nazwa
::       [_e] - INTEGER - [0]/1 - czy zapisywać nazwę w content (po zapisaniu pulpitu znajdzie się w pliku dsk)
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_name:=_d;

_content:=0;
{? var_pres('_e')=type_of(0)
|| _content:=_e
?};

_result:='';

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:=ctr_call(_window_id,_ctr_id,'setName',_element_id,_name,_content);
_result


\set_name_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia nazwę dla podanego elementu pulpitu, czyli tekst w etykiecie - wersja grupowa operująca na tabelce przesyłanej do kontrolki
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - nazwa
::       _e - tab_tmp - tabelka tymczasowa do zasilenia
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_name:=_d;

_result:='';

_tab.cntx_psh();
_tab.prefix(_element_id,);
{? _tab.first()
|| _tab.NAME:=_name;
   {? _tab.add()>0
   || _result:=_name
   ?}
||
   _tab.blank();
   _tab.ID_SYS:=_element_id;
   _tab.NAME:=_name;
   {? _tab.add()>0
   || _result:=_name
   ?}
?};
_tab.cntx_pop()


\refresh_element
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Odświeża elementy pulpitu które pobierają dane z bazy
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       [_d] - INTEGER - [0]/1 - czy po wczytaniu elementów wykonać formułę przypiętą do elementu
::       [_e] - STRING - wartość jaką nadać elementowi po wczytaniu danych
::  OLD: \refresh_element/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;

_callback:=0;
{? var_pres('_d')=type_of(0)
|| _callback:=_d
?};

_value:='';
{? var_pres('_e')=type_of('')
|| _value:=_e
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'refreshElement',_element_id,_callback,_value);
~~


\grab_data
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Odświeża elementy pulpitu który pobieraja dane z bazy, ale element nie wykonuje formuły aby przygotować dane
::       Dane muszą być wcześniej przygotowane przez wywołanie exec('fetch_data','#desktop')
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - identyfikator danych
::       [_e] - INTEGER - [0]/1 - czy po wczytaniu elementów wykonać formułę przypiętą do elementu
::       [_f] - STRING - wartość jaką nadać elementowi po wczytaniu danych lub '~~empty~~' dla pustej wartości
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_data_id:=_d;

_callback:=0;
{? var_pres('_e')=type_of(0)
|| _callback:=_e
?};

_value:='';
{? var_pres('_f')=type_of('')
|| _value:=_f
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'grabData',_element_id,_data_id,_callback,_value);
~~


\refresh_all
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Odświeża wszystkie elementy pulpitu które pobierają dane z bazy
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::  OLD: \refresh_all/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'refreshAll');
~~


\enable_comm
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Włącza/wyłącza globalną flagę czy kontrolka może wykonywać formuły czy nie
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - INTEGER - 0 - wykonywanie formuł niedozwolone
::                      1 - wykonywanie formuł dozwolone
::  OLD: \enable_comm/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_stan:=_c;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'setCommunicationEnabled',_stan);
~~


\grab_focus
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Podanemu elementowi pulpitu ustawia focus
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::  OLD: \grab_focus/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'grabFocus',_element_id);
~~


\get_focus
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Pobiera id systemowe elementu który ma focus
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::   WY: STRING - id elementu (systemowe) na pulpicie który ma aktualnie focus lub '' jesli żaden element nie ma focusa
::  OLD: \get_focus/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:=ctr_call(_window_id,_ctr_id,'getFocus');
_result


\dynamic_prefix
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zakłada 'dynamiczny filtr' w tabeli.
::       Warunkiem poprawnego działania jest to aby był ustawiony indeks którego ostatnim polem
::       jest pole typu STRING po którym będzie dynamicznie prefiksowanie
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu na pulpicie którego wartość będzie użyta do ustawienia prefiksu
::       _d - Akronim tabeli którą prefiksować
::       _e - STRING - identyfikator okna które odświezyć za pomoca grp_disp
::       _f - INTEGER - liczba pól prefiksu który jest wcześniej ustawiony
::                      (np. jesli=3 to dynamicznie prefiksujemy czwarte pole)
::  OLD: \dynamic_prefix/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_table:=_d;
_disp_win:=_e;
_num_pref:=_f;

_textfield:=exec('get_value','#desktop','',_ctr_id,_element_id);
_pref:=_table.cur_prfx();
_split:=spli_str(_pref,',');

{? obj_len(_split)>_num_pref
|| _pref:=_pref-(exec('revert','#string',_pref)*',')
?};
{? _textfield<>''
|| {? _num_pref>0
   ||
::    Jeśli prefiks wcześniej założony to doklejam do istniejącego prefiksu to co w polu tekstowym
      _pref:=_pref+',\''+_textfield+'\''
   ||
::    Jeśli wcześniej nie było prefiksu to prefiksem będzie napis z pola tekstowego
      _pref:='\''+_textfield+'\''
   ?}
|| {? _num_pref=0
   ||
::    Usuwam prefiks jeśli nie było wcześniej pól w prefiksie i pole tekstowe puste
      _pref:=''
   ?}
?};

($('_table:=_a;_table.prefix('+_pref+')'))(_table);
grp_disp(_table,_disp_win);
exec('grab_focus','#desktop',_window_id,_ctr_id,_element_id);
~~


\ask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zamiennik dla funkcji FUN.ask()
::   WE: _a - tekst komunikatu
::       _b - ikona
::       _c - tytuł okna
::   WY: 0 / 1
::  OLD: \ask/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=exec('create','#desktop',SYSLOG,'ask',,15,96,_c,,,0,4,6);
_win_id:='ask';
SYSLOG.win_ctr(_ctr_id);
_before:=$("
   exec('load','#desktop','ask','#ask.dsk',,,,,,0);
   exec('set_value','#desktop','','ask','txt@ask','"+gsub(gsub(_a,'=','"="'),'''','''''')+"');
   exec('set_name','#desktop','','ask','button_tak@ask','&"+'Tak'@+"');
   exec('set_name','#desktop','','ask','button_nie@ask','&"+'Nie'@+"');
   ctr_ret(0);
   1
");
SYSLOG.control(_win_id,'modal=true',_before)


\info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zamiennik dla funkcji FUN.info()
::   WE: _a - tekst komunikatu
::       _b - tytuł okna
::  OLD: \info/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=exec('create','#desktop',SYSLOG,'info',,15,96,_b,,,0,4,6);
_win_id:='info';
SYSLOG.win_ctr(_ctr_id);
_before:=$("
   exec('load','#desktop','info','#info.dsk',,,,,,0);
   exec('set_value','#desktop','','info','txt@info','"+gsub(gsub(_a,'=','"="'),'''','''''')+"');
   exec('set_name','#desktop','','info','button_ok@info','"+'OK'@+"');
   1
");
SYSLOG.control(_win_id,'modal=true',_before);
0


\emsg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zamiennik dla funkcji FUN.emsg()
::       Uwaga: narazie to samo co info
::   WE: _a - tekst komunikatu
::       _b - tytuł okna
::  OLD: \emsg/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
exec('info','#desktop',_a,_b)


\error
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zamiennik dla funkcji FUN.error()
::       Uwaga: narazie to samo co info
::   WE: _a - tekst komunikatu
::       _b - tytuł okna
::  OLD: \error/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
exec('info','#desktop',_a,_b)


\clip_set_txt
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Kopiuje przekazany napis do schowka
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - tekst do umieszczenia w schowku
::  OLD: \clip_set_txt/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_text:=_c;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'setClipboardText',_text);
~~


\clip_set_img
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Kopiuje przekazany obrazek do schowka
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - sciezka do pliku z obrazkiem który zostanie umieszczony w schowku
::  OLD: \clip_set_img/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_filepath:=_c;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'setClipboardImage',_filepath);
~~


\clip_get_txt
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Pobiera napis ze schowka
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::   WY: STRING - napis w schowku lub '' jeśli w schowku brak napisu
::  OLD: \clip_get_txt/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:=ctr_call(_window_id,_ctr_id,'getClipboardText');
_result


\fetch_sysmemo
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Kopiuje pole SYSMEMO do pliku, zwraca ścieżkę do pliku
::   WE: _a - STRING - akronim tabeli z polem typu SYSMEMO
::       _b - STRING - akronim pola typu SYSMEMO
::       [_c] - STRING - formula na prefix
::       [_d] - STRING - Sql rekordu dla którego pobrać treść
::   WY: STRING - scieżka do pliku z treścią sysmemo
::  OLD: \fetch_sysmemo/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_field:=_b;

_result:='';

_prefix:=~~;
{? var_pres('_c')=type_of('')
|| _prefix:=_c
?};

_ref:='';
{? var_pres('_d')=type_of('')
|| _ref:=_d
?};

{? _prefix<>~~
|| ($_prefix)()
?};

_result:=exec('memo_get','#blob',_table,_field,_ref);
_result


\dnd_install
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Umozliwia przeciąganie na pulpit rekordów z podanego źrodla
::   WE: _a - alias tabeli do której jest przypięta kontrolka (podawana jako pierwszy argument exec('create','#desktop'))
::       _b - STRING - akronim okna z kontrolką - wynik mk_ctr
::       _c - STRING - identyfikator kontrolki np. 'kontrolka1'
::       _d - STRING - identyfikator danych - patrz help dla funkcji dnd_sel
::  OLD: \dnd_install/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_win_acr:=_b;
_ctr_id:=_c;
_data_id:=_d;

_tab.dnd_ctr(_win_acr,_ctr_id,_data_id,"exec('dnd_bridge','#desktop');~~");
~~


\dnd_bridge
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Formula most dla mechanizmu dnd - wywoływana automatycznie po zdarzeniu drop, pobiera z pulpitu formułę po
::       dropie dla danego elementu i ją wywołuje
::  OLD: \dnd_bridge/desktop.fml
::----------------------------------------------------------------------------------------------------------------------

:: Pobieram z kontrolki formułę, którą kontrolka wystawiła
_formula:=dnd_info('drop_formula');

:: Uruchamiam pobraną formułę
{? type_of(_formula)=type_of('')
|| {? _formula<>''
   || ($_formula)()
   ?}
?};
~~


\dynamic_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: 'Dynamiczne szukanie' w tabeli
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu na pulpicie którego wartość będzie użyta do ustawienia prefiksu
::       _d - Alias tabeli w której będziemy szukać
::       _e - STRING - identyfikator okna tabeli _d, które trzeba odświeżyć za pomocą grp_disp
::       _f - STRING - akronim pola wg którego będziemy szukać
::  OLD: \dynamic_find/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_table:=_d;
_disp_win:=_e;
_fld_acr:=_f;

_textfield:=exec('get_value','#desktop','',_ctr_id,_element_id);
($('
   _table:=_a;
   {? _table.f_active()>0
   || _ref_tab:=exec(''ref_table'',''#table'');
      {!
      |? _table.blank(1);
         _table.'+_fld_acr+':='''+_textfield+''';
         _ok:=_table.find_rec(1);
         {? _ok
         || {? _ref_tab.r_find(_table.ref())>0
            || _added:=0
            || _added:=_ref_tab.r_add(_table.ref())
            ?};
            _ref:=_table.ref();
            _ok:=_table.f_seek(_ref)
         || _added:=0
         ?};
         ~(_ok | _added=0)
      !}
   || _table.blank(1);
      _table.'+_fld_acr+':='''+_textfield+''';
      _ok:=_table.find_rec(1)
   ?};
   _ok
'))(_table);

grp_disp(_table,_disp_win);
exec('grab_focus','#desktop',_window_id,_ctr_id,_element_id);
~~


\debug_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Ustawia kontrolce tekst do debugowania który jest widoczny w popupMenu kontrolki (prawy klik na kontrolce)
::       Tekst ten jest szczególnie przydatny do rozróżniania kontrolek, jeżeli jednocześnie jest wyświetlone kilka
::       okien
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - tekst debugujacy
::  OLD: \debug_string/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_text:=_c;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'setDebugString',_text);
~~


\set_options_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Tablica parametrów dla set_options
::   WY: _args
::  OLD: \set_options_a/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('blank'
::             Określa czy podczas ładowania pliku .dsk ma się pojawiać animacja że się coś ładuje (wartosc=1),
::             czy pusty panel (wartosc=0)
               ,'LOAD_ANI'
::             Włącza obsługę oddawania focusa po wykonaniu formuly przez kontrolkę z pulpitem. Jeżeli w momencie wykonania
::             formuły z pulpitu inne okno w oknie grupowym było aktywne, to po wykonaniu formuly znowu będzie ono aktywne
::             UWAGA - DZIALA NA RUNTIME OD 12.30 WZWYŻ - ustawienie tej opcji na starszym runtime bedzie powodowalo błędy
::             podczas KAŻDEGO wywołania formuły z pulpitu
               ,'FOCUS_RET'
              );
:: - - - - poniżej ustawienie wartości domyślnych
_args.blank:="
               .LOAD_ANI:=1;
               .FOCUS_RET:=0
      ";
:: - - - - koniec ustalania wartosci domyślnych
_args.blank();
_args


\set_options
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia 'systemowe wlasciwości' pulpitu, tzn takie których nie można w inny sposób ustawić oprócz tej formuły
::       Właściwości są ustawiane po utworzeniu kontrolki z pulpitem, przed załadowaniem jakiegokolwiek pliku .dsk
::   WE: _args - tablica nazwana z wlaściwosciami - wynik formuły exec('set_options_a','#desktop')
::       _b - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _c - STRING - identyfikator kontrolki w oknie
::  OLD: \set_options/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('set_options_a','#desktop')
?};
_window_id:=_b;
_ctr_id:=_c;

_result:='';

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'setOptionLoadingAnimation',_args.LOAD_ANI);

ctr_call(_window_id,_ctr_id,'setOptionFocusReturn',_args.FOCUS_RET);
~~


\get_active_win
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: W oknie grupowym zwraca id aktywnego okna
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::   WY: INTEGER - numer aktywnego okna w grupie [0..n] lub -1 jeśli wystąpił jakiś błąd
::  OLD: \get_active_win/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_result:=-1;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:=ctr_call(_window_id,_ctr_id,'getActiveWindowId');
_result


\set_active_win
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: W oknie grupowym próbuje ustawić aktywne okno
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - INTEGER - nr okna które ma zostać aktywowane
::   WY: INTEGER - numer aktywnego okna w grupie [0..n] lub -1 jeśli wystąpił jakiś błąd
::  OLD: \set_active_win/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_id_act:=_c;

_result:=-1;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'setActiveWindow',_id_act);
~~


\stop_timers
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Zatrzymuje okresowe wykonywanie akcji na pulpicie.
::       Akcje nie będą wykonywane aż ich obsługa nie zostanie przywrócona formułą exec('start_timers','#desktop')
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::  OLD: \stop_timers/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'stopActionTimers');
~~


\start_timers
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Uruchamia okresowe wykonywanie akcji na pulpicie, które mogło zostać wyłączone za pomocą formuły stop_timers
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::  OLD: \start_timers/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'startActionTimers');
~~


\set_wallpaper_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Argumenty dla funkcji set_wallpaper
::   WY: obj_new()
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
:: Ścieżka do pliku z tapetą - obsługiwane pliki: bmp,jpg,png,pdf
   'FILEPATH'
:: Nazwa pulpitu któremu ustawić tapetę (nazwa nadawana w kontrolce pupitu)
   ,'DESK_NAME'
:: Czy tapeta ma być rozciągnięta na cały obszar okna
   ,'STRETCH'
:: Czy obszar pulpitu dopasować do rozmiaru tapety
   ,'ADAPT'
:: Czy tapeta tymczasowa czy normalna (tymczasowa nie jest zapisywana w definicji pulpitu): NORMAL,TEMP
   ,'WALL_KIND'
:: Dla plików PDF - numer strony który ustawić jako tapetę
   ,'PDF_PAGE'
:: Dla plików PDF - współczynnik przez który przeskalować oryginalny rozmiar strony przed jego wyświetleniem
   ,'PDF_RATIO'
:: Dla plików PDF - szerokość obrazka ze stroną
   ,'PDF_WIDTH'
:: Dla plików PDF - wysokość obrazka ze stroną
   ,'PDF_HEIGHT'

);
_args.FILEPATH:='';
_args.DESK_NAME:='';
_args.STRETCH:=0;
_args.ADAPT:=0;
_args.WALL_KIND:='TEMP';
_args.PDF_PAGE:=0;
_args.PDF_RATIO:=1;
_args.PDF_WIDTH:=0;
_args.PDF_HEIGHT:=0;
_args


\set_wallpaper
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Ustawia stałą lub tymczasową tapetę na pulpicie (tymczasowa tapeta NIE będzie zapisana w definicji pulpitu)
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - obj_new() - dodatkowe opcje dla tapety - wynik działania funkji exec('set_wallpaper_a','#desktop')
::  OLD: \set_wallpaper/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
{? var_pres('_c')>100
|| _args:=_c
|| _args:=exec('set_wallpaper_a','#desktop')
?};

_options:='start';
{? _args.STRETCH>0
|| _options+=';stretch=1'
?};
{? _args.ADAPT>0
|| _options+=';resizeToWall=1'
?};
_options+=';kind='+$_args.WALL_KIND;

_options+=';pdfPage='+$_args.PDF_PAGE;
_options+=';pdfRatio='+$_args.PDF_RATIO;
_options+=';pdfW='+$_args.PDF_WIDTH;
_options+=';pdfH='+$_args.PDF_HEIGHT;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'setExternalWallpaper',_args.DESK_NAME,_args.FILEPATH,_options);
~~


\get_elements
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca tabelę tymczasową zawierającą wszystkie elementy pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - nazwa pulpitu którego zawartość pobrać (nazwa podawana podczas tworzenia pulpitu w
::                       kontrolce a nie w formuli)
::   WY: tab_tmp
::  OLD: \get_elements/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_desk_name:=_c;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_tab:=ctr_call(_window_id,_ctr_id,'getDesktopElements',_desk_name);
_tab


\unload
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Odładowuje załadowany pulpit - pokazuje puste okno
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'unloadAll');
~~


\elements_table
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca definicję tabeli tymczasowej zawierającej info o elemetach pulpitu
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(2,
:: 'POLE','TYP','Nazwa w oknie',
   'ID_SYS','STRING[255]','Id systemowe'
   ,'DESKTOP','STRING[255]','Nazwa pulpitu na którym się znajduje'
   ,'ORDER','INTEGER','Lp.'
   ,'TYPE','STRING[255]','Typ elementu'
   ,'NAME','STRING[255]','Nazwa elementu'
   ,'ID_OWN','STRING[255]','Id użytkownika'
   ,'ACT_TYPE','STRING[255]','Typ akcji'
   ,'ACTION','STRING[255]','Akcja'
   ,'X','INTEGER','Współrzędna X'
   ,'Y','INTEGER','Współrzędna Y'
   ,'WIDTH','INTEGER','Szerokość'
   ,'HEIGHT','INTEGER','Wysokość'
   ,'VISIBLE','STRING[255]','Widoczny?'
   ,'ENABLED','STRING[255]','Aktywny?'
   ,'VALUE','STRING[255]','Wartość elementu'
   ,'COL_TXT','STRING[11]','Kolor czcionki'
   ,'COL_BCK','STRING[11]','Kolor tła'
   ,'TOOLTIP','STRING[255]','Podpowiedź'
);
_tab


\elements_win
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy okno tabeli zawierającej elementy pulpitu
::   WE: _a - tabela tymczasowa z definicją pulpitu
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_win:=_tab.mk_sel('Elementy pulpitu'@,,0,,,,,,'U');
_tab.win_fld(_win,,'ORDER',,,10);
_tab.win_fld(_win,,'TYPE',,,20);
_tab.win_fld(_win,,'ID_SYS',,,20);
_win


\test_xml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS:
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------

~~


\test_chart
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS:
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ctr_id:=exec('create','#desktop',SYSLOG,'chart',,40);
_win_id:='kontrolka1';
SYSLOG.win_ctr(_ctr_id);
_before:="
            exec('load','#desktop','chart','chart.dsk');
::            exec('set_visible','#desktop','','chart','12207dn9g4ij6khc4eeh6cbdii4nf',0);
            1";

SYSLOG.control(_win_id,'modal=false',_before);
~~


\chart
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Zwraca tabelkę tymczasową
::   WE:
::   WY:
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'LP','INTEGER','Lp'@,
   'ID','STRING[16]','Identyfikator'@,
   'KOLOR','STRING[11]','Nazwa pola 2'@,
   'VAL','REAL','Wartosc'@,
   'TOOLTIP','STRING[255]','Dymek'@
);

_max_kol:=50;
{? var_pres('__m_kol')=type_of(0) & __m_kol>0
|| _max_kol:=__m_kol
?};

_max_value:=1000;
{? var_pres('__m_val')=type_of(0) & __m_val>0
|| _max_value:=__m_val
?};

_max_subbars:=10;
{? var_pres('__m_sub')=type_of(0) & __m_sub>0
|| _max_subbars:=__m_sub
?};

_below_x:='false';
{? var_pres('__below')=type_of('') & __below<>''
|| _below_x:=__below
?};

{! _it:=1..(_max_kol*rand())$0
|!
   _value:=(_max_value*rand())$0;
   _subbars:=(_max_subbars*rand())$0;

   _sign:=1;
   {? rand()*10>5 & _below_x='true'
   || _sign:=-1
   ?};
   _value*=_sign;

   _kolor:=exec('kolor_rand','#color');
   _tab.blank();
   _tab.LP:=_it;
   _tab.ID:=$_it;
   _tab.KOLOR:=_kolor;
   _tab.VAL:=_value;

   _tab.add();

   {! _it2:=1.._subbars
   |! _tab.cntx_psh();
      _tab.blank();
      _tab.LP:=_it;
      _tab.ID:=$_it;
      _tab.VAL:=(_max_value*rand())$0;
      _tab.VAL*=_sign;
      _value+=_tab.VAL;
      _tab.KOLOR:=exec('kolor_rand','#color');
      _tab.add();
      _tab.cntx_pop()
   !};

   _tab.TOOLTIP:='<html>';
   _tab.TOOLTIP+='<b>Kolumna nr '+$_it+'</b>';
   _tab.TOOLTIP+='<br>Wartość :'+$_value;
   _tab.TOOLTIP+='<br>Części słupka: '+$(_subbars+1);
   _tab.TOOLTIP+='</html>';
   _tab.put()
!};
_tab


\chart_refresh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS:
::   WE:
::   WY:
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
__m_kol:=#exec('get_value','#desktop','','chart','10f4d6egn0dcbkd9hf626c947b13i');
__m_val:=#exec('get_value','#desktop','','chart','30d49lmcn88ed6mf5bdk2dl1fk656');
__m_sub:=#exec('get_value','#desktop','','chart','1l25jnbgbf205am2bnd7eh0gaa1la');
__below:=exec('get_value','#desktop','','chart','mc91k9h0a8fhj5a395le0n1g728m');
exec('refresh_element','#desktop','','chart','2m3fi49h3lkdma2g0m32a9nl19m3a');
~~


\revert_user
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wycofuje modyfikacje użytkownika - po stronie serwera usuwa plik z ustawieniami użytkownika
::   WE: _a - STRING - nazwa pliku .dsku
::       _b - STRING - '0'/'1' - czy wyswietlac dialogi
::   WY: '0'/'1'
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_filename:=_a;
_dialog:=_b;

_result:='0';
_can_continue:=1;

{? _filename*'.dsk'>0
|| _filename:=exec('get_user_name','#desktop',_filename)
?};

{? _filename*'.dsku'>0
||
:: Sprawdzam czy plik istnieje
   {? fexists(_filename,1)
   || {? _dialog*'1'>0
      || _can_continue:=FUN.ask('Wszystkie ustawienia użytkownika w tym oknie zostaną usunięte. Czy kontynuować?'@)
      ?};
      {? _can_continue>0
      ||
         {? ferase(_filename,1)
         ||
::          Usuwam plik z bloba
            {? exec('add','#blob',_filename,1,1)>0
            || _result:='1'
            ?}
         ?}
      ?}
   || FUN.info('Brak pliku z ustawnieniami użytkownika po stronie serwera.'@)
   ?}
?};
_result


\dsku_files
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca tablicę tymczasową zawierającą wszystkie pliki dsku na serwerze dla podanego pliku dsk w danej firmie
::   WE: [_a] - STRING - nazwa pliku dsk który mnie interesuje, jeżeli nie podane to zwraca wszystkie dsku
::   WY: tab_tmp
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_dsk:='';
{? var_pres('_a')=type_of('')
|| _dsk:=_a;

:: Odrzucam rozszerzenie
   _dsk:=gsub(_dsk,'.dsk','');

:: Doklejam separator pulpit~~użytkownik
   _dsk+='~~'
?};

:: katalog w którym się znajdują pliki .dsku aktualnie zalogowanego użytkownika
_dir:=pth_dir('.dsku');

_tab:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'FILENAME','STRING[255]','Nazwa pliku'
   ,'FILEPATH','STRING[255]','Ścieżka pliku'
   ,'USERS','STRING[50]','Użytkownik'
);

:: przechodzę poziom wyżej, do katalogu wszystkich użytkowników

_dir:=pth_dir('.dsku')-(+OPERATOR.USER().KOD);

_sep:=exec('sep','#file',1);
USERS.cntx_psh();
USERS.index('USR_AKOD');
USERS.prefix();
{? USERS.first()
|| {!
   |?
      _user_dir:=_dir+USERS.KOD;
      {? var_pres('_files')>100
      || obj_del(_files)
      ?};
      _files:=exec('pliki','#file',_user_dir,,,_sep);
      {? _files.first()
      || {!
         |?
            {? _dsk<>''
            || {? _files.LINE*_dsk>0
               || _tab.blank();
                  _tab.FILEPATH:=_files.LINE;
                  _tab.FILENAME:=_files.FILENAME;
                  _tab.USERS:=USERS.KOD;
                  _tab.add()
               ?}
            || _tab.blank();
               _tab.FILEPATH:=_files.LINE;
               _tab.FILENAME:=_files.FILENAME;
               _tab.USERS:=USERS.KOD;
               _tab.add()
            ?};
            _files.next()
         !}
      ?};
      USERS.next()
   !}
?};
USERS.cntx_pop();
_tab


\dsku_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Usuwa wszystkie zmiany użytkowników dla przekazanego pliku .dsk
::   WE: _a - STRING - nazwa pliku dsk
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_filename:=_a;

_can_continue:=1;
_result:=0;
_tab:=exec('dsku_files','#desktop',_filename);
{? _tab.first()
|| {!
   |? _filepath:=_tab.FILEPATH;
      {? _filepath<>''
      || _can_continue:=ferase(_filepath,0)
      ?};
      _tab.next() & _can_continue>0
   !}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\libload
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Laduje panelplus.jar jako bibliotekę jar
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::laduje biblioteke
_panelplus:=obj_new(  'LIB_ID'
                  ,'CALL_JTERM_SIZE'
                  ,'CALL_DPI'
                  ,'set_jterm_size'
                  ,'get_dpi');
_jar_name:='panelplus.jar';
::_jar_name:='panelplus_j8.jar';
::{? exec('runtime_p60','#system')
::|| _jar_name:='panelplus_j11.jar'
::?};

_panelplus.LIB_ID:=lib_load(_jar_name,1,0);
VAR_DEL.delete('__PPLUS');
{? _panelplus.LIB_ID=0
|| FUN.emsg('Błąd załadowania biblioteki: %1'@[_jar_name])
||
   _panelplus.CALL_JTERM_SIZE:=lib_decl(_panelplus.LIB_ID,,'int','setJtermSize','int','int');
   _panelplus.set_jterm_size:="lib_call(.CALL_JTERM_SIZE,_a,_b)";
   _panelplus.CALL_DPI:=lib_decl(_panelplus.LIB_ID,,'int','getDpi');
   _panelplus.get_dpi:="lib_call(.CALL_DPI)";
   __PPLUS:=_panelplus;
   ~~
?};
_panelplus


\uni_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Uniwersalny 'display', który dokłada duży przycisk do zamykania okienka
::       UWAGA: nie do użycia w trybie lumen
::   WE: _a - tabela
::       _b - akronim oryginalnego okienka redakcyjnego
::       _c - tytuł okna
::       _d - współrzędna pozioma okna
::       _e - współrzędna pionowa okna
::       _f - identyfikator okna
::       [_g] - tryb wyświetlania okna (domyślnie 'normal')
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_red:=_b;
_title:=_c;
_pos_x:=_d;
_pos_y:=_e;
_id:=_f;
_mode:={? var_pres('_g')=type_of('') || _g || 'normal' ?};

_before:="exec('load','#desktop','ctr_menu_esc','#escape.dsk',,,,,,0); ~~";
_grp:=_tab.grp_make(_title,_before,_id,_pos_x,_pos_y,,,_mode,'jterm');
_tab.grp_edit(_grp,,_red,,,,,,'maximized',_id);
_tab.grp_splt(_grp,,'horizontal','pozioma');
exec('create','#desktop',_tab,'ctr_menu_esc',_grp,3,1,,,,1);
_tab.win_sel(_grp);
_tab.select();
~~


\uni_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Uniwersalny 'select', który dokłada duży przycisk do zamykania okienka
::   WE: _a - tabela
::       _b - akronim oryginalnego okienka wertowania
::       _c - tytuł okna
::       _d - współrzędna pozioma okna
::       _e - współrzędna pionowa okna
::       _f - wysokość okna wertowania
::       _g - identyfikator okna
::       [_h] - tryb wyświetlania okna (domyślnie 'normal')
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_wer:=_b;
_title:=_c;
_pos_x:=_d;
_pos_y:=_e;
_high:=_f;
_id:=_g;
_mode:={? var_pres('_h')=type_of('') || _h || 'normal' ?};

_before:="exec('load','#desktop','ctr_menu_esc','#escape.dsk',,,,,,0); ~~";
_grp:=_tab.grp_make(_title,_before,_id,_pos_x,_pos_y,,,_mode);
_tab.grp_sel(_grp,,_wer,,,,,_high,,,,,'maximized',_id);
_tab.grp_splt(_grp,,'horizontal','pozioma');
exec('create','#desktop',_tab,'ctr_menu_esc',_grp,3,1,,,,1);
_tab.win_sel(_grp);
_tab.select();
~~


\choice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Zamiennik dla funkcji FUN.choice()
::   WE: _a - komunikat,
::       _b - numer wyróżnionego przycisku - domyślnie ostatni 'Anuluj'
::       _c.._f możliwe 4 przyciski do przekazania
::       [_g] - opcjonalna nazwa dla przycisku 'Anuluj'
::       _h - tytuł okna
::       zawsze ostatnim przyciskiem będzie 'Anuluj'
::       funkcja zwraca 0 dla ESC i przycisku 'Anuluj' bądź numery przycisków przekazanych do choice
::----------------------------------------------------------------------------------------------------------------------
_default:={? var_pres('_b')=type_of(0) || _b || 5 ?};

_ctr_id:=exec('create','#desktop',SYSLOG,'choice',,15,96,_h,,,0,4,6);
_win_id:='choice';

_id:=obj_new(5);
{! _it:=1..5 |! _id[_it]:='button'+$_it+'@buttons' !};

_btn:=obj_new(5); _visible:=obj_new(5);
{? var_pres('_c')=type_of('') || _btn[1]:=_c; _visible[1]:=1 || _btn[1]:='1'; _visible[1]:=0 ?};
{? var_pres('_d')=type_of('') || _btn[2]:=_d; _visible[2]:=1 || _btn[2]:='2'; _visible[2]:=0 ?};
{? var_pres('_e')=type_of('') || _btn[3]:=_e; _visible[3]:=1 || _btn[3]:='3'; _visible[3]:=0 ?};
{? var_pres('_f')=type_of('') || _btn[4]:=_f; _visible[4]:=1 || _btn[4]:='4'; _visible[4]:=0 ?};
{? var_pres('_g')=type_of('') || _btn[5]:=_g; _visible[5]:=1 || _btn[5]:='Anuluj'@; _visible[5]:=1 ?};

SYSLOG.win_ctr(_ctr_id);
_before:=$("
   exec('load','#desktop','choice','#choice.dsk',,,,,,0);
   exec('set_value','#desktop','','choice','txt@choice','"+gsub(gsub(_a,%92,2*%92),%39,2*%39)+"');
   exec('set_value','#desktop','','choice','"+_id[1]+"','"+gsub(gsub(_btn[1],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','choice','"+_id[1]+"',"+$_visible[1]+");
   exec('set_value','#desktop','','choice','"+_id[2]+"','"+gsub(gsub(_btn[2],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','choice','"+_id[2]+"',"+$_visible[2]+");
   exec('set_value','#desktop','','choice','"+_id[3]+"','"+gsub(gsub(_btn[3],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','choice','"+_id[3]+"',"+$_visible[3]+");
   exec('set_value','#desktop','','choice','"+_id[4]+"','"+gsub(gsub(_btn[4],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','choice','"+_id[4]+"',"+$_visible[4]+");
   exec('set_value','#desktop','','choice','"+_id[5]+"','"+gsub(gsub(_btn[5],%92,2*%92),%39,2*%39)+"');
   exec('set_visible','#desktop','','choice','"+_id[5]+"',"+$_visible[5]+");
   exec('grab_focus','#desktop','','choice','"+_id[_default]+"');
   ctr_ret(0);
   1
");
SYSLOG.control(_win_id,'modal=true',_before)


\update_desktop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [Shupa]
:: OPIS: Uruchamia wciągnięcie wystawionej tabeli tymczasowej aktualizującej elementy pulpitu
::       Dane muszą być wcześniej przygotowane przez wywołanie exec('update_prepare','#desktop')
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - identyfikator danych
::      [_d] - STRING - nazwa pulpitu który będzie aktualizowany. Jeżeli nie podane to główny i wszystkie pulpity w pulpitach
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_data_id:=_c;
_desk_name:='';
{? var_pres('_d')=type_of('')
|| _desk_name:=_d
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'updateDesktop',_data_id,_desk_name);
~~


\update_prepare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Wystawia przesłaną tabelkę do pobrania przez kontrolkę
::   WE: _a - tab_tmp - tabelka aktualizująca elementy pulpitu. Wynik działania exec('elements_table','#desktop')
::       _b - STRING - identyfikator danych
::       _c - STRING - identyfikator kontrolki w oknie
::   WY:
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_data_id:=_b;
_ctr_id:=_c;

_window_id:='';
{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_table.cntx_psh();

{? type_of(_table)=type_of(SYSLOG)
||
   {? _ctr_id*'desktop:'>0
   || _rule:=$("ctr_tab('"+_data_id+"','!desktop','"+_ctr_id+"',,_a)")
   || _rule:=$("ctr_tab('"+_data_id+"',,'"+_ctr_id+"',,_a)")
   ?};
   _rule(_table)
?};
_table.cntx_pop();
~~


\update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Aktualizuje elementy pulpitu na podstawie przekazanej tabelki
::   WE: _a - tab_tmp - tabelka aktualizująca elementy pulpitu. Wynik działania exec('elements_table','#desktop')
::       _b - STRING - identyfikator kontrolki
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_ctr_id:=_b;

_data_id:=$SYSLOG.tm_stamp();

exec('update_prepare','#desktop',_tab,_data_id,_ctr_id);
exec('update_desktop','#desktop','',_ctr_id,_data_id);
~~


\param_write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zapisuje wartość dowolnego parametru po stronie javy na terminalu klienta
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - nazwa parametru
::       _d - STRING - wartość parametru
::      [_e] - INTEGER - 0/[1] czy parametr użytkownika, jeśli nie to globalny
::      [_f] - STRING - kod użytkownika któremu zapisać parametr - jeśli nie podany to czytane ze zmiennej
::                      OPERATOR.USER
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_name:=_c;
_value:=_d;
_user:=1;
{? var_pres('_e')=type_of(0)
|| _user:=_e
?};
_usr_kod:='';
{? var_pres('_f')=type_of('')
|| _usr_kod:=_f
?};

{? _user>0
|| {? _usr_kod<>''
   || _name+='_'+_usr_kod
   || _name+='_'+OPERATOR.USER().KOD
   ?}
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'paramWrite',_name,_value);
~~


\param_read
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Odczytuje wartość dowolnego parametru po stronie javy na terminalu klienta
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - nazwa parametru
::      [_d] - INTEGER - 0/[1] czy parametr użytkownika, jeśli nie to globalny
::      [_e] - STRING - kod użytkownika któremu zapisać parametr - jeśli nie podany to czytane ze zmiennej
::                      OPERATOR.USER
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_name:=_c;
_user:=1;
{? var_pres('_d')=type_of(0)
|| _user:=_d
?};
_usr_kod:='';
{? var_pres('_e')=type_of('')
|| _usr_kod:=_e
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

{? _user>0
|| {? _usr_kod<>''
   || _name+='_'+_usr_kod
   || _name+='_'+OPERATOR.USER().KOD
   ?}
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'paramRead',_name);
_result


\get_selection
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Zwraca tabelę tymczasową (KEY, VALUE) zawierającą zaznaczone pozycje elementu pulpitu
::       (działa dla elementu typu list)
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
?};

_tab:=ctr_call(_window_id,_ctr_id,'getSelection',_element_id);
_tab


\editor_sysmemo_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Ładuje pole SYSMEMO do edytora
::   WE: _a - STRING - akronim tabeli
::       _b - STRING - akronim pola SYSMEMO
::       _c - STRING - formuła na prefix
::       _d - STRING - SQL Ref konkretnego rekordu
::   WY: STRING - ścieżka do pliku tymczasowego
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_field:=_b;
_prefix:=_c;
_ref:=_d;

_can_continue:=1;
_result:='';

{? _table=''
|| _can_continue:=0;
   FUN.emsg('Nie podano akronimu tabeli z polem typu: %1'@['SYSMEMO'])
?};

{? _field=''
|| _can_continue:=0;
   FUN.emsg('Nie podano akronimu pola typu: %1'@['SYSMEMO'])
?};

{? _can_continue>0
|| _result:=exec('fetch_sysmemo','#desktop',_table,_field,_prefix,_ref)
?};
_result


\editor_sysmemo_save
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Zapisuje zawartość edytora do sysmemo
::   WE: _a - STRING - lokalizacja pliku tymczasowego
::       _b - STRING - akronim tabeli
::       _c - STRING - akronim pola SYSMEMO
::       _d - STRING - SQL Ref rekordu
::   WY: '0' - porażka
::       '1' - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_file_location:=_a;
_table:=_b;
_field:=_c;
_ref:=_d;
_result:=$exec('memo_add','#blob','@'+_file_location,_table,_field,_ref);
_result


\editor_blob_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Ładuje pole BLOB do edytora
::   WE: _a - STRING - akronim tabeli
::       _b - STRING - akronim pola BLOB
::       _c - STRING - formuła na prefix
::       _d - STRING - SQL Ref konkretnego rekordu
::   WY: STRING - ścieżka do pliku tymczasowego
::  TAG: <PUBLICZNA>
:: ~OST: INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_field:=_b;
_prefix:=_c;
_ref:=_d;

_can_continue:=1;
_result:='';

{? _table=''
|| _can_continue:=0;
   FUN.emsg('Nie podano akronimu tabeli z polem typu: %1'@['BLOB'])
?};

{? _field=''
|| _can_continue:=0;
   FUN.emsg('Nie podano akronimu pola typu: %1'@['BLOB'])
?};
{? exec('interm','#system')
|| FUN.emsg(exec('interm_nacc_msg','#system'));
   _can_continue:=0
?};

{? _can_continue>0
||
   _tab:=($_table)();
   _separator:=exec('sep','#file');

   _can_continue:=1;
   _tab.cntx_psh();
   {? _ref<>''
   || _tab.prefix();
      _can_continue:=_tab.seek(_ref)
   ?};
   {? _can_continue>0
   || _rule:='_tab:=_a;_tab.'+_field;
      _val:=($_rule)(_tab);
      {? _val=null()
      || _can_continue:=0
      ?}
   ?};
   {? _can_continue>0
   || _file:=_tab.bl_info(_field,'NAME');
      _fpath:='@'+tmp_dir()+_separator+_file;
      _can_continue:=_tab.bl_get(_field,_fpath,0)
   ?};

   {? _can_continue>0
   || {? (1+_fpath)='@'
      || _result:=1-_fpath
      || _result:=_fpath
      ?}
   ?};
   _tab.cntx_pop()
?};
_result


\editor_blob_save
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Zapisuje zawartość edytora do bloba
::   WE: _a - STRING - lokalizacja pliku tymczasowego
::       _b - STRING - akronim tabeli
::       _c - STRING - akronim pola BLOB
::       _d - STRING - SQL Ref rekordu
::   WY: '0' - porażka
::       '1' - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_file_location:=_a;
_table:=_b;
_field:=_c;
_ref:=_d;

_tab:=($_table)();

_can_continue:=1;

_result:='0';

{? exec('cli_functions','#system')=0
|| _can_continue:=0;
   FUN.emsg(exec('indevice_nacc_msg','#system'))
?};

{? _can_continue>0
||
   _tab.cntx_psh();
   {? _ref<>''
   || _tab.prefix();
      _can_continue:=_tab.seek(_ref)
   ?};
   {? _can_continue>0
   || _can_continue:=_tab.bl_put(_field,_file_location,0)
   ?};

   {? _can_continue>0
   || _result:='1'
   ?};
   _tab.cntx_pop()
?};
_result


\set_icons
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Wskazuje pulpitowi lokalny plik z ikonkami. Od tego momentu elementy pulpitu mogą dziedziczyć ten plik z ikonami
::       i używać ikon które są w środku
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - ścieżka do pliku z tapetami na terminalu
::       [_d] - STRING - nazwa pulpitu w pulpicie któremu ustawić ikony
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_filepath:=_c;
_desk_name:='';
{? var_pres('_d')=type_of('')
|| _desk_name:=_d
?};

{? 1+_filepath='@'
||
:: Ucinam małpę jeśli podana
   _filepath:=1-_filepath
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

ctr_set(_window_id,_ctr_id,'setDesktopIcons',_desk_name,_filepath);
~~


\pulpit_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Dodaje kontrolkę panelplus na pulpit Merit
::   WE: _a - STRING - tytuł okienka kontrolką
::       _b - STRING - identyfikator kontrolki
::       _c - INTEGER - szerokość panelu
::       _d - INTEGER - wysokość panelu
::       [_e] - INTEGER - współrzędna X
::       [_f] - INTEGER - współrzędna Y
::       [_g] - INTEGER - 0/[1] - czy kontrolka ma być domyślnie widoczna
::       [_h] - STRING - nazwa klasy z kontrolką, domyślnie org.mcl.czest.xdesk.core.app.DesktopControlPulpit
::       [_i] - STRING - nazwa pliku desc
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_title:=_a;
_ctr_id:=_b;
_width:=_c;
_height:=_d;
_x:=-1;
{? var_pres('_e')=type_of(0)
|| _x:=_e
?};
_y:=-1;
{? var_pres('_f')=type_of(0)
|| _y:=_f
?};
_visible:=1;
{? var_pres('_g')=type_of(0)
|| _visible:=_g
?};
{? exec('interm','#system')
|| _class:='org.mcl.czest.xdesk.interm.app.DesktopControlInPulpit'
|| _class:='org.mcl.czest.xdesk.core.app.DesktopControlPulpit'
?};
{? var_pres('_h')=type_of('')
|| _class:=_h
?};
{? exec('interm','#system')
|| _desc_name:='panelplus_interm'
|| _desc_name:='panelplus'
?};
{? var_pres('_i')=type_of('')
|| _desc_name:=_i
?};
::_desc_name:='panelplus_j8';
::{? exec('runtime_p60','#system')
::|| _desc_name:='panelplus_j11'
::?};
ctr_call('!desktop',,'addWindowControl',_ctr_id,_class+':'+_desc_name,_title,_x,_y,_width,_height,_visible);
~~


\pulpit_visible
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Sprawdza czy kontrolka o podanym identyfikatorze jest aktualnie widoczna na pulpicie Merita
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

_result:=0;
_can_continue:=1;

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
|| FUN.wdrerror('Funkcja pulpit_visible dotyczy tylko kontrolek umieszczonych na pulpicie.'@);
   _can_continue:=0
?};
{? _can_continue>0
|| _result:=ctr_call(_window_id,_ctr_id,'pulpitVisible')
?};
_result


\pulpit_hidden_executor
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [20.42]
:: OPIS: Sprawdza czy kontrolka o podanym identyfikatorze ma jakiś panel który może wykonywać formuły
::       mimo tego że kontrolka jest niewidoczna
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

_result:=0;
_can_continue:=1;

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
|| FUN.wdrerror('Funkcja pulpit_hidden_executor dotyczy tylko kontrolek umieszczonych na pulpicie.'@);
   _can_continue:=0
?};
{? _can_continue>0
|| _result:=ctr_call(_window_id,_ctr_id,'hiddenExecutorPresent')
?};
_result


\set_timer
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Ustawia czas timera zdefiniowany dla podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - INTEGER - czas dla timera
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_value:=_d;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'setTimerFor',_element_id,_value);
_result


\pulpit_filter
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Zwraca tekst aktualnie widoczny w polu 'Wyszukaj' na pulpicie
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

_result:='';
_can_continue:=1;

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
|| FUN.wdrerror('Funkcja pulpit_filter dotyczy tylko kontrolek umieszczonych na pulpicie.'@);
   _can_continue:=0
?};
{? _can_continue>0
|| _result:=ctr_call(_window_id,_ctr_id,'pulpitFilter')
?};
{? type_of(_result)=0
|| _result:=''
?};
_result


\set_tooltip
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Ustawia podpowiedź dla podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - treść podpowiedzi
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_tooltip:=_d;
_result:='';

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:=ctr_call(_window_id,_ctr_id,'setTooltip',_element_id,_tooltip);
_result


\system
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Wykonuje komendę systemową na terminalu klienta
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - komenda
::       [_d] - STRING - ścieżka do pliku w którym będzie przechwycony wynik z konsoli
::       [_e] - STRING - kodowanie w pliku: 'UTF-8' lub 'windows-1252'. Na systemie Windows
::                       dobrze działa 'windows-1252', jednak odczytując linie pliku należy korzystać
::                       z metody STR.s852maz(_line)
::   WY: INTEGER - wynik wywołania komendy, lub -100 - błąd kontrolki
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_command:=_c;
_output:='';
{? var_pres('_d')=type_of('')
|| _output:=_d
?};
_encoding:='windows-1252';
{? var_pres('_e')=type_of('')
|| _encoding:=_e
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:=ctr_call(_window_id,_ctr_id,'system',_command,_output,_encoding);
_result


\clone
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Klonuje podany elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       [_d] - INTEGER - 0/[1] - czy po sklonowaniu wykonać zapis do pliku .dsku
::   WY: STRING - id sklonowanego elementu lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_save:=1;
{? var_pres('_d')=type_of(0)
|| _save:=_d
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'cloneOf',_element_id,_save);
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Usuwa podany elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       [_d] - INTEGER - 0/[1] - czy po usunięciu wykonać zapis do pliku .dsku
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_save:=1;
{? var_pres('_d')=type_of(0)
|| _save:=_d
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'deleteOf',_element_id,_save);
_result


\user_save
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Zapisuje zmiany do pliku .dsku o ile panel umożliwia edytowanie przez użytkowników
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'userSave');
_result


\user_revert
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.22]
:: OPIS: Wycofuje zmiany w pliku .dsku o ile panel umożliwia edytowanie przez użytkowników
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       [_c] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'userRevert',_dialog);
_result


\set_icon
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.42]
:: OPIS: Ustawia ikonę dla podanego elementu pulpitu - o ile element obsługuje ikony
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - ścieżka do ikony na terminalu
::       [_e] - INTEGER - [0]/1 - czy zapisywać ikonę w content (po zapisaniu pulpitu znajdzie się w pliku dsk)
::       [_f] - INTEGER - [0]/1 - czy po ustawieniu ikony zapisywać pulpit użytkownika w .dsku
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_filepath:=_d;

_content:=0;
{? var_pres('_e')=type_of(0)
|| _content:=_e
?};

_save:=0;
{? var_pres('_f')=type_of(0)
|| _save:=_f
?};

_result:='';

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};
_result:=ctr_call(_window_id,_ctr_id,'setIcon',_element_id,_filepath,_content,_save);
_result


\set_formula
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.42]
:: OPIS: Ustawia formułę dla podanego elementu pulpitu - o ile element wykonuje akcję formułową
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - STRING - formuła do wykonania
::       [_e] - INTEGER - [0]/1 - czy zapisywać ikonę w content (po zapisaniu pulpitu znajdzie się w pliku dsk)
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_formula:=_d;

_content:=0;
{? var_pres('_e')=type_of(0)
|| _content:=_e
?};

_result:='';

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};
_result:=ctr_call(_window_id,_ctr_id,'setFormula',_element_id,_formula,_content);
_result


\set_location
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.42]
:: OPIS: Ustawia położeni podanego elementu pulpitu - pod warunkiem że panel na którym się znajduje ma prosty rozkład
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::       _d - INTEGER - X
::       _e - INTEGER - Y
::       [_f] - INTEGER - [0]/1 - czy zapisywać położenie w content (po zapisaniu pulpitu znajdzie się w pliku dsk)
::   WY: STRING - ustawiona wartość lub '' jeśli coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;
_loc_x:=_d;
_loc_y:=_e;

_content:=0;
{? var_pres('_f')=type_of(0)
|| _content:=_f
?};

_result:='';

{? _ctr_id*'desktop:'>0
|| _window_id:='!desktop'
?};
_result:=ctr_call(_window_id,_ctr_id,'setLocation',_element_id,_loc_x,_loc_y,_content);
_result


\get_formula
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.42]
:: OPIS: Zwraca formułę którą wykonuje podany element pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::   WY: STRING - formuła dla elementu (pusty napis dla elementów ktore nie wykonują nic)
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'getFormulaOf',_element_id);
_result


\get_background
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.42]
:: OPIS: Zwraca kolor tła podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::   WY: STRING - kolor w formacie MBASE np '255:255:255'
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'getBackgroundOf',_element_id);
_result


\get_foreground
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.42]
:: OPIS: Zwraca kolor czcionki podanego elementu pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::   WY: STRING - kolor w formacie MBASE np '255:255:255'
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
?};

_result:='';
_result:=ctr_call(_window_id,_ctr_id,'getForegroundOf',_element_id);
_result


\repaint
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Odrysowywuje wszystkie elementy kontrolki
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
?};

ctr_call(_window_id,_ctr_id,'repaint');
~~


\get_bounds
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [19.42]
:: OPIS: Zwraca rozmiar w pikselach podanego elementu pulpitu, lub całego pulpitu
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::   WY: STRING - kolor w formacie MBASE np '255:255:255'
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
?};

_result:=obj_new('x','y','w','h');
_result.x:=0;
_result.y:=0;
_result.w:=0;
_result.h:=0;

_res:=ctr_call(_window_id,_ctr_id,'getBoundsOf',_element_id);
{? _res<>''
||
   _split:=spli_str(_res,';');
   {? obj_len(_split)>3
   || _result.x:=#_split[1];
      _result.y:=#_split[2];
      _result.w:=#_split[3];
      _result.h:=#_split[4];
      ~~
   ?}
?};
_result


\get_value_elements
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [23.25]
:: OPIS: Zwraca wartość dla podanego elementu pulpitu. W pierwszej kolejności zwraca wartość z tablicy _e, dopiero jak nie znajdzie
::       elementu w tablicy albo tablica nie przekazana wykonuje normalne get_value
::   WE: _a - STRING - identyfikator okna z kontrolką ('' dla aktualnego okna, patrz help dla funkcji ctr_call)
::       _b - STRING - identyfikator kontrolki w oknie
::       _c - STRING - id elementu (systemowe) na pulpicie lub string w formacie 'id elementu (użytkownika)@nazwa pulpitu'
::      [_d] - STRING - argument funkcji get_value;
::      [_e]  - tab_tmp - tablica z elementami pulpitu, jeżeli podana to stamtąd jest czytana wartość
::   WY: STRING - wartość elementu (pusty napis dla elementów ktore nie zwracają nic)
::  OLD: \get_value/desktop.fml
::----------------------------------------------------------------------------------------------------------------------
_window_id:=_a;
_ctr_id:=_b;
_element_id:=_c;

_args:='';
{? var_pres('_d')=type_of('')
|| _args:=_d
?};
_elements:=~~;
{? var_pres('_e')>100
|| _elements:=_e
?};

{? _ctr_id*'desktop:'
|| _window_id:='!desktop'
?};

_result:='';
{? type_of(_elements)>0
|| _elements.cntx_psh();
   _elements.prefix(_element_id,);
   {? _elements.first()
   || _result:=_elements.VALUE
   || _result:=exec('get_value','#desktop',_window_id,_ctr_id,_element_id,_args)
   ?};
   _elements.cntx_pop()
|| _result:=exec('get_value','#desktop',_window_id,_ctr_id,_element_id,_args)
?};
_result


:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 7dd5725a41c7ba142b6ef76207c4e8a44b09e1617a70c5db8a950da4fd25b3f9ead2ce23ea3f414e2331ec7848cb16d44f740b023ba17ac2a9d583baaa050ef9a747815825c076c7616aea735e33004c03524761a0bc9d7c0dd6cd00b2dc1e7c39852f4b2cd7a4a59bc4c01e5b25421d34434cbf4fda3686059e6880ea1af330
