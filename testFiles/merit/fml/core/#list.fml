:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #list.fml
:: Utworzony: 28.11.2013
:: Autor: RWR
::======================================================================================================================
:: Zawartość: Formuły związane z listami danych. Listy mogą być alternatywą dla tablic o nieznanym rozmiarze.
::======================================================================================================================


\list_decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Definicja klasy List implementującej listę. Opis metod publicznych - poniżej.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Historia zmian:
:: 29.11.2013  RWR      Implementacja listy jednokierunkowej z podstawową funkcjonalnością:
::                      - dodawanie elementów na końcu (add());
::                      - przeglądanie (first(), next());
::                      - wyszukiwanie elementu (find()).
::
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('List',@.CLASS)>0
|| return()
?};

obj_decl('List',

:  Pola prywatne -------------------------------------------------------------------------------------------------------

:  Wskazanie na głowę (pierwszy element) listy.
   obj_fld('HEAD',~~),

:  Wskazanie na ogon (ostatni element) listy.
   obj_fld('TAIL',~~),

:  Wskazanie na "bieżący" element listy.
   obj_fld('CURRENT',~~),

:  Licznik elementów - rozmiar listy.
   obj_fld('SIZE',0),

:  Metody prywatne -----------------------------------------------------------------------------------------------------

:  Tworzy węzeł listy.
   obj_meth('newNode',"_node:=obj_new('DATA','NEXT'); _node.DATA:=_a; _node"),

:  Metody publiczne ----------------------------------------------------------------------------------------------------

   obj_meth('add',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda dodaje element na końcu listy.
::   WE: _a = el - Element (dowolnego typu), który będzie dodany na końcu listy.
::   WY: Aktualny rozmiar listy.
::----------------------------------------------------------------------------------------------------------------------
   "  {? _=0
      || return(0)
      ?};
      _data:=_a;

      _node:=.newNode(_data);
      {? type_of(.HEAD)=0
      || .HEAD:=.TAIL:=.CURRENT:=_node
      || .TAIL.NEXT:=_node;
         obj_del(.TAIL);
         .TAIL:=_node;
         obj_del(.CURRENT);
         .CURRENT:=_node
      ?};
      .SIZE+=1
   "),


   obj_meth('find',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda odnajduje element listy spełniający zadany warunek (określony formułą przekazaną w pierwszym argumencie
::       wywołania). Jeżeli element zostanie znaleziony - zmienia się bieżąca pozycja w liście i element można pobrać
::       metodą .get(). Jeżeli element nie został znaleziony - bieżąca pozycja w liście nie jest zmieniana.
::   WE: _a = war - Formuła odpowiedzialna za rozstrzygnięcie, czy bieżący element jest tym, którego poszukujemy.
::                  Do formuły, poczynając od pierwszego (w kolejności dodawania do listy), przekazywane są kolejne
::                  elementy. Przetwarzanie jest kończone:
::                   - sukcesem, jeżeli formuła zwróci wartość 1;
::                   - porażką, jeżeli przejrzana została cała lista;
::   WY: 0 - Nie udało się znaleźć elementu spełniającego zadany warunek. Bieżąca pozycja listy nie zmieniła się.
::       1 - Znaleziono element spełniający zadany warunek. Bieżąca pozycja listy wskazuje na znaleziony element.
::----------------------------------------------------------------------------------------------------------------------
   "  _condition:=_a;
:     A może bieżący jest szukanym (taka drobna optymalizacja)?
      {? type_of(.CURRENT) & _condition(.CURRENT.DATA)
      || 1

      || _current:=.CURRENT;
::       Metoda get użyta w pętli zmienia wartość pola .CURRENT. Zapamietajmy je, aby w przypadku porażki szukania
::       przywrócić.
         _found:=0;
         {? .first()
         || {!
            |? {? _condition(.get())
               || _found:=1;
                  0
               || .next()
               ?}
            !}
         ?};
         {? ~_found
         || {? type_of(.CURRENT)
            || obj_del(.CURRENT)
            ?};
            .CURRENT:=_current
         ?};
         _found
      ?}
   ",type_of(""),-1),


   obj_meth('first',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda zmienia bieżącą pozycję listy na pierwszy element listy. Dla listy bez elementów metoda ma działanie
::       puste.
::   WE:
::   WY: 0 - Nie udało się zmienić bieżącej pozycji listy (lista jest pusta).
::       1 - Bieżącą pozycją listy jest głowa.
::----------------------------------------------------------------------------------------------------------------------
   "  {? type_of(.CURRENT)
      || obj_del(.CURRENT)
      ?};
      {? type_of(.HEAD)
      || .CURRENT:=.HEAD;
         1
      ?}
   ",-1),


   obj_meth('get',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda udostępnia wartość bieżącego elementu. Jeżeli bieżąca pozycja listy nie została ustalona, metoda
::       zwraca ~~.
::   WE:
::   WY: Wartość bieżącej pozycji listy.
::----------------------------------------------------------------------------------------------------------------------
   "  {? type_of(.CURRENT)
      || .CURRENT.DATA
      || ~~
      ?}
   "),


   obj_meth('next',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda przesuwa bieżącą pozycję listy na następny element, jeżeli jest to możliwe, tzn.:
::        - bieżąca pozycja jest ustalona;
::        - bieżący element nie jest ostatni - ma następnik.
::   WE:
::   WY: 0 - Nie udało się przesunąć bieżącej pozycji listy.
::       1 - Bieżąca pozycja listy została przesunięta.
::----------------------------------------------------------------------------------------------------------------------
   "  {? type_of(.CURRENT) & type_of(.CURRENT.NEXT)
      || _next:=.CURRENT.NEXT;
         obj_del(.CURRENT);
         .CURRENT:=_next;
         1
      ?}
   ",-1),


   obj_meth('size',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda zwraca aktualną liczbę elementów listy.
::   WE:
::   WY: Liczba elementów listy.
::----------------------------------------------------------------------------------------------------------------------
      ".SIZE",-1),


   obj_virt('tostring',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda wirtualna zwracająca znakową reprezentację elementu.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      "'?'")

)


\list_demo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Przykład zastosowania klasy List.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('FUN','#object');
:Deklaracja klasy.
exec('list_decl','#list');

:Powołanie obiektu.
_lista:=obj_new(@.CLASS.List);

:Definicja metody wirtualnej.
set_virt(_lista,'tostring',"
   {? type_of(.CURRENT) || $.CURRENT.DATA.I+' - '+.CURRENT.DATA.S || 'Wartość nieustalona.' ?}");

: Test metody next na pustej liście.
FUN.info('Lista pusta, wynik metody next() = %1 '@ [$_lista.next()]);

:Prezentacja "bieżącego" elementu. Lista jest pusta - bieżąca pozycja listy nie jest ustalona.
FUN.info('Lista jest pusta - bieżąca pozycja jest nieustalona.\n%1'@ [_lista.tostring()]);

:Dodanie 3 elementów listy. Elementy są tablicami.
{! _lp:=1..3
|! _el:=obj_new('I','S');
   _el.I:=_lp;
   _el.S:=%(64+_lp);
   _lista.add(_el);
   obj_del(_el)
!};

:Prezentacja "bieżącego" elementu - po dodaniu elementu do listy stoimy na ostatnim.
FUN.info('Bieżący element (po dodaniu wszystkich):\n%1'@[_lista.tostring()]);

:Zebranie w pętli reprezentacji kolejnych elementów.
_str:='';
{? _lista.first()
|| {!
   |?
:     Przykład użycia metody .get() - metoda zwraca element. Ponieważ wiemy, że element jest tablicą, możemy się do
:     niego w ten sposób odwoływać.
      _el:=_lista.get();
      _str+='[1] '+$_el.I+' - '+_el.S+'\n';
      obj_del(_el);
:
:     Gdyby zależało nam jedynie na prezentacji elementów listy moglibyśmy użyć wcześniej zdefiniowanej (wirtualnej)
:     metody .tostrng()
      _str+='[2] '+_lista.tostring()+'\n';
:
      _lista.next()
   !}
|| _str:='-=Lista jest pusta=-'@
?};
FUN.info('Do listy dodano 3 elementy. Zawartość listy (uzyskana dwoma sposobami):\n%1'@[_str]);

:Prezentacja "bieżącego" elementu - po wykonaniu pętli stoimy na ostatnim.
FUN.info('Bieżący element (po pętli):\n%1'@[_lista.tostring()]);

:Przykład zachowania podczas użycia metody .find():
: - element został znaleziony - bieżąca pozycja wskazuje na niego;
{? _lista.find("_a.I=2")
|| _str:='Szukano 2 i znaleziono.'@
|| _str:='Szukano 2 ale nie znaleziono.'@
?};
FUN.info('%1\nBieżący element:\n%2'@[_str,_lista.tostring()]);
: - element nie został znaleziony - wciąż stoimy na "2".
{? _lista.find("_a.I=4")
|| _str:='Szukano 4 i znaleziono.'@
|| _str:='Szukano 4 ale nie znaleziono.'@
?};
FUN.info('%1\nBieżący element:\n%2'@[_str,_lista.tostring()]);

~~

:Sign Version 2.0 jowisz:1028 2019/06/07 15:58:47 35d8c71d9f34275b5f44dd574cfcab5ee369b1547bfce8973fe1a4992b046e2edb59de83bfa9714d7edb2b8bf30895d5a796a5725845ebe53bad6a86946f7500da76d503c590fcc7383009069e78bc0109959fea21cf9a62c6bc1e8226d489ca50952caa72f494981fd90819d0641c42d0b0ff70a5dea3299750464f6e5b97e6
