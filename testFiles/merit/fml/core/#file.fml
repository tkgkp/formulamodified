:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: #file.fml [17.00]
:: Utworzony: 17.12.2014
:: Autor: AK
::======================================================================================================================
:: Zawartość: Uniwersalne formuły do obsługi plików
::======================================================================================================================


\get_fun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca obiekt plikowy z zawartością formuły w trybie do odczytu,
::       pobierane mogą być tylko wiersze opatrzone podanym prefiksem
::   WE: _a - plik
::       _b - formuła
::       [_c] - prefiks pobieranych wierszy (usuwany z pobieranych wierszy)
::   WY: obiekt plikowy
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_c')<>type_of('') || _c:='' ?};

_f_name:='#!Tmp\\'+$SYSLOG.tm_stamp()+'.txt';
_f_out:=fopen(_f_name,'uw',0,1,1);

_ok:=0;
::{? _a+4<>'.fml' || _a+='.fml' ?};
_filename:=__FileLayer.real_name({? _a+4='.fml' || _a-4 || _a ?},'fml',_b);
_f_in:=fopen(_filename,'ur',1,0,1);
{? _f_in.is_open()
|| {!
   |?
      _w:=_f_in.fread();
      {? 1+_w='\\'
      || _find:=_w*' ';
         {? _find || _w:=1-((_find-1)+_w) || _w:=1-_w  ?};
         {? _w=_b
         ||
            _ok:=1;
            {!
            |?
               _w:=_f_in.fread();
               {? 1+_w<>'\\' & (+_c)+_w=_c || _f_out.fwrite((+_c)-_w) ?};
               1+_w<>'\\' & 1+_w<>'\n'
            !}
         ?}
      ?};
      _w<>'\n' & ~_ok
   !}
?};
obj_del(_f_out);

_f_out:=fopen(_f_name,'ur',0,1,1);
_f_out


\string_fun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca napis z zawartością formuły,
::       pobierane mogą być tylko wiersze opatrzone podanym prefiksem
::   WE: _a - plik
::       _b - formuła
::       [_c] - prefiks pobieranych wierszy (usuwany z pobieranych wierszy)
::       [_d] - prefiks pobieranych wierszy (wartość do wyszukania w wierszu)
::       [_e] - znak kontynuacji w następnym wierszu [domyślnie: '']
::       [_f] - prefiks lini będącej kontynuacja poprzedniej [domyślnie: '']
::       [_g] - 1-pomijać linie z komentarzem - domyślnie nie 0 ::
::       [_h] - INTEGER - 0/[1] - czy pobierać prawdziwą warstwę pliku _a. Jeżeli nie
::                                to należy się upewnić że parametr _a został przepuszczony
::                                wcześniej przez obiekt __FileLayer
::   WY: STRING - treść formuły
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_c')<>type_of('') || _c:='' ?};
{? var_pres('_d')<>type_of('') || _d:='' ?};
{? var_pres('_e')<>type_of('') || _e:='' ?};
{? var_pres('_f')<>type_of('') || _f:='' ?};
{? var_pres('_g')<>type_of(0)  || _g:=0  ?};

_file_layer:=1;
{? var_pres('_h')=type_of(0)
|| _file_layer:=_h
?};

_dlc:=+_c;
_dld:=+_d;
_dle:=+_e;
_dlf:=+_f;

_result:='';

{? _file_layer>0
|| _filename:=__FileLayer.real_name({? _a+4='.fml' || _a-4 || _a ?},'fml',_b)
|| _filename:=_a
?};
_f_in:=fopen(_filename,'ur',1,0,1);
{? _f_in.is_open()
|| {!
   |?
      _w:=_f_in.fread();
      {? 1+_w='\\'
      || _find:=_w*' ';
         {? _find || _w:=1-((_find-1)+_w) || _w:=1-_w  ?};
         {? _w=_b
         ||
            _cont:=0;
            {!
            |?
               _w:=_f_in.fread();
               {? _g & (2+_w)='::'
               || _cont:=0
               |? 1+_w<>'\\' & {? _dld || _w*_d || _dlc+_w=_c ?}
               || _cont:=_dle & _w+_dle=_e;
                  _result+={? _cont || _dlc-_w-1 || _dlc-_w+'\n' ?}
               |? _cont & _dlf+_w=_f
               || _cont:=_dle & _w+_dle=_e;
                  _result+=|{? _cont || _dlf-_w-1 || _dlf-_w+'\n' ?}
               |? _cont
::                Domknięcie błędnej kontynuacji.
               || _result+='\n';
                  _cont:=0
               ?};
               1+_w<>'\\' & 1+_w<>'\n'
            !}
         ?}
      ?};
      _w<>'\n'
   !}
?};
_result


\get_fun_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Zwraca tabelkę z zawartością formuły,
::       pobierane mogą być tylko wiersze opatrzone podanym prefiksem
::   WE: _a - nazwa pliku (wyszukiwanego zgodnie z PTH) lub uchwyt
::       _b - formuła
::       [_c] - prefiks pobieranych wierszy (usuwany z pobieranych wierszy)
::       [_d] - prefiks pobieranych wierszy (wartość do wyszukania w wierszu)
::       [_e] - znak kontynuacji w następnym wierszu [domyślnie: '']
::       [_f] - prefiks lini będącej kontynuacja poprzedniej [domyślnie: '']
::       [_g] - 1-pomijać linie z komentarzem - domyślnie nie 0 ::
::       [_h] - INTEGER - 0/[1] - czy pobierać prawdziwą warstwę pliku _a. Jeżeli nie
::                                to należy się upewnić że parametr _a został przepuszczony
::                                wcześniej przez obiekt __FileLayer
::   WY: _tab_tmp z polami LINE i MEMO
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_c')<>type_of('') || _c:='' ?};
{? var_pres('_d')<>type_of('') || _d:='' ?};
{? var_pres('_e')<>type_of('') || _e:='' ?};
{? var_pres('_f')<>type_of('') || _f:='' ?};
{? var_pres('_g')<>type_of(0)  || _g:=0  ?};

_file_layer:=1;
{? var_pres('_h')=type_of(0)
|| _file_layer:=_h
?};

_dlc:=+_c;
_dld:=+_d;
_dle:=+_e;
_dlf:=+_f;

_tab:=tab_tmp(2,
:: 'POLE','TYP','Nazwa w oknie',
   'UID','REAL','Identyfikator',
   'LINE','STRING[255]','Pierwsze 255 znaków',
   'MEMO','SYS_MEMO','Notatka',
   'PARENT','REAL','Dla kontynuacji - uid rodzica'
);

{? var_pres('_a')=type_of(@.CLASS.FILE_T)
|| _f_in:=_a
|| {? _file_layer>0
   || _filename:=__FileLayer.real_name({? _a+4='.fml' || _a-4 || _a ?},'fml',_b)
   || _filename:=_a
   ?};
   _f_in:=fopen(_filename,'ur',1,0,1)
?};
{? _f_in.is_open()
|| {!
   |?
      _w:=_f_in.fread();
      {? 1+_w='\\'
      || _find:=_w*' ';
         {? _find || _w:=1-((_find-1)+_w) || _w:=1-_w  ?};
         {? _w=_b
         ||
            _cont:=0;
            _parent:=0;
            {!
            |?
               _w:=_f_in.fread();
               {? _g & (2+_w)='::'
               || _cont:=0
               |? 1+_w<>'\\' & {? _dld || _w*_d || _dlc+_w=_c ?}
               || _cont:=_dle & _w+_dle=_e;
                  _tab.blank();
                  _tab.UID:=SYSLOG.tm_stamp();
                  _tab.PARENT:=_parent;
                  _result:={? _cont
                           || _parent:=_tab.UID;
                              _dlc-_w-1
                           || _parent:=0;
                              _dlc-_w+'\n'
                           ?};
                  _tab.LINE:=_result;
                  _tab.memo_set(_result,'MEMO');
                  {? _tab.add()
                  || _tab.memo_put(,'MEMO')
                  ?}
               |? _cont & _dlf+_w=_f
               || _cont:=_dle & _w+_dle=_e;
                  _tab.blank();
                  _tab.UID:=SYSLOG.tm_stamp();
                  _tab.PARENT:=_parent;
                  _result:=|{? _cont
                            || _parent:=_tab.UID;
                               _dlf-_w-1
                            || _parent:=0;
                               _dlf-_w+'\n'
                            ?};
                  _tab.LINE:=_result;
                  _tab.memo_set(_result,'MEMO');
                  {? _tab.add()
                  || _tab.memo_put(,'MEMO')
                  ?}
               |? _cont
::                Domknięcie błędnej kontynuacji.
               || _result:='\n';
                  _tab.blank();
                  _tab.LINE:=_result;
                  _tab.PARENT:=_parent;
                  _tab.UID:=SYSLOG.tm_stamp();
                  _tab.memo_set(_result,'MEMO');
                  {? _tab.add()
                  || _tab.memo_put(,'MEMO')
                  ?};
                  _parent:=0;
                  _cont:=0
               ?};
               1+_w<>'\\' & 1+_w<>'\n'
            !}
         ?}
      ?};
      _w<>'\n'
   !}
?};
_tab


\is_fun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Formuła sprawdza czy istnieje funkcja w podanym pliku fml
::       Sprawdza po kolei w warstwach: modify, standard
::   WE: _a = plik,
::       _b = formula
::   WY: 1 - tak, 0 - nie, lub wystąpił problem podczas czytania pliku
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? exec_ver(_b,_a)<>0
|| _result:=1
?};
_result


\is_fun_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [17.00]
:: OPIS: Formuła sprawdza czy istnieje funkcja w podanym pliku fml (funkcja elementarna sprawdza w konkretnym pliku)
::   WE: _a = plik,
::       _b = formula
::   WY: 1 - tak, 0 - nie, lub wystąpił problem podczas czytania pliku
::----------------------------------------------------------------------------------------------------------------------
{? _a+4<>'.fml' || _a+='.fml' ?};
_f:=fopen(_a,'r',1);
{? _f
|| {! |? (_w:=fread(_f))<>'\n' |!
      {? 1+_w='\\'
      || _find:=_w*' ';
         {? _find || _w:=1-((_find-1)+_w) || _w:=1-_w  ?};
         {? _w=_b
         || fclose(_f);
            return(1)
         ?}
      ?}
   !};
   fclose(_f)
?};
0


\oblicz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: rr [2006]
:: OPIS: wywołuje formułę _a z pliku _b
::   WE: _a - nazwa formuły
::       _b - nazwa pliku
::   WY: _wyn - wartość
::----------------------------------------------------------------------------------------------------------------------
($('exec(\''+_a+'\',\''+_b+'\')'))()


\select_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Pokazuje selektor plików wg pth i umożliwia wybór któregoś z nich
::   WE: _a - STRING - maska plików np 'b_*.fml'
::       [_b] - STRING - nazwa pliku na którym stanąć po wyświetleniu okna
::   WY: STRING - nazwa wybranego pliku lub ''
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mask:=_a;

_jump:='';
{? var_pres('_b')=type_of('')
|| _jump:=_b
?};

_result:='';

_files:=files(_mask);

_wer:=_files.mk_sel('Pliki na serwerze'@,,,,,,,,'U');
_files.win_fld(_wer,,'FILENAME',,,50);
_files.win_act(_wer,,'Formuła','Wybierz'@@,,,"sel_exit()",,1,,,,'W');
_files.win_sel(_wer);

{? _jump<>''
|| {? _files.find_key(_jump)=0
   || _files.first()
   ?}
|| _files.first()
?};

{? _files.select(,1,5)>0
|| _result:=_files.FILENAME
?};
_result


\select_formula
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Pokazuje selektor formuł w pliku na serwerze i umożliwia wybór którejś formuły
::   WE: [_a] - STRING - nazwa_pliku.fml - jeśli nie podana to najpierw umożliwia wybór pliku
::       [_b] - STRING - nazwa_pliku.fml - plik na którym stanąć w selektorze plików - tylko jeśli _a nie podane
::   WY: STRING - 'nazwa_wybranej_formuły\nazwa_pliku.fml' lub ''
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_jump:='';
{? var_pres('_b')=type_of('')
|| _jump:=_b
?};

_filename:='';
{? var_pres('_a')=type_of('')
|| _filename:=_a
|| _filename:=exec('select_file','#file','*.fml',_jump)
?};

_result:='';

{? _filename<>''
||
   {? _filename+4<>'.fml' || _filename+='.fml' ?};

   _tab:=tab_tmp(1,
      'FORMULA','STRING[30]','Formuła'@,
      'OPIS','STRING[100]','Opis'@,
      'UTW','STRING[20]','Autor i wersja'@,
      'NAGL','SYS_MEMO','Nagłówek formuły'@);
   _file:=fopen(_filename,'ur',1);
   {? _file
   || {!
      |? {? (_line:=fread(_file))<>'\n'
         ||
            {? 1+_line='\\'
            || _tab.blank();
               _tab.FORMULA:=1-_line;

::             Wyciągamy z formuły OPIS i AUTORA
               _pr_opis:=' OPIS:';
               _pr_utw:=' UTW:';

::             Wyciągamy z formuły nagłówek
               _pr_nagl:='----------';
               _nagl_num:=0;
               _nagl_txt:='';

               _found_opis:=0;
               _found_utw:=0;
               _found_nagl:=0;
               {? var_pres('_f_search')>100
               || obj_del(_f_search)
               ?};
               _f_search:=exec('get_fun','#file',_filename,_tab.FORMULA,'::');
               {? _f_search.is_open()
               || {!
                  |?
                     _can_continue:=1;
                     {? (_line2:=fread(_f_search))<>'\n'
                     || {? _line2*_pr_opis>0
                        || _tab.OPIS:=|gsub(_line2,_pr_opis,'');
                           _found_opis:=1
                        ?};
                        {? _line2*_pr_utw>0
                        || _tab.UTW:=|gsub(_line2,_pr_utw,'');
                           _found_utw:=1
                        ?};

                        {? _line2*_pr_nagl>0
                        || _nagl_num+=1
                        ?};

                        {? _nagl_num>0
                        || _nagl_txt+=_line2+'\n'
                        ?};
                        {? _nagl_num=2
                        || _found_nagl:=1
                        ?};

                        {? _found_opis>0 & _found_utw>0 & _found_nagl>0
                        || _can_continue:=0
                        ?}
                     || _can_continue:=0
                     ?};
                     _can_continue>0
                  !};
                  fclose(_f_search);
                  obj_del(_f_search)
               ?};
               _tab.add();

               {? _nagl_txt<>''
               || _tab.memo_set(_nagl_txt);
                  _tab.memo_put()
               ?}
            ?};
            1
         || 0
         ?}
      !};
      fclose(_file)
   ?};

   _wer:=_tab.mk_sel('Formuły w pliku: %1'@[_filename],,,,,,,,'U');
   _tab.win_fld(_wer,,'FORMULA',,,30);
   _tab.win_fld(_wer,,'OPIS',,,100);
   _tab.win_fld(_wer,,'UTW',,,20);
   _tab.win_act(_wer,,'Formuła','Wybierz'@@,,,"sel_exit()",,1,,,,'W');

   _fml:="
      _tab:=cur_tab(1,1);
      exec('edit_memo','#edit',_tab.memo_txt(,1),'Nagłówek formuły'@,,,20,,0,0);
      ~~
   ";
   _tab.win_act(_wer,,'Wyświetl',,,,_fml);

   _tab.win_sel(_wer);
   _tab.first();
   {? _tab.select(,1)>0
   || _result:=_tab.FORMULA+'\\'+_filename
   ?}
?};
_result


\sep
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Funkcja zwraca separator katalogów w systemie operacyjnym, w którym jest uruchomiona wskazana składowa
::       oprogramowania.
::   WE: [_a] [NUMBER] - Składowa oprogramowania:
::                         0 - Klient [domyślnie];
::                         1 - Serwer aplikacji;
::                         2 - Serwer bazy danych.
::   WY: Właściwy separator katalogów.
::----------------------------------------------------------------------------------------------------------------------
_kind:={? var_pres('_a')=type_of(0) & (0<=_a & _a<=2) || _a || 0 ?};
{? 2+sys_name(_kind)='U_'
|| '/'
|| '\\'
?}


\path
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMK] [2006]
:: OPIS: Zwraca sciezke do pliku (wycina nazwe pliku wraz z rozszerzeniem
::   WE: _a - sciezka wraz z nazwa pliku (i 3 znakowym rozszerzeniem)
::   WY: Sciezka do pliku
::  OLD: \path/skid_xd.fml
::----------------------------------------------------------------------------------------------------------------------
_windows:=sys_name(0)='WINDOWS';
{? _windows & _a*'.'<>0
|| _koniec:=1;
   {! _i:=1..(+_a)
   |? _koniec
   |! _znak:=(_a+1);
      {? _znak='.' || _a:=(_a-1); _koniec:=0 || _a:=(_a-1) ?}
   !}
?};
_koniec:=1;
{! _i:=1..(+_a)
|? _koniec
|! _znak:=(_a+1);
   {? (_windows & _znak='\\') | (~_windows & _znak='/') || _koniec:=0 || _a:=(_a-1) ?}
!};
_a


\pliki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: BZ [2006]
:: OPIS: Formuła zwraca listę plików poprzedzoną sciąką bezwzględną
::   WE: [_a] - katalog dla którego mają zostać wylistowane pliki
::       [_b] - ignore
::       [_c] - recursive
::       [_d] - separator
::   WY: alias do tabeli z listą plików
::  OLD: \pliki/skid_dir.fml
::----------------------------------------------------------------------------------------------------------------------
_directory:={? var_pres('_a')=type_of('') || _a || '' ?};
_ignore:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_recursive:={? var_pres('_c')=type_of(0) || _c || 0 ?};
_sep:={? var_pres('_d')=type_of('') || _d || '/' ?};

_pliki:=tab_tmp(1
   ,'LP',      'INTEGER',     'Lp'
   ,'LINE',    'STRING[250]', 'Line'
   ,'FILENAME','STRING[250]', 'Nazwa pliku'
   ,'SIZE',    'REAL', 'Rozmiar'
   ,'MOD_DATE','DATE','Data modyfikacji'
   ,'MOD_TIME','TIME','Godzina modyfikacji'
);
{? fexists(_directory)<>2
||
   return(_pliki)
?};
_lp:=0;
_local:={? (1+_directory)='@' || '@' || '' ?};
_fdir:=
   {? _directory=''
   || fdir(,_ignore,_recursive)
   || fdir(_directory,_ignore,_recursive)
   ?};
{? type_of(_fdir)<>type_of(~~)
||
   _loop:=_fdir.first();
   {!
   |? _loop
   |!
      {? _fdir.TYPE='f'
      ||
         _line:=_local+_fdir.DIR+_sep+_fdir.NAME;
         {? +_line>255
         ||
            FUN.info('Ścieżka dostępu do katalogu i nazwa pliku przekroczyły 255 znaków.'@)
         ||
            _lp+=1;
            _pliki.LP:=_lp;
            _pliki.LINE:=_line;
            _pliki.FILENAME:=_fdir.NAME;
            _pliki.SIZE:=_fdir.SIZE;
            _pliki.MOD_DATE:=_fdir.MOD_DATE;
            _pliki.MOD_TIME:=_fdir.MOD_TIME;
            _pliki.add()
         ?}
      ?};
      _loop:=_fdir.next()
   !}
?};
_pliki


\plik_size
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [19.42]
:: OPIS: Formuła sprawdzająca rozmiar pliku
::   WE: _a - pth
::       _b - nazwa pliku
::   WY: rozmiar podanego pliku, lub -1 gdy nie znaleziono pliku
::----------------------------------------------------------------------------------------------------------------------
_pth_new:=_a;
_file_new:=_b;
_size_new:=0;
{? fexists(_pth_new+_file_new)
||
   _list_new:=exec('pliki','#file',_pth_new);
   _list_new.index(_list_new.ndx_tmp(,,'FILENAME',,));
   _list_new.prefix(_file_new,);
   {? _list_new.first()
   || _size_new:=_list_new.SIZE
   ?}
||
   _size_new:=-1
?};
_size_new


\log_viewer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PS [17.00]
:: OPIS: Tworzy okno grupowe i osadza przeglądarkę logów wewnątrz niego
::----------------------------------------------------------------------------------------------------------------------
_init:="
   exec('load','#desktop','log_viewer','log_viewer.dsk',,,,,,0)
";

_tab:=exec('create_grp','#desktop','log_viewer',_init,25,150,'Przeglądarka logów'@);
_tab.select();
''


\filechooser
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PS] [17.14]
:: OPIS: Wyświetla dialog z pytaniem o wybór pliku/katalogu
::   WE: [_a] - STRING  - tytuł okienka, domyślnie 'Wybór pliku'.
::       [_b] - INTEGER - czy ma zostać dodany filtr ze wszystkimi plikami, 0 - nie, 1 - tak (domyślnie).
::       [_c] - STRING  - dodaje do wyboru filtr plików. Spodziewaną wartością są rozszerzenia
::                        oddzielone średnikami, domyslnie - brak dodatkowego filtru.
::       [_d] - STRING  - opis filtru dodanego w parametrze _c, na przykład 'Pliki xml'.
::                        domyślnie - pusty ciąg znaków.
::       [_e] - INTEGER - tryb wyboru plików, 0 - pojedynczy (domyślnie), 1 - wiele plików.
::       [_f] - STRING  - parametr okreslający, co można wskazać w dialogu, dostepne wartości to:
::                        'FILES_ONLY' - tylko pliki (domyślnie),
::                        'DIRECTORIES_ONLY' - tylko foldery,
::                        'FILES_AND_DIRECTORIES' - foldery i pliki.
::       [_g] - INTEGER - typ dialogu, 0 (domyślny) - otwarcia pliku, 1 - zapisu pliku.
::       [_h] - STRING  - katalog wskazywany w dialogu. Domyślną wartoscią jest ostatnio wskazany katalog zapisany
::                        w pliku .ini, lub jeżeli go nie ma, to katalog użytkownika.
::   WY: STRING - ścieżka w przypadku pojedynczego pliku lub '' jeżeli użytkownik zrezygnował.
::          TAB - tabela tymczasowa (DIR,FILENAME,I___NR) w przypadku wyboru wielu plików.
:: ~OST: INFILECHOOSER
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? exec('interm','#system')>0
|| FUN.emsg(exec('interm_nacc_msg','#system'));
   return('')
?};
_title:={? var_pres('_a')=type_of('') || _a || 'Wybór pliku'@ ?};
_defaultfilter:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_filter:={? var_pres('_c')=type_of('') || _c || '' ?};
_filterdesc:={? var_pres('_d')=type_of('') || _d || '' ?};
_multiselect:={? var_pres('_e')=type_of(0) || _e || 0 ?};
_filemode:={? var_pres('_f')=type_of('') & 'FILES_ONLY;DIRECTORIES_ONLY;FILES_AND_DIRECTORIES'*_f>0
           || _f
           || 'FILES_ONLY'
           ?};
_dialog:={? var_pres('_g')=type_of(0) || _g || 0 ?};
_defaultdir:={? var_pres('_h')=type_of('') || _h || '' ?};

ctr_set('!application', 'filechooser','reset');
ctr_set('!application', 'filechooser','setAcceptAllFileFilterUsed',_defaultfilter);
{? _filter<>'' || ctr_set('!application','filechooser','addFilter',_filterdesc,_filter) ?};
ctr_set('!application', 'filechooser','setMultiSelectionEnabled',_multiselect);
ctr_set('!application', 'filechooser','setFileSelectionMode',_filemode);
ctr_set('!application', 'filechooser','setDialogTitle',_title);
ctr_set('!application', 'filechooser','setCurrentDirectory',_defaultdir);

_can_continue:=ctr_call('!application', 'filechooser',{? _dialog || 'showSaveDialog' || 'showOpenDialog' ?});

{? _can_continue>0
|| _result:=ctr_call('!application', 'filechooser','getSelectedFile'+{? _multiselect || 's' || '' ?})
?};
_result


\chk_exec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.14]
:: OPIS: Sprawdza poprawność użycia exec
::   WE: _a - napis podlegajacy sprawdzeniu
::   WY: tablica nazwana z polami:
::       OK: 1-poprawnie 0-błąd
::       FILE: błędny plik
::       FORMULA: błędna formuła
::----------------------------------------------------------------------------------------------------------------------
_wyn:=obj_new('OK','FILE','FORMULA');
_wyn.OK:=1;
_a:=gsub(_a,' ','');
{!
|? _poz:=_a*'exec(';
   {? _poz
   || _a:=(_poz+4)-_a;
      _poz:=_a*')';
      {? _poz
      || _exec:=gsub((_poz-1)+_a,'\'','');
         _a:=_poz-_a;
         _str:=spli_str(_exec,',');
         _file:=_str[2];
         _formula:=_str[1];
         &_str;
         {? ~exec('is_fun','#file',_file,_formula)
         || _wyn.OK:=0;
            _wyn.FILE:=_file+'.fml';
            _wyn.FORMULA:=_formula;
            0
         || 1
         ?}
      || 0
      ?}
   ?}
!};
_wyn


\decl_filelayer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Deklaracja klasy obsługującej warstwowość plików.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('FileLayer',@.CLASS)>0
|| return()
?};

obj_decl('FileLayer',
:: --POLA---------------------------------------------------------------------------------------------------------------
   obj_fld('cache',0),
   obj_fld('TAB',~~),
   obj_fld('TAB_NDX1',~~),
   obj_fld('TAB_NDX2',~~),
   obj_fld('BUF_FILES',~~),
   obj_fld('ws',''),
   obj_fld('ws2',''),

:: --KONSTRUKTOR/DESTRUKTOR---------------------------------------------------------------------------------------------
   obj_meth('__init',
      "  .cache:=var_pres('_b')=type_of(0) & _b;
         .TAB:=tab_tmp(3,
            'FILE','STRING[64]','Nazwa pliku (bez rozszerzenia)'@,
            'EXT','STRING[3]','Rozszerzenie nazwy pliku'@,
            'RULE','STRING[31]','Formuła (tylko dla *.fml)'@,
            'LAYER','STRING[1]','Warstwa'@
         );
         .BUF_FILES:=tab_tmp(3,
            'FILE','STRING[64]','Nazwa pliku (bez rozszerzenia)'@,
            'EXT','STRING[3]','Rozszerzenie nazwy pliku'@,
            'LAYER','STRING[1]','Warstwa'@,
            'SIZE','REAL','Rozmiar'@,
            'READ_ALL','INTEGER','Czy cały plik wczytany do cache'
         );
         .TAB_NDX1:=.TAB.ndx_tmp(,,'FILE',,,'EXT',,,'RULE',,);
         .TAB_NDX2:=.TAB.ndx_tmp(,,'FILE',,,'EXT',,,'LAYER',,);
         .ws:=.TAB.mk_sel(FUN.TYT,'P',1);
         .ws2:=.BUF_FILES.mk_sel(FUN.TYT,'P',1);
         ~~
      "),
:: --METODY-------------------------------------------------------------------------------------------------------------

   obj_meth('chk',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Dla danego pliku, rozszerzenia i formuły sprawdza, czy występuje w którejkolwiek warstwie
::      (jak jest, to dodaje do tabeli roboczej żeby zoptymalizować kolejne sprawdzenia).
::   WE:  _a  [STRING] - Nazwa pliku (bez rozszerzenia).
::        _b  [STRING] - Rozszerzenie.
::       [_c] [STRING] - Nazwa formuły. Parametr wymagany tylko dla _b='fml'.
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
      ".layer(_a,_b,_c)<>''",type_of(''),type_of(''),type_of(''),-1),

   obj_meth('chk',".chk(_a,_b,'')",type_of(''),type_of(''),-1),

   obj_meth('layer',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Dla danego pliku, rozszerzenia i formuły zwraca informację, w której warstwie występuje
::      (jak jest, to dodaje do tabeli roboczej żeby zoptymalizować kolejne sprawdzenia).
::   WE:  _a  - STRING - Nazwa pliku (bez rozszerzenia).
::        _b  - STRING - Rozszerzenie.
::       [_c] - STRING - Nazwa formuły. Parametr wymagany tylko dla _b='fml'.
::       [_d] - INTEGER - [0]/1 - czy wywołanie rekurencyjne?
::   WY: Kod warstwy:
::          's' - Warstwa standardowa.
::          'm' - Warstwa modyfikacji.
::          ''  - Ustalenie warstwy nie powiodło się.
::----------------------------------------------------------------------------------------------------------------------
      "  _file:=_a;
         _ext:=_b;
         _rule:=_c;

         _recursive:=0;
         {? var_pres('_d')=type_of(0)
         || _recursive:=_d
         ?};

         _layer:='';

         _cache:=0;
         {? _ext='fml' & _rule<>''
         ||
::          Póki co cache włączony tylko dla plików fml
            _cache:=1
         ?};

         {? _cache>0
         ||
::          Sprawdzam status cache i w razie potrzeb go usuwam
            .cache_file_core(_file,_ext,'m',,0);
            .cache_file_core(_file,_ext,'s',,0)
         ?};

         {? _cache>0
         ||
::          Szukam formuły w cache
            .TAB.cntx_psh();
            .TAB.index(.TAB_NDX1);
            .TAB.prefix(_file,_ext,_rule,);
            {? .TAB.first()
            || _layer:=.TAB.LAYER
            ||
               {? _recursive=0
               ||
::                Jeśli nie znalazło formuły w obecnym cache, to
::                są tylko dwie możliwości:
::                   1. Formuła w pliku jest i należy ją znaleźć
::                   2. Formuły nie ma wcale w tym pliku
::                W obu przypadkach trzeba będzie przeczytać fizycznie pliki, co jest kosztowne.
::                W pierwszym przypadku to jak długo będzie trwało czytanie pliku, zależy od tego
::                w którym miejscu pliku znajduje się formuła. Jeżeli na początku to luzik, jeżeli na końcu to pech.
::                W drugim przypadku plik i tak będą przeczytane całe dwa pliki.
::                Skoro pliki i tak będą fizycznie czytane, to lepiej wczytać je od razu w całości
::                do cache i każde następne sprawdzenie formuł w tym pliku będzie super szybkie

::                1. Najpierw wczytujemy cały plik z warstwy 'm'
                  _pth:=1;
                  .cache_file_core(_file,_ext,'m',_pth);
::                Sprawdzamy czy formuła się znajdzie
                  _rec_res:=.layer(_file,_ext,_rule,1);
                  {? _rec_res<>''
                  ||
::                   Znalazła się
                     _layer:=_rec_res
                  ?};

                  {? _layer=''
                  ||
::                   2. Następnie wczytujemy cały plik z warstwy 's'
                     .cache_file_core(_file,_ext,'s',_pth);
                     _rec_res:=.layer(_file,_ext,_rule,1);
                     {? _rec_res<>''
                     ||
::                      Znalazła się
                        _layer:=_rec_res
                     ?}
                  ?}
               ?}
            ?};
            .TAB.cntx_pop()
         || {? _ext='fml' & _rule<>''
            || {? exec('is_fun_core','#file',_file+'.m.fml',_rule)
               || _layer:='m'
               |? exec('is_fun_core','#file',_file+'.fml',_rule)
               || _layer:='s'
               ?}
            || {? fexists(_file+'.m.'+_ext,1)
               || _layer:='m'
               |? fexists(_file+'.'+_ext,1)
               || _layer:='s'
               ?}
            ?};
            {? _cache & _layer<>''
            ||
               .TAB.prefix(_file,_ext,_rule);
               {? .TAB.first()
               || .TAB.LAYER:=_layer;
                  .TAB.put()
               ||
                  .TAB.blank();
                  .TAB.FILE:=_file;
                  .TAB.EXT:=_ext;
                  .TAB.RULE:=_rule;
                  .TAB.LAYER:=_layer;
                  .TAB.add()
               ?}
            ?}
         ?};
         _layer
      ",type_of(''),type_of(''),type_of('')),

   obj_meth('layer',".layer(_a,_b,'')",type_of(''),type_of(''),-1),

   obj_meth('real_name',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Dla danego pliku, rozszerzenia i formuły zwraca rzeczywistą nazwę pliku, w którym jest formuła pod względem
::       warstwowości (jak jest, to dodaje do tabeli roboczej żeby zoptymalizować kolejne sprawdzenia).
::   WE:  _a  [STRING] - Nazwa pliku (bez rozszerzenia).
::        _b  [STRING] - Rozszerzenie.
::       [_c] [STRING] - Nazwa formuły. Parametr wymagany tylko dla _b='fml'.
::   WY: Nazwa pliku uwzględniająca warstwowość, lub '' w przypadku błędu.
::----------------------------------------------------------------------------------------------------------------------
      "  _file:=_a;
         _ext:=_b;
         _rule:=_c;
         _layer:=.layer(_file,_ext,_rule);
         {? _layer='m'
         || _file+'.m.'+_ext
         |? _layer='s' | _layer=''
         || _file+'.'+_ext
         || ''
         ?}
      ",type_of(''),type_of(''),type_of(''),-1),

   obj_meth('real_name',".real_name(_a,_b,'')",type_of(''),type_of(''),-1),

::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Dla danego pliku (pełnej jego nazwy) zwraca rzeczywistą nazwę pliku
::   WE:  _a  [STRING] - Pełna nazwa pliku (z rozszerzeniem).
::   WY: Nazwa pliku uwzględniająca warstwowość, lub '' w przypadku błędu.
::----------------------------------------------------------------------------------------------------------------------
   obj_meth('real_name',
      "  {? _a*'.'
         || _parts:=spli_str(_a,'.');
            _ext:=_parts[obj_len(_parts)];
            _name:=_a-((+_ext)+1);
            .real_name(_name,_ext,'')
         || ''
         ?}
      ",type_of(''),-1),

   obj_meth('select',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: selekcja tabeli z zapamiętanymi formułami
::----------------------------------------------------------------------------------------------------------------------
      "  {? 1
         || .TAB.prefix();
            .TAB.win_sel(.ws);
            .TAB.select();
            .BUF_FILES.prefix();
            .BUF_FILES.win_sel(.ws2);
            .BUF_FILES.select()
         || FUN.info('Informacje o dostępie do plików / formuł nie są gromadzone.'@)
         ?};
         ~~
      "),

      obj_meth('del_same',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Usuwa plik warstwy *.m gdy jest ten sam co warstwy standardowej
::   WE:  _a  - nazwa pliku bez rozszerzenia
::        _b  - rozszerzenie
::       [_c] - scieżka - 1-wg pth 0-lokalna
::   WY: czy usunieto plik warstwy *.m: 1-tak 0-nie
::----------------------------------------------------------------------------------------------------------------------
      "  _name:=_a;
         _ext:=_b;
         _pth:={? var_pres('_c')>0 || _c || 1 ?};
         _fn:=_name+'.'+_ext;
         _fnm:=_name+'.m.'+_ext;
         {? fexists(_fn,_pth) & fexists(_fnm,_pth)
         || _file:=fopen(_fnm,'b',_pth,,1);
            {? _file.is_open()
            || _hashm:=hash(_file);
               _file.fclose();
               &_file;
               _file:=fopen(_fn,'b',_pth,,1);
               {? _file.is_open()
               || _hash:=hash(_file);
                  _file.fclose();
                  {? _hash=_hashm
                  || ferase(_fnm,_pth)
                  ?}
               ?}
            ?}
         ?}
      ",type_of(''),type_of('')),

      obj_meth('cache_file',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Odczytuje cały plik i zapamiętuje jego formuły w cache. Od tej pory wszystkie
::       wywołania metod chk i layer będą działać dla danego pliku szybciej
::   WE:  _a  - nazwa pliku bez rozszerzenia
::        _b  - rozszerzenie
::       [_c] - scieżka - 1-wg pth 0-lokalna
::   WY: czy usunieto plik warstwy *.m: 1-tak 0-nie
::----------------------------------------------------------------------------------------------------------------------
      "  _name:=_a;
         _ext:=_b;
         _pth:={? var_pres('_c')>0 || _c || 1 ?};
         _fn:=_name+'.'+_ext;
         _fnm:=_name+'.m.'+_ext;

         .cache_file_core(_name,_ext,'m',_pth);
         .cache_file_core(_name,_ext,'s',_pth);
         ~~
      ",type_of(''),type_of('')),


      obj_meth('cache_file_core',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Jądro funkcji cachującej plik
::   WE:  _a  - STRING - nazwa pliku bez rozszerzenia
::        _b  - STRING - rozszerzenie
::        _c  - STRING - warstwa
::       [_d] - INTEGER - scieżka - 1-wg pth 0-lokalna
::       [_e] - INTEGER - czy czytać wszystkie formuły z pliku
::----------------------------------------------------------------------------------------------------------------------
      "
         _name:=_a;
         _ext:=_b;
         _layer:=_c;
         _pth:={? var_pres('_d')>0 || _d || 1 ?};
         _read_file:={? var_pres('_e')>0 || _e || 1 ?};

         {? _layer='m'
         || _filename:=_name+'.m.'+_ext
         || _filename:=_name+'.'+_ext
         ?};

         {? .cache_status(_name,_ext,_layer,_pth)=2
         ||
::          Plik byl w cache, ale jego rozmiar się zmienił, albo pliku już nie ma, więc usuwam cały cache w piguły
::          Na wszelki wypadek usuwam oba cache, bo formuła mogła być w jednej warstiwe, ale pojawiła
::          się dodatkowo w drugiej warstwie
            .cache_delete(_name,_ext,'m');
            .cache_delete(_name,_ext,'s')
         ?};

         {? fexists(_filename,_pth)
         ||
            _file:=fopen(_filename,'r',_pth,,1);
            {? _file.is_open()
            ||
               _size:=0;
               _binary:=fopen(_filename,'br',_pth,,1);
               {? _binary.is_open()
               || _size:=fgetsize(_binary)
               ?};
               .BUF_FILES.prefix(_name,_ext,_layer,);
               {? .BUF_FILES.first()
               || {? _read_file>0 & .BUF_FILES.READ_ALL=0
                  ||
::                   Coś było w cache, ale częściowo. usuwam wiec cache dla tego pliku
                     .cache_delete(_name,_ext,_layer);
::                   Czytam caly plik
                     .read_file(_file,_name,_ext,_layer);

                     .BUF_FILES.blank();
                     .BUF_FILES.FILE:=_name;
                     .BUF_FILES.EXT:=_ext;
                     .BUF_FILES.SIZE:=_size;
                     .BUF_FILES.LAYER:=_layer;
                     .BUF_FILES.READ_ALL:=1;
                     .BUF_FILES.add()
                  ?}
               ||
::                Pliku nie było w buforze - dodaję go
                  .BUF_FILES.blank();
                  .BUF_FILES.FILE:=_name;
                  .BUF_FILES.EXT:=_ext;
                  .BUF_FILES.SIZE:=_size;
                  .BUF_FILES.LAYER:=_layer;

                  {? _read_file>0
                  ||
::                   Czytam formuły z pliku i umieszczam je w .TAB
                     .read_file(_file,_name,_ext,_layer);
                     .BUF_FILES.READ_ALL:=1
                  ?};
                  .BUF_FILES.add()
               ?}
            ?}
         ?};
         ~~
      ",type_of(''),type_of(''),type_of('')),

      obj_meth('cache_status',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Sprawdza status danego pliku
::   WE:  _a - STRING - nazwa pliku
::        _b - STRING - rozszerzenie
::        _c - STRING - warstwa
::       [_d] - INTEGER - scieżka - 1-wg pth 0-lokalna
::   WY: 0 - pliku nie bylo w cache
::       1 - plik byl w cache i sie nie zmienil
::       2 - plik byl w cache i sie zmienil, zniknął
::----------------------------------------------------------------------------------------------------------------------
      "
         _name:=_a;
         _ext:=_b;
         _layer:=_c;
         _pth:={? var_pres('_d')>0 || _d || 1 ?};

         _result:=0;

         {? _layer='m'
         || _filename:=_name+'.m.'+_ext
         || _filename:=_name+'.'+_ext
         ?};

         _size:=0;

         {? fexists(_filename,_pth)
         ||
            _binary:=fopen(_filename,'br',_pth,,1);
            {? _binary.is_open()
            || _size:=fgetsize(_binary)
            ?}
         ?};

         .BUF_FILES.prefix(_name,_ext,_layer);
         {? .BUF_FILES.first()
         ||
::          Plik był już buforowany, sprawdzam czy się zmienił rozmiar
            {? _size>0 & _size=.BUF_FILES.SIZE
            || _result:=1
            || _result:=2
            ?}
         ?};
         _result
      "),

      obj_meth('read_file',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Odczytuje zawartość pliku i formuły dodaje do tabeli .TAB
::   WE:  _a - obj_new - uchwyt do obiektu FILE
::        _b - STRING - nazwa pliku
::        _c - STRING - rozszerzenie
::        _d - STRING - warstwa
::----------------------------------------------------------------------------------------------------------------------
      "  _file:=_a;
         _name:=_b;
         _ext:=_c;
         _layer:=_d;
         _line:='';
         {!
         |? (_line:=fread(_file))<>'\\n'
         |!
            {? 1+_line='\\\\'
            || _find:=_line*' ';
               {? _find
               || _line:=1-((_find-1)+_line)
               || _line:=1-_line
               ?};

               {? _line<>''
               || .TAB.cntx_psh();
                  .TAB.prefix(_name,_ext,_line,);
                  {? .TAB.first()=0
                  ||
                     .TAB.blank();
                     .TAB.FILE:=_name;
                     .TAB.EXT:=_ext;
                     .TAB.RULE:=_line;
                     .TAB.LAYER:=_layer;
                     .TAB.add()
                  ?};
                  .TAB.cntx_pop();
                  ~~
               ?}
            ?}
         !}
      "),

      obj_meth('cache_delete',
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Usuwa cały cache powiazany z plikiem
::   WE:  _a - STRING - nazwa pliku
::        _b - STRING - rozszerzenie
::        _c - STRING - warstwa
::   WY: czy usunieto cache
::----------------------------------------------------------------------------------------------------------------------
      "
         _name:=_a;
         _ext:=_b;
         _layer:=_c;
         _can_continue:=1;
         _result:=0;

         .BUF_FILES.cntx_psh();
         .BUF_FILES.prefix(_name,_ext,_layer,);
         {? .BUF_FILES.first()
         || {!
            |? _can_continue:=.BUF_FILES.del(,1);
               .BUF_FILES.first() & _can_continue>0
            !}
         ?};
         .BUF_FILES.cntx_pop();

         {? _can_continue>0
         || .TAB.cntx_psh();
            .TAB.index(.TAB_NDX2);
            .TAB.prefix(_name,_ext,_layer,);
            {? .TAB.first()
            || {!
               |? _can_continue:=.TAB.del(,1);
                  .TAB.first() & _can_continue>0
               !}
            ?};
            .TAB.cntx_pop();
            ~~
         ?};

         {? _can_continue>0
         || _result:=1
         ?};
         _result
      ")
);
~~


\dir
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Zwraca listę plików w podanym folderze
::   WE: _a   - STRING - ścieżka do folderu lokalnego lub na serwerze
::       [_b] - INTEGER - 0/1 czy do wyniku dopisywać również nazwy podfolderów
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
:: ~OST: INFOPEN,INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_dir:=_a;
_subdir:=0;
{? var_pres('_b')=type_of(0)
|| _subdir:=_b
?};

_local:=(1+_dir)='@';

_tab:=tab_tmp(3,
   'FILENAME','STRING[255]','Nazwa pliku',
   'FILEPATH','STRING[255]','Ścieżka',
   'IS_FILE','INTEGER','Czy jest plikiem',
   'EXT','STRING[20]','Rozszerzenie',
   'IS_DIR','INTEGER','Czy jest folderem'
);

{? _local>0
|| {? exec('cli_functions','#system')=0
   || FUN.emsg(exec('indevice_nacc_msg','#system'));
      return(_tab)
   ?}
?};

_ndx:=_tab.ndx_tmp('',1,'IS_DIR',,1, 'FILENAME',,0);
_tab.index(_ndx);
{? _local>0
|| _sep:=exec('sep','#file')
|| _sep:=exec('sep','#file',1)
?};
{? _dir+1=_sep
|| _dir:=_dir-1
?};

_cfg:=exec('get_cfg','#xml','dir_list','',0,_local);
_tmpfile:=_cfg.tmp_dir()+_sep+$SYSLOG.tm_stamp()+'.dir';
{? _local>0
|| _cfg.add_blob('dir_list.jar')
|| _cfg.add_file('dir_list.jar')
?};
::_dir2jar:=_dir;
::_tmp2jar:=_tmpfile;
{? _tmpfile<>''
||
   _dir2jar:='\"'+_dir+' \"';
   _tmp2jar:='\"'+_tmpfile+' \"';
   _can_continue:=_cfg.execute(_dir2jar,_tmp2jar)
|| _can_continue:=0
?};
{? _can_continue<>100
||
   _can_continue:=1;
   {? _local>0
   || _file:=fopen('@'+_tmpfile,'ur',0)
   || _file:=fopen(_tmpfile,'ur',0)
   ?};

   {? (1+_dir)='@'
   || _dir:=(1-_dir)
   ?};
   {? _file>0
   || {!
      |? _line:=fread(_file);
         {? _line*'File###'
         ||
            {? var_pres('_split')>100
            || obj_del(_split)
            ?};
            _split:=spli_str(_line,'File### ');
            {? obj_len(_split)>1
            || _tab.blank();
               _tab.FILENAME:=_split[2];
               _tab.FILEPATH:=_dir+_sep+_tab.FILENAME;
               _tab.EXT:=exec('extension','#file',_tab.FILENAME);
               _tab.IS_FILE:=1;
               _can_continue:=_tab.add()
            ?}
         ?};
         {? _subdir>0 & _line*'Directory###'
         ||
            {? var_pres('_split')>100
            || obj_del(_split)
            ?};
            _split:=spli_str(_line,'Directory### ');
            {? obj_len(_split)>1
            || _tab.blank();
               _tab.FILENAME:=_split[2];
               _tab.FILEPATH:=_dir+_sep+_tab.FILENAME;
               _tab.IS_DIR:=1;
               _can_continue:=_tab.add()
            ?}
         ?};
         _line<>'\n' & _can_continue>0
      !};
      fclose(_file);
      ferase(_tmpfile,0)
   ?}
|| _choice:=FUN.choice('Wystąpił nieoczekiwany błąd w programie: %1'@['dir_list.jar'],,'Szczegóły'@);
   {? _choice=1
   || _log:=_cfg.tmp_dir()+_sep+'dir_list.log';

      _can_continue:=1;
      _exist:=0;
      _log_pth:=0;

      {? exec('runtime_r10','#system')
      || {? _local>0
         || ~~
         || _dest:='dir_list_'+$SYSLOG.tm_stamp()+'.part';
            _can_continue:=fcopy(_log,_dest,0,1,1);
            {? _can_continue>0
            || _log:=_dest;
               _log_pth:=1
            ?}
         ?}

      ||
         {? _local>0
         || _log:='@'+_log
         || _dest:='@'+tmp_dir()+_sep+'dir_list.log';
            _can_continue:=fcopy(_log,_dest,0,0,1);
            {? _can_continue>0
            || _log:=_dest
            ?}
         ?}
      ?};

      {? _can_continue>0 & fexists(_log,_log_pth)>0
      || txt_view(_log,_log_pth,2,'UTF-8')
      || FUN.emsg('Podgląd pliku: %1 nieudany.'@[_log])
      ?}
   ?}
?};
_tab.prefix();
_tab.first();
_tab


\parse_exec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Z napisu zawierającego wywołanie exec lub params_exec wydłubuje nazwę formuły i nazwę pliku fml
::       UWAGA! kod formułowy jest traktowany tekstowo, czyli wydłubane będą nazwy formuł
::       z komentarzy, napisów i stałych formułowych które znajdą się w tym tekście
::   WE: _a - STRING - pojedyncza linia jakiegoś kodu formułowego
::   WY: tab_tmp - tablica z polami: .NAME, .FILE
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_line:=_a;

_result:=tab_tmp(2,
:: 'POLE','TYP','Nazwa w oknie',
   'NAME','STRING[40]','Nazwa formuły',
   'FILE','STRING[30]','Nazwa pliku'
);

{? _line<>''
||
   _split:=spli_str(_line,'exec(\'');

   {? obj_len(_split)>1
   ||
::    Iteruje od drugiego elementu podziału, bo pierwszy mnie nigdy nie interesuje - będzie zawierał
::    pusty tekst, albo coś co było przed exec
      {! _it:=2..obj_len(_split)
      |! _part:=_split[_it];
         {? _part<>''
         ||
            {? var_pres('_split2')>100
            || obj_del(_split2)
            ?};
::          to co zostało tnę przecinkami
            _split2:=spli_str(_part,',');

            {? obj_len(_split2)>1
            || _name:=_split2[1];
               _name:=gsub(_name,'\'','');
               _name:=gsub(_name,'\\','');
               _file:=_split2[2];

::             odrzucam pierwszy apostrof
               _file:=1-_file;
::             wszystko dalej po drugim apostrofie w pliku mnie nie interesuje
               _pos:=_file*'\'';
               _file:=(_pos-1)+_file;

               _file:=gsub(_file,'\\','');

               {? _name<>'' & _file<>''
               || _result.prefix(_name,_file,);
                  {? _result.first()=0
                  || _result.blank();
                     _result.NAME:=_name;
                     _result.FILE:=_file;
                     _result.add()
                  ?}
               ?}
            ?}
         ?}
      !};
      ~~
   ?}
?};
_result.prefix();
_result


\split_file_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Formuła wyodrębnia z pełnej nazwy pliku: nazwę i rozszerzenie.
::       Przez rozszerzenie rozumiana jest ta część pełnej nazwy pliku, która występuje po ostatniej kropce.
::       Jeżeli pełna nazwa pliku nie zawiera znaku kropki, to oznacza, że nie ma rozszerzenia.
::   WE: _a [STRING] - Nazwa pliku wraz z rozszerzeniem.
::   WY: Tablica z elementami:
::             'fn'  - Nazwa pliku.
::             'ext' - Rozszerzenie pliku.
::----------------------------------------------------------------------------------------------------------------------
_ret:=obj_new('fn','ext');
_ret.fn:=_ret.ext:='';

{? var_pres('_a')<>type_of('') | _a=''
|| return(_ret)
?};

_array:=spli_str(_a,'.');
_len:=obj_len(_array);
{? _len=1
|| _ret.fn:=_a
|| _ret.ext:=_array[obj_len(_array)];
   _ret.fn:=_a-(+_ret.ext+1)
?};

_ret


\get_unique_file_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Formuła zwraca unikalną nazwę pliku we wskazanym katalogu
::       (ochrona przed nadpisaniem - automatyczne przenazwanie).
::       Przykład zastosowania.
::          Jeżeli w katalogu _b nie istnieje plik o nazwie _a, to formuła zwróci nazwę _a.
::          Jeżeli jednak plik o nazwie _a istnieje, to zostanie on zmodyfikowany w ten sposób, aby wciąż przypominał
::          nazwę _a, ale był unikalny (dodany zostanie licznik w nazwie).
::   WE:  _a  [STRING] - Nazwa pliku.
::       [_b] [STRING] - Ścieżka dostępu do katalogu (jeżeli poprzedzona @, to katalog lokalny). Jeżeli parametr
::                       zostanie pominięty, to wartość zostanie określona na podstawie deklaracji ścieżek.
::   WY: Nazwa pliku, który może zostać utworzony i nie spowoduje to nadpisania lub ''.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('')
|| _fn:=_a
|| return('')
?};

_dir:={? var_pres('_b')=type_of('') || _b || pth_dir(_a) ?};

{? fexists(_dir,0)<>2
|| return('')
?};

_sep:=exec('sep','#file',1+_dir<>'@');
{? _dir+1<>_sep
|| _dir+=_sep
?};

_org:=exec('split_file_name','#file',_a);

:: Maksymalna długość nazwy pliku (zgodnie z ograniczeniami MacroBASE'a).
_mdl:=64;

_lp:=0;
_mod:='';

{!
|? _fn:=_org.fn+_mod+'.'+(-_org.ext);
   {? fexists(_dir+_fn,0)
   || _lp+=1;
      _mod:='('+$_lp+')';
      _adl:=(+_org.fn)+(+_mod);
      {? _adl>_mdl
      || _org.fn:=_org.fn-(_adl-_mdl)
      ?};
      1
   ?}
!};

_fn


\save_as
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Formuła służy do pobrania od użytkownika pełnej ścieżki do pliku lokalnego, który ma zostać zapisany.
::       Parametry: _b, _c, _d, _e obsługują mechanim "profile" - więcej na ten temat w #profile.fml.
::       Niepodanie parametrów _c lub _d spowoduje brak zapamiętania ścieżki do katalogu.
::       Niepodanie parametrów _c lub _e spowoduje brak zapamiętania nazwy pliku.
::       Funkcja ma charakter dialogowy - wszystkie ewewntualne komunikaty programistyczne (np. nieprawidłowe parametry
::       wywołania) są zgłaszane poprzez FUN.error().
::   WE: [_a] [STRING] - Proponowana nazwa pliku.
::       [_b] [STRING] - Nazwa pliku, w którym zapamiętane zostanie położenie katalogu.
::       [_c] [STRING] - Nazwa sekcji w pliku _b.
::       [_d] [STRING] - Nazwa parametru w sekcji _c (w pliku _b) przechowującego katalog.
::       [_e] [STRING] - Nazwa parametru w sekcji _c (w pliku _b) przechowującego plik.
::   WY: Pełna ścieżka dostępu do tworzonego pliku lub ''.
:: ~OST: INFEXISTS,INFILECHOOSER
::----------------------------------------------------------------------------------------------------------------------
{? exec('interm','#system')
|| FUN.emsg(exec('indevice_nacc_msg','#system'));
   return('')
?};
_tSTRING:=type_of('');
_file1:={? var_pres('_a')=_tSTRING || _a || '' ?};
_profile:={? var_pres('_b')=_tSTRING || _b || ~~ ?};
_section:={? var_pres('_c')=_tSTRING || _c || ~~ ?};
_pdir:={? var_pres('_d')=_tSTRING || _d || ~~ ?};
_pfile:={? var_pres('_e')=_tSTRING || _e || ~~ ?};

_dir:={? _section<>~~ & _pdir<>~~ || exec('get','#profile',_profile,_section,_pdir) || '' ?};
_file2:={? _section<>~~ & _pfile<>~~ || exec('get','#profile',_profile,_section,_pfile) || '' ?};

_file:={? _file2<>'' || _file2 || _file1 ?};

ctr_set('!application','filechooser','reset');
ctr_set('!application','filechooser','setDialogTitle','Zapisz jako'@);
ctr_set('!application','filechooser','setCurrentDirectory',_dir);
ctr_set('!application','filechooser','setSelectedFile',_file);
ctr_set('!application','filechooser','setMultiSelectionEnabled',0);
ctr_set('!application','filechooser','setFileSelectionMode','FILES_ONLY');
{? _file<>''
|| _of:=exec('split_file_name','#file',_file);
   {? _of.ext<>''
   || ctr_set('!application','filechooser','addDefaultFilter','Pliki typu %1'@ [~-_of.ext],_of.ext)
   ?}
?};

_ret:='';
_again:=1;
{!
|? _again
|! {? ctr_call('!application','filechooser','showSaveDialog')
   || _path:=ctr_call('!application','filechooser','getSelectedFile');
      {? ~fexists('@'+_path,0) | FUN.ask('Plik o podanej nazwie już istnieje.\nCzy chcesz go nadpisać?'@)
      || _ret:=_path;
         {? _section<>~~
         || _ap:=spli_str(_path,exec('sep','#file'));
            _dir:=_path-(+_ap[obj_len(_ap)]+1);
            {? _pdir<>~~
            || exec('set','#profile',_profile,_section,_pdir,_dir)
            ?};
            {? _pfile<>~~
            || exec('set','#profile',_profile,_section,_pfile,((+_dir)+1)-_path)
            ?}
         ?};
         _again:=0
      ?}
   || _again:=0
   ?}
!};
_ret


\save_1b_as
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Formuła służy do zapisywania jednego załącznika (bloba) na dysku lokalnym. Dodatkowo możliwe jest zapamiętanie
::       katalogu, w którym plik został zapisany - zostanie on podpowiedziany przy następnym zapisie.
::       Parametry: _c, _d, _e obsługują mechanim "profile" - więcej na ten temat w #profile.fml.
::       Niepodanie parametrów _d i _e spowoduje brak zapamiętania katalogu.
::       Funkcja ma charakter dialogowy - wszystkie ewewntualne komunikaty programistyczne (np. nieprawidłowe parametry
::       wywołania są zgłaszane poprzez FUN.error().
::   WE:  _a  [TABLE]  - Uchwyt tabeli z załącznikiem.
::        _b  [STRING] - Akronim pola z załącznikiem.
::       [_c] [STRING] - Nazwa pliku, w którym zapamiętane zostanie położenie katalogu.
::       [_d] [STRING] - Nazwa sekcji w pliku _c.
::       [_e] [STRING] - Nazwa parametru w sekcji _d (w pliku _c).
::   WY: Wynik operacji: 0 / 1.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(SYSLOG)
|| _stack:=form_stack();
   FUN.error('Nieprawidłowy typ parametru %1.'@ ['TABELA']+'\n(\\%1/%2.fml)' [_stack.name,_stack.file]);
   return(0)
|? var_pres('_b')<>type_of('')
|| _stack:=form_stack();
   FUN.error('Nieprawidłowy typ parametru %1.'@ ['POLE']+'\n(\\%1/%2.fml)' [_stack.name,_stack.file]);
   return(0)
|? var_pres(_b,_a)<>33
|| _stack:=form_stack();
   FUN.error('Nieprawidłowa wartość parametru %1.'@ ['POLE']+'\n(\\%1/%2.fml)' [_stack.name,_stack.file]);
   return(0)
?};

_TAB:=_a;
_fld:=_b;
_profile:={? var_pres('_c')=type_of('') || _c || ~~ ?};
_section:={? var_pres('_d')=type_of('') || _d || ~~ ?};
_param:={? var_pres('_e')=type_of('') || _e || ~~ ?};

_ret:=0;
_again:=1;
_ret:=exec('bl_save','#blob',_TAB,_fld);
_ret


\bin2txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Zwraca tekst z pliku binarnego
::       Dla dużych plików zwróconych zostanie domyślnie tylko 500000 znaków, nie należy zwiększać tej liczby ponad
::          limit zmiennej tekstowej.
::  OLD: \bin2txt/businesslink.fml
::   WE:  _a  [FILE]   - uchwyt pliku
::       [_b] [NUMBER] - liczba pierwszych znaków do pobrania (domyślnie 500000)
::   WY: [STRING]
::----------------------------------------------------------------------------------------------------------------------
_in_file:=_a;
{? var_pres('_b')=type_of(0) || _head:=_b || _head:=500000 ?};

_result:='';

_mode:=_in_file.get_mode();
{? _mode*'b'
|| _file:=_in_file.copy('br');
   {? _file.is_open()
   || _count:=0;
      {!
      |? _count+=1;
         _byte:=_file.fread();
         {? _byte<>-1
         || _result+=%_byte
         ?};
         _byte<>-1 & _count<_head
      !}
   ?};
   utf8_maz(_result,"{? _a<>0 || '?' || ~~ ?}")

|| _file:=_in_file.copy('ur');
   _result:='';
   {!
   |? (_linia:=_file.fread())<>'\n' & (_dl:=+_result)<_head
   |! _result+=(_head-_dl)+_linia
   !};
   _result
?}


\dir_from_path
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Zwraca katalog z pełnej ścieżki do pliku, ścieżka musi zawierać co najmniej jeden separator folderu (znak \ lub /)
::   WE: _a - STRING - ścieżka do pliku (musi być z @ jeśli lokalna)
::   WY: STRING lub ''
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_filepath:=_a;
_local:=0;

_result:='';

{? 1+_filepath='@'
|| _local:=1
?};

_sep:=exec('sep','#file',~_local);

_split:=spli_str(_filepath,_sep);

_len:=obj_len(_split);

{? _len>1
|| _filename:=_split[_len];
   {? _filename<>''
   || _result:=_filepath-((+_filename)+1)
   ?}
?};
_result


\file_from_path
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Zwraca nazwę i rozszerzenie pliku z podanej ścieżki. Jeżeli ścieżka nie zawiera separatora folderu, to zwracane
::       jest to co przyszło na wejście
::   WE: _a - STRING - ścieżka do pliku
::       [_b] - STRING - separator używany w ścieżce, jeżeli nie podany to znak '/' lub '\' znaleziony w ścieżce
::   WY: STRING - nazwa pliku wraz z rozszerzeniem lub ''
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_filepath:=_a;
_local:=0;

_result:='';

{? 1+_filepath='@'
|| _local:=1
?};
_aa:=1;

_sep:='';
{? var_pres('_b')=type_of('')
|| _sep:=_b
|| {? _filepath*'/'>0
   || _sep:='/'
   |? _filepath*'\\'
   || _sep:='\\'
   ?}
?};

{? _sep<>'' & _filepath*_sep>0
||
   {!
   |?
      {? 1+(_filepath+_aa)=_sep
      || _result:=1-(_filepath+_aa);0
      || _aa+=1; _aa<(+_filepath)
      ?}
   !}
|| _result:=_filepath
?};
_result


\tmp_filepath
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Zwraca ścieżkę do pliku w katalogu tymczasowym  po stronie klienta (nawet w interm)
::   WE: _a - STRING - nazwa pliku
::       [_b] - INTEGER - [0]/1 - czy doklejać małpę do ścieżki na starym runtime. Po emisji R.10 można nigdy nie doklejać
::   WY: STRING - ścieżka do folderu tymczasowego
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_filename:=_a;
_monkey:=0;
_result:='#!Tmp/'+_filename;
_result


\name_cleaner
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Usuwa z nazwy pliku niedozwolone znaki
::   WE: _a - STRING - nazwa pliku
::   WY: STRING - wyczyszczona nazwa
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_filename:=_a;
_filename:=gsub(_filename,':','');
_filename:=gsub(_filename,'/','');
_filename:=gsub(_filename,'\\','');
_filename:=gsub(_filename,'?','');
_filename:=gsub(_filename,'*','');
_filename:=gsub(_filename,'>','');
_filename:=gsub(_filename,'<','');
_filename:=gsub(_filename,'|','');
_filename


\extension
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Ze ścieżki lub nazwy pliku wyciąga i zwraca rozszerzenie
::   WE: _a - STRING - nazwa lub ścieżka pliku
::   WY: STRING np 'fml' lub '' jeżeli nie udało się wyciągnąć
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_path:=_a;
_result:='';
{? _path*'.'>0
|| _split:=spli_str(_path,'.');
   _len:=obj_len(_split);
   {? _len>0
   || _result:=_split[_len]
   ?}
?};
_result


\hash
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR & TMR [21.37]
:: OPIS: Formuła zwraca hash dla podanego pliku.
::   WE:  _a  [STRING] - Nazwa pliku (jeżeli parametr _b=0 to wraz ze ścieżką do pliku).
::        _b  [NUMBER] - Czy wyszukiwanie zgodne z pth
::       [_c] [STRING] - Rodzaj skrótu [domyślnie: 'sha1'].
::   WY: Hash lub ''.
::----------------------------------------------------------------------------------------------------------------------
_hash:='';
_name:={? var_pres('_a')=type_of('') || _a || return(_hash) ?};
 _pth:={? var_pres('_b')=type_of(0)  || _b || return(_hash) ?};
_kind:={? var_pres('_c')=type_of('') & ',sha1,sha224,sha256,sha384,sha512,md5,'*_c || _c || 'sha1' ?};

_fh:=fopen(_name,'br',_pth,0,1,1);
{? _fh.is_open()
|| _hash:=hash(_fh,_kind);
   _fh.fclose()
?};
obj_del(_fh);
_hash

:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 c77e2ea45e0145e125460be3a8f59eb72bbaeb80ac69b3570627f0d7987ee9b326d1de17b7f86736c11e96d11904c2694a9abd136f014f78d12e2c4cc395b997e8104069c1aa2c39a94de504ec0e7064af25e20f030d45a73af30c1c1e8455ae26818b80dcacb45ef8242305d574389fad3a4f164266f2d7378d21191aab8b07
