:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b_design.fml
:: Utworzony: 04.07.2013 [17.00]
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Formuły do obsługi modelera
::======================================================================================================================


\env
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Środowisko do obsługi modelera
::   WY: obj_new - tablica nazwana zawierająca wszystko co potrzebne
::----------------------------------------------------------------------------------------------------------------------

::UWAGA: _fld, i _mth to formułki pomocnicze, zeby wygodniej tworzyć tablicę i komentować poszczególne jej elementy
::       powiedzmy, że to bedzie pole
         _fld:="31+form(_a)";
::       powiedzmy, że to bedzie metoda
         _mth:="31+form(_a)";

_env:=obj_new( _fld('MODE_INST','Tryb zbierania danych dla instancji procesu: SINGLE,GROUP')
               ,_fld('SEL_PROC','Zaznaczony proces')
               ,_fld('KOMM_PROC','Zaznaczony proces')
               ,_fld('SEL_PREL','Zaznaczony element procesu')
               ,_fld('PROC_STAT','Status wyświetlanej instancji procesu')

::             zmienne pomocnicze
               ,_fld('EDITABLE','Czy modeler udostępnia edycję')
               ,_fld('LOCKED'  ,'Czy udało się zablokować proces')
               ,_fld('SAVING'  ,'Czy właśnie trwa zapis procesu')
               ,_fld('ADD_PREL','B_PREL.ref - dodanego elementu procesu')
               ,_fld('DIA_PRELS','Tablica refów zawierająca refy B_PRELów które udało się zapisać.')
               ,_fld('DIA_CONNS','Tablica refów zawierająca refy B_CONNów które udało się zapisać.')
               ,_fld('TM_MOD','Tm stamp ostatniej modyfikacji procesu')
               ,_fld('AFTER_SAVE_FML','Formuła którą wykonać po zapisaniu diagramu')
               ,_fld('AFTER_SAVE_ARG','Argumenty dla formuły którą wykonać po zapisaniu diagramu')
               ,_fld('IMPORTED','Czy diagram zawiera jakieś importowane elementy')
               ,_fld('IMPORT_FILEPROC','Nazwa pliku proc po stronie serwera na czas importu')
               ,_fld('AFTER_LOAD_FML','Formuła wykonywana po załadowaniu wszystkich elementów okna')
               ,_fld('EXPORT_DIR','Ścieżka do grupowego eksportu procesów')
               ,_fld('EXPORT_SERVER_DIR','Ścieżka do katalogu tymczasowego na serwerze w którym będzie eksport')
               ,_fld('EXPORT_SEL','Tabela zaznaczonych rekordów B_PROC do grupwego eksportu')
               ,_fld('EXCEL_SEL','Tabela zaznaczonych rekordów B_PROC do eksportu przez EXCEL')
               ,_fld('IMPORT_SEL','Tabela zaznaczonych rekordów B_PROC do grupwego importu')
               ,_fld('IMPORT_GR','Czy import grupowy')
               ,_fld('EXPORT_GR','Czy eksport grupowy')
               ,_fld('GRP_ACT','Czy akcja grupowa dla procesów')
               ,_fld('NR_ROOT','Numer root-a komunikatów')
               ,_fld('MEGA_PROC','Czy załadować mega proces')
               ,_fld('MEGA_RECURSIVE','Czy analizować sygnały w procesach rekurencyjnie?')
               ,_fld('MEGA_PROCESY','Tablica ref_table załadowanych procesów w widoku powiązanych procesów')
               ,_fld('MEGA_LOADED','Czy załadowano już wszystkie procesy w mega procesie')
               ,_fld('ACTION_CHK','Czy dokonywać porównania sum kontrolnych czynności podczas importu')
               ,_fld('LAST_ID','Ostatni wygenerowany identyfikator')
               ,_fld('EXPORT_MODELER','Czy eksport przy użyciu modelera czy formułowy')
::             Optymalizacja
               ,_fld('FIELDS','Tablica zawierająca strukturę tabel')
               ,_fld('HASHES','Hashe właściwości czynności w obecnym systemie')

::             identyfikatory okienek
               ,_fld('wid_main' ,'ID okienka głównego')
               ,_fld('wid_proc' ,'ID okienka z procesami')
               ,_fld('wid_desi' ,'ID okienka designera')
               ,_fld('wid_act'  ,'ID okienka z czynnościami')
               ,_fld('wid_port' ,'ID okienek z portami')
               ,_fld('wid_gate' ,'ID okienka z bramami')
               ,_fld('wid_even' ,'ID okienka ze zdarzeniami')
               ,_fld('wid_lane' ,'ID okienka z torami')
               ,_fld('wid_next' ,'ID okienka z następnikami')
               ,_fld('wid_prev' ,'ID okienka z poprzednikami')

::             tytuły okienek
               ,_fld('tit_main' ,'Tytuł okienka głównego')
               ,_fld('tit_proc' ,'Tytuł okienka z procesami')
               ,_fld('tit_desi' ,'Tytuł okienka designera')
               ,_fld('tit_act'  ,'Tytuł okienka z akcjami')
               ,_fld('tit_port' ,'Tytuły okienek z portami')
               ,_fld('tit_gate' ,'Tytuł okienka z bramami')
               ,_fld('tit_even' ,'Tytuł okienka ze zdarzeniami')
               ,_fld('tit_lane' ,'Tytuł okienka z torami')
               ,_fld('tit_next' ,'Tytuł okienka z następnikami')
               ,_fld('tit_prev' ,'Tytuł okienka z poprzednikami')

::             tabele tymczasowe
               ,_fld('TAB_DESI'      ,'Tabela tymczasowa zawierająca zawartość procesu')
               ,_fld('TAB_PROC'      ,'Tabela tymczasowa zawierająca drzewo procesów')
               ,_fld('TAB_KOMM'      ,'Tabela tymczasowa zawierająca komunikaty dla elementów diagramu')
               ,_fld('TAB_IMEX_ACT'  ,'Tabela tymczasowa używana podczas importu - dla mechanizmu kontrolnego czynności')
               ,_fld('TAB_IMEX_PROC' ,'Tabela tymczasowa używana podczas importu - zawiera całą zawartość pliku .proc')
               ,_fld('TAB_IMEX_SIG'  ,'Tabela tymczasowa używana podczas importu - dla mechanizmu kontrolnego czynności')
               ,_fld('TAB_UID_DECODE','Tabela tymczasowa używana podczas eksportu - jeżeli UID elementu się zmienił to pozwala przejść ze starego do nowego')
               ,_fld('TAB_ACTROL_DEL','Tabela tymczasowa używana podczas odtworzenia uprawnień dla procesu')
               ,_fld('TAB_EXP'       ,'Tabela tymczasowa z jednym rekordem - trzyma uchwyt do okna grupowego')
               ,_fld('TAB_CONN_DEF'  ,'Tabela tymczasowa zawierająca B_CONNY którym należy ustawić/zdjąć domyślność podczas zapisu')

::             indeksy tymczasowych tabel
               ,_fld('IN_DESI1' ,'Indeks tabeli designera: PARENT,SYMBOL')
               ,_fld('IN_DESI2' ,'Indeks tabeli designera: B_PREL')
               ,_fld('IN_PROC0' ,'Indeks tabeli procesów: B_PROC')
               ,_fld('IN_PROC1' ,'Indeks tabeli procesów: PARENT,SYMBOL')

::             uchwyty do okien
               ,_fld('WIN_MAIN' ,'Glowne okno grupowe')
               ,_fld('WIN_PROC' ,'Okno z procesami')
               ,_fld('WIN_DESI' ,'Okno designera')
               ,_fld('WIN_ACT'  ,'Okno z czynnościami')
               ,_fld('WIN_PORT' ,'Okna z portami')
               ,_fld('WIN_GATE' ,'Okno z bramami')
               ,_fld('WIN_EVEN' ,'Okno ze zdarzeniami')
               ,_fld('WIN_LANE' ,'ID okienka z torami')
               ,_fld('WIN_NEXT' ,'Okienko z następnikami')
               ,_fld('WIN_PREV' ,'Okienko z poprzednikami')
               ,_fld('WIN_BPMN' ,'Okienko kontrolki modelera')

::             uchwyty do kontrolek
               ,_fld('ctr_id'   ,'Identyfikator kontrolki z diagramem')
               ,_fld('ctr_bpmn' ,'Identyfikator elementu - modeler BPMN')
               ,_fld('ctr_dirty','Identyfikator elementu - ikonka o niezapisanych zmianach')
               ,_fld('ctr_save' ,'Identyfikator elementu - przycisk Zapisz')
               ,_fld('ctr_accept' ,'Identyfikator elementu - przycisk Akceptuj')
               ,_fld('ctr_verify' ,'Identyfikator elementu - przycisk Weryfikuj')
               ,_fld('ctr_wyc' ,'Identyfikator elementu - przycisk Wycofaj')

::             uchwyty do przycisków
               ,_fld('BTN_AUTO' ,'Przycisk `Automatyczna` w oknie designera')
               ,_fld('BTN_WAR'  ,'Przycisk `Warunki` w oknie designera')

::             METODY
               ,_mth('select'  ,'Działanie puste')
               ,_mth('sel4proc','Wyswietla designera dla podanego procesu')
               ,_mth('sel4biproc','Wyswietla designera dla podanej instancji procesu')
               ,_mth('sel4biproc_alt','Wyswietla designera dla podanej instancji procesu')
               ,_mth('sel4biproc_sum','Wyswietla designera dla podanej instancji procesu')
               ,_mth('sel4export','Wyswietla pustego designera dla funkcji eksportującej')
               ,_mth('sel4import','Wyswietla pustego designera dla funkcji importującej')
               ,_mth('sel4mega_bproc','Wyswietla designera dla mega procesu')
               ,_mth('sel4mega_biproc','Wyswietla designera dla mega procesu')
               ,_mth('load'    ,'Ładuje zawartość designera, tworzy struktury')
               ,_mth('next_id','Zwraca kolejny identyfikator dla SYSMEMów i sygnałów')
               );
_env.SEL_PROC:=null();
_env.KOMM_PROC:=null();
_env.SEL_PREL:=null();
_env.PROC_STAT:=null();
_env.TM_MOD:=0;
_env.AFTER_SAVE_FML:="";
_env.AFTER_SAVE_ARG:=~~;
_env.AFTER_LOAD_FML:="";
_env.EDITABLE:=1;
_env.SAVING:=0;
_env.LOCKED:=1;
_env.IMPORTED:='0';
_env.IMPORT_FILEPROC:='';
_env.IMPORT_GR:=0;
_env.EXPORT_GR:=0;
_env.EXPORT_DIR:='';
_env.EXPORT_SERVER_DIR:='';
_env.EXPORT_MODELER:=1;
_env.GRP_ACT:=0;
_env.NR_ROOT:=0;
_env.MEGA_PROC:=0;
_env.MEGA_RECURSIVE:=0;
_env.MEGA_PROCESY:=exec('ref_table','#table');
_env.MEGA_LOADED:=0;
_env.ACTION_CHK:=1;
_env.LAST_ID:='id:0';
:: DO optymalizacji zapisu - pobieram strukturę tabel raz
_env.FIELDS:=obj_new('B_PREL'
                     ,'B_CONN'
                     ,'B_PROC'
                     ,'B_ELE'
                     ,'B_ROLE'
                     ,'B_WORKER'
                     ,'B_SIGNAL'
                     ,'IVAL_DEF'
                     ,'B_DOMAIN'
                     ,'ISTDEF'
);
_env.FIELDS.B_PREL:=exec('mbTabFields_tab','#table',B_PREL);
_env.FIELDS.B_CONN:=exec('mbTabFields_tab','#table',B_CONN);
_env.FIELDS.B_PROC:=exec('mbTabFields_tab','#table',B_PROC);
_env.FIELDS.B_ELE:=exec('mbTabFields_tab','#table',B_ELE);
_env.FIELDS.B_ROLE:=exec('mbTabFields_tab','#table',B_ROLE);
_env.FIELDS.B_WORKER:=exec('mbTabFields_tab','#table',B_WORKER);
_env.FIELDS.B_SIGNAL:=exec('mbTabFields_tab','#table',B_SIGNAL);
_env.FIELDS.IVAL_DEF:=exec('mbTabFields_tab','#table',IVAL_DEF);
_env.FIELDS.B_DOMAIN:=exec('mbTabFields_tab','#table',B_DOMAIN);
_env.FIELDS.ISTDEF:=exec('mbTabFields_tab','#table',ISTDEF);

B_ACTION.cntx_psh();
B_ACTION.index('UNIK');
B_ACTION.prefix();
{? B_ACTION.first()
|| _rule:='obj_new(\'EMPTY\'';
   {!
   |? _rule+=',\''+B_ACTION.UID+'\'';
      B_ACTION.next()
   !};
   _rule+=')';
   _env.HASHES:=($_rule)();

   {! _it:=1..obj_len(_env.HASHES)
   |! _env.HASHES[_it]:=~~
   !}
?};
B_ACTION.cntx_pop();

_env.wid_main:='#b_design_main';
_env.wid_proc:='#b_design_proc';
_env.wid_desi:='#b_design_desi';
_env.wid_act:='#b_design_act';
_env.wid_port:=obj_new('IN','INTERNAL','OUT');
_env.wid_port.IN:='#b_design_port1';
_env.wid_port.INTERNAL:='#b_design_port2';
_env.wid_port.OUT:='#b_design_port3';
_env.wid_gate:='#b_design_gate';
_env.wid_even:='#b_design_even';
_env.wid_lane:='#b_design_lane';
_env.wid_next:='#b_design_next';
_env.wid_prev:='#b_design_prev';

_env.tit_port:=obj_new('IN','INTERNAL','OUT');
_env.tit_port.IN:='Parametry %1'@[exec('opis_in','#b_port').MM];
_env.tit_port.INTERNAL:='Parametry %1'@[exec('opis_internal','#b_port').MM];
_env.tit_port.OUT:='Parametry %1'@[exec('opis_out','#b_port').MM];

_env.WIN_MAIN:='';
_env.WIN_PROC:='';
_env.WIN_DESI:='';
_env.WIN_ACT:='';
_env.WIN_PORT:='';
_env.WIN_GATE:='';
_env.WIN_EVEN:='';
_env.WIN_LANE:='';
_env.WIN_NEXT:='';
_env.WIN_PREV:='';
_env.WIN_BPMN:='';

_env.ctr_id:='b_design';
_env.ctr_bpmn:='12dlm9ae3chj1ieg36kb9i5g92h2g';
_env.ctr_dirty:='2fb14hija04llkd0nm1ln681ae011';
_env.ctr_save:='1cnj2l072ga3g5dh8gfjkmgj59014';
_env.ctr_accept:='n5k8cf1d1384ldn2702hg765fj3j';
_env.ctr_verify:='2dg48h5jn9821aeiken70h2g8cc2';
_env.ctr_wyc:='23edddjikl6i200k3mimk62ke6e2k';

_env.DIA_PRELS:=exec('ref_table','#table');
_env.DIA_CONNS:=exec('ref_table','#table');

_env.TAB_KOMM:=exec('tab_komm','#b_design',_env);
_env.TAB_IMEX_ACT:=exec('tab_imex_act','#b_design',_env);
_env.TAB_IMEX_PROC:=exec('tab_imex_proc','#b_design',_env);
_env.TAB_IMEX_SIG:=exec('tab_imex_sig','#b_design',_env);
_env.TAB_ACTROL_DEL:=exec('tab_actrol_del','#b_design',_env);

_env.IMPORT_SEL:=tab_tmp(1,
   'B_PROC','STRING[16]','SQL ref B_PROC'
);

_env.TAB_CONN_DEF:=tab_tmp(1,
   'B_CONN','STRING[16]','SQL ref B_CONN',
   'DEFAULT','STRING[1]','Czy domyślny?'
);

_env.TAB_UID_DECODE:=tab_tmp(1,
   'UID_OLD','STRING[20]','Stary UID',
   'UID_NEW','STRING[20]','Nowy UID'
);

_env.select:="
      ~~
";

_env.sel4proc:="
::    _a - B_PROC.ref - proces który wyświetlic
::    _b - INTEGER - czy edycja procesu czy podgląd
::    _c - B_PREL.ref - element który zanzaczyć
      {? exec('interm','#system')
      || FUN.emsg(exec('interm_nacc_msg','#system'));
         return()
      ?};

      .SEL_PROC:=_a;
      {? var_pres('_b')=type_of(0)
      || .EDITABLE:=_b
      ?};
::    Dla zaakceptowanego procesu zawsze tylko podgląd
      _akc:=exec('FindAndGet','#table',B_PROC,.SEL_PROC,,\"ACCEPTED\",'N');
      _sym:=exec('record','#to_string',B_PROC.ref());
      {? _akc='T'
      || .EDITABLE:=0
      ?};
      .SEL_PREL:=null();
      {? var_pres('_c')=type_of(B_PREL.ref())
      || .SEL_PREL:=_c
      ?};

::    Próbuję zablokować proces do edycji
      _msg:='';
      {? _akc<>'T'
      || _msg:='Proces \'\'%1\'\' dostępny tylko do podglądu ponieważ jest redagowany'@[_sym]
      ?};
      .LOCKED:=exec('blk_lock','#table','B_PROC',.SEL_PROC,,1,_msg);
      {? .LOCKED=0 & .EDITABLE=1
      || .EDITABLE:=0
      ?};

::    Tworzymy okno główne
      exec('win_ctr_make','#b_design',.,,,1,1);

::    Czyszczę obiekt KOMM bo mogły zostać jakieś śmieci z importu
      KOMM.init(250,,'Modelowanie procesu'@);

::    Przekazujemy argumenty
      params_set(params_get());

::    Pokazujemy okno
      _before:=\"
         params_set(params_get());
         _env:=params_get().env;
         _elements:=exec('elements_table_modeler','#b_design');
         exec('load','#desktop',_env.ctr_id,'#'+_env.ctr_id+'.dsk',,,,,_elements,0);
         exec('load_diagram','#b_design',_env,_elements,_env.SEL_PROC);
         {? _env.SEL_PREL<>null()
         || _uid:=exec('FindAndGet','#table',B_PREL,_env.SEL_PREL,,\"\"B_PREL.UID\"\",'');
            _uid:=gsub(_uid,'\"\"','\"\"\"\"');
            _uid:=gsub(_uid,';','\"\";\"\"');
            _uid:=gsub(_uid,'=','\"\"=\"\"');
            _value:='select='+_uid;
            exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,_value)
         ?};

         exec('update_accept_status','#b_bpmn',_elements,0);
         exec('update_mod_icon','#b_bpmn',_elements,0);

         exec('update','#desktop',_elements,_env.ctr_id);
         1
      \";
      {? .MEGA_PROC>0
      || B_PROC.control(.ctr_id+'_mega','modal=false',_before)
      || B_PROC.control(.ctr_id,'modal=false',_before)
      ?};

      {? .LOCKED>0
      || exec('blk_unlock','#table','B_PROC',.SEL_PROC)
      ?};
      ~~
";

_env.sel4mega_bproc:="
::    _a - B_PROC.ref - proces który wyświetlic

      {? exec('interm','#system')
      || FUN.emsg(exec('interm_nacc_msg','#system'));
         return()
      ?};
      .SEL_PROC:=_a;
      .EDITABLE:=1;

::    Tworzymy okno główne
      exec('win_ctr_make','#b_design',.,0,1);

::    Czyszczę obiekt KOMM bo mogły zostać jakieś śmieci z importu
      KOMM.init(250,,'Modelowanie procesu'@);

::    Przekazujemy argumenty
      params_set(params_get());

::    Pokazujemy okno
      _before:=\"
         params_set(params_get());
         _env:=params_get().env;
         _elements:=exec('elements_table_mega','#b_design');
         exec('load','#desktop',_env.ctr_id,'#'+_env.ctr_id+'.dsk',,,,,_elements,0);
         exec('load_diagram','#b_design',_env,_elements,_env.SEL_PROC);

         exec('update','#desktop',_elements,_env.ctr_id);
         1
      \";
      B_PROC.control(.ctr_id+'_mega','modal=false',_before);
      ~~
";

_env.sel4biproc_alt:="
::    _a - BI_PROC.ref - proces który wyświetlic
::    _b - INTEGER - czy edycja procesu czy podgląd
::    _c - B_PREL.ref() - element który zaznaczyć

      {? exec('interm','#system')
      || FUN.emsg(exec('interm_nacc_msg','#system'));
         return()
      ?};
      .SEL_PROC:=_a;
      {? var_pres('_b')=type_of(0)
      || .EDITABLE:=_b
      ?};
      .SEL_PREL:=_c;
      .PROC_STAT:=exec('FindAndGet','#table',BI_PROC,.SEL_PROC,,\"BI_STAT\",null());

::    Tworzymy okno główne
      exec('win_ctr_make','#b_design',.,0,1,1,,1);

::    Czyszczę obiekt KOMM bo mogły zostać jakieś śmieci z importu
      KOMM.init(250,,'Modelowanie procesu'@);

::    Przekazujemy argumenty
      params_set(params_get());

::    Pokazujemy okno
      _before:=\"
         params_set(params_get());
         _env:=params_get().env;
         _elements:=exec('elements_table_inst','#b_design',_env.SEL_PROC);
         exec('load','#desktop',_env.ctr_id,'#'+_env.ctr_id+'.dsk',,,,,_elements,0);
         BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID'); BI_PROC.clear();
         {? BI_PROC.seek(_env.SEL_PROC)
         ||
            {? exec('is_archivized','#bi_proc',BI_PROC.ref())
            ||
::             Jeśli instancja w archiwum to nie pokazuje przycisku powiązane procesy
               _elements.cntx_psh();
               _elements.prefix('btn_mega@przyciski',);
               {? _elements.first()
               || _elements.VISIBLE:='N';
                  _elements.put()
               ?};
               _elements.cntx_pop()
            ?};

            _args:=exec('load_args','#b_bpmn');
            _args.CTR_ID:=_env.ctr_id;
            _args.BPMN_ID:=_env.ctr_bpmn;
            _args.B_PROC:=BI_PROC.B_PROC;
            _args.BI_PROC:=BI_PROC.ref();
            _args.EDITABLE:=0;
            _args.POPUP_MENU:=1;
             exec('load_diagram','#b_design',_env,_elements,BI_PROC.B_PROC,_args)
         ?};
         exec('update','#desktop',_elements,_env.ctr_id);
         BI_PROC.cntx_pop();
         1
      \";
      B_PROC.control(.ctr_id,'modal=false',_before);
      ~~
";

_env.sel4mega_biproc:="
::    _a - BI_PROC.ref - proces który wyświetlic
::    _b - INTEGER - czy edycja procesu czy podgląd
::    _c - B_PREL.ref() - element który zaznaczyć
      {? exec('interm','#system')
      || FUN.emsg(exec('interm_nacc_msg','#system'));
         return()
      ?};
      .SEL_PROC:=_a;
      {? var_pres('_b')=type_of(0)
      || .EDITABLE:=_b
      ?};
      .SEL_PREL:=_c;
      .PROC_STAT:=exec('FindAndGet','#table',BI_PROC,.SEL_PROC,,\"BI_STAT\",null());

::    Tworzymy okno główne
      _action_all:=0;
      {? .MEGA_PROC>0 & .MEGA_RECURSIVE=0
      || _action_all:=1
      ?};
      exec('win_ctr_make','#b_design',.,0,1,,_action_all);

::    Czyszczę obiekt KOMM bo mogły zostać jakieś śmieci z importu
      KOMM.init(250,,'Modelowanie procesu'@);

::    Przekazujemy argumenty
      params_set(params_get());

::    Pokazujemy okno
      _before:=\"
         params_set(params_get());
         _env:=params_get().env;
         _elements:=exec('elements_table_inst','#b_design',_env.SEL_PROC);
         exec('load','#desktop',_env.ctr_id,'#'+_env.ctr_id+'.dsk',,,,,_elements,0);
         BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID'); BI_PROC.clear();
         {? BI_PROC.seek(_env.SEL_PROC)
         ||
            _args:=exec('load_args','#b_bpmn');
            _args.CTR_ID:=_env.ctr_id;
            _args.BPMN_ID:=_env.ctr_bpmn;
            _args.B_PROC:=BI_PROC.B_PROC;
            _args.BI_PROC:=BI_PROC.ref();
            _args.EDITABLE:=0;
            _args.POPUP_MENU:=1;
             exec('load_diagram','#b_design',_env,_elements,BI_PROC.B_PROC,_args)
         ?};
         exec('update','#desktop',_elements,_env.ctr_id);
         BI_PROC.cntx_pop();
         1
      \";
      B_PROC.control(.ctr_id,'modal=false',_before);
      ~~
";

_env.sel4biproc_sum:="
::    _a - B_PROC.ref - proces który wyświetlic
::    _b - INTEGER - czy edycja procesu czy podgląd
      {? exec('interm','#system')
      || FUN.emsg(exec('interm_nacc_msg','#system'));
         return()
      ?};
      .SEL_PROC:=_a;
      {? var_pres('_b')=type_of(0)
      || .EDITABLE:=_b
      ?};

::    Tworzymy okno główne
      exec('win_ctr_make','#b_design',.,0);

::    Czyszczę obiekt KOMM bo mogły zostać jakieś śmieci z importu
      KOMM.init(250,,'Modelowanie procesu'@);

::    Przekazujemy argumenty
      params_set(params_get());

::    Pokazujemy okno
      _before:=\"
         params_set(params_get());
         _env:=params_get().env;
         _elements:=exec('elements_table_sum','#b_design');
         exec('load','#desktop',_env.ctr_id,'#'+_env.ctr_id+'.dsk',,,,,_elements,0);
         exec('load_diagram','#b_design',_env,_elements,_env.SEL_PROC);
         exec('update','#desktop',_elements,_env.ctr_id);
         1
      \";
      B_PROC.control(.ctr_id,'modal=false',_before);
      ~~
";

_env.load:="
::    Tworzymy tabele tymczasowe
      {? type_of(.TAB_PROC)=0
      || .TAB_PROC:=exec('tab_proc','#b_design',.)
      ?};
      {? type_of(.TAB_DESI)=0
      || .TAB_DESI:=exec('tab_desi','#b_design',.)
      ?};

::    Ładujemy procesy do drzewa
      exec('load_proc','#b_design',.);

      ~~
";
_env.sel4export:="
      {? var_pres('_a')=type_of('')
      || .EXPORT_DIR:=_a
      ?};
      {? var_pres('_b')>100
      || .EXPORT_SEL:=_b
      ?};
      .EDITABLE:=0;
      .EXPORT_GR:=1;
      {? exec('interm','#system')
      || FUN.emsg(exec('interm_nacc_msg','#system'));
         return()
      ?};

      .AFTER_LOAD_FML:=\"params_set(params_get());exec('export_group_start','#b_export')\";
::    Tworzymy okno główne
::      exec('win_ctr_make','#b_design',.);

::    Przekazujemy argumenty
      params_set(params_get());

::    Pokazujemy okno
      _before:=\"
         params_set(params_get());
         _env:=params_get().env;
         exec('load','#desktop',_env.ctr_id,'#'+_env.ctr_id+'_exp.dsk',,,,,,0);
::         exec('set_value','#desktop','#',_env.ctr_id,_env.ctr_bpmn,'loading_text=%1'['Eksportowanie procesów...'@]);
::         exec('set_value','#desktop','#',_env.ctr_id,_env.ctr_bpmn,'loading=true');
         1
      \";
      {? var_pres('TAB_EXP',.)>100
      || obj_del(.TAB_EXP)
      ?};
      .TAB_EXP:=exec('create_grp','#desktop',.ctr_id,_before,20,100,'Eksport procesów');
      .TAB_EXP.select();
      ~~
";
_env.sel4import:="
      {? var_pres('_a')=type_of('')
      || .IMPORT_SEL:=_a
      ?};
      .EDITABLE:=0;

      _close:=\"\";
      {? var_pres('_b')=type_of(\"\")
      || _close:=_b
      ?};
      {? exec('interm','#system')
      || FUN.emsg(exec('interm_nacc_msg','#system'));
         return()
      ?};

      .AFTER_LOAD_FML:=\"params_set(params_get());exec('import_group_start','#b_export')\";
::    Tworzymy okno główne
::      exec('win_ctr_make','#b_design',.);

::    Przekazujemy argumenty
      params_set(params_get());

::    Pokazujemy okno
      _before:=\"
         params_set(params_get());
         _env:=params_get().env;
         exec('load','#desktop',_env.ctr_id,'#'+_env.ctr_id+'_exp.dsk',,,,,,0);
::         exec('set_value','#desktop','#',_env.ctr_id,_env.ctr_bpmn,'loading_text=%1'['Eksportowanie procesów...'@]);
::         exec('set_value','#desktop','#',_env.ctr_id,_env.ctr_bpmn,'loading=true');
         1
      \";

      .TAB_EXP:=exec('create_grp','#desktop',.ctr_id,_before,20,100,'Import procesów',,,_close);
      .TAB_EXP.select()
";
_env.next_id:="
   params_set(params_get());
   _result:='';
   _split:=spli_str(.LAST_ID,':');
   {? obj_len(_split)>1
   || _num:=#_split[2];
      _num+=1;
      _result:=_split[1]+':'+$_num;
      .LAST_ID:=_result
   || _result:=.LAST_ID
   ?};
   _result
";
_env


\new_code
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Kod identyfikujący na podstawie tm_stamp i symbolu
::   WE: _a - akronim tabeli
::       _b - kod UID
::   WY: nowy kod
::----------------------------------------------------------------------------------------------------------------------
_wyn:='';
_fyear:=2016;
_maxn:=238328;

_wyn:={? _a='B_PREL'  || 'D'
      |? _a='BI_PROC' || 'P'
      |? _a='BI_PREL' || 'I'
      || '?'
      ?};

no_msg(1); on_error(3); errno();
_tform:=tm_form(_b);
_err:=errno();
on_error(0); no_msg(0);

{? ~_err
||
   _date:=10+_tform; _yy:=#(4+_date); _mm:=#(2+(5-_date)); _dd:=#(_date+2);
   _time:=_tform+8;  _hr:=#(2+_time); _mn:=#(2+(3-_time)); _sc:=#(_time+2);
   _uid3:=(3+(8-_b));

   {? _yy<_fyear
   ||
:     rok przed początkowym
      _wyn+=form(_fyear)+'????????'
   ||
::    ciąg znakowy - znaki dostępne w masce (kolejność ich jest isotna)
      _chars:=''; {! _i:=48..57 |! _chars+=%_i !}; {! _i:=97..122 |! _chars+=%_i !};

::    powołanie obiektu generującego maski
      exec('declGenMask','#bi_arch');
      _mask3:=obj_new(@.CLASS.GENMASK,3,_chars);
      _mask4:=obj_new(@.CLASS.GENMASK,4,_chars);
      _mask5:=obj_new(@.CLASS.GENMASK,5,_chars);

      _zn1:=^(1+_uid3);
      _zn2:=^(1+(1-_uid3));
      _zn3:=^(1+(2-_uid3));
      _codedt:=_mask3.numMask(((_yy-_fyear)*372)+((_mm-1)*31)+_dd);
      _codetm:=_mask4.numMask((_hr*60*60)+(_mn*60)+_sc);
      _codezn:=_mask5.numMask((_zn1*256*256)+(_zn2*256)+_zn3);

      obj_del(_mask3);
      obj_del(_mask4);
      obj_del(_mask5);
      _wyn+=(_codedt+_codetm+_codezn)
   ?}
|| _wyn+='????????????'
?};
_wyn


\win_ctr_make
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy okienko modelera jako samodzielne okno z kontrolką
::   WE: _a - _env - środowisko designera exec('env','#b_design')
::       [_b] - INTEGER - 0/[1] - czy do okna kontrolki dodawać akcje edycyjne
::       [_c] - INTEGER - [0]/1 - czy do okna kontrolki dodawać akcję Legenda
::       [_d] - INTEGER - [0]/1 - czy do okna kontrolki dodawać akcję Powiązane procesy
::       [_e] - INTEGER - [0]/1 - czy do okna kontrolki dodawać akcję Wszystkie procesy
::       [_f] - INTEGER - [0]/1 - czy do okna kontrolki dodawać akcję Kopiuj kod instancji
::  TAG: <PUBLICZNA><MODELER><YWORKS><WERTOWANIE>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_actions_edit:=1;
{? var_pres('_b')=type_of(0)
|| _actions_edit:=_b
?};
_action_leg:=0;
{? var_pres('_c')=type_of(0)
|| _action_leg:=_c
?};
_action_pow:=0;
{? var_pres('_d')=type_of(0)
|| _action_pow:=_d
?};
_action_all:=0;
{? var_pres('_e')=type_of(0)
|| _action_all:=_e
?};
_action_copy_kod:=0;
{? var_pres('_f')=type_of(0)
|| _action_copy_kod:=_f
?};

params_set(params_get());
_title:='Definicja procesu: '+B_PROC.SYMBOL+' '+B_PROC.NAME+' wersja: '+B_PROC.VER;

_ctrl:=exec('create','#desktop',B_PROC,_env.ctr_id,,40,,_title);
_env.WIN_BPMN:=_ctrl;

B_PROC.win_ctr(_ctrl);
{? _actions_edit>0
||
   _formula:="params_set(params_get());exec('save_diagram_act','#b_bpmn')";
   B_PROC.win_act(_ctrl,0,'Formuła','Zapisz'@@,,,_formula,,,,,,'Z');

   _formula:="params_set(params_get());exec('modeler_akc_act','#b_bpmn')";
   B_PROC.win_act(_ctrl,0,'Formuła','Akceptuj'@@,,,_formula,,,,,,'A');

   _formula:="params_set(params_get());exec('modeler_wyc_act','#b_bpmn')";
   B_PROC.win_act(_ctrl,0,'Formuła','Wycofaj'@@,,,_formula,,,,,,'W');

   _formula:="params_set(params_get());exec('modeler_verify_act','#b_bpmn')";
   B_PROC.win_act(_ctrl,0,'Formuła','Wery&fikuj'@@,,,_formula,,,,,,'F');

   _formula:="params_set(params_get());exec('proc_poconn_act','#b_design')";
   B_PROC.win_act(_ctrl,0,'Formuła','Powiązania argumentów'@@,,,_formula,,,,,,'P');

   _formula:="params_set(params_get());exec('proc_upr_act','#b_design')";
   B_PROC.win_act(_ctrl,0,'Formuła','Uprawnienia'@@,,,_formula,,,,,,'U');

   _formula:="params_set(params_get());exec('exit','#b_design')";
   B_PROC.win_act(_ctrl,,'Okienko',,,,,_formula)
?};
{? _action_leg>0
|| _formula:="params_set(params_get());exec('legenda_alt','#bi_inst')";
   B_PROC.win_act(_ctrl,0,'Formuła','Legenda'@@,,,_formula,,,,,,'L');
   ~~
?};
{? _action_copy_kod>0
|| _formula:="params_set(params_get());exec('copy_id','#bi_inst')";
   B_PROC.win_act(_ctrl,0,'Formuła','&Kopiuj kod instancji'@@,,,_formula,,,,,,'K');
   ~~
?};
{? _action_pow>0
|| _formula:="";
   {? ref_tab(_env.SEL_PROC)=BI_PROC
   || _formula:="params_set(params_get());_env:=params_get().env;exec('select_mega_biproc','#b_design',_env.SEL_PROC)"
   |? ref_tab(_env.SEL_PROC)=B_PROC
   || _formula:="params_set(params_get());exec('select_mega_bproc','#b_design')"
   ?};
   {? _formula<>""
   || B_PROC.win_act(_ctrl,0,'Formuła','Powiązane p&rocesy'@@,,,_formula,,,,,,'R')
   ?};
   ~~
?};
{? _action_all>0
|| _formula:="";
   {? ref_tab(_env.SEL_PROC)=BI_PROC
   || _formula:="params_set(params_get());exec('select_mega_biproc','#b_design',BI_PROC.ref(),,1)"
   |? ref_tab(_env.SEL_PROC)=B_PROC
   || _formula:="params_set(params_get());exec('select_mega_bproc','#b_design',,1)"
   ?};
   B_PROC.win_act(_ctrl,0,'Formuła','Wsz&ystkie procesy'@@,,,_formula,,,,,,'Y');
   ~~
?};
~~


\tab_proc
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę tymczasową zawierającą widok procesów w kategoriach
::   WE: _a - env - srodowisko designera - wynik działania exec('env','#b_design')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 2
               ,'PARENT'   ,'TREE_REF'    ,'Rodzic'
               ,'SYMBOL'   ,'STRING[50]'  ,'Symbol'
               ,'NAZWA'    ,'STRING[30]'  ,'Nazwa'
               ,'B_PROC'   ,'STRING[16]'  ,'Ref. SQL procesu'
               ,'ACCEPTED' ,'STRING[1]'   ,'Zaakceptowana - T-tak, N-nie'
               );
_env.IN_PROC0:=_tab.ndx_tmp(,,'B_PROC',,);
_env.IN_PROC1:=_tab.ndx_tmp(,,'PARENT',,,'SYMBOL',,);
_tab


\tab_desi
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę tymczasową zawierającą widok procesów w kategoriach
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 2
               ,'PARENT'   ,'TREE_REF'    ,'Rodzic'@
               ,'SYMBOL'   ,'STRING[100]' ,'Symbol'@
               ,'SYM_BELE' ,'STRING[100]' ,'Symbol el. ogólnego'@
               ,'B_PREL'   ,'STRING[16]'  ,'Ref. SQL elementu'@
               ,'NEXT'     ,'STRING[16]'  ,'Ref SQL następnika'@
               ,'PREV'     ,'STRING[16]'  ,'Ref SQL poprzednika'@
               ,'CLASS'    ,'STRING[30]'  ,'Tabela z której pochodzi element'@
               ,'AUTOMAT'  ,'STRING[1]'   ,'Uruchamianie automatyczne'@
               ,'UID'      ,'STRING[15]'  ,'Identyfikator elementu'@
               ,'TYPE'     ,'STRING[1]'   ,'Typ czynności'@
               );
_env.IN_DESI1:=_tab.ndx_tmp(,,'PARENT',,,'SYMBOL',,);
_env.IN_DESI2:=_tab.ndx_tmp(,,'B_PREL',,);
_tab


\after_rfr_proc
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Po odswieżeniu w tabeli .TAB_PROC
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_PROC;
BPMN.B_DOMAIN:=null();

params_set(params_get());

_env.SEL_PROC:=exec('FindAndGet','#table',B_PROC,_tab.B_PROC);
exec('load_prel','#b_design',_env,_env.SEL_PROC);

::exec('load_diagram','#b_design',_env);

grp_disp(_env.TAB_DESI,_env.WIN_DESI,1);
~~


\after_rfr_desi
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Po odświeżeniu w tabeli .TAB_DESI
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_DESI;
_wer:=_env.WIN_DESI;

params_set(params_get());

{? _tab.B_PREL<>''
|| _env.SEL_PREL:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,,null());
   _class:=_tab.CLASS;
   _gate_split:=exec('is_gate_prel','#b_gate',_env.SEL_PREL,,exec('kind_split','#b_gate'));
   {? _gate_split>0
   || B_CONN.cntx_psh();
      B_CONN.index('FROM');
      B_CONN.prefix(_env.SEL_PROC,_env.SEL_PREL);
      {? B_CONN.first()
      || _tab.btn_sopt(_wer,_env.BTN_WAR,'state=normal')
      || _tab.btn_sopt(_wer,_env.BTN_WAR,'state=grayed')
      ?};
      B_CONN.cntx_pop()
   || _tab.btn_sopt(_wer,_env.BTN_WAR,'state=grayed')
   ?};
   {? _class='B_ACTION'
   || _tab.btn_sopt(_wer,_env.BTN_AUTO,'state=normal')
   || _tab.btn_sopt(_wer,_env.BTN_AUTO,'state=grayed')
   ?}
|| _env.SEL_PREL:=null();
   _tab.btn_sopt(_wer,_env.BTN_WAR,'state=grayed');
   _tab.btn_sopt(_wer,_env.BTN_AUTO,'state=grayed')
?};

grp_disp(B_CONN,'WER_TO',1);
grp_disp(B_CONN,'WER_FROM',1);
~~


\prel_del_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Akcja Usuń w tabeli .TAB_DESI
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_tab:=_env.TAB_DESI;

_can_continue:=0;

{? exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.ACCEPTED='T'")
|| exec('akc_info','#b_design',exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.SYMBOL"))
|? _tab.CLASS='B_LANE'
||
   _tab.cntx_psh();
   _tab.index(_env.IN_DESI1);
   _tab.prefix(_tab.ref());
   _can_continue:=
      {? _tab.first()
      || FUN.info('Należy usunąć elementy podrzędne.'@);
         0
      || 1
      ?};
   _tab.cntx_pop();
   {? _can_continue>0 || _can_continue:=FUN.ask('Czy na pewno usunąć tor: %1?'@[_tab.SYMBOL]) ?}
|? _tab.CLASS='B_ACTION'
||
   _can_continue:=FUN.ask('Czy na pewno usunąć akcję: %1?'@[_tab.SYMBOL])
|? _tab.CLASS='B_EVENT'
||
   _can_continue:=FUN.ask('Czy na pewno usunąć zdarzenie: %1?'@[_tab.SYMBOL])
|? _tab.CLASS='B_GATE'
||
   _can_continue:=FUN.ask('Czy na pewno usunąć bramę: %1?'@[_tab.SYMBOL])
?};

{? _can_continue>0
|| _prel:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,,null());
   {? _prel<>null()
   ||
      _b_role:=exec('FindAndGet','#table',B_PREL,$_prel,,"B_PREL.B_ROLE",null());
      KOMM.init(250,,'Usuwanie elementów procesu.'@);
      {? _can_continue>0
      || _can_continue:=exec('delete','#b_prel',_prel,1)
      ?};
      {? _can_continue>0
      || exec('prel_del','#b_design',_env,_tab.ref())
      ?};
      KOMM.select()
   ?};
   ~~
?};
~~


\proc_del
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Usuwa z tabeli .TAB_PROC przekazany rekord wraz ze wszystkimi węzłami niżej
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::       _b - INTEGER - ref rekordu do usunięcia
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_ref:=_b;

_result:=0;
_can_continue:=1;

_tab:=_env.TAB_PROC;

_tab.cntx_psh(); _tab.clear();
{? _tab.seek(_ref)
||
:: Najpierw usuwam wszystkie elementy podrzędne
   _tab.cntx_psh();
   _tab.index(_env.IN_PROC1);
   _tab.prefix(#_ref);
   {? _tab.first()
   || {!
      |? _can_continue:=exec('proc_del','#b_design',_env,_tab.ref());
         _tab.first() & _can_continue>0
      !}
   ?};
   _tab.cntx_pop();

   {? _can_continue>0
   || _result:=_tab.del()
   ?};
   ~~
?};
_tab.cntx_pop();
_result


\prel_del
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Usuwa z tabeli .TAB_DESI przekazany rekord wraz ze wszystkimi węzłami niżej
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::       _b - INTEGER - ref rekordu do usunięcia
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_ref:=_b;

_result:=0;
_can_continue:=1;

_tab:=_env.TAB_DESI;

_tab.cntx_psh(); _tab.clear();
{? _tab.seek(_ref)
||
:: Najpierw usuwam wszystkie elementy podrzędne
   _tab.cntx_psh();
   _tab.index(_env.IN_DESI1);
   _tab.prefix(#_ref);
   {? _tab.first()
   || {!
      |? _can_continue:=exec('prel_del','#b_design',_env,_tab.ref());
         _tab.first() & _can_continue>0
      !}
   ?};
   _tab.cntx_pop();

   {? _can_continue>0
   || _result:=_tab.del()
   ?};
   ~~
?};
_tab.cntx_pop();
_result


\proc2tab
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Dodaje/aktualizuje w tabeli .TAB_PROC element typu 'Proces' na podstawie bieżącego rekordu
::       tabeli B_PROC
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_result:=0;

_tab:=_env.TAB_PROC;

_parent:=0;

_tab.cntx_psh();
_tab.index(_env.IN_PROC0);
_tab.prefix($B_PROC.ref());
{? _tab.first()
||
   _tab.PARENT:=_parent;
   _tab.SYMBOL:=B_PROC.SYMBOL;
   _tab.NAZWA:=B_PROC.NAME;
   _tab.ACCEPTED:=B_PROC.ACCEPTED;
   _result:=_tab.put()
||
   _tab.clear();
   _tab.blank();
   _tab.PARENT:=_parent;
   _tab.SYMBOL:=B_PROC.SYMBOL;
   _tab.NAZWA:=B_PROC.NAME;
   _tab.B_PROC:=$B_PROC.ref();
   _tab.ACCEPTED:=B_PROC.ACCEPTED;
   _result:=_tab.add()
?};
_tab.cntx_pop();

{? _result
|| _env.SEL_PROC:=B_PROC.ref()
?};

_result


\prel2tab
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Dodaję do tabeli .TAB_DESI element procesu
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_result:=0;

_tab:=_env.TAB_DESI;

:: Najpierw szukam elementu nadrzędnego
_tab.cntx_psh();
_tab.index(_env.IN_DESI2);
_parent:=0;
{? B_PREL.UID_PAR<>''
||
   B_PREL.cntx_psh();
   B_PREL.index('UID');
   B_PREL.prefix(_env.SEL_PROC,B_PREL.UID_PAR);
   {? B_PREL.first()
   ||
      _tab.prefix($B_PREL.ref());
      {? _tab.first()
      || _parent:=#_tab.ref()
      ?}
   ?};
   B_PREL.cntx_pop();
   ~~
?};
B_ELE.cntx_psh();
_tab.prefix($B_PREL.ref());
_add:=_tab.first()=0;
_tab.blank();
_tab.PARENT:=_parent;
_tab.SYMBOL:=B_PREL.SYMBOL;
_tab.SYM_BELE:=B_PREL.B_ELE().SYMBOL;
_tab.B_PREL:=$B_PREL.ref();
_tab.CLASS:=B_PREL.CLASS;
_tab.AUTOMAT:=B_PREL.AUTOMAT;
_tab.UID:=B_PREL.UID;
_tab.TYPE:=B_PREL.TYPE;
_result:={? _add || _tab.add() || _tab.put() ?};
_tab.cntx_pop();
B_ELE.cntx_pop();
~~


\prel_add_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Dodaje do widoku tymczasowego element diagramu oraz uruchamianie do tabeli B_PREL
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::       _b - B_ELE.ref() - element który dodaje
::       [_c] - .TAB_DESI.ref() - element na który upuszczam
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_ele:=_b;

_result:=0;

_tab:=_env.TAB_DESI;
params_set(params_get());

_drop_dest:=~~;
{? var_pres('_c')=type_of(_tab.ref())
|| _drop_dest:=_c
?};

_uid_par:='';
_b_role:=null();
{? type_of(_drop_dest)>0
||
   _tab.cntx_psh();
   _tab.clear();
   {? _tab.seek(_drop_dest)
   ||
      _uid_par:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,"UID",'');
      _b_role:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,"B_ROLE",'')
   ?};
   _tab.cntx_pop();
   ~~
?};

_continue:=1;
B_ELE.cntx_psh(); B_ELE.clear();
{? B_ELE.seek(_ele)
|| {? B_ELE.CLASS='B_ACTION' | B_ELE.CLASS='B_GATE' | B_ELE.CLASS='B_EVENT'
   || {? type_of('_drop_dest')=type_of(~~)
         | _drop_dest=null()
      || FUN.info('Należy upuścić na tor.'@);
         _continue:=0
      ?}
   ?}
?};
{? _continue
||
:: wyznaczenie roli
   {? B_ELE.CLASS='B_LANE'
   || _b_lane:=exec('get_lane','#b_lane',B_ELE.ref());
      {? _b_lane<>null()
      || _b_role:=exec('FindAndGet','#table',B_LANE,$_b_lane,,"B_ROLE",null())
      ?};
      {? _b_role=null()
      || _b_role:=exec('rol_sel','#b_role');
         {? _b_role=null()
         || FUN.info('Nie wybrano roli.'@);
            B_ELE.cntx_pop();
            return()
         ?}
      ?}

   ?};
:: dodanie elementu do diagramu
   {? _continue
   || undefine();
      _def_sym:=
         {? B_ELE.CLASS='B_LANE'
         || exec('FindAndGet','#table',B_ROLE,$_b_role,,"B_ROLE.NAME",'')
         || B_ELE.SYMBOL
         ?};
      _symbol:='';
      define('SYMBOL',_def_sym,'Symbol elementu'@,,100,50);
      _fm_edit:=0;
      {? B_ELE.CLASS='B_ACTION'
      || B_ACTION.cntx_psh();
         B_ACTION.index('B_ELE');
         B_ACTION.prefix(B_ELE.ref());
         {? B_ACTION.first() & B_ACTION.MANUAL='T'
         || define('FMANMAIN','','Formuła do obsługi ręcznej'@,,100,50);
            define('FMANDESC','','Formuła do obsługi ręcznej (opis)'@,,100,50);
            _fm_edit:=1
         ?};
         B_ACTION.cntx_pop()
      ?};
      def_btn('text=%1'['Zapisz'@],'key:F2');
      def_btn('text=%1'['Anuluj'@],'key:Esc');
      _valid:=$(
         "{? ~exec('valid_symbol','#b_prel','"+$_env.SEL_PROC+"',DEFINE.SYMBOL,'') || 'SYMBOL'"+
         {? _fm_edit
         || "|? ~exec('valid_formula','#field',DEFINE.FMANMAIN) || 'FMANMAIN'"+
            "|? ~exec('valid_formula','#field',DEFINE.FMANDESC) || 'FMANDESC'"
         || ""
         ?}+
         "|| 1 ?}"
      );
      {? def_edit(_valid,'Dołączanie elementu procesu'@)>0
      ||
         _symbol:=DEFINE.SYMBOL;
         _buffer:=exec('buffer','#b_prel');
         _buffer.bl_table();
         _buffer.B_PROC:=_env.SEL_PROC;
         _buffer.SYMBOL:=_symbol;
         _buffer.B_ELE:=_ele;
         _buffer.UID:=exec('uid','#blank');
         _buffer.UID_PAR:=_uid_par;
         _buffer.CLASS:=B_ELE.CLASS;
         _buffer.B_ROLE:=_b_role;
         _buffer.CODE:=exec('new_code','#b_design','B_PREL',_buffer.UID);
         _buffer.START:='N';
         _buffer.AUTOMAT:='N';
         {? B_ELE.CLASS='B_ACTION'
         || B_ACTION.cntx_psh();
            B_ACTION.index('B_ELE');
            B_ACTION.prefix(B_ELE.ref());
            {? B_ACTION.first() & B_ACTION.AUTOMAT='T' || _buffer.AUTOMAT:='M' ?};
            B_ACTION.cntx_pop()
         ?};
         {? _fm_edit
         || _buffer.FMANMAIN:=DEFINE.FMANMAIN;
            _buffer.FMANDESC:=DEFINE.FMANDESC
         ?};

         _env.ADD_PREL:=_added:=exec('add','#b_prel',_buffer);
         {? _added<>null()
         || _result:=1;
            B_PREL.cntx_psh(); B_PREL.clear();
            {? B_PREL.seek(_added)
            || exec('prel2tab','#b_design',_env)
            ?};
            B_PREL.cntx_pop();
            ~~
         ?}
      ?};
      undefine()
   ?}
?};
B_ELE.cntx_pop();
grp_disp(_env.TAB_DESI,_env.WIN_DESI,1);
_result


\load_proc
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Ładuje do designera procesy
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

B_PROC.cntx_psh();
B_PROC.index('AKT');
B_PROC.prefix('N','T');
{? B_PROC.first()
|| {!
   |? exec('proc2tab','#b_design',_env);
      B_PROC.next()
   !}
?};
B_PROC.cntx_pop();
~~


\load_prel
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Ładuje do designera zawartość procesu
::   WE: _a - env - śodowisko designera - wynik działania exec('env','#b_design')
::       _b - B_PROC.ref() - proces którego zawartość załadować
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_proc:=_b;

_tab:=_env.TAB_DESI;

_tab.erase();
{? type_of(_proc)=type_of(null) & _proc<>null()
||
   B_PREL.cntx_psh();
   B_PREL.index('TREE');
   B_PREL.prefix(_proc);
   {? B_PREL.first()
   || {!
      |? exec('prel2tab','#b_design',_env);
         B_PREL.next()
      !}
   ?};
   B_PREL.cntx_pop();
   ~~
?};
~~


\load_diagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ładuje do modelera diagram z procesem
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::       _b - tab_tmp - tabelka tymczasowa zasilająca panelplus tłumaczeniami itp
::       [_c] - B_PROC.ref lub jeśli nie podane to wartość _env.SEL_PROC
::       [_d] - obj_new - argumenty dla funkcji ladujacej, wynik działania exec('load_args','#b_bpmn')
::  TAG: <PRYWATNA><MODELER><PROCES><ZASILANIE>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_elements:=_b;

_b_proc:=_env.SEL_PROC;
{? var_pres('_c')=type_of(B_PROC.ref())
|| _b_proc:=_c
?};
{? var_pres('_d')>100
|| _args:=_d
|| _args:=exec('load_args','#b_bpmn');
   _args.CTR_ID:=_env.ctr_id;
   _args.BPMN_ID:=_env.ctr_bpmn;
   _args.B_PROC:=_b_proc;
   _args.EXPORT_GR:=_env.EXPORT_GR
?};

:: Ładuje diagram BPMN
{? type_of(_b_proc)=type_of(null)
||
   _imex_gml:=exec('FindAndGet','#table',B_PROC,_b_proc,,"IMEX_GML",null());
   {? _imex_gml=null()
   || {? _env.MEGA_PROC>0
      || ~~
      || exec('load_diagram4proc','#b_bpmn',_args)
      ?}
   || exec('load_imported4proc','#b_bpmn',_args,1)
   ?}
||
:: Jeśli nie ma procesu to chowam modelera
   exec('set_visible','#desktop','',_env.ctr_id,_env.ctr_bpmn,0)
?};
~~


\load_bidiagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: mario [17.00]
:: OPIS: Ładuje do modelera diagram z instancją procesu
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::       [_b] - BI_PROC.ref lub jeśli nie podane to wartość _env.SEL_PROC
::  TAG: <PRYWATNA><MODELER><PROCES><ZASILANIE>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_bi_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(null())
|| _bi_proc:=_b
?};

:: Ładuje diagram BPMN
{? type_of(_bi_proc)=type_of(null)
|| _args:=exec('load_args','#b_bpmn');
   _args.CTR_ID:=_env.ctr_id;
   _args.BPMN_ID:=_env.ctr_bpmn;
   _args.B_PROC:=_bi_proc;

   _args.EDITABLE:=0;
   _args.DO_LAYOUT:=1;
   _args.POPUP_MENU:=0;
::   _args.TITLE:='Podgląd przebiegu procesu';

   exec('load_bidiagram','#b_bpmn',_args)
||
:: Jeśli nie ma procesu to chowam modelera
   exec('set_visible','#desktop','',_env.ctr_id,_env.ctr_bpmn,0)
?};
~~


\drop_element
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Obsługa upuszczania jakiegoś elementu
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::       _b - B_ELE.ref() - co upuściłem
::       _c - .TAB_DESI.ref() - element na który upuszczam
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_ref:=_b;
_dest:=_c;
params_set(params_get());

_result:=0;

{? _env.SEL_PROC=null()
|| FUN.emsg('Elementy można tworzyć tylko jeżeli w oknie Procesy zaznaczono proces.'@);
   return(_result)
?};

{? exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.ACCEPTED='T'")
|| exec('akc_info','#b_design',exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.SYMBOL"));
   return(_result)
?};

B_ELE.cntx_psh(); B_ELE.clear();
{? B_ELE.seek(_ref)
|| _result:=exec('prel_add_act','#b_design',_env,B_ELE.ref(),_dest)
?};
B_ELE.cntx_pop();
_result


\drop_lane
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Obsługa upuszczania rekordow B_LANE do modelera
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
params_set(params_get());

_tab:=dnd_info('dropped_records');

B_LANE.cntx_psh(); B_LANE.clear();
{? _tab.first()
|| {!
   |?
      {? B_LANE.seek(_tab.REF,)
      || exec('drop_element','#b_design',_env,B_LANE.B_ELE,null())
      ?};
      _tab.next()
   !}
?};
B_LANE.cntx_pop();
~~


\drop_action
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Obsługa upuszczania rekordow B_ACTION do modelera
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
params_set(params_get());

_Tab:=_env.TAB_DESI;

_tab:=dnd_info('dropped_records');

_cont:=1;

{? _cont
||
   B_ACTION.cntx_psh(); B_ACTION.clear();
   {? _tab.first()
   || {!
      |?
         {? B_ACTION.seek(_tab.REF,)
         || _dest:=dnd_info('dest_record');
            _Tab.cntx_psh();
            {? _Tab.seek(_dest)
            || {? _Tab.PARENT
               || _dest:={? _Tab.seek(_Tab.PARENT,) || _Tab.ref() || null() ?}
               |? _Tab.CLASS<>'B_LANE'
               || _dest:=null()
               ?}
            ?};
            _Tab.cntx_pop();
            exec('drop_element','#b_design',_env,B_ACTION.B_ELE,_dest)
         ?};
         _tab.next()
      !}
   ?};
   B_ACTION.cntx_pop()
?};
~~


\drop_event
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa upuszczania rekordow B_EVENT do modelera
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
params_set(params_get());

_Tab:=_env.TAB_DESI;

_tab:=dnd_info('dropped_records');

_cont:=1;

{? _tab.size()>1
|| FUN.emsg('Dołączać można tylko pojedyncze zdarzenia.'@);
   _cont:=0
?};

{? _cont
||
   B_EVENT.cntx_psh(); B_EVENT.clear();
   {? _tab.first()
   || {!
      |?
         {? B_EVENT.seek(_tab.REF,)
         ||
            {? ((B_EVENT.TYPE=exec('type_start','#b_event')
                | B_EVENT.TYPE=exec('type_end','#b_event')
                | B_EVENT.TYPE=exec('type_intermed','#b_event')
               )
                  &
               B_EVENT.KIND=exec('kind_none','#b_event')
               )
                  |
               (B_EVENT.TYPE=exec('type_start','#b_event')
                & B_EVENT.KIND=exec('kind_timer','#b_event')
               )
                  |
               (1)
            ||
               _dest:=dnd_info('dest_record');
               _Tab.cntx_psh();
               {? _Tab.seek(_dest)
               || {? _Tab.PARENT
                  || _dest:={? _Tab.seek(_Tab.PARENT,) || _Tab.ref() || null() ?}
                  |? _Tab.CLASS<>'B_LANE'
                  || _dest:=null()
                  ?}
               ?};
               _Tab.cntx_pop();
               exec('drop_element','#b_design',_env,B_EVENT.B_ELE,_dest)
            ||
               FUN.emsg('Nieobsługiwane zdarzenie — nie można dołączyć.'@)
            ?}
         ?};
         _tab.next()
      !}
   ?};
   B_EVENT.cntx_pop()
?};
~~


\drop_gate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa upuszczania rekordów B_GATE do modelera
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
params_set(params_get());

_tab:=dnd_info('dropped_records');

_Tab:=_env.TAB_DESI;

B_GATE.cntx_psh(); B_GATE.clear();
{? _tab.first()
|| {!
   |?
      {? B_GATE.seek(_tab.REF,)
      || _dest:=dnd_info('dest_record');
         _Tab.cntx_psh();
         {? _Tab.seek(_dest)
         || {? _Tab.PARENT
            || _dest:={? _Tab.seek(_Tab.PARENT,) || _Tab.ref() || null() ?}
            |? _Tab.CLASS<>'B_LANE'
            || _dest:=null()
            ?}
         ?};
         _Tab.cntx_pop();
         exec('drop_element','#b_design',_env,B_GATE.B_ELE,_dest)
      ?};
      _tab.next()
   !}
?};
B_GATE.cntx_pop();
~~


\drop_n_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Obsługa upuszczania rekordów B_ACTION do następników modelera
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
params_set(params_get());

_Tab:=_env.TAB_DESI;

_tab:=dnd_info('dropped_records');

_cont:=1;

{? _env.SEL_PREL=null()
|| FUN.info('Należy wskazać element w oknie Zawartość procesu.'@);
   _cont:=0
|? exec('FindAndGet','#table',B_PREL,$D_ENV.SEL_PREL,,"B_PREL.CLASS='B_LANE'")
|| FUN.info('Definiowanie następników i poprzedników niedostępne dla toru.'@);
   _cont:=0
|? exec('FindAndGet','#table',B_PREL,$D_ENV.SEL_PREL,,"exec('is_event','#b_event',B_ELE,exec('type_end','#b_event'))>0")
|| FUN.info('Definiowanie następników niedostępne dla zdarzenia końcowego.'@);
   _cont:=0
?};

{? _cont
||
   B_ACTION.cntx_psh(); B_ACTION.clear();
   {? _tab.first()
   || _b_conn:=exec('buffer','#b_conn');
      {!
      |?
         {? B_ACTION.seek(_tab.REF,)
         || _env.ADD_PREL:=null();
            B_PREL.cntx_psh();
            B_PREL.index('PREL');
            B_PREL.prefix(_env.SEL_PROC,B_ACTION.B_ELE);
            {? B_PREL.first() & ~FUN.ask('Czynność %1 jest już w procesie oznaczona symbolem "%2".'
                  '\nCzy dodać ją ponownie z nowym symbolem i uczynić następnikiem?'
                  '\n\nRezygnacja z dodawania oznacza dodanie następnika "%2".'@[B_ACTION.UID,B_PREL.SYMBOL])
            || _env.ADD_PREL:=B_PREL.ref()
            || _Tab.cntx_psh();
               _dest:={? _Tab.seek(_Tab.PARENT,) || _Tab.ref() || null() ?};
               _Tab.cntx_pop();
               exec('drop_element','#b_design',_env,B_ACTION.B_ELE,_dest)
            ?};
            B_PREL.cntx_pop();
            {? _env.ADD_PREL
            || _b_conn.bl_void();
               _b_conn.B_PROC:=_env.SEL_PROC;
               _b_chain:=exec('add','#b_chain','B_CONN','Połączenie');
               _b_conn.B_ELE:=exec('add','#b_ele',_b_chain,'Połączenie proste');
               _b_conn.FROM:=_env.SEL_PREL;
               _b_conn.TO:=_env.ADD_PREL;
               _b_conn.UID:=exec('uid','#blank');
               _result:=exec('add','#b_conn',_b_conn);
               {? _result<>null()
               ||
::                Pokazuje konfiguratora połączeń
                  _conns:=exec('select4conn','#b_poconn',_result);

                  {? _conns=0
                  ||
::                   Jeżeli użytkownik niezaakceptował powiązań międzyargumentowych, to usuwam połączenie
                     exec('delete','#b_conn',_result);
                     _result:=null()
                  ||
::                   Jeśli powiązanie wychodzi do bramy rozdzielającej typu AND
::                   to tworzę automatyczny B_CHOICE
                     exec('auto_choice','#b_choice',_b_conn.FROM,_result);

::                   Aktualizacja czynności startowej
                     B_PREL.clear();
                     {? B_PREL.seek(_b_conn.FROM)
                     || {? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_start','#b_event'))>0
                        || B_PREL.START:='T';
                           B_PREL.put()
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ?};
         _tab.next()
      !}
   ?};
   B_ACTION.cntx_pop()
?};
~~


\conns_before
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Przed obsługą okienek z poprzednikami, następnikami w modelerze
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::       _b - INTEGER - tryb prefiksowania:
::                                           -1 - poprzedniki
::                                            1 - następniki
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_mode:=_b;

_proc:={? type_of(_env.SEL_PROC)=type_of(null()) || _env.SEL_PROC || null() ?};
_prel:={? type_of(_env.SEL_PREL)=type_of(null()) || _env.SEL_PREL || null() ?};
{? _mode=-1
|| B_CONN.index('TO');
   B_CONN.prefix(_proc,_prel);
   ~~
|? _mode=1
|| B_CONN.index('FROM');
   B_CONN.prefix(_proc,_prel);
   ~~
?};

~~


\proc_run_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Akcja uRuchom w tabeli .TAB_DESI
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_DESI;
params_set(params_get());
_ope:=exec('operatorUser','#users');
_prel:=null();
_no:=1;
_Tab:=tab_tmp(1
   ,'NO'       ,'INTEGER'     ,'Lp.'
   ,'DESC'     ,'STRING[255]' ,'Opis'
   ,'B_PREL'   ,'STRING[16]'  ,'B_PREL.ref()'
   ,'BI_PREL'  ,'STRING[16]'  ,'BI_PREL.ref()');
_wer:=_Tab.mk_sel('Opcje'@,,,'asfwepowqefkfd');
_Tab.win_fld(_wer,,'DESC',,,100,,,,1);
_Tab.win_act(_wer,,'Formuła','Akceptuj'@@,,,"sel_exit()",,1,,,,'A');
_Tab.win_sel(_wer);

_buffer:=exec('buffer','#b_prel');
_b_prel:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,,null());
{? _b_prel<>null()
|| _buffer.cntx_get(_b_prel);
   _b_proc:=_buffer.B_PROC;
   _b_prel:=null();

:: Sprawdzam czy proces zaakceptowany
   _akc:=exec('FindAndGet','#table',B_PROC,#_buffer.B_PROC,ref_name(_buffer.B_PROC),"ACCEPTED",'N');

   {? _akc='T'
   ||
::    nowa instancja procesu
      B_PREL.cntx_psh();
      B_USRROL.cntx_psh();
      B_USRROL.index('USER');
      B_USRROL.prefix(REF.FIRMA,_ope);
      _loop:=B_USRROL.first();
      {!
      |? _loop
      |!
         B_PREL.index('PROCSTAR');
         B_PREL.prefix(_b_proc,'T',B_USRROL.B_ROLE);
         _loop1:=B_PREL.first();
         {!
         |? _loop1
         |!
            _Tab.NO:=_no; _no+=1;
            _Tab.DESC:='Nowa instancja procesu - '+B_PREL.SYMBOL;
            _Tab.B_PREL:=$B_PREL.ref();
            _Tab.BI_PREL:='';
            _Tab.add();
            _loop1:=B_PREL.next()
         !};
         _loop:=B_USRROL.next()
      !};
      B_USRROL.cntx_pop();
      B_PREL.cntx_pop();
::    istniejące instancje
      BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID'); BI_PROC.prefix();
      BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?}; BI_PREL.index('UID'); BI_PREL.prefix();
      BI_TODO.cntx_psh(); {? BI_TODO.name()='' || BI_TODO.use('bi_t____') ?};
      BI_TODO.index('USERPROC'); BI_TODO.prefix(_b_proc,_ope,1);
      _loop:=BI_TODO.first();
      {!
      |? _loop
      |!
         _Tab.NO:=_no; _no+=1;
         _Tab.DESC:={? BI_TODO.BI_PREL().DESC<>''
                    || BI_TODO.BI_PREL().DESC
                    || BI_TODO.BI_PREL().BI_PROC().CODE+' - '+BI_PREL.CODE
                    ?};
         _Tab.B_PREL:='';
         _Tab.BI_PREL:=$BI_TODO.BI_PREL;
         _loop:=_Tab.add() & BI_TODO.next()
      !};
::    decyzja co uruchamiamy
      _path:='';
      {? ~_Tab.first()
      || FUN.info('Brak uprawnień do uruchomienia procesu.'@)
      || _sel:=0;
         {? _Tab.next() & _Tab.first()
         || {? _Tab.select() || _sel:=1 ?}
         || _sel:=1
         ?};
         {? _sel
         ||
            {? _Tab.B_PREL<>''
            || _prel:=exec('FindAndGet','#table',B_PREL,_Tab.B_PREL);
               _path:='Proc'
            |? _Tab.BI_PREL<>''
            || _prel:=exec('FindAndGet','#table',BI_PREL,_Tab.BI_PREL);
               _path:='Todo'
            || _prel:=null()
            ?}
         ?}
      ?};
      BI_TODO.cntx_pop();
      BI_PREL.cntx_pop();
      BI_PROC.cntx_pop();
::    menedżer procesu
      {? _prel
      || exec('proMan','#b_proman',_prel,'',,_path);
         grp_disp(_env.TAB_PROC,_env.WIN_PROC,1)
      ?}
   ||
::    Proces niezaakceptowany
      FUN.emsg('Nie można uruchomić niezaakceptowanego procesu.'@)
   ?}
?};
~~


\bi_proc_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wyświetla instancje procesu
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_tab:=_env.TAB_PROC;

_proc:=exec('FindAndGet','#table',B_PROC,_tab.B_PROC,,,null());

{? _proc=null()
|| FUN.info('Nie znaleziono definicji procesu.'@)
|| exec('select','#bi_inst',_proc)
?}


\akc_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Informacja o niedostępności opcji ponieważ definicja procesu zaakceptowana
::   WE: _a - Symbol procesu
::       _b - INTEGER - 0/1/2 - czy wyswietlac komunikaty, czy na ekran, czy do komma
::----------------------------------------------------------------------------------------------------------------------
_symbol:=_a;
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};
_msg:='Definicja procesu %1 jest zaakceptowana.\nOperacja niedostępna.'@[_symbol];
{? _dialog=1
|| FUN.info(_msg)
|? _dialog=2
|| KOMM.add(_msg,2,,1)
?};
~~


\akc_icon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Ikona akceptacji definicji procesu oraz ikona uruchomionych instancji procesu
::   WY: ikona
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
_pole:=cur_afld();
{? _pole='SYMBOL'
|| {? _tab.ACCEPTED='T' || 'xwin16.png:13' || 'xwin16.png:110' ?}
|? _pole='NAZWA'
|| {? _tab.B_PROC=''
   || 'xwin16.png:110'
   || _bi_proc:=exec('FindAndGet','#table',B_PROC,_tab.B_PROC,,,null());
      _bi_stat:=exec('URUCHOMIONY','#bi_stat');
      _running:=0;
      BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
      BI_PROC.index('PROSTAN');
      BI_PROC.prefix(_bi_proc,_bi_stat);
      {? BI_PROC.first() || _running:=1 ?};
      BI_PROC.cntx_pop();
      {? _running || 'xwin16.png:131' || 'xwin16.png:157' ?}
   ?}
?}


\win_port
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Okna tabeli B_PORT - wyświetla parametry czynności
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::   WY: STRING - uchwyt do okna
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _env:=_a
|| _env:=exec('env','#b_design')
?};
_wer:=obj_new('IN','INTERNAL','OUT');

_test:='';

_wer.IN:=B_PORT.mk_sel(_test+_env.tit_port.IN,'P',,_env.wid_port.IN);
B_PORT.win_fld(_wer.IN,,'SYMBOL',,,,,,'Symbol'@);
B_PORT.win_fld(_wer.IN,,'NAME',,,30,,,'Nazwa'@);
B_PORT.win_fld(_wer.IN,,'B_TYPE','SYMBOL',,10,,,'Typ'@);
B_PORT.win_fld(_wer.IN,,'REQUIRED',,,,,,'Wymagany?'@,,,2,,"'T'","'N'");
B_PORT.win_fld(_wer.IN,,'ACTIVE',,,,,,'Aktywny?'@,,,2,,"'T'","'N'");
B_PORT.win_act(_wer.IN,,'Kolejność');

_wer.INTERNAL:=B_PORT.mk_sel(_test+_env.tit_port.INTERNAL,'P',,_env.wid_port.INTERNAL);
B_PORT.win_fld(_wer.INTERNAL,,'SYMBOL',,,,,,'Symbol'@);
B_PORT.win_fld(_wer.INTERNAL,,'NAME',,,30,,,'Nazwa'@);
B_PORT.win_fld(_wer.INTERNAL,,'B_TYPE','SYMBOL',,10,,,'Typ'@);
B_PORT.win_fld(_wer.INTERNAL,,'REQUIRED',,,,,,'Wymagany?'@,,,2,,"'T'","'N'");
B_PORT.win_fld(_wer.INTERNAL,,'ACTIVE',,,,,,'Aktywny?'@,,,2,,"'T'","'N'");
B_PORT.win_act(_wer.INTERNAL,,'Kolejność');

_wer.OUT:=B_PORT.mk_sel(_test+_env.tit_port.OUT,'P',,_env.wid_port.OUT);
B_PORT.win_fld(_wer.OUT,,'SYMBOL',,,,,,'Symbol'@);
B_PORT.win_fld(_wer.OUT,,'NAME',,,30,,,'Nazwa'@);
B_PORT.win_fld(_wer.OUT,,'B_TYPE','SYMBOL',,20,,,'Typ'@);
:: B_PORT.win_fld(_wer.OUT,,'REQUIRED',,,,,,'Wymagany?',,,2,,"'T'","'N'");
B_PORT.win_fld(_wer.OUT,,'ACTIVE',,,,,,'Aktywny?'@,,,2,,"'T'","'N'");
B_PORT.win_act(_wer.OUT,,'Kolejność');

_wer


\ports_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed obsługą okienek z portami dla czynności w modelerze
::   WE: _a - rodzaj czynności (wynik formuły exec('kind_*','#b_port')
::----------------------------------------------------------------------------------------------------------------------
_kind:=_a;

B_PORT.index('UNIK');
B_PORT.prefix(B_ACTION.B_ELE,null(),null(),_kind,);
~~


\after_rfr_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła 'after refresh' w oknie B_ACTIONS w widoku modelera
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
params_set(params_get());
grp_disp(B_PORT,_env.WIN_PORT.IN);
grp_disp(B_PORT,_env.WIN_PORT.INTERNAL);
grp_disp(B_PORT,_env.WIN_PORT.OUT);
~~


\act_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła 'after refresh' w oknie B_ACTIONS w widoku modelera
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
B_ACTION.index('PROC');
B_ACTION.prefix('T','T');
~~


\lane_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przed obsługą okienek z torami w modelerze
::   WE: _a - STRING - typ toru
::  TAG: <PRYWATNA><MODELER><PROCES><ROLE>
::----------------------------------------------------------------------------------------------------------------------
_type:=_a;
B_LANE.index('TYP');
B_LANE.prefix(REF.FIRMA);
~~


\prel_auto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Włącza/wyłącza automatyczne uruchamianie czynności
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_DESI;
_can_continue:=1;

{? exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.ACCEPTED='T'")
|| exec('akc_info','#b_design',exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.SYMBOL"));
   return()
?};

_buffer:=exec('buffer','#b_prel');
_b_prel:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,,null());
{? _b_prel<>null()
|| _buffer.cntx_get(_b_prel);
   {? _buffer.CLASS<>'B_ACTION'
   || FUN.info('Opcja dostępna tylko dla czynności.'@)
   || B_ACTION.cntx_psh();
      B_ACTION.index('B_ELE');
      B_ACTION.prefix(_buffer.B_ELE);
      {? B_ACTION.first()
      || {? _buffer.AUTOMAT='M' & B_ACTION.AUTOMAT='T'
         || {? FUN.ask('Czy włączyć automayczne uruchamianie czynności?'@)
            || _buffer.AUTOMAT:='T'
            ?}
         |? _buffer.AUTOMAT='T' & B_ACTION.AUTOMAT='T'
         || {? FUN.ask('Czy wyłączyć automatyczne uruchamianie czynności?'@)
            || _buffer.AUTOMAT:='M'
            ?}
         || FUN.info('Opcja dostępna dla czynności automatycznych.'@);
            _buffer.AUTOMAT:='N'
         ?};
         {? exec('put','#b_prel',_buffer)
         || _tab.AUTOMAT:=_buffer.AUTOMAT;
            _tab.put()
         ?}
      ?};
      B_ACTION.cntx_pop()
   ?}
?};
~~


\b_choice_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Uruchamia kreator warunków dla bram
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::       [_b] - B_PREL.ref() - brama na diagramie, jeśli nie podane to aktualny rekord
::                             tabeli _env.TAB_DESI
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_b_prel:=null();
{? var_pres('_b')=type_of(B_PREL.ref())
|| _b_prel:=_b
|| _tab:=_env.TAB_DESI;
   _b_prel:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,,null())
?};

_can_continue:=1;

_buffer:=exec('buffer','#b_prel');

{? _b_prel<>null()
||
   _buffer.cntx_get(_b_prel);
   {? exec('is_gate','#b_gate',_buffer.B_ELE,,exec('kind_split','#b_gate'))>0
      | exec('is_gate','#b_gate',_buffer.B_ELE,,exec('kind_merge','#b_gate'))>0
        & exec('is_gate','#b_gate',_buffer.B_ELE,exec('type_complex','#b_gate'))>0
   ||
      _editable:=1;

::    Podgląd, jeśli brama AND albo
      {? exec('is_gate','#b_gate',_buffer.B_ELE,exec('type_and','#b_gate'))>0
         | exec('is_gate','#b_gate',_buffer.B_ELE,exec('type_event','#b_gate'))>0
      || _editable:=0
      ?};

::    Wyświetlam komunikat o podglądzie, jeśli proces zaakceptowany
      {? exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.ACCEPTED='T'")
      || _editable:=0;
         _msg:='Proces jest zaakceptowany. Warunki zostaną wyświetlone w trybie podglądu.'@;
         FUN.info(_msg)
      ?};

      exec('select4gate','#b_choice',_b_prel,_editable);
      ~~
   ||
::    Komunikat o niedostępności
      exec('kom_forbidden','#b_choice')
   ?}
?};
~~


\bPrel_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Zmiana symbolu elementu w procesie
::       Dla czynności ręcznej dodatkowo przypisanie formuł
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_DESI;

{? exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.ACCEPTED='T'")
|| exec('akc_info','#b_design',exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.SYMBOL"));
   return(0)
?};

undefine();
_def_sym:=_tab.SYMBOL;
_symbol:='';
_bPrel:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL);
_bEle:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,"B_ELE");
_class:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,"CLASS",'');
_fmanmain:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,"FMANMAIN",'');
_fmandesc:=exec('FindAndGet','#table',B_PREL,_tab.B_PREL,,"FMANDESC",'');
define('SYMBOL',_def_sym,'Symbol elementu'@,,100,50);

_fm_edit:=0;
{? _class='B_ACTION'
|| B_ACTION.cntx_psh();
   B_ACTION.index('B_ELE');
   B_ACTION.prefix(_bEle);
   {? B_ACTION.first() & B_ACTION.MANUAL='T'
   || define('FMANMAIN',_fmanmain,'Formuła do obsługi ręcznej'@,,100,50);
      define('FMANDESC',_fmandesc,'Formuła do obsługi ręcznej (opis)'@,,100,50);
      _fm_edit:=1
   ?};
   B_ACTION.cntx_pop()
?};

def_btn('text=%1'['Zapisz'@],'key:F2');
def_btn('text=%1'['Anuluj'@],'key:Esc');
_valid:=$(
   "{? ~exec('valid_symbol','#b_prel','"+$_env.SEL_PROC+"',DEFINE.SYMBOL,'"+$_bPrel+"') || 'SYMBOL'"+
   {? _fm_edit
   || "|? ~exec('valid_formula','#field',DEFINE.FMANMAIN) || 'FMANMAIN'"+
      "|? ~exec('valid_formula','#field',DEFINE.FMANDESC) || 'FMANDESC'"
   || ""
   ?}+
   "|| 1 ?}"
);
{? def_edit(_valid,'Poprawianie elementu procesu'@)>0
||
   _symbol:=DEFINE.SYMBOL;
   _buffer:=exec('buffer','#b_prel');
   _buffer.cntx_get(_bPrel);
   _buffer.B_PROC:=_env.SEL_PROC;
   _buffer.SYMBOL:=_symbol;
   {? _fm_edit
   || _buffer.FMANMAIN:=DEFINE.FMANMAIN;
      _buffer.FMANDESC:=DEFINE.FMANDESC
   ?};
   {? exec('put','#b_prel',_buffer)
   || B_PREL.cntx_psh(); B_PREL.clear();
      {? B_PREL.seek(_bPrel)
      || exec('prel2tab','#b_design',_env)
      ?};
      B_PREL.cntx_pop()
   ?}
?};
undefine()


\procrol2actrol
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Przepisanie ról czynności w procesie do czynności i akceptacja niezaakceptowanych ról
::   WE: _a - B_PROC.ref()
::       _b - B_PREL.UID
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;
_uid:=_b;

B_PREL.cntx_psh();
B_PREL.index('TREE');
B_PREL.prefix(_b_proc,_uid,);
_loop:=B_PREL.first();
{!
|? _loop
|! {? B_PREL.B_ELE().CLASS='B_ACTION' & B_PREL.TYPE<>'S'
   || exec('procrol2actrol','#b_action',B_PREL.B_ELE,B_PREL.B_ROLE)
   ?};
   exec('procrol2actrol','#b_design',_b_proc,B_PREL.UID);
   _loop:=B_PREL.next()
!};
B_PREL.cntx_pop()


\treeWer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Okno wertowania tabeli tworzonej w exec('treeTab','#b_proc')
::   WE: _a - obj_new('TAB','WER')
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_Tab:=_obj.TAB;

_obj.WER:=_wer:=_Tab.mk_sel('Struktura'@,'P',,'jdfkjhrfwpqwoe',1,,,1);
_Tab.win_fld(_wer,,'DESC',,,50,,,'Opis'@);
_fb:="exec('assignRol4User','#b_design',__ProUpr)";
_Tab.win_act(_wer,,'Formuła','Nadaj'@@,,,_fb,,1)


\usrolWer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Okno wertowania użytkownikow z tabeli B_USRROL
::   WE: _a - obj_new('TAB','WER')
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_Tab:=_obj.TAB;

_obj.WER:=_wer:=B_USRROL.mk_sel('Użytkownicy'@,'P',,'ferfejfjbaldjkf',,,,,'U');
_Tab.win_fld(_wer,,'USERS','KOD',,30,,,'Użytkownik'@);
_fb:="exec('assignRol4User','#b_design',__ProUpr)";
_Tab.win_act(_wer,1,'Formuła','Nadaj'@@,,,_fb,,1,,,,'N');
_Tab.win_act(_wer,,'Formuła','Nadaj'@@,,,_fb,,1,,,,'N');
_Tab.win_act(_wer,,'Usuń',,,,,,,1);
_Tab.win_act(_wer,,'Kolejność')


\assignRol4User
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Przypisanie użytkownikow do roli
::   WE: _a - środowisko
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_czysc:="VAR_DEL.delete('__Dane')";
_czysc();

_firma:=REF.FIRMA;
_b_role:=exec('FindAndGet','#table',B_ROLE,_env.TREE.TAB.B_ROLE);

{? _b_role=null() | _b_role=~~
|| FUN.info('Nie wybrano roli.\nOperacja niemożliwa.'@);
   return()
?};

_buffer:=exec('buffer','#b_usrrol');

__Dane:=obj_new('SEL_U');

_wer:=USERS.mk_sel('Użytkownicy'@,'P',,'georfjqopadfodj',,,,,'U');
USERS.win_fld(_wer,,'KOD',,,30,,,'Użytkownik'@);
_fb:="
   _Sel:=USERS.sel_aget();
   {? ~_Sel.first() || _Sel.REF:=#USERS.ref(); _Sel.add() ?};
   USERS.sel_adel();
   __Dane.SEL_U:=_Sel;
   sel_exit();
   0";
USERS.win_act(_wer,,'Formuła','Akceptuj'@@,,,_fb,,1,1,_fb,,'A');

USERS.cntx_psh();

USERS.index('USR_AKOD');
USERS.prefix('T');

KOMM.init(250,,'Przypisywanie użytkowników do ról'@);
USERS.win_sel(_wer);
{? USERS.select()
|| _Tab:=__Dane.SEL_U;
   _loop:=_Tab.first();
   {!
   |? _loop
   |!
      {? USERS.seek(_Tab.REF,)
      || _buffer.blank();
         _buffer.USERS:=USERS.ref();
         _buffer.B_ROLE:=_b_role;
         _buffer.FIRMA:=_firma;
         exec('add','#b_usrrol',_buffer,,2)
      ?};
      _loop:=_Tab.next()
   !}
?};
KOMM.select();
USERS.cntx_pop();
_czysc()


\drop_desi
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Obsługa upuszczania rekordów w ramach modelera
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

params_set(params_get());

{? exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.ACCEPTED='T'")
|| exec('akc_info','#b_design',exec('FindAndGet','#table',B_PROC,$_env.SEL_PROC,,"B_PROC.SYMBOL"));
   return(~~)
?};


_Tab:=_env.TAB_DESI;

_tab:=dnd_info('dropped_records');
_des_rec:=dnd_info('dest_record');

{? _des_rec=null() || return(~~) ?};

_des_bprel:='';
_Tab.cntx_psh();
_Tab.prefix();
{? _Tab.seek(_des_rec)
|| _Tab.PARENT & _Tab.seek(_Tab.PARENT,);
   _des_bprel:=_Tab.B_PREL
?};
_Tab.cntx_pop();
_des_uid:=exec('FindAndGet','#table',B_PREL,_des_bprel,,"B_PREL.UID",'');
_des_rol:=exec('FindAndGet','#table',B_PREL,_des_bprel,,"B_PREL.B_ROLE",'');

{? _des_uid='' || return(~~) ?};

B_PREL.cntx_psh();
_Tab.cntx_psh();
{? _Tab.first()
|| {!
   |?
      {? _Tab.seek(_tab.REF,)
      || {? _Tab.CLASS<>'B_LANE'
         || _src_prel:=exec('FindAndGet','#table',B_PREL,_Tab.B_PREL);
            {? _src_prel
            || B_PREL.prefix();
               {? B_PREL.seek(_src_prel)
               || B_PREL.UID_PAR:=_des_uid;
                  B_PREL.B_ROLE:=_des_rol;
                  {? B_PREL.put()
                  || _Tab.del();
                     exec('prel2tab','#b_design',_env)
                  ?}
               ?}
            ?}
         ?}
      ?};
      _tab.next()
   !}
?};
_Tab.cntx_pop();
B_PREL.cntx_pop();
~~


\import_needed
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Importuje wszystko co potrzebne modelerowi do działania
::   WE: _a - 0 - obszar "Obsługa procesów"
::       _b - formuła do wykoania
::      [_c]- czy wyświetlać komunikaty, 1 - tak (domyślnie), 0 - nie
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_c')=type_of(1) && _c=0
|| _force:=1
|| _force:=0
?};
{? _force | FUN.ask('Czy importować elementy modelera?'@)
|| _txt:='Importowanie niezbędnych elementów dla Modelera.'@;
   KOMM.init(250,,_txt);

   FUN.prg_start(11,_txt,,,1);
   _tab_opt_idadd:=exec('tab_optimize_idadd','#b_action');
   exec('stat_list','#bi_stat');
   FUN.prg_next();
   exec('fill_tab','#b_type',0);
   FUN.prg_next();
   exec('add_domain','#b_action');
   FUN.prg_next();
   exec('imp_act','#b_action',0);
   FUN.prg_next();
   exec('import','#b_port',0,,_tab_opt_idadd);
   FUN.prg_next();
   exec('import','#b_portgr',0);
   FUN.prg_next();
   exec('import','#b_perm',0);
   FUN.prg_next();
   exec('import','#parses',0);
   FUN.prg_next();
   exec('import','#b_cond',0);
   FUN.prg_next();
   exec('fill_all','#b_dane',0);
   FUN.prg_next();
   exec('import_hash','#b_action');
   FUN.prg_stop();
::exec('valid_all','#b_action',0);
   {? _a=0 & type_of(_b)=type_of("") || params_set(params_get()); _b() ?};
   {? ~_force
   || KOMM.select()
   ?}
?};
{? _a=0
|| win_activate('<')
?};
''


\import_needed_dom
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Aktualizuje czynności podanego obszaru
::   WE: _a - B_DOMAIN.ref - obszar którego czynności aktualizować
::       [_b] - 1(domyślnie) - pytanie i komunikaty 0-brak
::----------------------------------------------------------------------------------------------------------------------
_domain:=_a;
_komm:={? var_pres('_b')=type_of(0) || _b || 1 ?};

B_DOMAIN.cntx_psh(); B_DOMAIN.prefix();
{? B_DOMAIN.seek(_domain)
||
   {? ~_komm | FUN.ask('Czy aktualizować czynności obszaru \'%1\'?'@[B_DOMAIN.NAME])
   ||
      _tab_opt_idadd:=exec('tab_optimize_idadd','#b_action');

      KOMM.init(250,,'Importowanie niezbędnych elementów dla Modelera.'@);
      exec('imp_act','#b_action',0,B_DOMAIN.ref());
      exec('import','#b_port',0,B_DOMAIN.ref(),_tab_opt_idadd);
      exec('import','#b_portgr',0,B_DOMAIN.ref());
      exec('import','#b_perm',0,B_DOMAIN.ref());
      exec('import','#parses',0,B_DOMAIN.ref());
      exec('import','#b_cond',0,B_DOMAIN.ref());
      exec('import_hash','#b_action',B_DOMAIN.ref());
      {? _komm || KOMM.select() ?}
   ?}
?};
B_DOMAIN.cntx_pop();
''


\import_needed_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Aktualizuje podaną czynność
::----------------------------------------------------------------------------------------------------------------------
_action:=_a;

B_ACTION.cntx_psh(); B_ACTION.prefix();
{? B_ACTION.seek(_action)
||
   {? FUN.ask('Czy aktualizować czynność \'%1\'?'@[B_ACTION.NAME])
   ||
      _fields:=exec('mbTabFields_tab','#table',B_ACTION);
      _ndx:=_fields.ndx_tmp('',1,'FLD_ACR',,);
      _fields.index(_ndx);
      KOMM.init(250,,'Importowanie niezbędnych elementów dla Modelera.'@);

      _fun_g:='main';
      _fun_n:='n_main';
      _plik:=exec('filename','#b_action');

      exec('import_access','#b_action',_fun_g,_plik,1);
      exec('import_properties','#b_action',_fun_g,_plik,_fields,1);
      exec('import','#portal',_fun_g,_plik);
      exec('import_nrun','#b_action',_fun_n,_plik);

      FIRMA.cntx_psh();
      FIRMA.index('SYMBOL');
      FIRMA.prefix();
      {? FIRMA.first()
      || {!
         |? exec('update_b_actpro','#b_action',FIRMA.ref());
            FIRMA.next()
         !}
      ?};
      FIRMA.cntx_pop();

      exec('imp4act','#b_port',_fun_g,_plik);

      exec('imp4action','#b_portgr',_fun_g,_plik);

      {? B_ACTION.MANUAL<>'T'
      || exec('perm4act','#b_perm',1);
         exec('imp4act','#parses');
         exec('imp4act','#b_cond')
      ?};
      {? B_ACTION.AKT='T'
      || _hash:=exec('hash_params','#b_action');
         {? _hash<>''
         || B_ACTION.PAR_HASH:=_hash;
            _can_continue:=B_ACTION.put() & B_ACTION.memo_put(,'PORT_OPR')
         ?}
      ?};
      exec('update_micro','#b_action');
      KOMM.select()
   ?}
?};
B_ACTION.cntx_pop();
''


\properties
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Właściwości elementu
::   WE: _a - B_PREL.ref
::       [_b] - INTEGER - czy proces udało się zablokować do edycji
::       [_c] - INTEGER - czy widok od strony instancji
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;

_locked:=1;
{? var_pres('_b')=type_of(0)
|| _locked:=_b
?};
_inst:=0;
{? var_pres('_c')=type_of(0)
|| _inst:=_c
?};

params_set(params_get());
VAR_DEL.delete('VALPRT_CR');
_env:=exec('env','#b_valprt');
_env.LOCKED:=_locked;
_env.INST:=_inst;
VALPRT_CR:=_env;

_env_modeler:=~~;
{? var_pres('env',params_get())
|| _env_modeler:=params_get().env
?};

{? type_of(_env_modeler)>100
|| params_set('env',_env,'env_modeler',_env_modeler)
|| params_set('env',_env)
?};

{? _env.load(_ref)
|| _env.select()
?};

:: Odblokowuje porty
exec('unlock_ports','#b_valprt',_env);
:: Odblokowuje element procesu
exec('unlock','#b_prel',_env.B_PREL);

VAR_DEL.delete('VALPRT_CR')


\exit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła wykonywana przy zamykaniu modelera - sprawdza czy są niezapisane zmiany i jeśli są
::       to umożliwia ich zapis
::   WY: 0 - user zrezygnował
::       1 - można zamknąć okno
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_result:=1;

{? _env.TM_MOD>B_PROC.TM_SAVE
|| _msg:='Istnieją niezapisane zmiany na diagramie. Czy na pewno wyjść z okienka modelera?'@;
   _choice:=FUN.choice(_msg,,'Zapisz i wyjdź'@,'Wyjdź'@);
   {? _choice=1
   || _env.AFTER_SAVE_FML:="sel_exit()";
      exec('save_diagram_act','#b_bpmn');
      _result:=0
   |? _choice=2
   || _result:=1;
::    Pytam się modelera czy był robiony import
      _imported:=exec('get_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'imported');
      {? _imported='true'
      ||
::       Jeżeli był robiony import i wychodzę bez zapisywania to sprzątam plik .proc po stronie
::       serwera żeby nie zostawały śmieci
         exec('procfile_clean','#b_export',_env.IMPORT_FILEPROC);
         ~~
      ?}
   || _result:=0
   ?}
?};
_result


\proc_akc_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Akceptacja definicji procesu
::   WE: [_a] - INTEGER - 0/[1] - czy wyświetlać komunikaty
::       [_b] - tab_tmp - tabela procesów do akceptacji - jeśli nie podana to bieżące zaznaczenie B_PROC
::       [_c] - INTEGER - 0/[1] - czy inicjować KOMMa
::       [_d] - tab_tmp - tabela z licencjonowanymi dziedzinami
::       [_e] - INTEGER - 0/[1] - czy wyświetlać KOMMa
::       [_f] - INTEGER - 0/[1] - czy blokować proces na czas akceptacji
::  TAG: <PUBLIC><MODELER><PROCES><AKCJA><AKCEPTACJA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;

_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

_sel:=~~;
{? var_pres('_b')>100
|| _sel:=_b
|| _sel:=B_PROC.sel_aget();
   B_PROC.sel_adel()
?};

_komm_init:=1;
{? var_pres('_c')=type_of(0)
|| _komm_init:=_c
?};
_domain_lic:=~~;
{? var_pres('_d')>100
|| _domain_lic:=_d
?};
_komm_select:=1;
{? var_pres('_e')=type_of(0)
|| _komm_select:=_e
?};
_can_lock:=1;
{? var_pres('_f')=type_of(0)
|| _can_lock:=_f
?};

_grp_act:=0;

{? type_of(_sel)>100 & _sel.size()>0
|| _grp_act:=1
?};

_args:=exec('komm_args','#b_proc');

_can_continue:=1;

{? _grp_act
||
   {? _dialog>0
   || _can_continue:=FUN.ask('Czy zaakceptować zanaczone procesy?\n\n'
                             'Uwaga. Procesy, które nie zostaną pozytywnie zweryfikowane zostaną pominięte.'@)
   ?};
   {? _can_continue>0
   ||
      B_PROC.cntx_psh();
      {? _sel.first()
      || _args.WARN_SHOW:=0;
         {? _komm_init>0
         || KOMM.init(250,,'Akceptacja procesów'@)
         ?};
         FUN.prg_start(_sel.size()+1,'Akceptacja procesów.'@,,,1);
         {!
         |? {? (B_PROC.prefix(); B_PROC.seek(_sel.REF,))
            ||
               _env.KOMM_PROC:=B_PROC.ref();
               FUN.prg_next(1,'Akceptacja procesu: %1 - %2'@[B_PROC.SYMBOL,B_PROC.NAME]);
               params_set(params_get());
               _b_proc:=B_PROC.ref();

               {? _can_lock>0
               ||
                  _r_lock:=B_PROC.r_lock(1,1,1);
                  _what:=exec('record','#to_string',_b_proc);
                  _msg:='Proces \'%1\' niemożliwy do zaakceptowania ponieważ jest redagowany'@[_what];
                  {? ~_r_lock
                  || _locked:=0;
                     _args.MSG:=_msg;
                     _args.KIND:='empty';
                     _args.SECT:='';
                     exec('komm_add','#b_proc',_args);
                     _args.KIND:=''
                  || _locked:=exec('blk_lock','#table','B_PROC',_b_proc,,1,_msg,,1)
                  ?}
               || _locked:=1
               ?};
               {? _locked>0
               || {? B_PROC.ACCEPTED='T'
                  || _msg:='Proces jest już zaakceptowany.'@;
                     _args.SECT:='';
                     _args.KIND:='empty';
                     _args.MSG:=_msg;
                     _args.ICON:=19;
                     exec('komm_add','#b_proc',_args);
                     _args.KIND:=''
                  || _verify:=exec('proc_verify_act','#b_design',0,0,0,_args,_domain_lic);
                     {? _verify=0
                     || _msg:='Weryfikacja procesu zakończona niepowodzeniem — akceptacja się nie powiodła'@;
                        _args.SECT:='';
                        _args.KIND:='empty';
                        _args.MSG:=_msg;
                        _args.ICON:=19;
                        exec('komm_add','#b_proc',_args);
                        _args.KIND:=''
                     ?};
                     _del_gatele:=1;
                     {? _verify=1 | _verify=-1
                     ||
                        _end:=1;
::                      Utworzenie portów wyjściowych zdarzeń startowych nieoznaczonych
                        {? _end
                        || _mydo:=do_state()=0;
                           {? _mydo || do() ?};
                           exec('port4event','#b_actsta',_b_proc,'create');
                           {? _mydo || _end:=end() ?}
                        ?};
::                      Utworzenie portów dynamicznych do bram warunkowych
                        {? _end
                        || _mydo:=do_state()=0;
                           {? _mydo || do() ?};
                           exec('create_port4gate','#b_choice',_b_proc);
                           {? _mydo || _end:=end() ?}
                        ?};
::                      Utworzenie tras portów wyjściowych dla procesu
                        {? _end
                        ||
                           _mydo:=do_state()=0;
                           {? _mydo || do() ?};
                           exec('route_delete4bproc','#b_proute',_b_proc);
                           exec('route_create4bproc','#b_proute',1,_b_proc,_args);
                           {? _mydo || _end:=end() ?}
                        ?};
::                      Przepisanie ról
                        {? _end
                        ||
                           _mydo:=do_state()=0;
                           {? _mydo || do() ?};
                           exec('procrol2actrol','#b_design',_b_proc,'');
                           B_PROC.ACCEPTED:='T';
                           B_PROC.A_IDTIME:=time_ident(date(),time());
                           B_PROC.put();
                           {? _mydo || _end:=end() ?}
                        ?};
                        {? _end
                        ||
                           _del_gatele:=0
                        ||
                           _msg:='Nie udało się zaakceptować procesu.'@;
                           _args.SECT:='';
                           _args.KIND:='empty';
                           _args.MSG:=_msg;
                           _args.ICON:=19;
                           exec('komm_add','#b_proc',_args);
                           _args.KIND:=''
                        ?};
::                      Dodanie harmonogramów zdarzeń startowych dla procesu
                        exec('add_b_proc','#b_harm',_b_proc)
                     ?};
                     {? _del_gatele || exec('delete','#b_gatele',_b_proc) ?}
                  ?}
               ?};
::             Odblokowuję proces
               B_PROC.r_unlock();
               exec('blk_unlock','#table','B_PROC',_b_proc)
            ?};
            _sel.next()
         !};
         FUN.prg_stop();
         {? _komm_select>0
         || KOMM.select()
         ?};
         _env.NR_ROOT:=0;
         _env.KOMM_PROC:=null();
         _env.GRP_ACT:=0;
         params_set(params_get())
      ?};
      B_PROC.cntx_pop()
   ?}
|? ~_grp_act
||
   {? _komm_init>0
   || KOMM.init(250,,'Akceptacja procesu'@)
   ?};
   params_set(params_get());
   _r_lock:=B_PROC.r_lock(1,1,1);
   _b_proc:=B_PROC.ref();
   _what:=exec('record','#to_string',_b_proc);
   _msg:='Proces \'%1\' niemożliwy do zaakceptowania ponieważ jest redagowany'@[_what];
   {? ~_r_lock
   || _locked:=0;
      KOMM.add(_msg,2)
   || _locked:=exec('blk_lock','#table','B_PROC',_b_proc,,1,_msg,,0)
   ?};
   {? _locked>0
   || {? B_PROC.ACCEPTED='T'
      || exec('akc_info','#b_design',B_PROC.SYMBOL)
      || _verify:=exec('proc_verify_act','#b_design',0,0,1,_args);
         {? _verify=-1
         || _msg:='Podczas weryfikacji procesu zostały zgłoszone uwagi — można zatwierdzić proces'@;
            KOMM.add(_msg,'xwin16.png:9')
         |? _verify=0
         || _msg:='Weryfikacja procesu zakończona niepowodzeniem — akceptacja się nie powiodła'@;
            KOMM.add(_msg,'xwin16.png:8')
         ?};
         {? _komm_select>0
         || KOMM.select()
         ?};
         _del_gatele:=1;

         {? _dialog>0
         || {? _verify=-1
            || _can_continue:=FUN.ask('Podczas weryfikacji procesu zostały zgłoszone uwagi.\n\n'
                                      'Czy zaakceptować definicję procesu?'@)
            |? _verify=1
            || _can_continue:=FUN.ask('Czy zaakceptować definicję procesu?'@)
            || _can_continue:=0
            ?}
         ?};
         {? _can_continue>0
         ||
            _end:=1;
            FUN.prg_start(4,'Akceptacja procesu.'@);
            {? _end
            || _mydo:=do_state()=0;
               {? _mydo || do() ?};
::             Utworzenie portów wyjściowych zdarzeń startowych nieoznaczonych
               FUN.prg_next(1,'Dodanie portów wyjściowych zdarzeń startowych nieoznaczonych.'@);
               exec('port4event','#b_actsta',_b_proc,'create');
               {? _mydo || _end:=end() ?}
            ?};
            {? _end
            || _mydo:=do_state()=0;
               {? _mydo || do() ?};
::             Utworzenie portów dynamicznych do bram warunkowych
               FUN.prg_next(1,'Dodanie portów dynamicznych dla bram warunkowych.'@);
               exec('create_port4gate','#b_choice',_b_proc);
               {? _mydo || _end:=end() ?}
            ?};
            {? _end
            || _mydo:=do_state()=0;
               {? _mydo || do() ?};
::             Utworzenie tras portów wyjściowych dla procesu
               FUN.prg_next(1,'Dodanie tras portów wyjściowych.'@);
               exec('route_delete4bproc','#b_proute',_b_proc);
               exec('route_create4bproc','#b_proute',1,_b_proc,_args);
               {? _mydo || _end:=end() ?}
            ?};
            {? _end
            || _mydo:=do_state()=0;
               {? _mydo || do() ?};
               FUN.prg_next(1,'Przepisanie ról.'@);
               exec('procrol2actrol','#b_design',_b_proc,'');
               B_PROC.ACCEPTED:='T';
               B_PROC.A_IDTIME:=time_ident(date(),time());
               B_PROC.put();
               {? _mydo || _end:=end() ?}
            ?};
            {? _end
            || _del_gatele:=0
            ?};
::          Dodanie harmonogramów zdarzeń startowych dla procesu
            FUN.prg_next(1,'Dodanie harmonogramów zdarzeń startowych dla procesu.'@);
            exec('add_b_proc','#b_harm',_b_proc);
            FUN.prg_stop()
         ?};
         {? _del_gatele || exec('delete','#b_gatele',_b_proc) ?}
      ?}
   ?};
:: Odblokowuję proces
   B_PROC.r_unlock();
   exec('blk_unlock','#table','B_PROC',_b_proc);
   _env.NR_ROOT:=0;
   _env.GRP_ACT:=0;
   params_set(params_get())
?};
~~


\proc_wyc_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Wycofanie akceptacji definicji procesu
::  TAG: <PUBLIC><MODELER><PROCES><AKCJA><WYCOFANIE>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
_grp_act:=B_PROC.sel_size();
_sel:=B_PROC.sel_aget();
B_PROC.sel_adel();

{? _grp_act & FUN.ask('Czy wycofać akceptację zanaczonych procesów?\n\n'
                      'Uwaga. Procesy, które posiadają już jakieś instancje (uruchomienia) zostaną pominięte.'@)
|| B_PROC.cntx_psh();
   {? _sel.first()
   || KOMM.init(250,,'Wycofanie akceptacji procesów'@);
      FUN.prg_start(_sel.size,'Wycofanie akceptacji procesów.'@,,,1);
      {!
      |? {? (B_PROC.prefix(); B_PROC.seek(_sel.REF,))
         || _env.NR_ROOT:=KOMM.sect_beg('Proces: %1 - %2'@[B_PROC.SYMBOL,B_PROC.NAME]);
            KOMM.sect_end();
            FUN.prg_next(1);
            params_set(params_get());
            _r_lock:=B_PROC.r_lock(1,1,1);
            _b_proc:=B_PROC.ref();
            _what:=exec('record','#to_string',_b_proc);
            _msg:='Proces \'%1\' niemożliwy do wycofania akceptacji ponieważ jest redagowany'@[_what];
            {? ~_r_lock
            || _locked:=0;
               KOMM.add(_msg,2)
            || _locked:=exec('blk_lock','#table','B_PROC',_b_proc,,1,_msg,,1)
            ?};
            {? _locked>0
            || {? B_PROC.ACTIVE<>'T'
               || _msg:='Proces jest nieaktywny.'@;
                  KOMM.add(_msg,'xwin16.png:19')
               |? B_PROC.ACCEPTED='N'
               || _msg:='Proces jest niezaakceptowany.'@;
                  KOMM.add(_msg,'xwin16.png:19')
               |? exec('inst_test','#bi_proc',$B_PROC.ref())
               || _msg:='Proces posiada już jakieś instancje (uruchomienia).'@;
                  KOMM.add(_msg,'xwin16.png:19')
               || B_PROC.ACCEPTED:='N';
                  do();
                  B_PROC.put();
                  exec('delete','#b_gatele',_b_proc);
                  exec('del_b_proc','#b_harm',_b_proc);
                  exec('proc_actrol_del','#b_role',_b_proc);
::                usunięcie portów wyjściowych zdarzeń startowych nieoznaczonych
                  exec('port4event','#b_actsta',_b_proc,'remove');
                  {? end()
                  || _msg:='Wycofano akceptację procesu.'@;
                     KOMM.add(_msg,'xwin16.png:38')
                  ?}
               ?}
            ?};
::          Odblokowuję proces
            B_PROC.r_unlock();
            exec('blk_unlock','#table','B_PROC',_b_proc)
         ?};
         _sel.next()
      !};
      FUN.prg_stop();
      KOMM.select();
      _env.NR_ROOT:=0;
      _env.GRP_ACT:=0;
      params_set(params_get())
   ?};
   B_PROC.cntx_pop()
|? ~_grp_act & FUN.ask('Wycofać akceptację definicji procesu?'@)
|| _env.NR_ROOT:=1;
   params_set(params_get());
   _r_lock:=B_PROC.r_lock(1,1,1);
   _b_proc:=B_PROC.ref();
   _what:=exec('record','#to_string',_b_proc);
   _msg:='Proces \'%1\' niemożliwy do zaakceptowania ponieważ jest redagowany'@[_what];
   {? ~_r_lock
   || _locked:=0;
      FUN.info(_msg)
   || _locked:=exec('blk_lock','#table','B_PROC',_b_proc,,1,_msg,,0)
   ?};
   {? _locked>0
   || {? B_PROC.ACTIVE<>'T'
      || FUN.info('Proces jest nieaktywny.\nOpcja niedostępna.'@)
      |? B_PROC.ACCEPTED='N'
      || FUN.info('Definicja procesu jest niezaakceptowana.\nOpcja niedostępna.'@)
      |? exec('inst_test','#bi_proc',$B_PROC.ref())
      || exec('inst_info','#bi_proc',$B_PROC.ref())
      || B_PROC.ACCEPTED:='N';
         do();
         B_PROC.put();
         exec('delete','#b_gatele',_b_proc);
         exec('del_b_proc','#b_harm',_b_proc);
         exec('proc_actrol_del','#b_role',_b_proc);
::       usunięcie portów wyjściowych zdarzeń startowych nieoznaczonych
         exec('port4event','#b_actsta',_b_proc,'remove');
         end()
      ?}
   ?};
:: Odblokowuję proces
   B_PROC.r_unlock();
   exec('blk_unlock','#table','B_PROC',_b_proc);
   _env.NR_ROOT:=0;
   _env.GRP_ACT:=0;
   params_set(params_get())
?};
~~


\proc_verify_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'weryfikacja' w oknie procesów - uruchamia weryfikacje procesu
::   WE: [_a] - INTEGER - 0/[1] czy pokazywać info o sukcesie weryfikacji
::       [_b] - INTEGER - 0/[1] czy inicjować i pokazywać KOMM
::       [_c] - INTEGER - 0/[1] czy pokazywać progres weryfikacji
::       [_d] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::       [_e] - tab_tmp - tabela z licencjonowanymi dziedzinami
::   WY: -1 - tylko uwagi
::       0 - błędy (i ew. uwagi)
::       1 - sukces
::  TAG: <PUBLIC><MODELER><PROCES><AKCJA><CHK>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_info_sukces:=1;
{? var_pres('_a')=type_of(0)
|| _info_sukces:=_a
?};
_kom_show:=1;
{? var_pres('_b')=type_of(0)
|| _kom_show:=_b
?};
_prg_show:=1;
{? var_pres('_c')=type_of(0)
|| _prg_show:=_c
?};

_args:=~~;
{? var_pres('_d')>100
|| _args:=exec('obj_ntab_set','#array',_d)
|| _args:=exec('komm_args','#b_proc')
?};
_domain_lic:=~~;
{? var_pres('_e')>100
|| _domain_lic:=_e
?};


{? var_pres('ctr_bpmn',_env)=type_of('')
||
:: Usuwam komunikaty wysyłane na diagram z poprzedniej weryfikacji
   _env.TAB_KOMM.erase()
?};

_result:=1;
_can_continue:=1;

{? _kom_show>0
|| KOMM.init(250,,'Weryfikacja procesu'@)
?};
:: 0. Weryfikacja czy proces w ogóle zawiera jakieś elementy i jest sens przeprowadzać dalszą
::    weryfikację
B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(B_PROC.ref());
{? B_PREL.size()=0
||
   _sect:='Pusta zawartość'@;
   {? B_PROC.IMEX_GML<>null()
   ||
      _can_continue:=0;
      _result:=0;
      _msg:='Proces jest pusty, ponieważ nie dokończono jego importu.'@;

      _args.SECT:=_sect;
      _args.MSG:=_msg;
      exec('komm_add','#b_proc',_args)

   || _can_continue:=0;
      _result:=0;
      _msg:='Proces jest pusty, nie zawiera żadnych elementów.'@;

      _args.SECT:=_sect;
      _args.MSG:=_msg;
      exec('komm_add','#b_proc',_args)
   ?}
?};
B_PREL.cntx_pop();

{? _can_continue>0
||

:: 0. Weryfikacja czy były jakieś błędy importu
   {? B_PROC.IMP_ERR='T'
   || _result:=0;
      _sect:='Błędy importu'@;
      _msg:='Proces zawiera elementy błędnie zaimportowane.'@;
      _args.SECT:=_sect;
      _args.MSG:=_msg;
      _args.GRAPH_UID:='';
      exec('komm_add','#b_proc',_args)
   ?};

:: 1. Weryfikacja powiązań między elementami
   {? _prg_show
   || FUN.prg_start(13,'Weryfikacja powiązań między elementami.'@);
      FUN.PRGShide:=1
   ?};

   {? exec('chk_conns','#b_proc',B_PROC.ref(),0,_args)<=0
   || _result:=0
   ?};

:: 2. Weryfikacja listy zdarzeń
   {? _prg_show || FUN.prg_next(1,'Weryfikacja listy zdarzeń.'@) ?};
   {? exec('chk_events','#b_proc',B_PROC.ref(),0,_args)<=0
   || _result:=0
   ?};

:: 3. Wyznaczanie elementów dla bram zbierających OR
   {? _prg_show || FUN.prg_next(1,'Wyznaczanie elementów dla bram zbierających OR.'@) ?};
   _verify:=exec('gatele','#b_proc',B_PROC.ref(),_args);
   {? _verify=0
   || _result:=0
   |? _verify=-1
   || {? _result=1 || _result:=-1 ?}
   ?};

:: 4. Weryfikacja powiązań miedzyportowych
   {? _prg_show || FUN.prg_next(1,'Weryfikacja powiązań miedzyportowych.'@) ?};
   {? exec('chk_poconns','#b_proc',B_PROC.ref(),0,_args)<=0
   || _result:=0
   ?};

:: 5. Weryfikacja kompletów powiązań parametrów
   {? _prg_show || FUN.prg_next(1,'Weryfikacja powiązań miedzyportowych.'@) ?};
   {? exec('chk','#b_portgr',B_PROC.ref(),0,_args)<=0
   || _result:=0
   ?};

:: 6. Weryfikacja bram
   {? _prg_show || FUN.prg_next(1,'Weryfikacja bram.'@) ?};
   {? exec('chk_gates','#b_proc',B_PROC.ref(),0,_args)<=0
   || _result:=0
   ?};

:: 7. Weryfikacja czy wszystkie czynności użyte w procesie mają parametry złączeniowe z polami typu IDADD
   {? _prg_show || FUN.prg_next(1,'Weryfikacja czynności.'@) ?};
   {? exec('chk_idadd','#b_proc',,_args)<=0
   || _result:=0
   ?};

:: 8. Weryfikacja czy licencja obejmuje wszystkie czynnosci użyte w procesie
   {? _prg_show || FUN.prg_next(1,'Weryfikacja licencji czynności.'@) ?};
   {? exec('chk_lic','#b_proc',,_args,_domain_lic)=0
   || _result:=0
   ?};

:: 9. Weryfikacja czy wszystkie czynności aktywne, czyli czy są w defie
   {? _prg_show || FUN.prg_next(1,'Weryfikacja aktywności czynności.'@) ?};
   {? exec('chk_akt','#b_proc',,_args)=0
   || _result:=0
   ?};

:: 10. Sprawdzenie ciągłości tras portów wyjściowych
   {? _prg_show || FUN.prg_next(1,'Weryfikacja ciągłości tras portów wyjsciowych.'@) ?};
   {? exec('chk_proutes','#b_proc',B_PROC.ref(),_args)=0
   || _result:=0
   ?};

:: 11. Sprawdzenie czy wszystkie elementy leżą na torach
   {? _prg_show || FUN.prg_next(1,'Weryfikacja elementów na torach.'@) ?};
   {? exec('chk_lanes','#b_proc',B_PROC.ref(),_args)=0
   || _result:=0
   ?};

:: 12. Sprawdzenie czy elementy startowe nieokreślone są oznaczone domeną
::    i automatyczne wyznaczenie domeny dla elementów bez niej
   {? _prg_show || FUN.prg_next(1,'Weryfikacja elementów startowych nieokreślonych.'@) ?};
   {? exec('chk_domain','#b_proc',B_PROC.ref(),_args)=0
   || _result:=0
   ?};

:: 13. W firmie 000 dostępne tylko czynności typu GRP_FIRM
   {? _prg_show || FUN.prg_next(1,'Weryfikacja dostępu do czynności w firmie 000.'@) ?};
   {? exec('chk_grp_firm','#b_proc',B_PROC.ref(),_args)=0
   || _result:=0
   ?};

:: 14. Sprawdzenie, czy wszystkie czynności mogą być uruchamiane procesowo
   {? _prg_show || FUN.prg_next(1,'Weryfikacja sposobu uruchamiania czynności.'@) ?};
   {? exec('chk_nproc','#b_proc',B_PROC.ref(),_args)=0
   || _result:=0
   ?};

   {? _prg_show || FUN.prg_stop() ?}
?};

echo();

{? _result<=0 & _kom_show>0
|| KOMM.select(,,,,,,,,,,'MSG')
?};

{? var_pres('ctr_bpmn',_env)=type_of('')
||
:: Uruchamiam pokazywanie wyniku weryfikacji na diagramie
   exec('verify_info_push','#b_bpmn')
?};

{? _result>0 & _info_sukces>0
|| FUN.info('Weryfikacja procesu zakończona powodzeniem.'@)
?};
_result


\proc_poconn_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Pokazuje powiązania miedzyargumentowe dla całego procesu
::  TAG: <PUBLIC><MODELER><PROCES><AKCJA><PARAMETR><LISTA><WERTOWANIE>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

exec('select4proc','#b_poconn',B_PROC.ref());
~~


\proc_upr_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Przypisanie użytkowników do ról procesu
::  TAG: <PUBLIC><MODELER><PROCES><AKCJA><UPRAWNIENIA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_b_proc:=B_PROC.ref();

_czysc:="VAR_DEL.delete('__ProUpr')";
_czysc();

:: środowisko __ProUpr
__ProUpr:=obj_new('TREE','USROL');
__ProUpr.TREE:=obj_new('TAB','WER');
__ProUpr.USROL:=obj_new('TAB','WER');

:: tabela struktury ról i czynności
exec('treeTab','#b_proc',__ProUpr.TREE);
exec('treeTabFill','#b_proc',__ProUpr.TREE.TAB,_b_proc,'',null());
:: okno wertowania struktury ról i czynności
exec('treeWer','#b_design',__ProUpr.TREE);

:: tabela użytkowników
__ProUpr.USROL.TAB:=B_USRROL;
:: okno wertowania użytkowników
exec('usrolWer','#b_design',__ProUpr.USROL);

:: okno grupowe
_Tab:=__ProUpr.TREE.TAB;
_wer:=_Tab.grp_make('(WIDOK TESTOWY) Uprawnienia'@,,'nckeqwekrjvnjkf');

_far:="
   _TabCur:=__ProUpr.TREE.TAB;
   _Tab:=__ProUpr.USROL.TAB;
   _wer:=__ProUpr.USROL.WER;
   _b_role:=exec('FindAndGet','#table',B_ROLE,_TabCur.B_ROLE);
   {? type_of(_b_role)=type_of(~~) || _b_role:=null() ?};
   _Tab.index('WER1');
   _Tab.prefix(REF.FIRMA,_b_role);
   grp_disp(_Tab,_wer)
   ";
_Tab.grp_sel(_wer,,__ProUpr.TREE.WER,,_far,,,,,,,,'maximized_with_title');

_Tab.grp_splt(_wer,,'vertical','usrol');

_Tab.grp_sel(_wer,__ProUpr.USROL.TAB,__ProUpr.USROL.WER,,,,,,,,,,'maximized_with_title');

_hid_actions:='';

_Tab.actions(__ProUpr.TREE.WER,_hid_actions);
__ProUpr.USROL.TAB.actions(__ProUpr.USROL.WER,_hid_actions);
:: select
_Tab.win_sel(_wer);
_Tab.select();

_czysc()


\btn_manual_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przycisk poprawiania właściwości czynności ręcznej
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA><CZYNNOŚĆ><REDAKCJA><WŁAŚCIWOŚCI>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_can_continue:=1;

B_PROC.cntx_psh();
B_PREL.cntx_psh();
IVAL_DEF.cntx_psh();
{? _env.B_PREL<>null()
|| {? B_PREL.seek(_env.B_PREL)
   ||
      {? B_PREL.IVAL_DEF<>null()
      || B_PREL.IVAL_DEF()
      || IVAL_DEF.blank()
      ?};

      _win:='';
      {? B_PREL.B_PROC().ACCEPTED='T'
      || _win:='RED_MAN2'
      || _win:=exec('win_edit','#b_action',_env,'RED_MAN',1)
      ?};
      B_PREL.win_edit(_win);
      {? B_PREL.AUTOMAT='N'
      || B_PREL.efld_opt(_win,'enable=0',,'AUTOMAT')
      || B_PREL.efld_opt(_win,'enable=1',,'AUTOMAT')
      ?};
      _valid:="
         _result:='';
         {? _result='' & exec('valid_formula','#field',B_PREL.FMACCESS)=0
         || _result:='FMACCESS'
         ?};
         {? _result='' & exec('valid_formula','#field',B_PREL.FMANOUT)=0
         || _result:='FMANOUT'
         ?};
         {? _result='' & exec('valid_formula','#field',B_PREL.FMANMAIN)=0
         || _result:='FMANMAIN'
         ?};
         {? _result='' & exec('valid_formula','#field',B_PREL.FMANDESC)=0
         || _result:='FMANDESC'
         ?};
         {? _result='' & exec('valid_formula','#field',B_PREL.FMANVIEW)=0
         || _result:='FMANVIEW'
         ?};
         {? _result='' & BPMN.B_TYPE<>null() & 1+B_TYPE.SYMBOL='_'
         || _tab_acr:=1-BPMN.B_TYPE().SYMBOL;
            {? ~exec('has_idadd','#table',($_tab_acr)())
            || FUN.info('Tabela ''%1'' nie zawiera pola typu IDADD.'@[_tab_acr]);
               _result:='B_TYPE'
            ?}
         ?};
         {? _result=''
         ||
::          Sprawdzam czy nalezy sprawdzic bufor planowanego czasu pracy
            _plan_diff:=exec('buffer_compare','#interval');
            {? _plan_diff=0
            || _result:=exec('validate','#interval')
            ?}
         ?};
         _result
      ";
      {? B_PREL.edit(_valid)
      || _buffer:=exec('buffer','#b_prel');
         _buffer.get();
         exec('automat_setter','#b_bpmn',_buffer,B_PREL.AUTOMAT,0);
         {? BPMN.B_TYPE=null()
         || _buffer.FMANOUT:=''
         ?};
         _can_continue:=exec('put','#b_prel',_buffer);
         {? _can_continue>0
         ||
::          Aktualizacja planowanego interwału pracy
            _can_continue:=exec('interval_update','#b_design','B_PREL')
         ?};
         B_PORT.index('UNIK');
         B_PORT.prefix(null(),B_PREL.ref(),null(),exec('kind_out','#b_port'),);
         {? BPMN.B_TYPE=null()
         || {? B_PORT.first() || B_PORT.del() ?}
         || {? B_PORT.first()
            || B_PORT.B_TYPE:=BPMN.B_TYPE;
               B_PORT.put()
            || B_PORT.ACTIVE:='T';
               B_PORT.B_ELE:=null();
               B_PORT.B_PREL:=B_PREL.ref();
               B_PORT.B_TYPE:=BPMN.B_TYPE;
               B_PORT.KEYREF:='N';
               B_PORT.KIND:=exec('kind_out','#b_port');
               B_PORT.SYMBOL:='OUT';
               B_PORT.NAME:='Dynamiczny parametr wyjściowy';
               B_PORT.REQUIRED:='N';
               B_PORT.add()
            ?}
         ?};
         ~~
      ?}
   ?}
?};
B_PROC.cntx_pop();
B_PREL.cntx_pop();
IVAL_DEF.cntx_pop();
B_PREL.get();
IVAL_DEF.get();
grp_edisp(B_PREL,_env.WIN_ACT,1);
grp_edisp(B_PREL,_env.WIN_ACT1,1);
''


\bpmn_btype_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed redakcją pola BPMN.B_TYPE (sprawdzenie, czy dynamiczny port wyjściowy wykorzystany jest w procesie)
::       Kontekst wywołania: ustawiony rekord tabeli B_PREL
::----------------------------------------------------------------------------------------------------------------------
B_PORT.index('UNIK');
B_PORT.prefix(null(),B_PREL.ref(),null(),exec('kind_out','#b_port'),);
{? B_PORT.first()
|| _res:=B_PORT.count()=0
|| _res:=1
?};
_res


\bpmn_btype_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed wyświetleniem pola BMPN.B_TYPE
::       Kontekst wywołania: ustawiony rekord tabeli B_PREL
::----------------------------------------------------------------------------------------------------------------------
{? BPMN.B_TYPE=null()
|| B_PREL.efld_opt(cur_win(1,1),'enable=0',,'FMANOUT')
|| B_PREL.efld_opt(cur_win(1,1),'enable=1',,'FMANOUT')
?};
1


\bpmn_btype_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Po redakcji pola BMPN.B_TYPE
::       Kontekst wywołania: ustawiony rekord tabeli B_PREL
::----------------------------------------------------------------------------------------------------------------------
{? B_PREL.CLASS='B_EVENT' & BPMN.B_TYPE().SYMBOL='BLOB'
|| FUN.info('Parametr wyjściowy zdarzenia warunkowego nie może być typu %1.'@['BLOB']);
   BPMN.B_TYPE:=null();
   0
|| 1
?}


\btn_user_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przycisk poprawiania właściwości czynności użytkownika
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA><CZYNNOŚĆ><REDAKCJA><WŁAŚCIWOŚCI>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_can_continue:=1;

B_PROC.cntx_psh();
B_PREL.cntx_psh();
IVAL_DEF.cntx_psh();
{? _env.B_PREL<>null()
||
   {? B_PREL.seek(_env.B_PREL)
   ||
      {? B_PREL.IVAL_DEF<>null()
      || B_PREL.IVAL_DEF()
      || IVAL_DEF.blank()
      ?};
      _win:='';
      {? B_PREL.B_PROC().ACCEPTED='T'
      || _win:='RED_USR2';
         _win:=exec('win_edit','#b_action',_env,_win,1)
      || _is_edi:=exec('is_edi','#b_prel',B_PREL.ref());
         _win:={? _is_edi || 'RED_EDI' || 'RED_USR' ?};
         _win:=exec('win_edit','#b_action',_env,_win,1)
      ?};
      B_PREL.win_edit(_win);
      {? B_PREL.AUTOMAT='N'
      || B_PREL.efld_opt(_win,'enable=0',,'AUTOMAT')
      || B_PREL.efld_opt(_win,'enable=1',,'AUTOMAT')
      ?};
      _valid:="
         _result:='';
         {? exec('valid_formula','#field',B_PREL.FMACCESS)=0
         || _result:='FMACCESS'
         ?};
         {? _result='' & B_PREL.ISTDEF
::       Kontrola pól związanych z EDI
         || {? B_PREL.ISTDEF().IST_ISTK='E'
               & B_PREL.ISTDEF_T<>'R'
               & B_PREL.ISTDEF_T<>'W'
            || FUN.info('W typie komunikatu EDI należy wybrać Odczyt lub Zapis.'@);
               _result:='ISTDEF_T'
            ?}
         ?};
         {? _result=''
         ||
::          Sprawdzam czy nalezy sprawdzic bufor planowanego czasu pracy
            _plan_diff:=exec('buffer_compare','#interval');
            {? _plan_diff=0
            || _result:=exec('validate','#interval')
            ?}
         ?};
         _result
      ";

      _istdef:=B_PREL.ISTDEF;
      _istdef_t:=B_PREL.ISTDEF_T;

      _visible:=B_PREL.VISIBLE;
      _personal:=B_PREL.PERSONAL;

      {? B_PREL.CLASS='B_ACTION'
      ||
         {? exec('FindInSet','#table','B_ACTION','B_ELE',B_PREL.B_ELE,,"B_ACTION.RELEASE",'?')<>''
         ||
            B_PREL.efld_opt(_win,'editable=0',,'RELEASE')
         ||
            B_PREL.efld_opt(_win,'editable=1',,'RELEASE')
         ?}
      ?};

      {? B_PREL.edit(_valid)
      || _buffer:=exec('buffer','#b_prel');
         _buffer.get();
         exec('automat_setter','#b_bpmn',_buffer,B_PREL.AUTOMAT,0);
         _can_continue:=exec('put','#b_prel',_buffer);
         {? _can_continue>0
         ||
::          Aktualizacja planowanego interwału pracy
            _can_continue:=exec('interval_update','#b_design','B_PREL');
::          Dodanie portów czynności EDI
            {? B_PREL.ISTDEF<>_istdef | B_PREL.ISTDEF_T<>_istdef_t
            || exec('addBport4actEdi','#b_port',B_PREL.ref(),_env)
            ?};
::          Aktualizacja listy zadań
            exec('personalizuj_wg_bprel','#bi_todo',_visible<>B_PREL.VISIBLE,_personal<>B_PREL.PERSONAL)
         ?}
      ?}
   ?}
?};
B_PREL.cntx_pop();
B_PROC.cntx_pop();
B_PREL.get();
IVAL_DEF.cntx_pop();
IVAL_DEF.get();
grp_edisp(B_PREL,_env.WIN_ACT,1);
''


\btn_service_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przycisk poprawiania właściwości czynności usługowej
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA><CZYNNOŚĆ><REDAKCJA><WŁAŚCIWOŚCI>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;

_is_edi:=0;

B_PREL.cntx_psh();
{? _env.B_PREL<>null()
||
   {? B_PREL.seek(_env.B_PREL)
   ||
      _istdef:=B_PREL.ISTDEF;
      _istdef_t:=B_PREL.ISTDEF_T;
      _is_edi:=exec('is_edi','#b_prel',B_PREL.ref());
      _win:={? _is_edi || 'RED_EDIS' || 'RED_SRV' ?};
      B_PREL.win_edit(_win);
      _valid:="__CHK.record(B_PREL,,'B_WORKER')";
      {? B_PREL.edit(_valid)
      ||
         {? B_PREL.put()
         ||
::          Dodanie portów czynności EDI
            {? B_PREL.ISTDEF<>_istdef | B_PREL.ISTDEF_T<>_istdef_t
            || exec('addBport4actEdi','#b_port',B_PREL.ref(),_env)
            ?}
         ?}


      ?}
   ?}
?};
B_PREL.cntx_pop();
B_PREL.get();
_win:={? _is_edi || 'ACT_EDIS' || 'ACT_SRV' ?};
grp_edisp(B_PREL,_win);
''


\btn_uniservice_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przycisk poprawiania właściwości czynności usługowej - uniwersalnej
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA><CZYNNOŚĆ><REDAKCJA><WŁAŚCIWOŚCI>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;

B_PREL.cntx_psh();
{? _env.B_PREL<>null()
|| {? B_PREL.seek(_env.B_PREL)
   || B_PREL.win_edit('RED_SRW');
      _valid:="
         _result:='';
         _result:=__CHK.record(B_PREL,,'B_WORKER');
         {? _result='' & exec('valid_formula','#field',B_PREL.FMANOUT)=0
         || _result:='FMANOUT'
         ?};
         {? _result='' & exec('valid_formula','#field',B_PREL.FMANMAIN)=0
         || _result:='FMANMAIN'
         ?};
         {? _result='' & exec('valid_formula','#field',B_PREL.FMANDESC)=0
         || _result:='FMANDESC'
         ?};
         {? _result='' & BPMN.B_TYPE<>null() & 1+B_TYPE.SYMBOL='_'
         || _tab_acr:=1-BPMN.B_TYPE().SYMBOL;
            {? ~exec('has_idadd','#table',($_tab_acr)())
            || FUN.info('Tabela ''%1'' nie zawiera pola typu IDADD.'@[_tab_acr]);
               _result:='B_TYPE'
            ?}
         ?};
         _result
      ";
      {? B_PREL.edit(_valid)
      ||
         {? BPMN.B_TYPE=null()
         || B_PREL.FMANOUT:=''
         ?};
         B_PREL.put();

         B_PORT.index('UNIK');
         B_PORT.prefix(null(),B_PREL.ref(),null(),exec('kind_out','#b_port'),);
         {? BPMN.B_TYPE=null()
         || {? B_PORT.first() || B_PORT.del() ?}
         || {? B_PORT.first()
            || B_PORT.B_TYPE:=BPMN.B_TYPE;
               B_PORT.put()
            || B_PORT.ACTIVE:='T';
               B_PORT.B_ELE:=null();
               B_PORT.B_PREL:=B_PREL.ref();
               B_PORT.B_TYPE:=BPMN.B_TYPE;
               B_PORT.KEYREF:='N';
               B_PORT.KIND:=exec('kind_out','#b_port');
               B_PORT.SYMBOL:='OUT';
               B_PORT.NAME:='Dynamiczny parametr wyjściowy';
               B_PORT.REQUIRED:='N';
               B_PORT.add()
            ?}
         ?}
      ?}
   ?}
?};
B_PREL.cntx_pop();
B_PREL.get();
grp_edisp(B_PREL,'ACT_SRW');
''


\select4proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Pokazuje modeler procesów
::   WE: [_a] - B_PROC.ref() - proces który wyświetlić lub bieżący rekord
::       [_b] - INTEGER - 0/[1] - czy wyświetlić w w trybie edycji czy tylko podgląd
::       [_c] - B_PREL.ref() - element procesu który zaznaczyć
::       [_d] - INTEGER - 0/[1] - czy po zamknięciu modelera robić refresh środowiska
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(B_PROC.ref()) | var_pres('_a')=type_of('')
|| _b_proc:=_a
|| _b_proc:=B_PROC.ref()
?};
_editable:=1;
{? var_pres('_b')=type_of(0)
|| _editable:=_b
?};
_sel_prel:=null();
{? var_pres('_c')=type_of(B_PREL.ref())
|| _sel_prel:=_c
?};
_rfr:=1;
{? var_pres('_d')=type_of(0)
|| _rfr:=_d
?};
B_PROC.cntx_psh();
B_PROC.clear();
{? B_PROC.seek(_b_proc)
||
:: Usuwam środowisko menedżera procesów
   VAR_DEL.delete('__proenv');
::   {? _editable>0
::  ||
:: importuje to co potrzebne i wykonuje walidacje czynności
::      exec('import_needed','#b_design')
::   ?};
   {? exec('interm','#system')
   || exec('select_proc_interm','#b_design',B_PROC.ref())
   ||
      {? var_pres('MOD_ENV')>100 || MOD_ENV.clear() ?};
      VAR_DEL.delete('D_ENV');
      _modeler:=exec('env','#b_design');
      D_ENV:=_modeler;
      params_set('env',_modeler);
      _modeler.sel4proc(B_PROC.ref(),_editable,_sel_prel);
      VAR_DEL.delete('D_ENV');
      {? var_pres('MOD_ENV')>100 & _rfr>0
      || MOD_ENV.refreash()
      ?}
   ?}
?};
B_PROC.cntx_pop();
B_PROC.get();
~~


\select_mega_bproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Pokazuje modeler procesów z wczytanymi wszystkimi procesami powiązanymi
::   WE: [_a] - B_PROC.ref() - proces który wyświetlić lub bieżący rekord
::       [_b] - INTEGER - [0]/1 - czy analizować sygnały w procesach rekurencyjnie
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(B_PROC.ref())
|| _b_proc:=_a
|| _b_proc:=B_PROC.ref()
?};
_rec:=0;
{? var_pres('_b')=type_of(0)
|| _rec:=_b
?};

B_PROC.cntx_psh();
B_PROC.clear();
{? B_PROC.seek(_b_proc)
||
:: Usuwam środowisko menedżera procesów
   VAR_DEL.delete('__proenv');
   _modeler:=exec('env','#b_design');
   _modeler.MEGA_PROC:=1;
   _modeler.MEGA_RECURSIVE:=_rec;
   _modeler.AFTER_LOAD_FML:="params_set(params_get());exec(\'load_mega_bproc\',\'#b_bpmn\')";
   _modeler.ctr_id:='b_design_mega';
   _modeler.ctr_bpmn:='12dlm9ae3chj36kb9i5g92h2grhx8';
   params_set('env',_modeler);
   _modeler.sel4mega_bproc(_b_proc);
   ~~
?};
B_PROC.cntx_pop();
B_PROC.get();
~~


\select_mega_biproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Pokazuje modeler procesów dla instancji - wczytuje mega proces z powiązanymi procesami
::   WE: [_a] - BI_PROC.ref() - instancja proces którą wyświetlić lub bieżący rekord
::       [_b] - B_PREL.ref() - element który zaznaczyć
::       [_c] - INTEGER - [0]/1 - czy analizować sygnały w procesach rekurencyjnie
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _bi_proc:=_a
|| _bi_proc:=BI_PROC.ref()
?};
_sel_prel:=null();
{? var_pres('_b')=type_of(B_PREL.ref())
|| _sel_prel:=_b
?};
_rec:=0;
{? var_pres('_c')=type_of(0)
|| _rec:=_c
?};

{? _rec>0
|| _ctr_id:='bi_proc_mega2'
|| _ctr_id:='bi_proc_mega'
?};

BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID');
BI_PROC.clear();
{? BI_PROC.seek(_bi_proc)
||
:: Usuwam środowisko menedżera procesów
   VAR_DEL.delete('__proenv');

   {? var_pres('MOD_ENV')>100 || MOD_ENV.clear() ?};
   VAR_DEL.delete('D_ENV','__INST_2');
   _modeler:=exec('env','#b_design');
   _modeler.MODE_INST:='MEGA';
   _modeler.MEGA_PROC:=1;
   _modeler.MEGA_RECURSIVE:=_rec;
   _modeler.AFTER_LOAD_FML:="params_set(params_get());exec(\'load_mega_bproc\',\'#b_bpmn\',1)";
   _modeler.ctr_id:=_ctr_id;
   _modeler.ctr_bpmn:='26lcg6ki980el55ci24jmicjdcdch';
   params_set('env',_modeler);
   __INST_2:=_modeler;
   _modeler.sel4mega_biproc(_bi_proc,0,_sel_prel);

   VAR_DEL.delete('D_ENV','__INST_2')
::   {? var_pres('MOD_ENV')>100 || MOD_ENV.refreash() ?}
?};
BI_PROC.cntx_pop();
BI_PROC.get();
~~


\select4biproc_sum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Pokazuje modeler procesów
::   WE: [_a] - B_PROC.ref() - proces który wyświetlić lub bieżący rekord
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(B_PROC.ref())
|| _b_proc:=_a
|| _b_proc:=B_PROC.ref()
?};
_editable:=0;
_can_continue:=1;
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('PROSTAN');
B_PROC.cntx_psh();
B_PROC.clear();
{? B_PROC.seek(_b_proc)
||
:: Sprawdzam czy proces ma jakieś zakończone instancje
   BI_PROC.prefix(B_PROC.ref(),exec('ZAKONCZONY','#bi_stat'));
   {? BI_PROC.size()>0
   ||
::    Usuwam środowisko menedżera procesów
      VAR_DEL.delete('__proenv');
      {? var_pres('MOD_ENV')>100 || MOD_ENV.clear() ?};
      VAR_DEL.delete('D_ENV');
      _modeler:=exec('env','#b_design');
      _modeler.MODE_INST:='GROUP';
      D_ENV:=_modeler;
      D_ENV.ctr_id:='bi_proc_sum';
      D_ENV.ctr_bpmn:='26lcg6ki980el55ci24jmicjdcdch';
      params_set('env',_modeler);
      _modeler.sel4biproc_sum(_b_proc,_editable);
      VAR_DEL.delete('D_ENV');
      {? var_pres('MOD_ENV')>100 || MOD_ENV.refreash() ?}
   || FUN.emsg('Proces: \'%1 (wersja: %2)\' nie ma żadnych zakończonych instancji.'@[B_PROC.SYMBOL,B_PROC.VER])
   ?}
?};
BI_PROC.cntx_pop();
B_PROC.cntx_pop();
B_PROC.get();
~~


\select4biproc_alt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Pokazuje modeler procesów dla instancji - widok alternatywny bazujący na definicji procesu
::   WE: [_a] - BI_PROC.ref() - instancja proces którą wyświetlić lub bieżący rekord
::       [_b] - B_PREL.ref() - element który zaznaczyć
::       [_c] - STRING - identyfikator kontrolki (plik który wczytać)
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _bi_proc:=_a
|| _bi_proc:=BI_PROC.ref()
?};
_sel_prel:=null();
{? var_pres('_b')=type_of(B_PREL.ref())
|| _sel_prel:=_b
?};
_ctr_id:='bi_proc_alt';
{? var_pres('_c')=type_of('')
|| _ctr_id:=_c
?};

BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID');
BI_PROC.clear();
{? BI_PROC.seek(_bi_proc)
||
:: Naprawiator błędnego statusu na instancji, która powinna być zakończona, a nie jest z powodu jakiegoś błędu
   {? BI_PROC.BI_STAT<>__Status.ZAKONCZONY & BI_PROC.BI_STAT<>__Status.AWARYJNIE & exec('canEndBiProc','#b_proman',_bi_proc)
   || exec('setStatus','#bi_proc',_bi_proc,__Status.ZAKONCZONY)
   ?};

   {? exec('interm','#system')
   || exec('select_biproc_interm','#b_design')
   ||
::    Usuwam środowisko menedżera procesów
      VAR_DEL.delete('__proenv');

      {? var_pres('MOD_ENV')>100 || MOD_ENV.clear() ?};
      VAR_DEL.delete('D_ENV','__INST_2');
      _modeler:=exec('env','#b_design');
      _modeler.MODE_INST:='SINGLE';
      D_ENV:=_modeler;
      params_set('env',_modeler);
      D_ENV.ctr_id:=_ctr_id;
      D_ENV.ctr_bpmn:='26lcg6ki980el55ci24jmicjdcdch';
      __INST_2:=D_ENV;
      _modeler.sel4biproc_alt(_bi_proc,0,_sel_prel);

      VAR_DEL.delete('D_ENV','__INST_2')
   ?}
::   {? var_pres('MOD_ENV')>100 || MOD_ENV.refreash() ?}
?};
BI_PROC.cntx_pop();
BI_PROC.get();
~~


\select_proc_web
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PS [17.00]
:: OPIS: Wyświetla proces w formacie SVG na webTermie.
::   WE:  _a  - B_PROC.ref() - proces do wyświetlenia
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;
exec('env_wt_core','#web_srv');

B_PROC.cntx_psh(); SYSBLOB.cntx_psh();
B_PROC.prefix();
{? B_PROC.seek(_a)
||
:: Adres hosta
   _host:=$REF.FIRMA().URL;
   {? _host='' || _host:='http://127.0.0.1:8080' ?};

:: Nazwa aplikacji
   _app:=REF.FIRMA().APP_IDEN;

:: Jezyk aplikacji, domyślnie 0
   _lang:='0';

:: Ref rekordu z blobem
   _blob_ref:=$B_PROC.SVG;

:: Hash md5
   _query_result:=sql('SELECT ID FROM SYSBLOB WHERE SYSBLOB.REFERENCE = \''+_blob_ref+'\'');
   _md5:=_query_result.ID;

   _res:=_host+'/webterm/rws/blobimage/'+_app+'/'+_lang+'/w'+_blob_ref+'/'+_md5+'/proces.svg';
   web_open_link(_res)
?};
B_PROC.cntx_pop(); SYSBLOB.cntx_pop();
~~


\select_proc_interm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Wyświetla proces w formacie SVG na intermie
::   WE: [_a] - B_PROC.ref lub bieżący rekord
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(B_PROC.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

B_PROC.cntx_psh();
{? _ref<>null()
|| B_PROC.prefix();
   {? B_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| VAR_DEL.delete('__fname');
   __fname:='#!Tmp/'+$B_PROC.tm_stamp()+'.svg';
   {? B_PROC.bl_get('SVG',__fname,0)
   ||
      _win:=B_PROC.mk_ctr('Podgląd procesu: %1'[exec('B_PROC','#to_string',1)],'#proc_web_vie',,,,,'html_maximized');
      B_PROC.win_ctr(_win);
      B_PROC.win_cctr(_win,'ctr_id','@webframe');
      _fml:="
         ctr_set('!application',,'openWebBrowser',__fname);
         ~~
      ";
      B_PROC.win_act(_win,0,'Formuła','Pełny ekran',,,_fml,,1);
      B_PROC.control(,,"
         ctr_set(,'ctr_id','navigate','%1'[__fname]);
         ~~
      ");
      ~~
   || FUN.emsg('Błąd zapisu pliku: %1 po stronie serwera.'@[__fname])
   ?};
   VAR_DEL.delete('__fname');
   ~~
?};
B_PROC.cntx_pop();
~~


\select_biproc_interm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Wyświetla instancję procesu w formacie SVG na intermie
::   WE: [_a] - BI_PROC.ref lub bieżący rekord
::       [_b] - B_PREL.ref - element który zaznaczyć
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(BI_PROC.ref())
|| _ref:=_a
?};
_b_prel:=1;
{? var_pres('_b')=type_of(null())
|| _b_prel:=_b
?};

_result:=0;
_can_continue:=1;

B_PROC.cntx_psh();
BI_PROC.cntx_psh();
{? _ref<>null()
|| BI_PROC.prefix();
   {? BI_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| BI_PROC.B_PROC();
   {? B_PROC.MICRO<>'T'
   ||
      VAR_DEL.delete('__fname');
       _pth:='';
      _tmp_dir:=fmk_tmp_dir(0);
      {? type_of(_tmp_dir)<>type_of(~~)
      || _pth:=_tmp_dir.get_path();
         _msg:='Generowanie podglądu'@;
         progress(,_msg+'…',exec('nazwa','#system'),1);
         __fname:=exec('biproc_to_svg','#b_design',_pth,,_b_prel);
         prgs_clr();
         {? __fname<>''
         ||
            _win:=BI_PROC.mk_ctr('Podgląd procesu: %1'[exec('BI_PROC','#to_string',1)],'#bi_proc_web',,,,,'html_maximized');
            BI_PROC.win_ctr(_win);
            BI_PROC.win_cctr(_win,'ctr_id','@webframe');
            _fml:="
               ctr_set('!application',,'openWebBrowser',__fname);
               ~~
            ";
            BI_PROC.win_act(_win,0,'Formuła','Pełny ekran',,,_fml,,1);
            BI_PROC.control(,,"
               ctr_set(,'ctr_id','navigate','%1'[__fname]);
               ~~
            ");
            ~~
         ||
            _choice:=FUN.choice('Błąd generowania pliku z podglądem po stronie serwera.'@,,'Szczegóły...'@);
            {? _choice=1
            || _sep:=exec('sep','#file',2);
               _file1:=_pth+_sep+'panelplus_stderr.log';
               _file2:=_pth+_sep+'panelplus_stdout.log';
               {? fexists(_file1,0)
               || _file_pth:=$SYSLOG.tm_stamp()+'.log';
                  {? fcopy(_file1,_file_pth,0,1,1)
                  || txt_view(_file_pth,1);
                     ferase(_file_pth,1)
                  ?}
               |? fexists(_file2,0)
               || _file_pth:=$SYSLOG.tm_stamp()+'.log';
                  {? fcopy(_file2,_file_pth,0,1,1)
                  || txt_view(_file_pth,1);
                     ferase(_file_pth,1)
                  ?}
               || FUN.emsg('Brak plików ze szczegółami: %1 lub %2'@[_file1,_file2])
               ?}
            ?}
         ?}
      || FUN.emsg('Błąd tworzenia katalogu tymczasowego po stronie serwera.'@)
      ?};
      VAR_DEL.delete('__fname')
   || FUN.info('Podgląd procesu niemożliwy dla zadań powiązanych z mikroprocesami.'@)
   ?};
   ~~
?};
B_PROC.cntx_pop();
BI_PROC.cntx_pop();
~~


\btn_signal_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przycisk poprawiania właściwości zdarzenia sygnałowego
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA><ZDARZENIE><REDAKCJA><WŁAŚCIWOŚCI>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;

B_SIGNAL.win_sel('GRP');

_category_catch:=0;

B_PREL.cntx_psh();
{? _env.B_PREL<>null()
|| {? B_PREL.seek(_env.B_PREL)
   || _category_catch:=(exec('is_event','#b_event',B_PREL.B_ELE,,,exec('category_catch','#b_event'))>0);
      B_PREL.win_edit({? _category_catch || 'RED_SIGC' || 'RED_SIG' ?});
      _valid:="
         _result:='';
         {? B_PREL.B_SIGNAL=null()
         || FUN.emsg('Pole %1 musi być wypełnione.'@['Sygnał'@]);
            _result:='B_SIGNAL'
         ?};
         _result
      ";
      _signal:=B_PREL.B_SIGNAL;
      _automat:=B_PREL.AUTOMAT;
      {? B_PREL.edit(_valid)
      ||
::       Zdarzenie przechwytujące - generowanie portów wyjściowych
         {? _category_catch
         || B_PORT.index('UNIK');
            B_PORT.prefix(null(),B_PREL.ref(),null(),exec('kind_out','#b_port'));
            B_SIGPRT.index('PRELTYP');
            B_SIGPRT.prefix(B_PREL.ref());
            {? B_PORT.size()=0 & B_SIGPRT.size()=0
            || _update:=1
            |? B_PREL.B_SIGNAL=_signal
            || _update:=0
            |? B_PREL.B_SIGNAL=null()
            || _update:=FUN.ask(
                  'Czy na pewno usunąć przypisanie sygnału do zdarzenia?\n'
                  'Zostaną usunięte parametry wyjściowe.'@)
            || _update:=FUN.ask(
                  'Czy na pewno zmienić przypisanie sygnału do zdarzenia?\n'
                  'Zostaną na nowo wygenerowane parametry wyjściowe.'@)
            ?};
            {? _update
            ||
               {? B_PREL.put()
               || B_POCONN.index('PREL_SRC');
                  B_POCONN.prefix(B_PREL.ref());
                  _can_continue:=1;
                  {? _can_continue>0 & B_POCONN.first()
                  || {!
                     |? _can_continue:=exec('delete','#b_poconn',B_POCONN.ref());
                        B_POCONN.first() & _can_continue>0
                     !}
                  ?};
                  {? _can_continue>0 & B_PORT.first()
                  || {!
                     |? _can_continue:=exec('delete','#b_port',B_PORT.ref());
                        B_PORT.first() & _can_continue>0
                     !}
                  ?};
                  B_SIGTYP.index('PARAMETR');
                  B_SIGTYP.prefix(B_PREL.B_SIGNAL);
                  {? B_SIGTYP.first()
                  || {!
                     |? B_PORT.ACTIVE:='T';
                        B_PORT.B_ELE:=null();
                        B_PORT.B_PREL:=B_PREL.ref();
                        B_PORT.B_TYPE:=B_SIGTYP.B_TYPE;
                        B_PORT.FML_VAL:='';
                        B_PORT.KEYREF:='N';
                        B_PORT.KIND:=exec('kind_out','#b_port');
                        B_PORT.NAME:='Parametr '+B_SIGTYP.PARAMETR+' przejęty z sygnału '+B_SIGTYP.B_SIGNAL().SYMBOL;
                        B_PORT.REQUIRED:='N';
                        B_PORT.SYMBOL:=B_SIGTYP.PARAMETR;
                        B_PORT.add();
                        B_SIGTYP.next()
                     !}
                  ?};
::                Zdarzenie przechwytujące pośrednie - dodatkowo generowanie powiązań z portami wejściowymi
                  {? exec('is_event','#b_event',B_PREL.B_ELE,exec('type_intermed','#b_event'))>0
                  || {? B_SIGPRT.first() || {! |? B_SIGPRT.del() !} ?};
                     B_SIGTYP.index('PARAMETR');
                     B_SIGTYP.prefix(B_PREL.B_SIGNAL);
                     {? B_SIGTYP.first()
                     || {!
                        |? B_SIGPRT.B_PREL:=B_PREL.ref();
                           B_SIGPRT.B_SIGTYP:=B_SIGTYP.ref();
                           B_SIGPRT.B_PORT:=null();
                           B_SIGPRT.add();
                           B_SIGTYP.next()
                        !}
                     ?}
                  ?}
               ?}
            |? B_PREL.AUTOMAT<>_automat
            || B_PREL.put()
            ?}

::       Zdarzenie rzucające - generowanie powiązań z portami wejściowymi
         || B_SIGPRT.index('PRELTYP');
            B_SIGPRT.prefix(B_PREL.ref());
            {? B_SIGPRT.size()=0
            || _update:=1
            |? B_PREL.B_SIGNAL=_signal
            || _update:=0
            |? B_PREL.B_SIGNAL=null()
            || _update:=FUN.ask(
                  'Czy na pewno usunąć przypisanie sygnału do zdarzenia?\n'
                  'Zostanie usunięta lista parametrów.'@)
            || _update:=FUN.ask(
                  'Czy na pewno zmienić przypisanie sygnału do zdarzenia?\n'
                  'Zostanie od nowa wygenerowana lista parametrów.'@)
            ?};
            {? _update
            || {? B_PREL.put()
               || {? B_SIGPRT.first() || {! |? B_SIGPRT.del() !} ?};
                  B_SIGTYP.index('PARAMETR');
                  B_SIGTYP.prefix(B_PREL.B_SIGNAL);
                  {? B_SIGTYP.first()
                  || {!
                     |? B_SIGPRT.B_PREL:=B_PREL.ref();
                        B_SIGPRT.B_SIGTYP:=B_SIGTYP.ref();
                        B_SIGPRT.B_PORT:=null();
                        B_SIGPRT.add();
                        B_SIGTYP.next()
                     !}
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?}
?};
B_PREL.cntx_pop();
B_PREL.get();
grp_edisp(B_PREL,{? _category_catch || 'EVE_SIGC' || 'EVE_SIG' ?},1);
''


\btn_condition_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przycisk poprawiania właściwości zdarzenia warunkowego
::  TAG: <MBUILDER><MODELER><PROCES><AKCJA><ZDARZENIE><REDAKCJA><WŁAŚCIWOŚCI>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

_can_continue:=1;

B_PROC.cntx_psh();
B_PREL.cntx_psh();
{? _env.B_PREL<>null()
|| {? B_PREL.seek(_env.B_PREL)
   ||
      _win:='RED_COND';
      B_PREL.win_edit(_win);
      _valid:="
         _result:=__CHK.record2(B_PREL,'B_WORKER','Kolejka'@,'FCOND','Formuła warunku'@);
         {? _result='' & exec('valid_formula','#field',B_PREL.FCOND)=0
         || _result:='FCOND'
         ?};
         {? _result='' & exec('valid_formula','#field',B_PREL.FMANOUT)=0
         || _result:='FMANOUT'
         ?};
         {? _result='' & BPMN.B_TYPE<>null() & 1+B_TYPE.SYMBOL='_'
         || _tab_acr:=1-BPMN.B_TYPE().SYMBOL;
            {? ~exec('has_idadd','#table',($_tab_acr)())
            || FUN.info('Tabela ''%1'' nie zawiera pola typu %2.'@[_tab_acr,'IDADD']);
               _result:='B_TYPE'
            ?}
         ?};
         _result
      ";
      {? B_PREL.edit(_valid)
      || _buffer:=exec('buffer','#b_prel');
         _buffer.get();
         {? BPMN.B_TYPE=null()
         || _buffer.FMANOUT:=''
         ?};
         _can_continue:=exec('put','#b_prel',_buffer);
         B_PORT.index('UNIK');
         B_PORT.prefix(null(),B_PREL.ref(),null(),exec('kind_out','#b_port'),);
         {? BPMN.B_TYPE=null()
         || {? B_PORT.first() || B_PORT.del() ?}
         || {? B_PORT.first()
            || B_PORT.B_TYPE:=BPMN.B_TYPE;
               B_PORT.put()
            || B_PORT.ACTIVE:='T';
               B_PORT.B_ELE:=null();
               B_PORT.B_PREL:=B_PREL.ref();
               B_PORT.B_TYPE:=BPMN.B_TYPE;
               B_PORT.KEYREF:='N';
               B_PORT.KIND:=exec('kind_out','#b_port');
               B_PORT.SYMBOL:='OUT';
               B_PORT.NAME:='Dynamiczny parametr wyjściowy';
               B_PORT.REQUIRED:='N';
               B_PORT.add()
            ?}
         ?};
         ~~
      ?}
   ?}
?};
B_PROC.cntx_pop();
B_PREL.cntx_pop();
B_PREL.get();
grp_edisp(B_PREL,'EVE_COND',1);
''


\interval_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Uruchamia aktualizację zdefiniowanego planowanego czasu dla czynności/procesu
::   WE: _a - STRING - akronim tabeli zawierającej pole IVAL_DEF
::       [_b] - TABLE.ref() - Ref rekordu dla ktorego aktualizować IVAL_DEF
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab_acr:=_a;
_tab:=($_tab_acr)();

_ref:=null();
{? var_pres('_b')=type_of(_tab.ref())
|| _ref:=_b
?};

_result:=0;
_can_continue:=1;

_tab.cntx_psh();
{? _ref<>null()
|| _tab.clear();
   {? _tab.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? _tab.IVAL_DEF<>null()
   ||
      _ival_old:=_tab.IVAL_DEF;

      {? IVAL_DEF.KIND='B'
      ||
         _tab.IVAL_DEF:=null();
         _can_continue:=_tab.put();
         {? _can_continue>0
         ||
::          Usuwam starą definicję interwału jeżeli się uda
            exec('delete','#interval',_ival_old,0)
         ?}
      ||
::       Uruchamiam poprawianie planowanego czasu pracy
         _ival_new:=exec('ival_upd_act','#interval',0,0);
         {? _ival_new<>null()
         ||
            _tab.IVAL_DEF:=_ival_new;
            _can_continue:=_tab.put();
            {? _can_continue>0
            ||
::             Usuwam starą definicję interwału jeżeli się uda
               exec('delete','#interval',_ival_old,0)
            ?}
         ?}
      ?}
   ||
      {? IVAL_DEF.KIND<>'B'
      ||
::       Nie było jeszcze planowanego czasu pracy, więc zakładam nowy
::       Porównuję bieżący bufor IVAL_DEF z buforem domyślnym (po blank)
         _plan_diff:=exec('buffer_compare','#interval');
         {? _plan_diff=0
         ||
::          Są różnice więc zakładam rekord
            _tab.IVAL_DEF:=exec('ival_add_act','#interval',0);
            _can_continue:=_tab.put()
         ?}
      ?}
   ?}
?};
_tab.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\btn_event_startnone_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Edycja właściwości zdarzenia startowego nieokreślonego
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
B_DOMAIN.cntx_psh();
B_DOMAIN.index('SYMBOL');
B_DOMAIN.prefix();
B_PREL.cntx_psh();
{? B_PREL.B_PROC().ACCEPTED='T'
|| B_PREL.win_edit('EVE_SNON')
|| B_PREL.win_edit('RED_SNON')
?};
{? B_PREL.edit()
|| B_PREL.B_DOMAUT:='N';
   B_PREL.put()
?};
B_PREL.cntx_pop();
B_DOMAIN.cntx_pop();
B_PREL.get();
win_disp();
''


\tab_komm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę tymczasową zawierającą komunikaty dla elementów procesu
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 3
               ,'UID'      ,'STRING[20]'  ,'Identyfikator elementu procesu'
               ,'TYP'      ,'STRING[20]'  ,'Typ elementu procesu: NODE, EDGE'
               ,'MSG'      ,'STRING[255]' ,'Treść komunikatu'
               ,'KOLOR'    ,'STRING[11]'  ,'Kolor komunikatu'
               ,'KIND'     ,'INTEGER'     ,'Rodzaj komunikatu (błąd, ostrzeżenie, info)'
               );
_tab


\komm_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Dodaje komunikat dla elementu w procesie
::   WE:  _a  - STRING - identyfikator elementu
::        _b  - STRING - treść komunikatu
::       [_c] - STRING - typ komunikaty: 'NODE' - klocek
::                                       'EDGE' - połączenie
::       [_d] - INTEGER - rodzaj komunikatu: [0] - błąd
::                                            1  - ostrzeżenie
::                                            2  - informacja
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;

_uid:=_a;
_msg:=_b;

_result:=0;

_typ:='NODE';
{? var_pres('_c')=type_of('')
|| _typ:=_c
?};

_kind:=0;
{? var_pres('_d')=type_of(0)
|| _kind:=_d
?};

_kolor:='0:0:0';

{? _kind=0
|| _kolor:='255:0:0'
|? _kind=1
|| _kolor:='255:204:0'
|? _kind=2
|| _kolor:='0:153:255'
?};

_tab:=_env.TAB_KOMM;
_tab.cntx_psh();
_tab.prefix(_uid,_typ,_msg);
{? _tab.size()=0
|| _tab.blank();
   _tab.UID:=_uid;
   _tab.TYP:=_typ;
   _tab.MSG:=_msg;
   _tab.KOLOR:=_kolor;
   _tab.KIND:=_kind;
   _result:=_tab.add()
?};
_tab.cntx_pop();
_result


\tab_imex_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę tymczasową zawierającą elementy kontrolne dla mechanizmu importu czynności
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 2
               ,'B_PROC'   ,'STRING[16]'  ,'Ref SQL procesu'
               ,'ACT_UID'  ,'STRING[20]'  ,'Kod czynności'
               ,'ACT_VER'  ,'STRING[100]' ,'Wersja czynności'
               ,'ACT_HASH' ,'STRING[255]' ,'Suma kontrolna właściwości czynności'
               );
_tab


\tab_imex_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę tymczasową zawierającą wszystkie linie czytanego podczas importu pliku .proc
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 2
               ,'UID'  ,'STRING[100]' ,'Identyfikator linii'
               ,'UID2' ,'STRING[100]' ,'Identyfikator linii2'
               ,'LINE' ,'SYS_MEMO'    ,'Linia pliku'
               ,'TM_STAMP','REAL'     ,'Czas utworzenia rekordu'
               );
_tab


\tab_imex_sig
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę tymczasową zawierającą elementy kontrolne dla mechanizmu importu sygnałów
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 1
               ,'SYMBOL'  ,'STRING[100]' ,'Symbol sygnału który jest nieprawidłowy'
               );
_tab


\select_biprels_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PS [17.00]
:: OPIS: Wyświetlanie listy ToDo dla elementu przekazanego w parametrze.
::       W zależności od tego, co znajduje się w polu SEL_PROC w zmiennej env, formuła wyświetla:
::         - B_PROC.ref() - instancje elementu ze wszystkich instancji przekazanego procesu,
::         - BI_PROC.ref() - instancje elementu z przekazanej instancji procesu.
::   WE: _a  - STRING - $B_PREL.ref element procesu
::      [_b] - STRING - $BI_PREL.ref() - instancja elementu procesu
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
_b_prel_ref:=_a;
_bi_prel_ref:='';
{? var_pres('_b')=type_of('')
|| _bi_prel_ref:=_b
?};
:: Obiekt, w którym przechowywana jest tabela tymczasowa i jej okno wertowania.
_obj:=obj_new('TAB','WER');

BI_TODO.cntx_psh(); {? BI_TODO.name()='' || BI_TODO.use('bi_t____') ?};
BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?}; BI_PREL.index('UID'); BI_PREL.prefix();
B_PREL.cntx_psh();
B_PREL.prefix();
{? B_PREL.seek(_b_prel_ref)
||
:: Jeżeli przesłany został B_PROC, to znaczy, że należy wyświetlić wszystkie instancje
:: danego elementu procesu.
   {? ref_tab(_env.SEL_PROC)=B_PROC
   || exec('b_prel_tab','#bi_inst',_obj,B_PREL.ref(),exec('ZAKONCZONY','#bi_stat'));
      exec('b_prel_wer','#bi_inst',_obj);
      _obj.TAB.win_sel(_obj.WER);
      _obj.TAB.select()
   ?};

:: Jeżeli przesłany został BI_PROC, to znaczy, że należy wyświetlić pojedyncza instancję
:: danego elementu procesu.
   {? ref_tab(_env.SEL_PROC)=BI_PROC
   || _bi_prel:=null;
      _bi_proc:=_env.SEL_PROC;
      {? _bi_prel_ref<>''
      || BI_PREL.cntx_psh(); BI_PREL.prefix();
         {? BI_PREL.seek(_bi_prel_ref)
         || _bi_prel:=BI_PREL.ref();
            _bi_proc:=BI_PREL.BI_PROC
         ?};
         BI_PREL.cntx_pop()
      || BI_PREL.index('PREL');
         BI_PREL.prefix(_env.SEL_PROC,B_PREL.ref());
         {? BI_PREL.first()
         || _bi_prel:=BI_PREL.ref()
         ?}
      ?};
      {? _bi_prel<>null()
      || exec('select1','#bi_inst',_bi_proc,_bi_prel)
      || FUN.emsg('Nie znaleziono instancji elementu procesu'@)
      ?}
   ?}
?};
BI_TODO.cntx_pop(); BI_PREL.cntx_pop(); B_PREL.cntx_pop();
~~


\biproc_to_svg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Eksportuje instancję procesu do pliku SVG który można wyświetlić np w przeglądarce
::   WE: _a - STRING - ścieżka do katalogu na serwerze
::       [_b] - BI_PROC.ref lub bieżący rekord
::       [_c] - B_PREL.ref() - element który zaznaczyć

::   WY: STRING - ścieżka do pliku svg na serwerze
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_pth:=_a;

_ref:=null();
{? var_pres('_b')=type_of(BI_PROC.ref())
|| _ref:=_b
?};
_sel_prel:=null;
{? var_pres('_c')=type_of(B_PREL.ref())
|| _sel_prel:=_c
?};

_result:='';
_can_continue:=1;

BI_PROC.cntx_psh();
{? _ref<>null()
|| BI_PROC.prefix();
   {? BI_PROC.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};


{? _can_continue>0
|| BI_PROC.B_PROC();

   {? _pth<>''
   || _name:=B_PROC.bl_info('GRAPHMLZ','NAME');
      _file:='';
      _sep:=exec('sep','#file',2);
      _file:=_pth+_sep+_name;
      _file_copy:=_pth+_sep+'kopia_'+_name;
      _file_svg:='';
      _file_svg_copy:='';
      {? _file*'.graphmlz'>0
      || _file_svg:=gsub(_file,'.graphmlz','.svg')
      |? _file*'.graphml'>0
      || _file_svg:=gsub(_file,'.graphml','.svg')
      ?};
      {? _file_copy*'.graphmlz'>0
      || _file_svg_copy:=gsub(_file_copy,'.graphmlz','.svg')
      |? _file_copy*'.graphml'>0
      || _file_svg_copy:=gsub(_file_copy,'.graphml','.svg')
      ?};
      {? B_PROC.bl_get('GRAPHMLZ',_file,0)
      ||
::       Mam plik graphml na dysku, teraz tworzę XML z danymi o instancji
         _env:=exec('env','#b_design');
         _env.SEL_PROC:=BI_PROC.ref();
         _env.MODE_INST:='SINGLE';
         _env.SEL_PREL:=_sel_prel;
         params_set('env',_env);
         _tab:=exec('instance_info','#b_bpmn');

         _args:=exec('args_xml','#xml');
         _args.TABLE:=_tab;
         _fields:=exec('mbTabFields_tab','#table',_args.TABLE);
         _args.PROLOG:=1;
         _args.JAVA_OBJ:='InstanceInfo';
         _args.JAVA_PATH:='org.mcl.czest.xdesk.core.desktopContent.BPMN.modeler.xdb';

         _tab.prefix();
         {? _tab.first()
         || _filepath_xml:=_pth+_sep+$B_PROC.tm_stamp()+'.xml';
            _file_xml:=fopen(_filepath_xml,'Uw',0);
            {? _file_xml>0
            ||
               _prolog:=exec('prolog','#xml','java.util.Vector',2);
               fwrite(_file_xml,_prolog);
               {!
               |?
                  _xml:=exec('record2XML','#xml',_args,_fields);
                  {? _xml<>''
                  || _wyn:='<void method=\"add\">\n';
                     _wyn+=_xml;
                     _wyn+='</void>\n';
                      fwrite(_file_xml,_wyn)
                  ?};
                  _tab.next()
               !};
               _epilog:=exec('epilog','#xml',2);
               fwrite(_file_xml,_epilog);
               fclose(_file_xml);
               _cfg:=exec('get_cfg','#xml','panelplus','',0,0);
               _cfg.TMP_DIR:=_pth;
               _cfg.add_file('panelplus.jar');
               _cfg.add_file('y.jar');
               _cfg.add_file('ybpmn.jar');
               _cfg.add_file('ysvg.jar');
               _cfg.add_file('batik.jar');
               _sep:=exec('sep','#file',1);
               _jterm_src:=exe_dir(1)+_sep+'jTerm.jar';
               _jterm_dst:=_pth+_sep+'jTerm.jar';
               _can_continue:=fcopy(_jterm_src,_jterm_dst,0,0,1);

               {? _can_continue>0
               || _lib_src:=exe_dir(1)+_sep+'lib'+_sep+'MacroLAF.jar';
                  _lib_dst:=_pth+_sep+'MacroLAF.jar';
                  _can_continue:=fcopy(_lib_src,_lib_dst,0,0,1)
               ?};
               {? _can_continue>0
               ||
                  _res:=_cfg.execute('export_svg',_file,_filepath_xml);
                  {? _res<>0
                  || _can_continue:=0
                  ?}
               ?};
               ~~
            || _can_continue:=0
            ?}
         ?}
      || _can_continue:=0
      ?};
      {? _can_continue>0
      || _pth_tmp:='#!Tmp/'+$BI_PROC.tm_stamp()+'.svg';
         {? fcopy(_file_svg,_pth_tmp,0,0,1)
         || _result:=_pth_tmp
         ?}
      ?}
   ?}
?};
BI_PROC.cntx_pop();
_result


\tab_actrol_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelkę tymczasową zawierającą refy B_PRELi którym zmieniła się rola więc trzeba usunąć istniejące
::       powiązania rola-czynność
::   WE: _a - env - środowisko designera - wynik działania exec('env','#b_design')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 1
               ,'B_PREL','STRING[16]' ,'$B_PREL.ref'
               ,'B_ROLE','STRING[16]' ,'$B_ROLE.ref'
               );
_tab


\after_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wykonuje się po wczytaniu panelu modelera
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
_env.AFTER_LOAD_FML();
~~


\priority_action_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Nie używać - jądro akcji ustawiającej priorytety
::   WE: _a - STRING - akronim tabeli z polem PRIORITY
::       _b - INTEGER - czy robic put czy nie
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab_acr:=_a;
_tab:=($_tab_acr)();
_put:=_b;

_result:=1;
_can_continue:=1;

{? exec('has_field','#table',_tab,'PRIORITY','INTEGER')=0
|| FUN.emsg('W tabeli: %1 brak pola INTEGER o akronimie PRIORITY'@[_tab_acr]);
   _result:=0;
   _can_continue:=0
?};

{? _can_continue>0
|| _res_edit:=exec('edit_radiobutton','#edit',_tab.PRIORITY);
   {? type_of(_res_edit)>0
   || _tab.PRIORITY:=_res_edit;
      {? _put>0
      || _result:=_tab.put()
      ?}
   ?}
?};
_result


\elements_table_modeler
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Zwraca przetłumaczoną tablicę elementów na panelu przycisków w modelerze
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_elements:=exec('elements_table','#desktop');

_elements.blank();
_elements.ID_SYS:='btn_save@przyciski';
_elements.NAME:='&Zapisz'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_akc@przyciski';
_elements.NAME:='&Akceptuj'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_wyc@przyciski';
_elements.NAME:='&Wycofaj'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_verify@przyciski';
_elements.NAME:='Wery&fikuj'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_poconn@przyciski';
_elements.NAME:='&Powiązania argumentów'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_upr@przyciski';
_elements.NAME:='&Uprawnienia'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_mega@przyciski';
_elements.NAME:='Powiązane p&rocesy'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_mega_all@przyciski';
_elements.NAME:='Wsz&ystkie procesy'@;
_elements.add();

_elements


\elements_table_mega
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Zwraca przetłumaczoną tablicę elementów na panelu przycisków w widoku powiązanych procesów
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_elements:=exec('elements_table','#desktop');

_elements


\elements_table_sum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Zwraca przetłumaczoną tablicę elementów na panelu przycisków w raporcie przebiegu procesów
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_elements:=exec('elements_table','#desktop');

_elements


\elements_table_inst_ele
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Zwraca przetłumaczoną tablicę elementów na panelu przycisków w elementach instancji
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_elements:=exec('elements_table','#desktop');
_elements.blank();
_elements.ID_SYS:='Legenda@przyciski';
_elements.NAME:='&Legenda'@;
_elements.add();
_elements


\elements_table_inst
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Zwraca przetłumaczoną tablicę elementów na panelu przycisków w elementach instancji
::       [_a] - BI_PROC.ref - ref instancji procesu
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_bi_proc:=null();
{? var_pres('_a')=type_of(BI_PROC.ref())
|| _bi_proc:=_a
?};
_code:='';
{? _bi_proc<>null()
||
   BI_PROC.cntx_psh(); BI_PROC.prefix();
   {? BI_PROC.seek(_bi_proc)
   || _code:=BI_PROC.CODE
   ?};
   BI_PROC.cntx_pop()
?};

_elements:=exec('elements_table','#desktop');

_elements.blank();
_elements.ID_SYS:='btn_leg@przyciski';
_elements.NAME:='&Legenda'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_copy@przyciski';
_elements.NAME:='&Kopiuj kod inst.: %1'@[_code];
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_mega@przyciski';
_elements.NAME:='Powiązane p&rocesy'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='btn_mega_all@przyciski';
_elements.NAME:='Wsz&ystkie procesy'@;
_elements.add();

_elements

:Sign Version 2.0 jowisz:1045 2023/08/23 10:46:47 509910d87af9c3a321197fe69a999f0250989adbb3f03c4e8f6be085cc11aea09fa0a3e94cb0a683f77c7814492a20e28845337c71c9f4b7ce144b1a70f02608e2e08565c5cf5ecf7ff015623f143d041e43896b2caaad97be4ff89b91a2469ad65d166b626a567d09b14bfb14386ae5fd210f8ac2e045e948c757729dab409d
