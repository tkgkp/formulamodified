:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #bi_choice.fml
:: Utworzony: 29.12.2014 [17.00]
:: Autor: AWI
::======================================================================================================================
:: Zawartość: Formuły do obsługi tabeli B_CHOICE - wybory dla bram
::======================================================================================================================


\buffer
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Tworzy bufor tabeli B_CHOICE
::   WY: obj_new() - tablica nazwana - reprezentacją rekordu B_POCONN
::----------------------------------------------------------------------------------------------------------------------
exec('B_CHOICE','#buffer')


\add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Dodaje do tabeli B_CHOICE jeden rekord
::   WE: _a - obj_new - tablica nazwana bedaca buforem tabeli exec('buffer','#b_choice')
::   WY: B_CHOICE.ref() lub null
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100
         || _a
         || exec('buffer','#b_choice')
         ?};
_result:=null();

B_CHOICE.cntx_psh(); B_CHOICE.clear();
B_CHOICE.blank();
_buffer.set();
{? B_CHOICE.add()>0
|| _result:=B_CHOICE.ref()
?};
B_CHOICE.cntx_pop();
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Kasuje podany rekord tabeli B_CHOICE (wykonywane w transakcji!!!)
::   WE: _a - B_CHOICE.ref()
::   WY: >0 -wyczyszczone,
::      <=0 -niewyczyszczone
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=1;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;

{? _can_continue>0
||
   {? _mydo || do() ?};
   B_CHOICE.cntx_psh(); B_CHOICE.clear();
   {? B_CHOICE.seek(_ref)
   ||
::    Brama
      _b_prel:=B_CHOICE.B_PREL;
::    Element z którego pochodzi parametr do warunku na bramie
      _prel_src:=B_CHOICE.PREL_SRC;

::    Usunięcie warunku
      {? exec('clean','#b_choice',_ref)>0
      || {? B_CHOICE.del(,1)>0
         || _result:=1
         || undo();
            _result:=-3
         ?}
      || _result:=-2
      ?};

      {? _result=1
      ||
::       Renumeracja kolejności parametrów
         exec('renumOrder','#b_choice',_b_prel);
::       Analiza tras portów wyjściowych po usunięciu warunku na bramie
         B_CHOICE.cntx_psh();
         B_CHOICE.index('TO_PREL');
         B_CHOICE.prefix(_b_prel,_prel_src);
         {? ~B_CHOICE.first()
::       Usunięcie tras portów wyjściowych do bramki jeśli brak warunku dla elementu źródłowego
         || B_CONN.cntx_psh();
            B_CONN.index('TO');
            B_CONN.prefix(exec('FindAndGet','#table',B_PREL,_b_prel,,"B_PREL.B_PROC"),_b_prel);
            _loop:=B_CONN.first();
            {!
            |? _loop
            |!
               B_POCONN.cntx_psh();
               B_POCONN.index('UNIK');
               B_POCONN.prefix(B_CONN.ref(),_prel_src,_b_prel);
               _loop:=B_POCONN.first();
               {!
               |? _loop
               |!
                  _port_dst:=B_POCONN.TO;

                  _result:=exec('delete','#b_poconn',B_POCONN.ref());

                  _loop:=_result>0 & B_POCONN.next()
               !};
               B_POCONN.cntx_pop();
               _loop:=B_CONN.next()
            !};
            B_CONN.cntx_pop()
         ?};
         B_CHOICE.cntx_pop()
      ?}
   || _result:=0
   ?};
   B_CHOICE.cntx_pop();
   {? _result<0
   || undo()
   ?};

   {? _mydo || end() ?}
?};
_result


\can_delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza możliwosc usunięcia rekordu B_CHOICE
::   WE: [_a] - B_CHOICE.ref, jeśli nie podany to aktualny rekord
::       [_b] - INTEGER - czy wyswietlać komunikaty:  0  - nie
::                                                   [1] - wyskakujący komunikat
::                                                    2  - w KOMM
::   WY: 0 - nie można usunąć rekordu
::       1 - można usuwać
::----------------------------------------------------------------------------------------------------------------------
_b_choice:=null();

_display:=1;
{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_result:=1;
_can_continue:=1;


B_CHOICE.cntx_psh();
{? var_pres('_a')=type_of(B_CHOICE.ref())
|| _can_continue:=0;
   B_CHOICE.clear();
   {? B_CHOICE.seek(_b_choice)
   || _can_continue:=1
   ?}
?};

{? _can_continue>0
||
:: 1. Automatycznych powiązań nie moźna usuwać
   {? B_CHOICE.AUTO='T'
   || _result:=0;
      {? _display=1
      || _msg:='Automatycznie wygenerowanych warunków bram nie można usuwać.';
         FUN.emsg(_msg)
      |? _display=2
      || B_PREL.cntx_psh();
         _msg:='Nie można usunąć automatycznego warunku prowadzącego do: '+B_CHOICE.PREL_DST().SYMBOL;
         KOMM.add(_msg,'xwin16.png:14');
         B_PREL.cntx_pop()
      ?}
   ?}
?};

B_CHOICE.cntx_pop();
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
:: UTW: WH [17.00]
:: OPIS: Czyści powiązania do rekordu tabeli B_CHOICE
:: WE: _a - B_CHOICE.ref()
:: WY: >0 -wyczyszczone,
:: <=0 -niewyczyszczone
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---

:: --- wszystkie powiązania usunięte? ---
{? _can_continue>0
|| _result:=1
|| undo()
?};

{? _mydo || end()?};

_result


\env
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Środowisko obsługi ustalania warunków dla bram
::   WY: obj_new - tablica nazwana zawierająca wszystko co potrzebne
::----------------------------------------------------------------------------------------------------------------------
::UWAGA: _fld, i _mth to formułki pomocnicze, żeby wygodniej tworzyć tablice i komentować poszczególne jej elementy
::       powiedzmy, że to będzie pole
         _fld:="8+form(_a)";
::       powiedzmy, że to będzie metoda
         _mth:="8+form(_a)";

_env:=obj_new( _fld('GATE' ,'B_PREL.ref - Brama dla ktorej beda tworzone warunki')
               ,_fld('SEL_CHOI','Zaznaczony warunek')
               ,_fld('SEL_PORT','Zaznaczony port')
               ,_fld('SEL_PREV','Zaznaczony elemet procesu przed bramą')
               ,_fld('SEL_NEXT','Zaznaczony elemet procesu za bramą')
               ,_fld('ACCEPTED','Czy okno zostalo poprawnie zaakceptowane')
               ,_fld('EDITABLE','Czy mozliwe jest tworzenie powiazan, czy tylko podglad')
               ,_fld('CTR_TABS','Liczba zakładek z kontrolkami do redakcji właściwości')
               ,_fld('CTR_FINI','Tablica zawierająca statusy załadowania kontrolek [0/1]')

::             identyfikatory okienek
               ,_fld('wid_main' ,'ID okienka glownego')
               ,_fld('wid_choi' ,'ID okienka z warunkami')
               ,_fld('wid_prev' ,'ID okienka elementow procesu przed brama')
               ,_fld('wid_next' ,'ID okienka elementow procesu za brama')
               ,_fld('wid_ctr0' ,'ID okienka kontrolki dla przeplywu domyslnego')
               ,_fld('wid_ctr1' ,'ID okienka kontrolki dla warunku prostego')
               ,_fld('wid_ctr2' ,'ID okienka kontrolki dla typu number')
               ,_fld('wid_ctr3' ,'ID okienka kontrolki dla typu string')
               ,_fld('wid_ctr4' ,'ID okienka kontrolki dla typu złączeniowego')

               ,_fld('cid_dflt','Nazwa kontrolki dla przeplywu domyslnego')
               ,_fld('cid_comm','Nazwa kontrolki dla warunku prostego')
               ,_fld('cid_num' ,'Nazwa kontrolki dla typu number')
               ,_fld('cid_str' ,'Nazwa kontrolki dla typu string')
               ,_fld('cid_join','Nazwa kontrolki dla typu złączeniowego')

::             identyfikatory elementów kontrolek
               ,_fld('c_e_src'  ,'Zakładka: Ogólne, element: Źródło')
               ,_fld('c_e_dst'  ,'Zakładka: Ogólne, element: Cel')

               ,_fld('c_o_src'  ,'Zakładka: Ogólne, element: Źródło')
               ,_fld('c_o_dst'  ,'Zakładka: Ogólne, element: Cel')
               ,_fld('c_o_cond' ,'Zakładka: Ogólne, element: Warunek')
               ,_fld('c_o_form' ,'Zakładka: Ogólne, element: Formuła')
               ,_fld('c_o_name' ,'Zakładka: Ogólne, element: Nazwa warunku')
               ,_fld('c_o_add'  ,'Zakładka: Ogólne, element: Dołącz')
               ,_fld('c_o_edit' ,'Zakładka: Ogólne, element: Popraw')

               ,_fld('c_n_src'  ,'Zakładka: Liczba, element: Źródło')
               ,_fld('c_n_dst'  ,'Zakładka: Liczba, element: Cel')
               ,_fld('c_n_oper' ,'Zakładka: Liczba, element: Operator')
               ,_fld('c_n_val'  ,'Zakładka: Liczba, element: Wartość')
               ,_fld('c_n_add'  ,'Zakładka: Liczba, element: Dołącz')
               ,_fld('c_n_edit' ,'Zakładka: Liczba, element: Popraw')

               ,_fld('c_s_src'  ,'Zakładka: Tekst, element: Źródło')
               ,_fld('c_s_dst'  ,'Zakładka: Tekst, element: Cel')
               ,_fld('c_s_oper' ,'Zakładka: Tekst, element: Operator')
               ,_fld('c_s_val'  ,'Zakładka: Tekst, element: Wartość')
               ,_fld('c_s_add'  ,'Zakładka: Tekst, element: Dołącz')
               ,_fld('c_s_edit' ,'Zakładka: Tekst, element: Popraw')
               ,_fld('c_s_case' ,'Zakładka: Tekst, element: Uwzględniaj wielkość liter')

               ,_fld('c_j_src'  ,'Zakładka: Złączenie, element: Źródło')
               ,_fld('c_j_dst'  ,'Zakładka: Złączenie, element: Cel')
               ,_fld('c_j_oper' ,'Zakładka: Złączenie, element: Operator')
               ,_fld('c_j_add'  ,'Zakładka: Złączenie, element: Dołącz')
               ,_fld('c_j_edit' ,'Zakładka: Złączenie, element: Popraw')

::             tytuły okienek
               ,_fld('tit_main' ,'Tytul okienka glownego')
               ,_fld('tit_choi' ,'Tytul okienka z warunkami')
               ,_fld('tit_prev' ,'Tytul okienka elementow procesu przed brama')
               ,_fld('tit_next' ,'Tytul okienka elementow procesu za brama')
               ,_fld('tit_ctr_' ,'Tytul okienka z kontrolka dla przeplywu domyslnego')
               ,_fld('tit_ctr0' ,'Tytul okienka z kontrolka dla warunku prostego')
               ,_fld('tit_ctr1' ,'Tytul okienka z kontrolka dla typu number')
               ,_fld('tit_ctr2' ,'Tytul okienka z kontrolka dla typu string')
               ,_fld('tit_ctr3' ,'Tytul okienka z kontrolka dla typu złączeniowego')

::             tytuły zakładek
               ,_fld('tab_dflt' ,'Zakładka dla przeplywu domyslnego')
               ,_fld('tab_comm' ,'Zakładka ogólna')
               ,_fld('tab_num'  ,'Zakładka tworzenia warunku dla liczb')
               ,_fld('tab_str'  ,'Zakładka tworzenia warunku dla napisów')
               ,_fld('tab_join' ,'Zakładka tworzenia warunku dla złączeń')

::             tabele tymczasowe
               ,_fld('TAB_PREV' ,'Tabela tymczasowa zawierająca elementy procesu przed brama')
               ,_fld('TAB_NEXT' ,'Tabela tymczasowa zawierająca elementy procesu za brama')
               ,_fld('TAB_OPER' ,'Tabela tymczasowa zawierajaca slownik operatorow')

::             indeksy tymczasowych tabel
               ,_fld('IN_PREV1' ,'Indeks tabeli el. przed brama: PARENT, SYMBOL')
               ,_fld('IN_PREV2' ,'Indeks tabeli el. przed brama: PARENT, REF_PORT')
               ,_fld('IN_PREV3' ,'Indeks tabeli el. przed brama: REF_PREL')
               ,_fld('IN_PREV4' ,'Indeks tabeli el. przed brama: ?')
               ,_fld('IN_NEXT1' ,'Indeks tabeli el. za brama: SYM_PREL,SYM_BELE')
               ,_fld('IN_NEXT2' ,'Indeks tabeli el. za brama: REF_PREL')
               ,_fld('IN_NEXT3' ,'Indeks tabeli el. za brama: REF_CONN')
               ,_fld('IN_NEXT4' ,'Indeks tabeli el. za brama: ORDER')
               ,_fld('IN_OPERO' ,'Indeks slownika operatorow: OPER')
               ,_fld('IN_OPERN' ,'Indeks slownika operatorow: NUMBER,LP')
               ,_fld('IN_OPERS' ,'Indeks slownika operatorow: STRING,LP')
               ,_fld('IN_OPERD' ,'Indeks slownika operatorow: DATE,LP')
               ,_fld('IN_OPERJ' ,'Indeks slownika operatorow: JOIN,LP')

::             uchwyty do okien
               ,_fld('WIN_MAIN' ,'Glowne okno grupowe')
               ,_fld('WIN_CHOI' ,'Okno z polaczeniami')
               ,_fld('WIN_PREV' ,'Okno z portami')
               ,_fld('WIN_NEXT' ,'Okno z elementami za brama')
               ,_fld('WIN_CTR0' ,'Okno z kontrolka dla przeplywu domyslnego')
               ,_fld('WIN_CTR1' ,'Okno z kontrolka dla warunku prostego')
               ,_fld('WIN_CTR2' ,'Okno z kontrolka dla typu number')
               ,_fld('WIN_CTR3' ,'Okno z kontrolka dla typu string')
               ,_fld('WIN_CTR4' ,'Okno z kontrolka dla typu złączeniowego')

::             identyfikatory przycisków
               ,_fld('btn_ok'  ,'Przycisk akceptacji')
               ,_fld('btn_anul','Przycisk anulowania')

::             METODY
               ,_mth('select'   ,'Wyswietla okno kreatora warunkow')
               ,_mth('load4gat' ,'Laduje zawartosc kreatora powiazan, tworzy struktury')
               );
_env.GATE:=null();

_env.SEL_CHOI:=null();
_env.SEL_PREV:=null();
_env.SEL_PREV:=null();
_env.SEL_NEXT:=null();

_env.ACCEPTED:='N';
_env.EDITABLE:=1;
_env.CTR_TABS:=5;

_env.CTR_FINI:=obj_new(_env.CTR_TABS);

{! _it:=1.._env.CTR_TABS
|! _env.CTR_FINI[_it]:=0
!};

_env.wid_main:='#b_choice_main';
_env.wid_choi:='#b_choice_choi';
_env.wid_prev:='#b_choice_prev';
_env.wid_next:='#b_choice_next';
_env.wid_ctr0:='#b_choice_ctr0';
_env.wid_ctr1:='#b_choice_ctr1';
_env.wid_ctr2:='#b_choice_ctr2';
_env.wid_ctr3:='#b_choice_ctr3';
_env.wid_ctr4:='#b_choice_ctr4';

_env.cid_dflt:='bchoice_dflt';
_env.cid_comm:='bchoice_comm';
_env.cid_num:='bchoice_num';
_env.cid_str:='bchoice_str';
_env.cid_join:='bchoice_join';

_env.c_e_src:='1b8fe5h3lglk62nfkgna186mjkj2f';
_env.c_e_dst:='k79ebfc4k563i0e8k5b079k4elfn';

_env.c_o_src:='3b04553e7g4k3a8ek4jlm7dnifa5';
_env.c_o_dst:='117h12cbc37314dn1j4f006lkb2dk';
_env.c_o_cond:='2i20be188c21c1jk1hm8e9ja8ckm3';
_env.c_o_form:='i4blng3l4fdj141em26f74ih05cj';
_env.c_o_name:='1954ln1n8m15hf85adjm96h9fijag';
_env.c_o_add:='a83dj9d68d6b3c039h43c9agk5cc';
_env.c_o_edit:='6fb4emkegibf3hma1l9jfikmd7nn';

_env.c_n_src:='2j64fbba7gdf7m7dm91jnbdm197l';
_env.c_n_dst:='1n53n7fl01ibd29ch2ngane3aei9c';
_env.c_n_oper:='neajm2mk91g6j9j3e0kaihk8mkj0';
_env.c_n_val:='1m0ng629h018f65elmf86cm6bc48c';
_env.c_n_add:='1c4h4hfbnmgkjd6e33ll42lke3d2b';
_env.c_n_edit:='1dh97e57a2n8cmmji62178nd309g';

_env.c_s_src:='15n8bc86fbgmfadmijb0dgkgnhm21';
_env.c_s_dst:='1k2g91ih2l88d64jcmd8hkde41l5f';
_env.c_s_oper:='1f6078018a9c6i0kk4719dn63if47';
_env.c_s_val:='75db77bh0im8mk144df9di210dbf';
_env.c_s_add:='19g8c70e51jjciac1eghe85kigm6l';
_env.c_s_edit:='52djgb1f0klc9b5066en9nch1j6a';
_env.c_s_case:='h0dn240ch37i93imcjh1l5idkj2l';

_env.c_j_src:='15n8bc86fbgmfadmijb0dgkgnhm21';
_env.c_j_dst:='1k2g91ih2l88d64jcmd8hkde41l5f';
_env.c_j_oper:='1f6078018a9c6i0kk4719dn63if47';
_env.c_j_add:='19g8c70e51jjciac1eghe85kigm6l';
_env.c_j_edit:='52djgb1f0klc9b5066en9nch1j6a';

_env.tit_main:='Kreator warunków dla bram';
_env.tit_choi:='Utworzone warunki';
_env.tit_prev:='Elementy procesu przed bramą';
_env.tit_next:='Elementy procesu za bramą';

_env.tab_dflt:='Domyślnie';
_env.tab_comm:='Ogólne';
_env.tab_num:='Liczba';
_env.tab_str:='Tekst';
_env.tab_join:='Złączenie';

_env.btn_ok:='';
_env.btn_anul:='';

_env.WIN_MAIN:='';
_env.WIN_CHOI:='';
_env.WIN_PREV:='';
_env.WIN_NEXT:='';
_env.WIN_CTR0:='';
_env.WIN_CTR1:='';
_env.WIN_CTR2:='';
_env.WIN_CTR3:='';
_env.WIN_CTR4:='';

_env.select:="
::    Tworzymy okna
      .WIN_CHOI:=exec('win_choi','#b_choice',.);
      .WIN_PREV:=exec('win_prev','#b_choice',.);
      .WIN_NEXT:=exec('win_next','#b_choice',.);

::    Tworzymy okno główne
      exec('grp_make','#b_choice',.);

::    Pokazujemy okno
      .TAB_PREV.select();
      exec('endDndOrder','#b_choice',.WIN_CHOI);
      ~~
";
_env.load4gat:="

      _b_prel:=_a;
      .GATE:=_a;
::    Tworzymy tabele tymczasowe
      {? type_of(.TAB_PREV)=0
      || .TAB_PREV:=exec('tab_prev','#b_choice',.)
      ?};
      {? type_of(.TAB_NEXT)=0
      || .TAB_NEXT:=exec('tab_next','#b_choice',.)
      ?};
      {? type_of(.TAB_OPER)=0
      || .TAB_OPER:=exec('tab_oper','#b_choice',.);
         exec('load_oper','#b_choice',.)
      ?};
      KOMM.init(250,,'Wczytywanie elementów do kreatora');

::    Ładujemy elementy przed bramą
      exec('load_prev','#b_choice',.,_b_prel);

::    Ładujemy elementy za bramą
      exec('load_next','#b_choice',.,_b_prel,1);

::    Prefiksujemy tabele B_CHOICE
      exec('load_choice','#b_choice',.,_b_prel);

::    Tworzymy automatyczne warunki
      exec('create_cond4gate','#b_cond',,_b_prel);

      KOMM.select();
      ~~
";
_env


\tab_prev
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelke tymczasową zawierająca elementy przed bramą
::   WE: _a - env - środowisko kreatora - wynik działania exec('env','#b_choice')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 2
               ,'PARENT'   ,'TREE_REF'    ,'Rodzic'
               ,'SYMBOL'   ,'STRING[100]' ,'Symbol elementu/symbol portu'
               ,'NAME'     ,'STRING[100]' ,'Nazwa elementu/nazwa portu'
               ,'TYPE'     ,'STRING[8]'   ,'Typ elementu: B_PREL,B_PORT'
               ,'REF_BELE' ,'STRING[16]'  ,'Ref SQL elementu ogólnego'
               ,'REF_PREL' ,'STRING[16]'  ,'Ref SQL elementu procesu'
               ,'REF_PORT' ,'STRING[16]'  ,'Ref SQL portu'
               ,'REF_TYP'  ,'STRING[16]'  ,'Ref SQL typu zrodlowego'

               ,'SYM_TYP'  ,'STRING[50]'  ,'Symbol typu'
               ,'NAM_TYP'  ,'STRING[50]'  ,'Nazwa typu'

               ,'SYM_PORT' ,'STRING[31]'   ,'Symbol portu'
               ,'NAM_PORT' ,'STRING[250]' ,'Nazwa portu'

               ,'ACTIVE'   ,'STRING[1]'   ,'Czy port aktywny czy nie'
               ,'REQUIRED' ,'STRING[1]'   ,'Czy port wymaga polaczenia'
               );
_env.IN_PREV1:=_tab.ndx_tmp(,,'PARENT',,,'SYMBOL',,);
_env.IN_PREV2:=_tab.ndx_tmp(,,'PARENT',,,'REF_PORT',,);
_env.IN_PREV3:=_tab.ndx_tmp(,,'REF_PREL',,);
_tab


\tab_next
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Tworzy tabelke tymczasowa zawierająca elementy za bramą
::   WE: _a - env - środowisko kreatora - wynik działania exec('env','#b_choice')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 2
               ,'SYM_BELE' ,'STRING[100]' ,'Symbol elementu (ogólny)'
               ,'SYM_PREL' ,'STRING[100]' ,'Symbol elementu (proces)'
               ,'CLASS'    ,'STRING[8]'   ,'Klasa elementu za brama'
               ,'REF_BELE' ,'STRING[16]'  ,'Ref SQL elementu ogólnego'
               ,'REF_PREL' ,'STRING[16]'  ,'Ref SQL elementu procesu'
               ,'REF_CONN' ,'STRING[16]'  ,'Ref SQL polaczenia wychodzacego z bramy'
               ,'CHOI_NUM' ,'INTEGER'     ,'Liczba utworzonych warunków'
               ,'DEFAULT'  ,'STRING[1]'   ,'Wyjście domyślne'
               ,'ORDER'    ,'INTEGER'     ,'Kolejność'
               );
_env.IN_NEXT1:=_tab.ndx_tmp(,,'SYM_BELE',,,'SYM_PREL',,);
_env.IN_NEXT2:=_tab.ndx_tmp(,,'REF_PREL',,);
_env.IN_NEXT3:=_tab.ndx_tmp(,,'REF_CONN',,);
_env.IN_NEXT4:=_tab.ndx_tmp(,,'ORDER',,,'SYM_BELE',,,'SYM_PREL',,);
_tab


\tab_next_rek
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Rekord przed w tabeli .TAB_NEXT
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_result:='';

_tab:=cur_tab(1,1);
{? _tab.CHOI_NUM>0
|| _result:=Color.fnd_kol('B_CHOICE#01#01')
?};
_result


\tab_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Tworzy tabelke tymczasową zawierajacą "słownik" operatorów
::   WE: _a - env - środowisko kreatora - wynik działania exec('env','#b_choice')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 1
               ,'OPERATOR','STRING[30]','Operator'
               ,'NAME','STRING[255]','Nazwa'
               ,'LP','INTEGER','Liczba porządkowa'
               ,'NUMBER','STRING[1]','Czy operator dotyczy liczb'
               ,'STRING','STRING[1]','Czy operator dotyczy tekstów'
               ,'DATE','STRING[1]','Czy operator dotyczy dat'
               ,'JOIN','STRING[1]','Czy operator dotyczy złączeń'
               ,'FORMULA','STRING[250]','Formuła'
               );
_env.IN_OPERO:=_tab.index('?');
_env.IN_OPERN:=_tab.ndx_tmp(,,'NUMBER',,,'LP',,);
_env.IN_OPERS:=_tab.ndx_tmp(,,'STRING',,,'LP',,);
_env.IN_OPERD:=_tab.ndx_tmp(,,'DATE',,,'LP',,);
_env.IN_OPERJ:=_tab.ndx_tmp(,,'JOIN',,,'LP',,);
_tab


\load_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ładuje zawartość tabeli .TAB_OPER - "słownik" operatorów
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_OPER;

_tab.blank();

_tab.LP:=1;
_tab.OPERATOR:=exec('oper_eq_num','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_eq_num','#b_choice').NAME;
_tab.FORMULA:=exec('oper_eq_num','#b_choice').FORMULA;
_tab.NUMBER:='T';
_tab.STRING:='N';
_tab.DATE:='T';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_neq','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_neq','#b_choice').NAME;
_tab.FORMULA:=exec('oper_neq','#b_choice').FORMULA;
_tab.NUMBER:='T';
_tab.STRING:='N';
_tab.DATE:='T';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_gt','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_gt','#b_choice').NAME;
_tab.FORMULA:=exec('oper_gt','#b_choice').FORMULA;
_tab.NUMBER:='T';
_tab.STRING:='N';
_tab.DATE:='T';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_gte','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_gte','#b_choice').NAME;
_tab.FORMULA:=exec('oper_gte','#b_choice').FORMULA;
_tab.NUMBER:='T';
_tab.STRING:='N';
_tab.DATE:='T';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_lt','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_lt','#b_choice').NAME;
_tab.FORMULA:=exec('oper_lt','#b_choice').FORMULA;
_tab.NUMBER:='T';
_tab.STRING:='N';
_tab.DATE:='T';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_lte','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_lte','#b_choice').NAME;
_tab.FORMULA:=exec('oper_lte','#b_choice').FORMULA;
_tab.NUMBER:='T';
_tab.STRING:='N';
_tab.DATE:='T';
_tab.JOIN:='N';
_tab.add();

:: String
_tab.LP+=1;
_tab.OPERATOR:=exec('oper_neq_str','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_neq_str','#b_choice').NAME;
_tab.FORMULA:=exec('oper_neq_str','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_eq_str','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_eq_str','#b_choice').NAME;
_tab.FORMULA:=exec('oper_eq_str','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_contains','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_contains','#b_choice').NAME;
_tab.FORMULA:=exec('oper_contains','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_ncontains','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_ncontains','#b_choice').NAME;
_tab.FORMULA:=exec('oper_ncontains','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_begins','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_begins','#b_choice').NAME;
_tab.FORMULA:=exec('oper_begins','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_nbegins','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_nbegins','#b_choice').NAME;
_tab.FORMULA:=exec('oper_nbegins','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_ends','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_ends','#b_choice').NAME;
_tab.FORMULA:=exec('oper_ends','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_nends','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_nends','#b_choice').NAME;
_tab.FORMULA:=exec('oper_nends','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_empty','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_empty','#b_choice').NAME;
_tab.FORMULA:=exec('oper_empty','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_noempty','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_noempty','#b_choice').NAME;
_tab.FORMULA:=exec('oper_noempty','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='T';
_tab.DATE:='N';
_tab.JOIN:='N';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_isnull','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_isnull','#b_choice').NAME;
_tab.FORMULA:=exec('oper_isnull','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='N';
_tab.DATE:='N';
_tab.JOIN:='T';
_tab.add();

_tab.LP+=1;
_tab.OPERATOR:=exec('oper_isnotnull','#b_choice').OPERATOR;
_tab.NAME:=exec('oper_isnotnull','#b_choice').NAME;
_tab.FORMULA:=exec('oper_isnotnull','#b_choice').FORMULA;
_tab.NUMBER:='N';
_tab.STRING:='N';
_tab.DATE:='N';
_tab.JOIN:='T';
_tab.add();
~~


\win_choi
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Tworzy okno tymczasowe zawierające utworzone warunki
::   WE: _a - env - środowisko kreatora - wynik działania exec('env','#b_choice')
::   WY: STRING - uchwyt do okna
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=B_CHOICE;

_wer:=_tab.mk_sel(_env.tit_choi,'P',0,_env.wid_choi,1,1);
_tab.win_fld(_wer,,'PREL_SRC'   ,'SYMBOL',,15,,,'Źródło'@,0);
_tab.win_fld(_wer,,'PREL_DST'   ,'SYMBOL',,15,,,'Cel'@,0);
_tab.win_fld(_wer,,'NAME'       ,,,20,,,'Nazwa warunku'@,0);
_tab.win_fld(_wer,,'FORMULA'    ,,,20,,,'Formuła'@,0);
_tab.win_fld(_wer,,'B_PORT'     ,'SYMBOL',,20,,,'Parametr [symbol]'@,0);
_tab.win_fld(_wer,,'B_PORT'     ,'NAME',,20,,,'Parametr [nazwa]'@,0);
_tab.win_fld(_wer,,'OPERATOR'   ,,,30,,,'Operator'@,0);
_tab.win_fld(_wer,,'VALUE'      ,,,20,,,'Wartość'@,0);
_tab.win_fld(_wer,,'AUTO'       ,,,5,,,'Auto'@,0,,2,,"\'T\'","\'N\'","\'G\'");

_formula:="
   _result:='';
   _tab:=cur_tab(1,1);

   _b_ele:=B_CHOICE.PREL_DST().B_ELE;

   _result:=exec('icon','#b_ele',_b_ele);
   _result
";
_tab.win_fml(_wer,,'PREL_DST','SYMBOL','ICON_BEFORE',_formula);

{? _env.EDITABLE>0
||
   _formula:="exec('edit_act','#b_choice',CHOICE_CR)";
   _tab.win_act(_wer,0,'Formuła','Popraw'@@,,,_formula,,,,,,'P');

   _formula:="exec('del_act','#b_choice',CHOICE_CR)";
   _gr1:="exec('del_act_gr1','#b_choice',CHOICE_CR)";
   _gr2:="exec('del_act_gr2','#b_choice',CHOICE_CR)";
   _tab.win_act(_wer,0,'Formuła','Usuń'@@,,,_formula,,,1,_gr1,_gr2,'U');
   _tab.dnd_sel(_wer,,'records.B_CHOICE',"exec('goDndOrder','#b_choice')")
?};

_tab.win_act(_wer,,'Kolejność');

_formula:="exec('disp_act','#b_choice',CHOICE_CR)";
_tab.win_act(_wer,,'Wyświetl',,,,_formula);

_tab.win_sel(_wer);
_wer


\after_rfr_prev
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Po odświeżeniu okna z elementami przed brama
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_PREV;
_next:=_env.TAB_NEXT;

{? _env.EDITABLE>0
||
   {? _tab.TYPE='B_PREL'
   ||
      {? _next.DEFAULT='T'
      ||
::       Przepływ domyślny
         exec('tab_show','#b_choice',_env,1)
      ||
::       Pokazuje ogólną zakładkę
         exec('tab_show','#b_choice',_env,2)
      ?};

::    Ustawiam sygnalizatory na czym stoje
      _str:='Element\n'+_tab.SYMBOL;
      exec('set_value','#desktop','',_env.cid_dflt,_env.c_e_src,_str);
      exec('set_value','#desktop','',_env.cid_comm,_env.c_o_src,_str);
      {? _env.SEL_PREV<>_tab.ref()
      ||
         exec('set_enabled','#desktop','',_env.cid_comm,_env.c_o_cond,exec('cond_sel','#b_choice').size()>1);

::       Odświeżam checkboxa
         exec('refresh_cond_checkbox','#b_choice',_env);
         ~~
      ?};
      _env.SEL_PREV:=_tab.ref();
      ~~
   |? _tab.TYPE='B_PORT'
   ||
      {? _next.DEFAULT='T'
      ||
::       Przepływ domyślny
         exec('tab_show','#b_choice',_env,1)
      ||
::       Pokazuje zakładki odpowiednich typów
         {? _tab.SYM_TYP='NUMBER'
         || exec('tab_show','#b_choice',_env,3)
         |? _tab.SYM_TYP='STRING' | _tab.SYM_TYP='MEMO'
         || exec('tab_show','#b_choice',_env,4)
         |? 1+_tab.SYM_TYP='_'
         || exec('tab_show','#b_choice',_env,5)
         ||
::          Gasze wszystkie zakładki jeżeli typ nie jest obsługiwany
            exec('tab_show','#b_choice',_env,-10)
         ?}
      ?};

::    Ustawiam sygnalizatory na czym stoje
      _str:='Parametr\n'+_tab.SYM_PORT;
      exec('set_value','#desktop','',_env.cid_num,_env.c_n_src,_str);
      exec('set_value','#desktop','',_env.cid_str,_env.c_s_src,_str);
      exec('set_value','#desktop','',_env.cid_join,_env.c_j_src,_str);
      ~~
   ||
::    Gasze wszystkie zakładki jeśli stanąłem na niewiadomo czym, albo brak rekordów
      exec('tab_show','#b_choice',_env,-10)
   ?}
||
:: Gasze wszystkie zakładki jeśli dostępny tylko podgląd
   exec('tab_show','#b_choice',_env,-10)
?};
~~


\after_rfr_next
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Po odświeżeniu okna z portami docelowymi
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_NEXT;

:: Odświeżam okno poprzedników, żeby wywołać exec('after_rfr_prev','#b_choice')
::grp_disp(_env.TAB_PREV,_env.WIN_PREV,1);

:: Ustawiam sygnalizatory na czym stoje
_str:='Element\n'+_tab.SYM_BELE;
exec('set_value','#desktop','',_env.cid_dflt,_env.c_e_dst,_str);
exec('set_value','#desktop','',_env.cid_comm,_env.c_o_dst,_str);
exec('set_value','#desktop','',_env.cid_num,_env.c_n_dst,_str);
exec('set_value','#desktop','',_env.cid_str,_env.c_s_dst,_str);
exec('set_value','#desktop','',_env.cid_join,_env.c_j_dst,_str);
{? _env.SEL_NEXT<>_tab.ref()
||
   exec('set_enabled','#desktop','',_env.cid_comm,_env.c_o_cond,exec('cond_sel','#b_choice').size()>1);
   exec('refresh_cond_checkbox','#b_choice',_env);
   ~~
?};
_env.SEL_NEXT:=_tab.ref();
~~


\refresh_cond_checkbox
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Odświeża checkboxa z predefiniowanymi warunkami
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::   WY:
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_data_id:=$SYSLOG.tm_stamp();
exec('fetch_data','#desktop',_data_id,_env.cid_comm,exec('cond_sel','#b_choice'),'REF,NAME','');
exec('grab_data','#desktop','',_env.cid_comm,_env.c_o_cond,_data_id);
exec('set_value','#desktop','',_env.cid_comm,_env.c_o_cond,'');
~~


\load_prev
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Ładuje zawartość tabeli .TAB_PREV na podstawie aktualnego rekordu tabeli B_PREL który jest bramą
::       Uruchamia rownież dodawanie wszystkich portów wyjściowych
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - B_PREL.ref() - wyjściowy element procesu
::       _c - B_PREL.ref() - aktualnie przetwarzany element procesu
::       _d - B_PREL.ref()-y - odwiedzone elementy procesu
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
           _env:=_a;
   _b_prel_root:=_b;
        _b_prel:={? var_pres('_c')=type_of(null()) || _c || null() ?} ;
_b_prel_visited:={? var_pres('_d')=type_of('')     || _d || ''     ?};

_result:=0;
_first_call:=_b_prel=null();
{? _first_call || _b_prel:=_b_prel_root ?};
_can_continue:=1;
B_PREL.cntx_psh(); B_PREL.clear();
B_PORT.cntx_psh();
B_ELE.cntx_psh();
B_PORT.index('B_ELE');
B_CONN.cntx_psh();

{? B_PREL.seek(_b_prel)
||
:: Podczytanie B_ELE
   B_PREL.B_ELE();

:: Analiza wszystkich elementów poprzedzających
   B_ELE.cntx_psh();
   B_CONN.index('TO');
   B_CONN.prefix(B_PREL.B_PROC,B_PREL.ref());
   {? B_CONN.first()
   || {!
      |?
         {? B_CONN.FROM<>_b_prel_root & (_b_prel_visited*($B_CONN.FROM))=0
::       Poszukujemy wcześniejszych czynności !!! REKRURENCJA !!!
         || exec('load_prev','#b_choice',_env,_b_prel_root,B_CONN.FROM,_b_prel_visited+$_b_prel)
         ?};
         B_CONN.next()
      !}
   ?};
   B_ELE.cntx_pop();

:: Ładowanie portów czynności i zdarzeń przechwytujących
   {? _first_call=0
         &
      (B_ELE.CLASS='B_ACTION'
         |
       B_ELE.CLASS='B_EVENT' & exec('is_event','#b_event',B_ELE.ref(),,,exec('category_catch','#b_event'))>0
      )
   || _can_continue:=exec('prel2prev','#b_choice',_env,1)
   ?}
?};
B_CONN.cntx_pop();
B_ELE.cntx_pop();
B_PORT.cntx_pop();
B_PREL.cntx_pop();


{? _can_continue>0
|| _result:=1
?};
_result


\load_choice
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Prefiksuje tabele B_CHOICE, przetwarzam rekordy po prefiksie
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - B_PREL.ref() - brama której warunki wyświetlać
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_b_prel:=_b;

B_CHOICE.index('B_PREL');
B_CHOICE.prefix(_b_prel);

exec('update_choi_num','#b_choice',_env);
B_CHOICE.first();
~~


\update_choi_num
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Aktualizuje liczby utworzonych warunków w tabeli .TAB_NEXT
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_tab:=_env.TAB_NEXT;

_tab.cntx_psh();
_tab.index(_env.IN_NEXT1);

B_CHOICE.cntx_psh();
B_CHOICE.index('B_CONN');

{? _tab.first()
|| {!
   |? _b_conn:=exec('FindAndGet','#table',B_CONN,_tab.REF_CONN,,,null());
      {? _b_conn<>null()
      ||
         B_CHOICE.prefix(_b_conn);
         _tab.CHOI_NUM:=B_CHOICE.size();
         _tab.put()
      || _tab.CHOI_NUM:=0;
         _tab.put()
      ?};
      _tab.next()
   !}
?};
B_CHOICE.cntx_pop();
_tab.cntx_pop();
~~


\prel2prev
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Dodaje jeden rekord do tabeli .TAB_PREV na podstawie aktualnego rekordu tabeli B_PREL
::       Uruchamia również dodawanie wszystkich portów wyjściowych
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       [_b] - INTEGER -  1 - dodawać info do KOMMa jeśli się nie udało zablokować B_PORT
::                        [0]- dodawać info na ekran
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_komm:=0;
{? var_pres('_b')=type_of(0)
|| _komm:=_b
?};

_result:=0;
_can_continue:=1;

_tab:=_env.TAB_PREV;
_tab.cntx_psh();
_tab.index(_env.IN_PREV3);
_tab.prefix($B_PREL.ref());
{? _tab.size()=0
||
   _tab.blank();
   _tab.PARENT:=0;
   _tab.TYPE:='B_PREL';
   _tab.SYMBOL:=B_PREL.SYMBOL;
   _tab.NAME:=B_PREL.B_ELE().SYMBOL;
   _tab.REF_BELE:=$B_PREL.B_ELE;
   _tab.REF_PREL:=$B_PREL.ref();
   _result:=_tab.add();

   {? _result>0
   ||
::    Udało się dodać element procesu, dodaje jego porty (stałe)
      B_PORT.index('B_ELE');
      B_PORT.prefix('T',B_ELE.ref(),exec('kind_out','#b_port'),);
      {? B_PORT.first()
      || {!
         |? _can_continue:=exec('port2tab','#b_choice',_env,_tab.ref(),B_PREL.ref(),_komm);
            B_PORT.next() & _can_continue>0
         !}
      ?};
::    Udało się dodać element procesu, dodaje jego porty (dynamiczne)
      B_PORT.index('UNIK');
      B_PORT.prefix(null(),B_PREL.ref(),null(),exec('kind_out','#b_port'),);
      {? B_PORT.first()
      || {!
         |? _can_continue:=exec('port2tab','#b_choice',_env,_tab.ref(),B_PREL.ref(),_komm);
            B_PORT.next() & _can_continue>0
         !}
      ?};
::    Usunięcie elementu, który nie ma portów wyjściowych
      _tab.cntx_psh();
      _tab.index(_env.IN_PREV2);
      _tab.prefix(_tab.ref(),$B_PORT.ref());
      _del:=_tab.size()=0;
      _tab.cntx_pop();
      {? _del || _tab.del() ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_tab.cntx_pop();
_result


\load_next
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Ładuje zawartość tabeli .TAB_PREV na podstawie aktualnego rekordu tabeli B_PREL który jest bramą
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - B_PREL.ref - rekord bramy
::       [_c] - INTEGER -  1 - dodawać info do KOMMa jeśli się nie udało zablokować B_PORT
::                        [0]- dodawać info na ekran
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_b_prel:=_b;

_komm:=0;
{? var_pres('_c')=type_of(0)
|| _komm:=_c
?};

_result:=0;
_can_continue:=1;

B_PREL.cntx_psh(); B_PREL.clear();
B_ELE.cntx_psh();
B_CONN.cntx_psh();
B_PORT.cntx_psh();
B_PORT.index('B_ELE');

{? B_PREL.seek(_b_prel)
||
:: Podczytanie B_ELE
   B_PREL.B_ELE();

   {? exec('is_gate','#b_gate',B_ELE.ref())>0
   ||
::    Element jest bramą, wczytuje wszystkie następniki
      B_CONN.index('FROM');
      B_CONN.prefix(B_PREL.B_PROC,B_PREL.ref());
      {? B_CONN.first()
      || {!
         |?
            B_CONN.TO();
            _can_continue:=exec('prel2next','#b_choice',_env,B_CONN.ref(),_komm);
            B_CONN.next() & _can_continue>0
         !}
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
B_PORT.cntx_pop();
B_CONN.cntx_pop();
B_ELE.cntx_pop();
B_PREL.cntx_pop();
_result


\prel2next
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Dodaje jeden rekord do tabeli .TAB_NEXT na podstawie aktualnego rekordu tabeli B_PREL
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - B_CONN.ref
::       [_c] - INTEGER -  1 - dodawać info do KOMMa jeśli sie nie udało zablokować B_PORT
::                        [0]- dodawać info na ekran
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_b_conn:=_b;

_komm:=0;
{? var_pres('_c')=type_of(0)
|| _komm:=_c
?};

_result:=0;
_can_continue:=1;

_tab:=_env.TAB_NEXT;
_tab.cntx_psh();
_tab.index(_env.IN_NEXT3);
_tab.prefix($_b_conn);
{? _tab.size()=0
|| _tab.blank();
   _tab.SYM_BELE:=B_PREL.B_ELE().SYMBOL;
   _tab.SYM_PREL:=B_PREL.SYMBOL;
   _tab.CLASS:=B_PREL.CLASS;
   _tab.REF_BELE:=$B_PREL.B_ELE;
   _tab.REF_PREL:=$B_PREL.ref();
   _tab.REF_CONN:=$_b_conn;
   _tab.DEFAULT:=exec('FindAndGet','#table',B_CONN,$_b_conn,,"DEFAULT",'N');
   _tab.ORDER:=exec('FindAndGet','#table',B_CONN,$_b_conn,,"ORDER",0);
   _result:=_tab.add()
?};
_tab.cntx_pop();
_result


\port2tab
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Dodaje jeden rekord do tabeli .TAB_PREV na podstawie aktualnego rekordu
::       tabeli B_PORT
::       KONTEKST PRACY - B_PORT
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - .TAB_FROM.ref() - ref rekordu nadrzędnego
::       _c - B_PREL.ref() - element procesu do którego należy port
::       [_d] - INTEGER -  1 - dodawać info do KOMMa jeśli się nie udało zablokować B_PORT
::                        [0]- dodawać info na ekran
::   WY: 0 - nie udało sie dodać
::       1 - sukces, rekord został dodany
::       2 - rekord nie został dodany bo taki port już jest w tabeli
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_parent:=_b;
_b_prel:=_c;

_komm:=0;
{? var_pres('_d')=type_of(0)
|| _komm:=_d
?};

_result:=1;
_can_continue:=1;

_tab:=_env.TAB_PREV;

B_TYPE.cntx_psh();

{? _can_continue>0
||
:: Sprawdzam czy mogę zablokować B_PORTa
   {? _env.EDITABLE>0
   || {? exec('lock','#b_port',B_PORT.ref(),0)=0
      || _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   ||
      B_ELE.cntx_psh();

      _tab.cntx_psh();
      _tab.index(_env.IN_PREV2);
      _tab.prefix(_parent,$B_PORT.ref());
      {? _tab.size()=0
      ||
         _tab.blank();
         _tab.PARENT:=_parent;
         _tab.TYPE:='B_PORT';
         _tab.SYMBOL:=B_PORT.SYMBOL;
         _tab.NAME:=B_PORT.NAME;
         _tab.REF_BELE:=$B_PORT.B_ELE;
         _tab.REF_PREL:=$_b_prel;
         _tab.REF_TYP:=$B_PORT.B_TYPE;
         _tab.SYM_TYP:=B_PORT.B_TYPE().SYMBOL;
         _tab.NAM_TYP:=B_TYPE.TYPE;
         _tab.REF_PORT:=$B_PORT.ref();
         _tab.SYM_PORT:=B_PORT.SYMBOL;
         _tab.NAM_PORT:=B_PORT.NAME;
         _tab.ACTIVE:=B_PORT.ACTIVE;
         _tab.REQUIRED:=B_PORT.REQUIRED;
         _result:=_tab.add()
      || _result:=2
      ?};
      exec('unlock','#b_port',B_PORT.ref());
      _tab.cntx_pop();
      B_ELE.cntx_pop()
   || B_ELE.cntx_psh();
      _msg:='Parametr: \'%1\' jest zablokowany przez innego użytkownika i nie został wczytany (element źródłowy: \'%2\')'@[B_PORT.SYMBOL+' '+B_PORT.NAME,B_PORT.B_ELE().SYMBOL];
      {? _komm>0
      || KOMM.add(_msg,'xwin16.png:2')
      || FUN.emsg(_msg)
      ?};
      B_ELE.cntx_pop()
   ?}
?};
B_TYPE.cntx_pop();
_result


\tab_show
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Pozostawia widoczną jedną zakładkę w oknie z panelami kontrolek, reszte ukrywając
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - INTEGER - numer zakładki którą pozostawić
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_num_show:=_b;

_max_tabs:=_env.CTR_TABS;
_panel:='boczny';

{! _it:=1.._max_tabs
|!
   {? _it=_num_show
   || tab_show(_it,_panel)
   || tab_hide(_it,,_panel)
   ?}
!};
~~


\buffer_fill
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Zwraca bufor tabeli B_CHOICE wypełniony na podstawie aktualnie zaznaczonych
::       rekordów w oknie oraz wartości pól w kontrolce na zakładce 'Ogólne'
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - STRING - nazwa zakładki z kontrolka z której czytać pola redagowania
::       [_c] - obj_new() - bufor który wypelniać, jeśli nie podany, to tworzony jest nowy
::   WY: _buffer - wypełniony bufor tabeli - wynik działania exec('buffer','#b_choice')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_b;

{? var_pres('_c')>100
|| _buffer:=_c
|| _buffer:=exec('buffer','#b_choice')
?};

_buffer.B_PREL:=_env.GATE;
_buffer.ORDER:=exec('bl_order','#b_choice',_buffer.B_PREL);

:: 1. Wypełniam bufor na podstawie zaznaczonego rekordu w tabeli elementów przed brama
_tab_prev:=_env.TAB_PREV;
_buffer.PREL_SRC:=exec('FindAndGet','#table',B_PREL,_tab_prev.REF_PREL,,,null());
{? _tab_prev.TYPE='B_PREL'
|| ~~
|? _tab_prev.TYPE='B_PORT'
|| _buffer.B_PORT:=exec('FindAndGet','#table',B_PORT,_tab_prev.REF_PORT,,,null())
?};

:: 2. Wypełniam bufor na podstawie zaznaczonego rekordu w tabeli elementów za brama
_tab_next:=_env.TAB_NEXT;
_buffer.B_CONN:=exec('FindAndGet','#table',B_CONN,_tab_next.REF_CONN,,,null());
_buffer.PREL_DST:=exec('FindAndGet','#table',B_PREL,_tab_next.REF_PREL,,,null());

:: 3. Wypełniam bufor na podstawie kontrolki na podanej zakładce
{? _tab='Ogólne'
||
:: Zakładka 'Ogólne'
   _buffer.KIND:='F';
   _buffer.NAME:=exec('get_value','#desktop','',_env.cid_comm,_env.c_o_name);
   _buffer.FORMULA:=exec('get_value','#desktop','',_env.cid_comm,_env.c_o_form);
   ~~
|? _tab='Liczba'
||
:: Zakładka 'Liczba'
   _buffer.KIND:='N';
   _buffer.OPERATOR:=exec('get_value','#desktop','',_env.cid_num,_env.c_n_oper);
   _buffer.VALUE:=form(exec('get_value','#desktop','',_env.cid_num,_env.c_n_val));
   _buffer.VALUE:=exec('chn_real','#string',_buffer.VALUE,0);
::   _num:=#_buffer.VALUE;
::   _buffer.VALUE:=form(_num,,,'9.');
::   exec('set_value','#desktop','',_env.cid_num,_env.c_n_val,_buffer.VALUE);

   _port_sym:=exec('FindAndGet','#table',B_PORT,#_buffer.B_PORT,ref_name(_buffer.B_PORT),"SYMBOL",'');
   _port_nam:=exec('FindAndGet','#table',B_PORT,#_buffer.B_PORT,ref_name(_buffer.B_PORT),"NAME",'');
   _buffer.NAME:=exec('name_gen','#b_choice',_env,_buffer.OPERATOR,_port_nam,_buffer.VALUE);
   _buffer.FORMULA:=exec('formula_gen','#b_choice',_env,_buffer.OPERATOR,_port_sym,_buffer.VALUE);
   ~~
|? _tab='Tekst'
||
:: Zakładka 'Tekst'
   _buffer.KIND:='S';
   _buffer.OPERATOR:=exec('get_value','#desktop','',_env.cid_str,_env.c_s_oper);
   _buffer.VALUE:=exec('get_value','#desktop','',_env.cid_str,_env.c_s_val);

   _port_sym:=exec('FindAndGet','#table',B_PORT,#_buffer.B_PORT,ref_name(_buffer.B_PORT),"SYMBOL",'');
   _port_nam:=exec('FindAndGet','#table',B_PORT,#_buffer.B_PORT,ref_name(_buffer.B_PORT),"NAME",'');
   {? _buffer.OPERATOR=exec('oper_empty','#b_choice',2) | _buffer.OPERATOR=exec('oper_noempty','#b_choice',2)
   || _buffer.NAME:=exec('name_gen','#b_choice',_env,_buffer.OPERATOR,_port_nam,'')
   || _buffer.NAME:=exec('name_gen','#b_choice',_env,_buffer.OPERATOR,_port_nam,_buffer.VALUE,'''''')
   ?};
   _buffer.CASE_SEN:='N';
   {? exec('get_value','#desktop','',_env.cid_str,_env.c_s_case)='true'
   || _buffer.CASE_SEN:='T'
   ?};
   _buffer.FORMULA:=exec('formula_gen','#b_choice',_env,_buffer.OPERATOR,_port_sym,_buffer.VALUE,_buffer.CASE_SEN);
   ~~
|? _tab='Złączenie'
||
:: Zakładka 'Złączenie'
   _buffer.KIND:='J';
   _buffer.OPERATOR:=exec('get_value','#desktop','',_env.cid_join,_env.c_j_oper);
   _buffer.VALUE:='';

   _port_sym:=exec('FindAndGet','#table',B_PORT,#_buffer.B_PORT,ref_name(_buffer.B_PORT),"SYMBOL",'');
   _port_nam:=exec('FindAndGet','#table',B_PORT,#_buffer.B_PORT,ref_name(_buffer.B_PORT),"NAME",'');
   _buffer.NAME:=exec('name_gen','#b_choice',_env,_buffer.OPERATOR,_port_nam,_buffer.VALUE,'''''');
   _buffer.FORMULA:=exec('formula_gen','#b_choice',_env,_buffer.OPERATOR,_port_sym,_buffer.VALUE,_buffer.CASE_SEN);
   ~~
?};
_buffer


\add_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Akcja 'Dołącz' wywoływana z kontrolki
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - STRING - nazwa zakładki z której wywołano akcję
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_b;

_can_continue:=1;
_result:=0;

:: Tworze i wypełniam bufor tabeli B_CHOICE
_buffer:=exec('buffer_fill','#b_choice',_env,_tab);
:: Sprawdzam czy B_PORT którego dotyczy warunek jeszcze istnieje i czy ma właściwy typ
_tab_prev:=_env.TAB_PREV;
{? _tab_prev.TYPE='B_PORT'
|| _port:=exec('FindAndGet','#table',B_PORT,_tab_prev.REF_PORT,,,null());
   {? _port<>null()
   ||
::    Parametr istnieje, więc sprawdzam czy typ się zgadza
      _type_prev:=exec('FindAndGet','#table',B_TYPE,_tab_prev.REF_TYP,,,null());
      _type_now:=exec('FindAndGet','#table',B_PORT,_port,,"B_TYPE",null());
      {? _type_prev<>null()
      || {? $_type_prev<>$_type_now
         || _can_continue:=0;
            FUN.emsg('Zmienił się typ parametru: %1. Utworzenie warunku niemożliwe.'@[_tab_prev.SYM_PORT])
         ?}
      ?};

      {? _can_continue>0
      ||
::       Jeśli typ się zgadza to badam czy aktywny
         _akt:=exec('FindAndGet','#table',B_PORT,_port,,"ACTIVE",'');
         {? _akt<>'T'
         || _can_continue:=0;
            FUN.emsg('Parametr: %1 jest nieaktywny. Utworzenie warunku niemożliwe.'@[_tab_prev.SYM_PORT])
         ?}
      ?}
   |? _port=null()
   || _can_continue:=0;
      FUN.emsg('Nie znaleziono parametru: %1, którego ma dotyczyć warunek.'@[_tab_prev.SYM_PORT])
   ?}
?};

{? _can_continue>0
||
   _valid:=exec('validate','#b_choice',_buffer);

   {? _valid=''
   ||
      _result:=exec('add','#b_choice',_buffer);

      {? _result>0
      ||
::       Tworzymy trasy portów wyjściowych elementu źródłowego do bramy
         B_CONN.cntx_psh();
         B_CONN.index('TO');
         B_CONN.prefix(exec('FindAndGet','#table',B_PREL,_env.GATE,,"B_PREL.B_PROC"),_env.GATE);
         _loop:=B_CONN.first();
         {!
         |? _loop
         |!
            exec('route_prelPorts2gate','#b_proute',_buffer,B_CONN.ref());
            _loop:=B_CONN.next()
         !};
         B_CONN.cntx_pop();
::       Uaktualniam liczbe utworzonych polaczen
         exec('update_choi_num','#b_choice',_env);

         grp_disp(B_CHOICE,_env.WIN_CHOI);
         grp_disp(_env.TAB_NEXT,_env.WIN_NEXT)
      ?}
   ||
::    Powrót do redagowanego pola w kontrolce
      _cid:='';
      _id:='';
      _num_win:=0;
      {? _buffer.KIND='F'
      || _cid:=_env.cid_comm;
         _num_win:=2;
         {? _valid='NAME'
         || _id:=_env.c_o_name
         |? _valid='FORMULA'
         || _id:=_env.c_o_form
         ?}
      |? _buffer.KIND='N'
      || _cid:=_env.cid_num;
         _num_win:=3;
         {? _valid='VALUE'
         || _id:=_env.c_n_val
         ?}
      |? _buffer.KIND='S'
      || _cid:=_env.cid_str;
         _num_win:=4;
         {? _valid='VALUE'
         || _id:=_env.c_s_val
         ?}
      |? _buffer.KIND='J'
      || _cid:=_env.cid_join;
         _num_win:=5;
         {? _valid='VALUE'
         || _id:=_env.c_j_val
         ?}
      ?};
      exec('set_active_win','#desktop','',_cid,_num_win);
      exec('grab_focus','#desktop','',_cid,_id);

      _result:=0
   ?}
?};

_result


\edit_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Akcja 'Popraw' w tabeli B_CHOICE
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_result:=0;

B_PORT.cntx_psh();

:: Ustawiam okno redagowania
{? B_CHOICE.KIND='F'
|| B_CHOICE.win_edit('RED_COMM')
|? B_CHOICE.KIND='S'
|| B_CHOICE.win_edit('RED_STR')
|? B_CHOICE.KIND='N'
|| B_CHOICE.win_edit('RED_NUM')
|? B_CHOICE.KIND='J'
|| B_CHOICE.win_edit('RED_JOIN')
?};
exec('efld_opt','#b_choice');

_validate:="
   _buffer:=exec('buffer','#b_choice');
:: Wypełniam bufor na podstawie aktualnej zawartości tabeli
   _buffer.get();
   exec('validate','#b_choice',_buffer)
";

{? B_CHOICE.edit(_validate)>0
||
:: Generuje od nowa nazwe i formułe jeśli rodzaj warunku inny niż ręczny
   {? B_CHOICE.KIND='N'
   ||
      B_CHOICE.VALUE:=exec('chn_real','#string',B_CHOICE.VALUE,0);
      _num:=#B_CHOICE.VALUE;
      B_CHOICE.VALUE:=form(_num,,,'9.');
      _port_sym:=B_CHOICE.B_PORT().SYMBOL;
      _port_nam:=B_CHOICE.B_PORT().NAME;
      B_CHOICE.NAME:=exec('name_gen','#b_choice',_env,B_CHOICE.OPERATOR,_port_nam,B_CHOICE.VALUE,'');
      B_CHOICE.FORMULA:=exec('formula_gen','#b_choice',_env,B_CHOICE.OPERATOR,_port_sym,B_CHOICE.VALUE)
   |? B_CHOICE.KIND='S'
   ||
      _port_sym:=B_CHOICE.B_PORT().SYMBOL;
      _port_nam:=B_CHOICE.B_PORT().NAME;
      B_CHOICE.NAME:=exec('name_gen','#b_choice',_env,B_CHOICE.OPERATOR,_port_nam,B_CHOICE.VALUE,'''''');
      B_CHOICE.FORMULA:=exec('formula_gen','#b_choice',_env,B_CHOICE.OPERATOR,_port_sym,B_CHOICE.VALUE)
   |? B_CHOICE.KIND='J'
   ||
      _port_sym:=B_CHOICE.B_PORT().SYMBOL;
      _port_nam:=B_CHOICE.B_PORT().NAME;
      B_CHOICE.NAME:=exec('name_gen','#b_choice',_env,B_CHOICE.OPERATOR,_port_nam,B_CHOICE.VALUE,'''''');
      B_CHOICE.FORMULA:=exec('formula_gen','#b_choice',_env,B_CHOICE.OPERATOR,_port_sym,B_CHOICE.VALUE)
   ?};
   B_CHOICE.AUTO:='N';
   _result:=B_CHOICE.put()
?};
B_PORT.cntx_pop();
_result


\disp_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: TS [17.00]
:: OPIS: Akcja 'Wyświetl' w tabeli B_CHOICE
::----------------------------------------------------------------------------------------------------------------------
:: Ustawiam okno redagowania
{? B_CHOICE.KIND='F'
|| B_CHOICE.win_edit('RED_COMM')
|? B_CHOICE.KIND='S'
|| B_CHOICE.win_edit('RED_STR')
|? B_CHOICE.KIND='N'
|| B_CHOICE.win_edit('RED_NUM')
|? B_CHOICE.KIND='J'
|| B_CHOICE.win_edit('RED_JOIN')
?};

B_CHOICE.display();
~~


\del_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Akcja usuń w tabeli B_CHOICE
::   WE: [_a] - _env - środowisko designera exec('env','#b_choice')
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_env:=~~;

{? var_pres('_a')>100
|| _env:=_a
?};

_tab:=cur_tab(1,1);

_result:=0;
_can_continue:=1;

_group:=0;
{? _tab.sel_size()>0
|| _group:=1
?};

_choice:=1;

:: zapytanie czy na pewno
{? _group=0
|| _choice:=FUN.ask('Czy usunąć warunek: %1?'@[_tab.NAME])
?};

:: Sprawdzam czy można usunąć
{? _group>0
|| _can_continue:=exec('can_delete','#b_choice',,2)
|| _can_continue:=exec('can_delete','#b_choice',,1)
?};

{? _can_continue>0
|| {? _group=0
   || KOMM.init(200,,'Usuwanie warunków bram'@,'')
   ?};

   {? _choice=1
   || _result:=exec('delete','#b_choice',B_CHOICE.ref())
   ?};

:: jeśli akcja nie była grupowa to pokazuje okno z komunikatami i odswieżam okna
   {? _group=0
   ||
      {? type_of(_env)>100
      ||
::    Uaktualniam liczbe utworzonych połączeń
         exec('update_choi_num','#b_choice',_env);

         {? var_pres('TAB_PREV',_env)>100
         || grp_disp(_env.TAB_PREV,_env.WIN_PREV)
         ?};
         {? var_pres('TAB_NEXT',_env)>100
         || grp_disp(_env.TAB_NEXT,_env.WIN_NEXT,1)
         ?};
         grp_disp(B_CHOICE,_env.WIN_CHOI,1)
      ?};
      KOMM.select(,,,,,0)
   ?}
?};
~~


\del_act_gr1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Akcja usuń grupa przed w oknie wertowania tabeli B_CHOICE
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
_tab:=cur_tab(1,1);
{? FUN.ask('Zaznaczono: %1 warunków. Czy usunąć je wszystkie?'@[$_tab.sel_size()])
|| _ok:=1;
   sel_nchk();
   KOMM.init(200,,'Usuwanie warunków bram'@,'')
?};
_ok


\del_act_gr2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Akcja usuń grupa po w oknie wertowania tabeli B_CHOICE
::   WE: _a - _env - środowisko kreatora exec('env','#b_choice')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
{? type_of(_env)>100
||
:: Uaktualniam liczbę utworzonych połączeń
   exec('update_choi_num','#b_choice',_env);

   {? var_pres('TAB_PREV',_env)>100
   || grp_disp(_env.TAB_PREV,_env.WIN_PREV)
   ?};
   {? var_pres('TAB_NEXT',_env)>100
   || grp_disp(_env.TAB_NEXT,_env.WIN_NEXT,1)
   ?};
   grp_disp(B_CHOICE,_env.WIN_CHOI,1)
?};
KOMM.select(,,,,,0);
~~


\oper_eq_num
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora = (dla liczb)
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='równa się';
_res.FORMULA:='_a=_b';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_neq
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora <>
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='nie równa się';
_res.FORMULA:='_a<>_b';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_neq_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora <> (dla tekstów)
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:='tekst nie równa się';
_res.NAME:='nie równa się';
_res.FORMULA:='{? ''_c''=''N'' || _par:=-_a; _war:=-''_b'' || _par:=_a; _war:=''_b'' ?}; _par<>_war';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_lt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora <
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='jest mniejsza niż';
_res.FORMULA:='_a<_b';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_gt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora >
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='jest większa niż';
_res.FORMULA:='_a>_b';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_lte
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuly dla operatora <=
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='jest mniejsza niż lub równa';
_res.FORMULA:='_a<=_b';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_gte
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuly dla operatora >=
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='jest większa niż lub równa';
_res.FORMULA:='_a>=_b';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_eq_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora = (dla tekstów)
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:='tekst równa się';
_res.NAME:='równa się';
_res.FORMULA:='{? ''_c''=''N'' || _par:=-_a; _war:=-''_b'' || _par:=_a; _war:=''_b'' ?}; _par=_war';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_begins
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'zaczyna sie od'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='zaczyna się od';
_res.FORMULA:='{? ''_c''=''N'' || _par:=-_a; _war:=-''_b'' || _par:=_a; _war:=''_b'' ?}; ((+_war)+_par)=_war';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_nbegins
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'nie zaczyna sie od'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='nie zaczyna się od';
_res.FORMULA:='{? ''_c''=''N'' || _par:=-_a; _war:=-''_b'' || _par:=_a; _war:=''_b'' ?}; ((+_war)+_par)<>_war';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_ends
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'konczy sie na'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwana
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='kończy się na';
_res.FORMULA:='{? ''_c''=''N'' || _par:=-_a; _war:=-''_b'' || _par:=_a; _war:=''_b'' ?}; (_par+(+_war))=_war';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_nends
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'nie konczy sie na'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='nie kończy się na';
_res.FORMULA:='{? ''_c''=''N'' || _par:=-_a; _war:=-''_b'' || _par:=_a; _war:=''_b'' ?}; (_par+(+_war))<>_war';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_contains
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'zawiera'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='zawiera';
_res.FORMULA:='{? ''_c''=''N'' || _par:=-_a; _war:=-''_b'' || _par:=_a; _war:=''_b'' ?}; _par*_war>0';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_ncontains
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'nie zawiera'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='nie zawiera';
_res.FORMULA:='{? ''_c''=''N'' || _par:=-_a; _war:=-''_b'' || _par:=_a; _war:=''_b'' ?}; _par*_war=0';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_isnull
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.42]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'pusta wartość'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='pusta wartość';
_res.FORMULA:='_a=null() | _a=~~';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_isnotnull
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.42]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'niepusta wartość'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:=_res.NAME:='niepusta wartość';
_res.FORMULA:='_a<>null() & _a<>~~';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_empty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'jest pusty'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:='jest pusty';
_res.NAME:='jest pusta';
_res.FORMULA:='_a=''''';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\oper_noempty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zwraca nazwe i wzorzec formuły dla operatora wzorca 'nie jest pusty'
::   WE: [_a] - INTEGER - co zwracać: [1] - tablice nazwaną
::                                     2 - string z identyfikatorem operatora
::                                     3 - string z nazwą operatora
::   WY: obj_new(NAME,FORMULA) lub STRING
::----------------------------------------------------------------------------------------------------------------------
_res_type:=1;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_res:=obj_new('OPERATOR','NAME','FORMULA');
_res.OPERATOR:='nie jest pusty';
_res.NAME:='nie jest pusta';
_res.FORMULA:='_a<>''''';

{? _res_type=1
|| _res
|? _res_type=2
|| _res.OPERATOR
|? _res_type=3
|| _res.NAME
?}


\get_oper_num
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Zwraca tabele tymczasową zawierajacą operatory dla typu: liczba
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
CHOICE_CR.TAB_OPER.index(CHOICE_CR.IN_OPERN);
CHOICE_CR.TAB_OPER.prefix('T');
CHOICE_CR.TAB_OPER.first();
CHOICE_CR.TAB_OPER


\get_oper_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca tabele tymczasową zawierajacą operatory dla typu: tekst
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
CHOICE_CR.TAB_OPER.index(CHOICE_CR.IN_OPERS);
CHOICE_CR.TAB_OPER.prefix('T');
CHOICE_CR.TAB_OPER.first();
CHOICE_CR.TAB_OPER


\get_oper_dat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca tabele tymczasową zawierajacą operatory dla typu: data
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
CHOICE_CR.TAB_OPER.index(CHOICE_CR.IN_OPERD);
CHOICE_CR.TAB_OPER.prefix('T');
CHOICE_CR.TAB_OPER.first();
CHOICE_CR.TAB_OPER


\get_oper_join
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.42]
:: OPIS: Zwraca tabele tymczasową zawierajacą operatory dla typu: złączenie
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
CHOICE_CR.TAB_OPER.index(CHOICE_CR.IN_OPERJ);
CHOICE_CR.TAB_OPER.prefix('T');
CHOICE_CR.TAB_OPER.first();
CHOICE_CR.TAB_OPER


\formula_gen
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Generuje formułe dla rekordu B_CHOICE
::   WE: _a - _env - środowisko kreatora exec('env','#b_choice')
::       _b - STRING - operator
::       _c - STRING - akronim parametru wyjściowego
::       _d - STRING - wartość
::       [_e] - STRING - czy wielkość znaków ma znaczenie ([T]/N)
::   WY: STRING - gotowa formuła
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
{? var_pres('_e')<>type_of('') || _e:='T' ?};

_tab:=_env.TAB_OPER;
_tab.index(_env.IN_OPERO);
_tab.prefix(_b,);
{? _tab.first()
|| _formula:=_tab.FORMULA;
   _formula:=gsub(_formula,'_a','_a.'+_c);
   _formula:=gsub(_formula,'_b',_d);
   _formula:=gsub(_formula,'_c',_e);
   _formula:='{? var_pres('''+_c+''',_a)>0 || '+_formula+' || 0 ?}';
   _formula
|| ''
?}


\name_gen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Generuje nazwę dla rekordu B_CHOICE
::   WE: _a - _env - środowisko kreatora exec('env','#b_choice')
::       _b - STRING - operator
::       _c - STRING - nazwa parametru wyjściowego
::       _d - STRING - wartość
::       [_e] - STRING - znaki cytowania dla wartości
::   WY: STRING - gotowa nazwa
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

{? var_pres('_e')=type_of('') || _cit1:=1+_e; _cit2:=_e+1 || _cit1:=_cit2:='' ?};

_tab:=_env.TAB_OPER;
_tab.index(_env.IN_OPERO);
_tab.prefix(_b,);
{? _tab.first()
|| {? form(_d)=''
   || 'Wartość parametru "%1" %2'[_c,_tab.NAME]
   || 'Wartość parametru "%1" %2 %3%4%5'[_c,_tab.NAME,_cit1,form(_d),_cit2]
   ?}
|| ''
?}


\validate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza poprawność danych w buforze tabeli B_CHOICE
::   WE: _a - bufor - wynik formuły exec('buffer','#b_choice')
::   WY: '' - ok, akronim błędnego pola (jak dla chk_rec())
::----------------------------------------------------------------------------------------------------------------------
_buffer:=_a;

_result:='';

{? _buffer.KIND='F'
||
:: ogolne
   {? _buffer.NAME=''
   || FUN.emsg('Należy podać nazwę warunku.'@);
      _result:='NAME'
   |? _buffer.FORMULA=''
   || FUN.emsg('Należy podać formułę.'@);
      _result:='FORMULA'
   |? ~exec('valid_formula','#field',_buffer.FORMULA)
   || _result:='FORMULA'
   ?}

|? _buffer.KIND='N'
||
:: liczba
   _value:=form(_buffer.VALUE);
   {? _value='0'
   || _result:=''
   |? _value=''
   || FUN.emsg('Należy podać wartość.'@);
      _result:='VALUE'
   |? #_value=0
   || FUN.emsg('Wprowadzona wartość nie reprezentuje poprawnie liczby.'@);
      _result:='VALUE'
   ?}
|? _buffer.KIND='S'
||
:: tekst
   {? _buffer.OPERATOR<>exec('oper_empty','#b_choice',2) &
      _buffer.OPERATOR<>exec('oper_noempty','#b_choice',2)
   || {? _buffer.VALUE=''
      || FUN.emsg('Należy podać wartość.'@);
         _result:='VALUE'
      |? _buffer.VALUE*''''>0
      || FUN.emsg('Wartość pola nie może zawierać znaku ''.'@);
         _result:='VALUE'
      ?}
   ?}
|? _buffer.KIND='D'
||
:: data
   {? _buffer.VALUE=''
   || FUN.emsg('Należy podać wartość.'@);
      _result:='VALUE'
   ?}
|? _buffer.VALUE='T'
||
:: czas
   {? _buffer.VALUE=''
   || FUN.emsg('Należy podać wartość.'@);
      _result:='VALUE'
   ?}
|? _buffer.VALUE='J'
||
:: złączenie
   _result:=''
?};

_result


\unlock_ports
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Odblokowuje wszystkie B_PORTy aktualnie załadowane do okienka
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

B_PORT.cntx_psh();
B_PORT.clear();

:: Odblokowuje porty w tabelce przed bramą
_tab_port:=_env.TAB_PREV;
_tab_port.cntx_psh();
_tab_port.clear();
{? _tab_port.first()
|| {!
   |? {? _tab_port.REF_PORT<>''
      ||
         {? B_PORT.seek(_tab_port.REF_PORT)
         || exec('unlock','#b_port',B_PORT.ref())
         ?}
      ?};
      _tab_port.next()
   !}
?};
_tab_port.cntx_pop();
B_PORT.cntx_pop();
~~


\auto_choice
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Tworzy automatyczne wybory dla bramy rozdzielającej AND albo EVENT
::       Jeśli parametr _b podany tworzy B_CHOICE tylko dla tego połączenia, jeśli nie podany
::       tworzy B_CHOICE dla wszystkich połączeń wychodzących z bramy
::   WE: _a - B_PREL.ref - brama której tworzyć wybory
::       [_b] - B_CONN.ref() - połączenie dla którego tworzyć automatyczny wybór
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;

_b_conn:=null();
{? var_pres('_b')=type_of(B_CONN.ref())
|| _b_conn:=_b
?};

_result:=0;
_can_continue:=1;

B_CHOICE.cntx_psh();
B_CHOICE.index('B_CONN');
B_PREL.cntx_psh(); B_PREL.clear();
B_CONN.cntx_psh();
B_CONN.index('FROM');
B_CONN.clear();

{? B_PREL.seek(_b_prel)
||
:: Sprawdzam czy element procesu jest bramą rozdzielającą typu and
   {? exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_and','#b_gate'),exec('kind_split','#b_gate'))>0
         |
      exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_event','#b_gate'),exec('kind_split','#b_gate'))>0
   ||
      _buffer:=exec('buffer','#b_choice');
      _buffer.NAME:='Automatyczny - zawsze prawdziwy';
      _buffer.B_PREL:=B_PREL.ref();
      _buffer.FORMULA:='1';
      _buffer.KIND:='F';
      _buffer.AUTO:='T';

      {? _b_conn<>null()
      ||
::       Tworze tylko jednego B_CHOICE
         {? B_CONN.seek(_b_conn)
         ||
::          Sprawdzam czy jest już taki automatyczny warunek dla podanego połączenia
            B_CHOICE.prefix(B_CONN.ref(),'T');
            {? B_CHOICE.size()=0
            || _buffer.B_CONN:=B_CONN.ref();
               _buffer.PREL_DST:=B_CONN.TO;
               _can_continue:=exec('add','#b_choice',_buffer)
            ?}
         ?}
      ||
::       Tworze B_CHOICE dla wszystkich połączeń wychodzących z bramy
         B_CONN.prefix(B_PREL.B_PROC,B_PREL.ref());
         {? B_CONN.first()
         || {!
            |?
::             Sprawdzam czy jest już taki automatyczny warunek dla podanego połączenia
               B_CHOICE.prefix(B_CONN.ref(),'T');
               {? B_CHOICE.size()=0
               ||
                  _buffer.B_CONN:=B_CONN.ref();
                  _buffer.PREL_DST:=B_CONN.TO;
                  _can_continue:=exec('add','#b_choice',_buffer)
               ?};
               B_CONN.next() & _can_continue>0
            !}
         ?}
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};

B_CONN.cntx_pop();
B_PREL.cntx_pop();
B_CHOICE.cntx_pop();
_result


\fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format wyswietlania pól w tabeli B_CHOICE (np. wytłumienie wyświetlania wartości)
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:='';

{? _fld='FORMULA'
|| {? B_CHOICE.KIND='F'
   || _result:='empty=0'
   || _result:='empty=1'
   ?}
?};

_result


\tab_ready
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Wykonywane po załadowaniu sie desktopu. Po załadowaniu się wszystkich desktopów
::       oddaje focus do pierwszego okna w grupie
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - INTEGER - nr desktopa który zakończył się ładować
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_ready:=_b;

_tabs:=_env.CTR_TABS;

_env.CTR_FINI[_ready]:=1;

:: Sprawdzam czy wszystkie załadowane
{? exec('array_sum','#array',_env.CTR_FINI)=_tabs
||
:: Jeśli suma elementów równa liczbie zakładek to znak ze wszystkie załadowane, oddaje focus
   exec('set_active_win','#desktop','',_env.cid_comm,0)
?};
~~


\kom_forbidden
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Wyświetla komunikat o niedostępności redagowania warunków bram
::----------------------------------------------------------------------------------------------------------------------
FUN.info('Tworzenie warunków jest dostępne tylko dla elementów typu: brama rozdzielająca.'@);
~~


\run
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Uruchamia formuły na wyjściach z bramy. Zwraca tablice refów do B_CONN którymi można iść dalej
::   WE: _a - BI_PREL.ref() - element procesu będący brama
::       _b - uchwyt do menadżera procesu
::   WY: obj_new(x) - tablica refów
::----------------------------------------------------------------------------------------------------------------------
_bi_prel:=_a;
_mp:=_b;

_result:=obj_new(1);
_result[1]:=null();
_can_continue:=1;

BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?}; BI_PREL.clear();
B_PREL.cntx_psh();
BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?}; BI_PROC.index('UID'); BI_PROC.prefix();
B_CHOICE.cntx_psh();
B_CHOICE.index('B_CONN');

{? BI_PREL.seek(_bi_prel)
||
:: Wykonuje tylko dla bram rozdzielających
   {? exec('is_gate','#b_gate',BI_PREL.B_PREL().B_ELE,,exec('kind_split','#b_gate'))
      | exec('is_gate','#b_gate',BI_PREL.B_PREL().B_ELE,,exec('kind_merge','#b_gate'))
   ||
      _gate_type:=exec('get_type','#b_gate',BI_PREL.B_PREL().B_ELE);
      _found_esc:=0;
::    Prefiksuje polaczenia wychodzace z bramy, ale tylko niedomyslne
      B_CONN.cntx_psh();
      B_CONN.index('FROM');
      B_CONN.prefix(BI_PREL.BI_PROC().B_PROC,BI_PREL.B_PREL,'N');

      {? B_CONN.size()>0
      ||
::       Inicjuje wynik - tablica bedzie zawierała tyle elementów ile jest połączeń wychodzących
::       z bramy, ale tylko niektóre będą miały coś więcej niż null()
         obj_del(_result);
         _result:=obj_new(B_CONN.size());

         {! _it:=1..B_CONN.size()
         |! _result[_it]:=null()
         !};

         _ndx_conn:=0;
::       zmieniam indeksakcje z uwzględnieniem kolejności pole ORDER dla B-CONN-a
         B_CONN.index('ORDER');
         B_CONN.prefix(BI_PREL.BI_PROC().B_PROC,BI_PREL.B_PREL);
         {? B_CONN.first()
         ||
            {!
            |?
::             Pomijane są domyślne
               {? B_CONN.DEFAULT='N'
               ||
::                Formuła która wykonam na końcu, która mi zwróci wynik dla całego B_CONN
                  _ff_conn:='0';

                  _ndx_conn+=1;
                  _choi_res:=0;

                  B_CHOICE.prefix(B_CONN.ref());

::                Iteruje po warunkach
                  {? B_CHOICE.first()
                  ||
                     _ff_conn:='';
                     {!
                     |?
::                      Znajduję instancję elementu bezpośrednio przed bramką
                        _bi_prev:=exec('back2prel','#bi_prel',_bi_prel,B_CHOICE.PREL_SRC);
                        _operator:='&';

                        {? B_CHOICE.AUTO<>'T'
                        ||
::                         Warunek nie jest automatycznie utworzony
::                         więc należy wykonać formułe warunku przekazujac jej wartości parametrów wyjściowych
::                         z czynności przed bramą

::                         Inicjuje porty wyjściowe z czynności przed bramą, które przekaże formułe na warunku
                           _kind:=exec('kind_out','#b_port');

                           {? var_pres('_ports')>100 || obj_del(_ports) ?};
                           _act_bele:=exec('FindAndGet','#table',B_PREL,B_CHOICE.PREL_SRC,,"B_PREL.B_ELE",null());

                           _ports:=exec('getPorts','#b_port',_act_bele,_kind,B_CHOICE.PREL_SRC);

                           {? var_pres('_portsOut')>100 || obj_del(_portsOut) ?};
                           _portsOut:=exec('fillPorts','#bi_port',_bi_prev,_kind,_ports,B_CHOICE.PREL_SRC,,B_CHOICE.KIND<>'F');

                           _formula:=B_CHOICE.FORMULA;

::                         Ustawienie parametrów
                           params_set('mp',_mp);
::                         Wywołanie formuły
                           _choi_res:=($_formula)(_portsOut)
                        ||
::                         Warunek jest automatyczny lub brak poprzedniego elementu, wiec wykonuje formułe nie przekazując jej żadnych parametrów
                           _formula:=B_CHOICE.FORMULA;
::                         Wywołanie formuły
                           _choi_res:=($_formula)()
                        ?};

                        {? type_of(_choi_res)=type_of(0)
                        ||
                           {? _choi_res
                           || _ff_conn+=_operator+'1'
                           || _ff_conn+=_operator+'0'
                           ?}
                        ?};
                        B_CHOICE.next()
                     !}
                  ?};
::                Z formuły usuwam pierwszy znak który jest pierwszym operatorem
                  _ff_conn:=1-_ff_conn;

::                Wykonuje formułe na warunek dla całego B_CONN
                  {? ($(_ff_conn))()>0
                  || _result[_ndx_conn]:=B_CONN.ref();

::                   Coś juz mam w wyniku więc nie musze szukać wyjścia domyślnego
                     _found_esc:=1;

::                   Jeśli brama typu XOR to nie przetwarzam kolejnych wyjść bo moge puścić tylko jednym
                     {? _gate_type=exec('type_xor','#b_gate')
                     || _can_continue:=0
                     ?}
                  ?}
               ?};
               B_CONN.next() & _can_continue>0
            !}
         ?}
      ?};

      {? _found_esc=0
      ||
::       Jeśli żadne z wyjść nie dostało prawdziwego warunku to sprawdzam czy jest domyślne
         B_CONN.index('FROM');
         B_CONN.prefix(BI_PREL.BI_PROC().B_PROC,BI_PREL.B_PREL,'T');
         {? B_CONN.first()
         || obj_del(_result);
            _result:=obj_new(1);
            _result[1]:=B_CONN.ref()
         ?}
      ?};
      B_CONN.cntx_pop()
   ?}
?};

B_CHOICE.cntx_pop();
BI_PROC.cntx_pop();
B_PREL.cntx_pop();
BI_PREL.cntx_pop();
_result


\verify
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Weryfikuje B_CHOICE
::   WE: _a - B_CHOICE.ref()
::       [_b] - INTEGER - typ raportowania o błędach: [0] - w ogole nigdzie nie raportować
::                                                     1 - raportować do KOMMa
::                                                     2 - raportować na ekran
::       [_c] - INTEGER - czy pilnować aby między źródłem a celem nie było żadnych
::                        innych czynności:
::                                           [0] - nie
::                                            1  - tak
::       [_d] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::   WY: 0 - weryfikacja zakończona niepowodzeniem
::       1 - B_CHOICE jest ok
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_b_choice:=_a;
_display:=0;

{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_others:=0;
{? var_pres('_c')=type_of(0)
|| _others:=_c
?};

_args:=~~;
{? var_pres('_d')>100
|| _args:=exec('obj_ntab_set','#array',_d)
|| _args:=exec('komm_args','#b_proc')
?};

_result:=1;

B_CHOICE.cntx_psh(); B_CHOICE.clear();
B_PREL.cntx_psh();
{? B_CHOICE.seek(_b_choice)
||
   {? B_CHOICE.PREL_SRC<>null() & B_CHOICE.PREL_DST<>null()
   ||
      _has_connection:=0;
      _conn_dir:=0;
::    Sprawdzam czy można dojść z elementu źródłowego do docelowego
      _args1:=exec('is_path_a','#b_conn');
      _args1.DIR=1;
      _args1.PREL_SRC:=B_CHOICE.PREL_SRC;
      _args1.PREL_DST:=B_CHOICE.PREL_DST;

      {? exec('is_path','#b_conn',_args1)>0
      || _has_connection:=1;
         _conn_dir:=1
      ?};

      {? _has_connection=0
      ||
::       Sprawdzam czy można dojść z elementu docelowego do źródłowego
         _args2:=exec('is_path_a','#b_conn');
         _args2.DIR=-1;
         _args2.PREL_SRC:=B_CHOICE.PREL_DST;
         _args2.PREL_DST:=B_CHOICE.PREL_SRC;
         {? exec('is_path','#b_conn',_args2)>0
         || _has_connection:=1;
            _conn_dir:=-1
         ?}
      ?};

      {? _has_connection>0
      ||
         {? _others>0
         ||
::          Istnieje połączenie, sprawdzam czy pomiędzy źródłowym elementem a docelowym istnieje
::          bezpośrednie połączenie albo takie które używa tylko bram
            _args_conn:=exec('is_path_a','#b_conn');
            _args_conn.CLASS:='B_GATE';
            {? _conn_dir>0
            || _args_conn.PREL_SRC:=B_CHOICE.PREL_SRC;
               _args_conn.PREL_DST:=B_CHOICE.PREL_DST
            |? _conn_dir<0
            || _args_conn.PREL_SRC:=B_CHOICE.PREL_DST;
               _args_conn.PREL_DST:=B_CHOICE.PREL_SRC
            ?};
            _args_conn.DIR:=_conn_dir;

            {? exec('is_path','#b_conn',_args_conn)=0
            ||
::             Pomiędzy źródlem a celem B_CHOICE istnieją jakieś inne czynności, co jest
::             niedopuszczalne
               _result:=0;
               {? _display=1
               ||
                  _sect:='Warunki bram, dla których pomiędzy źródłem a celem znajdują się inne czynności'@;

                  _nam:=B_CHOICE.NAME;
                  _gat:=B_CHOICE.B_PREL().SYMBOL;
                  _src:=B_CHOICE.PREL_SRC().SYMBOL;
                  _dst:=B_CHOICE.PREL_DST().SYMBOL;
                  _msg:='Warunek: \'%1\' na bramie: \'%2\' (źródło: %3, cel: %4)'@[_nam,_gat,_src,_dst];

                  _args.SECT:=_sect;
                  _args.MSG:=_msg;
                  _args.GRAPH_UID:=B_CHOICE.B_PREL().UID;
                  exec('komm_add','#b_proc',_args)
               |? _display=2
               ||
                  _nam:=B_CHOICE.NAME;
                  _gat:=B_CHOICE.B_PREL().SYMBOL;
                  _src:=B_CHOICE.PREL_SRC().SYMBOL;
                  _dst:=B_CHOICE.PREL_DST().SYMBOL;

                  _msg:='Dla warunku: \'%1\' na bramie: \'%2\n'
                        'pomiędzy źródłem a celem znajdują się inne czynności.\n\n'
                        'Źródło: %3\n'
                        'Cel: %4\n'@[_nam,_gat,_src,_dst];
                  FUN.emsg(_msg)
               ?}
            ?}
         ?}
      ||
::       Brak połączenia
         _result:=0;
         {? _display=1
         ||
            _sect:='Warunki bram, dla których brak połączenia pomiędzy źródłem a celem ';

            _nam:=B_CHOICE.NAME;
            _gat:=B_CHOICE.B_PREL().SYMBOL;
            _src:=B_CHOICE.PREL_SRC().SYMBOL;
            _dst:=B_CHOICE.PREL_DST().SYMBOL;
            _msg:='Warunek: \'%1\' na bramie: \'%2\' (źródło: %3, cel: %4)'@[_nam,_gat,_src,_dst];

            _args.SECT:=_sect;
            _args.MSG:=_msg;
            _args.GRAPH_UID:=B_CHOICE.B_PREL().UID;
            exec('komm_add','#b_proc',_args)
         |? _display=2
         ||
            _nam:=B_CHOICE.NAME;
            _gat:=B_CHOICE.B_PREL().SYMBOL;
            _src:=B_CHOICE.PREL_SRC().SYMBOL;
            _dst:=B_CHOICE.PREL_DST().SYMBOL;

            _msg:='Dla warunku: \'%1\' na bramie: \'%2\n'
                  'brak połączenia pomiędzy źródłem a celem.\n\n'
                  'Źródło: %3\n'
                  'Cel: %4\n'@[_nam,_gat,_src,_dst];
            FUN.emsg(_msg)
         ?}
      ?}
   ?}
?};
B_CHOICE.cntx_pop();
B_PREL.cntx_pop();
_result


\bl_order
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: wartość początkowa pola ORDER
::   WE: [_a] - B_PREL.ref
::----------------------------------------------------------------------------------------------------------------------
{? _>=1 || {? type_of(_a)<>7 || _a:=null() ?} || _a:=null() ?};

_res:=0;
_b_prel:={? _a<>null() || _a || B_CHOICE.B_PREL ?};
B_CHOICE.cntx_psh();
B_CHOICE.index('B_PREL');
B_CHOICE.prefix(_b_prel);
_res:={? B_CHOICE.last() || B_CHOICE.ORDER || 0 ?}+1;
B_CHOICE.cntx_pop();
_res


\renumOrder
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: przenumerowuje pole ORDER po usunięciu rekordu
::   WE: [_a] - B_PREL.ref
::----------------------------------------------------------------------------------------------------------------------
B_CHOICE.cntx_psh();
B_CHOICE.index('B_PREL');
B_CHOICE.prefix(_a);
{? B_CHOICE.first()
|| _i:=0;
   {!
   |? _i+=1;
      B_CHOICE.ORDER:=_i;
      B_CHOICE.put(1);
      B_CHOICE.next()
   !}
?};
B_CHOICE.cntx_pop();
~~


\goDndOrder
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: włączenie renumeracji Drag&Drop dla pola ORDER tabeli B_CHOICE
::----------------------------------------------------------------------------------------------------------------------
B_CHOICE.cntx_psh();
_ref:=dnd_info('dest_record');
{? B_CHOICE.seek(_ref) || exec('zmien_lp','#dragdrop','ORDER','B_PREL') ?};
B_CHOICE.cntx_pop()


\endDndOrder
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: wyłączenie renumeracji Drag&Drop dla pola ORDER tabeli B_CHOICE
::   WE: _a - uchwyt okienka
::----------------------------------------------------------------------------------------------------------------------
B_CHOICE.dnd_sel(_a,,'records.B_CHOICE',"''");
~~


\legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Legenda w oknie warunkow
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','#B_ELE#01','#B_PORT#01','#B_PORT#02')


\fld_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed wyświetleniem pól w tabeli B_CHOICE (np. kolorowanie)
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:='';

{? _fld='FORMULA'
|| {? B_CHOICE.KIND<>'F'
   || _result:=exec('findfnv','#color')
   ?}
|? _fld='B_PORT' | _fld='OPERATOR' | _fld='VALUE'
|| {? B_CHOICE.KIND='F'
   || _result:=exec('findfnv','#color')
   ?}
?};

_result


\win_prev
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Tworzy okno tymczasowe zawierające elementy przed bramą
::   WE: _a - env - środowisko kreatora - wynik działania exec('env','#b_choice')
::   WY: STRING - uchwyt do okna
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_PREV;

_wer:=_tab.mk_sel(_env.tit_prev,'P',0,_env.wid_prev,1,1,,1);
_tab.win_fld(_wer,,'SYMBOL',,,20,,,'Symbol'@,0);
_tab.win_fld(_wer,,'NAME',,,20,,,'Nazwa'@,0);
_tab.win_fld(_wer,,'SYM_TYP',,,-10,,,'Typ [symbol]'@,0);
_tab.win_fld(_wer,,'REQUIRED',,,-5,,,'Wymagany?'@,0,,2,,"\'T\'","\'N\'");

_formula:=" _env:=CHOICE_CR;
            _result:='';
            _tab:=cur_tab(1,1);

            {? _tab.TYPE='B_PORT'
            ||
::             Ikona portu
               {? _tab.SYM_TYP='STRING' | _tab.SYM_TYP='NUMBER' | _tab.SYM_TYP='MEMO' | 1+_tab.SYM_TYP='_'
               || _result:='xwin16.png:28'
               || _result:='xwin16.png:8'
               ?}
            ||
               _b_ele:=exec('FindAndGet','#table',B_ELE,_tab.REF_BELE,,,null());
               _result:=exec('icon','#b_ele',_b_ele)
            ?};
            _result";
_tab.win_fml(_wer,,'SYMBOL',,'ICON_BEFORE',_formula);

_tab.win_act(_wer,,'Kolejność');

_formula:="exec('legenda','#b_choice')";
_tab.win_act(_wer,,'Formuła','Legenda'@@,,,_formula,,,,,,'L');

_tab.win_sel(_wer);
_wer


\win_next
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Tworzy okno tymczasowe zawierające elementy za brama
::   WE: _a - env - środowisko kreatora - wynik działania exec('#env','#b_choice')
::   WY: STRING - uchwyt do okna
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_NEXT;
_editable:=_env.EDITABLE;

_wer:=_tab.mk_sel(_env.tit_next,'P',0,_env.wid_next,1,1);
_tab.win_fld(_wer,,'SYM_PREL',,,30,,,'Symbol w procesie'@,0);
_tab.win_fld(_wer,,'SYM_BELE',,,18,,,'Symbol ogólny'@,0);
_tab.win_fld(_wer,,'DEFAULT',,,-3,,,'Domyślny'@,,,2,,"'T'","'N'");
_tab.win_fld(_wer,,'ORDER',,,-5,,,'Kolejność'@);

_formula:="exec('tab_next_rek','#b_choice',CHOICE_CR)";
_tab.win_act(_wer,,'Rekord',,,,_formula);

_formula:="
   _result:='';
   _tab:=cur_tab(1,1);

   _b_ele:=exec('FindAndGet','#table',B_ELE,_tab.REF_BELE,,,null());
   _result:=exec('icon','#b_ele',_b_ele);
   _result
";
_tab.win_fml(_wer,,'SYM_PREL',,'ICON_BEFORE',_formula);

{? _editable
|| _formula:="
      _tab:=cur_tab(1,1);
      B_CONN.cntx_psh();
      B_CONN.clear();
      {? B_CONN.seek(_tab.REF_CONN)
      || exec('default_action','#b_conn',B_CONN.ref());
         B_CONN.get();
         _tab.DEFAULT:=B_CONN.DEFAULT;
         _tab.put()
      ?};
      B_CONN.cntx_pop();
      ~~
   ";
   _tab.win_act(_wer,,'Formuła','Do&myślny'@@,,,_formula,,1,,,,'M')
?};
_tab.win_act(_wer,,'Kolejność');

_formula:="exec('legenda','#b_choice')";
_tab.win_act(_wer,,'Formuła','Legenda'@@,,,_formula,,,,,,'L');
_formula:="
   _tab:=cur_tab(1,1);
   _tab.cntx_psh();
   _ndx:=_tab.ndx_tmp(,,'ORDER',,);
   _ref:=dnd_info('dest_record');
   {? _tab.seek(_ref)
   || exec('zmien_lp','#dragdrop','ORDER',_ndx);
      B_CONN.cntx_psh();
      {? _tab.first()
      || {!
         |? B_CONN.clear();
            {? B_CONN.seek(_tab.REF_CONN)
            || B_CONN.ORDER:=_tab.ORDER;
               B_CONN.put(1)
            ?};
            _tab.next()
         !}
      ?};
      B_CONN.cntx_pop()
   ?};
   _tab.ndx_drop(_ndx);
   _tab.cntx_pop()
";

_tab.dnd_sel(_wer,,'records.'+_env.wid_next,_formula);

_tab.win_sel(_wer);
_wer


\grp_make
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Tworzy okienko grupowe konfiguratora warunków
::   WE: _a - _env - środowisko designera exec('#env','#b_choice')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_env.TAB_PREV;
{? _env.WIN_MAIN=''
||
   _grpbefor:="
         _env:=CHOICE_CR;
         _env.TAB_PREV.index(_env.IN_PREV1);
         _env.TAB_PREV.first();
         _env.TAB_PREV.tr_set(1,_env.WIN_PREV,1,0);
         grp_disp(_env.TAB_PREV,_env.WIN_PREV);
         _env.TAB_NEXT.index(_env.IN_NEXT4);
         _env.TAB_NEXT.first(); grp_disp(_env.TAB_NEXT,_env.WIN_NEXT,1);
         B_CHOICE.index('B_PREL'); B_CHOICE.first(); grp_disp(B_CHOICE,_env.WIN_CHOI);

         _opt:=exec('set_options_a','#desktop');
         _opt.FOCUS_RET:=0;
         _tab:=exec('elements_choice_table','#b_choice');
         exec('load','#desktop',_env.cid_dflt,'#'+_env.cid_dflt+'.dsk',_opt,,,,_tab,1);
         exec('load','#desktop',_env.cid_comm,'#'+_env.cid_comm+'.dsk',_opt,,,,_tab,1);
         exec('load','#desktop',_env.cid_num,'#'+_env.cid_num+'.dsk',_opt,,,,_tab,1);
         exec('load','#desktop',_env.cid_str,'#'+_env.cid_str+'.dsk',_opt,,,,_tab,1);
         exec('load','#desktop',_env.cid_join,'#'+_env.cid_join+'.dsk',_opt,,,,_tab,1);

::       Znikam przyciski 'Popraw'
         exec('set_visible','#desktop','',_env.cid_comm,_env.c_o_edit,0);
         exec('set_visible','#desktop','',_env.cid_num,_env.c_n_edit,0);
         exec('set_visible','#desktop','',_env.cid_str,_env.c_s_edit,0);
         exec('set_visible','#desktop','',_env.cid_join,_env.c_j_edit,0);

         {? _env.EDITABLE=0
         ||
            exec('set_enabled','#desktop','',_env.cid_comm,_env.c_o_add,0);
            exec('set_enabled','#desktop','',_env.cid_num,_env.c_n_add,0);
            exec('set_enabled','#desktop','',_env.cid_str,_env.c_s_add,0);
            exec('set_enabled','#desktop','',_env.cid_join,_env.c_j_add,0);
            ~~
         ?};
         ~~
      ";

   _title:=_env.tit_main;
   {? _env.EDITABLE=0
   || _title+=' — PODGLĄD'
   ?};

   _grp:=_tab.grp_make(_title,_grpbefor,_env.wid_main,1,1);

   _tab.grp_sel(_grp,_env.TAB_PREV,_env.WIN_PREV,,"exec('after_rfr_prev','#b_choice',CHOICE_CR)",,,,,,,,'maximized_with_title');

   _tab.grp_splt(_grp,'panel0','horizontal','dolny',20);
   _tab.grp_sel(_grp,B_CHOICE,_env.WIN_CHOI,,,,,,,,,,'maximized_with_title');

   _tab.grp_splt(_grp,'panel0','vertical','boczny');
   _env.WIN_CTR0:=exec('create','#desktop',_tab,_env.cid_dflt,_grp,10,50,,_env.tab_dflt);
   _tab.win_act(_env.WIN_CTR0,,'Formuła','Legenda'@@,,,"exec('legenda','#b_choice')",,,,,,'L');
   _env.WIN_CTR1:=exec('create','#desktop',_tab,_env.cid_comm,_grp,10,50,,_env.tab_comm);
   _tab.win_act(_env.WIN_CTR1,,'Formuła','Legenda'@@,,,"exec('legenda','#b_choice')",,,,,,'L');
   _env.WIN_CTR2:=exec('create','#desktop',_tab,_env.cid_num,_grp,10,50,,_env.tab_num);
   _tab.win_act(_env.WIN_CTR2,,'Formuła','Legenda'@@,,,"exec('legenda','#b_choice')",,,,,,'L');
   _env.WIN_CTR3:=exec('create','#desktop',_tab,_env.cid_str,_grp,10,50,,_env.tab_str);
   _tab.win_act(_env.WIN_CTR3,,'Formuła','Legenda'@@,,,"exec('legenda','#b_choice')",,,,,,'L');
   _env.WIN_CTR4:=exec('create','#desktop',_tab,_env.cid_join,_grp,10,50,,_env.tab_join);
   _tab.win_act(_env.WIN_CTR4,,'Formuła','Legenda'@@,,,"exec('legenda','#b_choice')",,,,,,'L');

   _tab.grp_splt(_grp,'boczny','vertical','boczny2');
   _tab.grp_sel(_grp,_env.TAB_NEXT,_env.WIN_NEXT,,"exec('after_rfr_next','#b_choice',CHOICE_CR)",,,,,,,,'maximized_with_title');

   _tab.win_sel(_grp);
   _env.WIN_MAIN:=_grp;
   ~~
?};
~~


\select4gate
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Pokazuje konfigurator warunków dla bram
::   WE: _a - B_PREL.ref - brama dla której pokazać
::       [_b] - INTEGER - czy dostępna edycja warunków 0/[1]
::----------------------------------------------------------------------------------------------------------------------
_b_prel:=_a;
_editable:=1;

{? var_pres('_b')=type_of(0)
|| _editable:=_b
?};

B_PREL.cntx_psh(); B_PREL.clear();
{? B_PREL.seek(_b_prel)
||
   {? exec('is_gate','#b_gate',B_PREL.B_ELE,,exec('kind_split','#b_gate'))>0
      | exec('is_gate','#b_gate',B_PREL.B_ELE,,exec('kind_merge','#b_gate'))>0
        & exec('is_gate','#b_gate',B_PREL.B_ELE,exec('type_complex','#b_gate'))>0
   ||
::    Sprawdzam czy można zablokować brame
      {? exec('lock','#b_gate',_b_prel,1)>0
      ||
         VAR_DEL.delete('CHOICE_CR');
         _env:=exec('env','#b_choice');
         _env.EDITABLE:=_editable;
         CHOICE_CR:=_env;
         _env.load4gat(B_PREL.ref());
         _env.select();
::       Odblokowuje porty
         exec('unlock_ports','#b_choice',_env);

::       Odblokowuje brame
         exec('unlock','#b_gate',_b_prel);

         VAR_DEL.delete('CHOICE_CR')
      ?}
   ||
::    Komunikat o niedostępnosci
      exec('kom_forbidden','#b_choice')
   ?}
?};
B_PREL.cntx_pop();
~~


\cond_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Tabela tymczasowa dla kontrolki _env.c_o_cond
::   WE:
::   WY: Uchwyt do tabeli
::----------------------------------------------------------------------------------------------------------------------
_env:=CHOICE_CR;

_Tab:=tab_tmp(1
   ,'NAME'  ,'STRING[100]' ,'Nazwa'
   ,'REF'   ,'STRING[16]'  ,'$B_COND.ref()');

_Tab.NAME:='';
_Tab.REF:='';
_Tab.add();

_act_uid:=_env.TAB_NEXT.SYM_BELE;
_env1:=obj_new('NEXT_ACT');
{? exec('next_act','#b_cond',_env1,_env.GATE)
|| _Act:=_env1.NEXT_ACT;
   _loop:=_Act.first();
   {!
   |? _loop
   |!
      {? _env.TAB_NEXT.REF_CONN=_Act.B_CONN || _act_uid:=_Act.ACT_UID ?};
      _loop:=_Act.next()
   !}

?};

_b_ele:=exec('FindAndGet','#table',B_ELE,_env.TAB_PREV.REF_BELE,,,null());

B_COND.index('B_ELE');
B_COND.prefix(_b_ele);
_loop:=B_COND.first();
{!
|? _loop
|!
   {? B_COND.ACT_UID='' | B_COND.ACT_UID=_act_uid
   || _Tab.NAME:=B_COND.NAME;
      _Tab.REF:=$B_COND.ref();
      _Tab.add()
   ?};
   _loop:=B_COND.next()
!};

_Tab


\cond_exec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Formuła do wykonania dla kontrolki _env.c_o_cond
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_env:=CHOICE_CR;

_cond:=exec('get_value','#desktop','',_env.cid_comm,_env.c_o_cond);
_name:='';
_formula:='';

{? _cond<>''
||
   _name:=exec('FindAndGet','#table',B_COND,_cond,,"B_COND.NAME",'');
   _formula:=exec('FindAndGet','#table',B_COND,_cond,,"B_COND.FORMULA",'')
?};

exec('set_value','#desktop','',_env.cid_comm,_env.c_o_name,_name);
exec('set_value','#desktop','',_env.cid_comm,_env.c_o_form,_formula)


\delete4prel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Usuwa wszystkie warunki dla podanego B_PRELa
::   WE: [_a] - B_PREL.ref lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(B_PREL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

B_PREL.cntx_psh();
{? _ref<>null()
|| B_PREL.prefix();
   {? B_PREL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| B_CHOICE.cntx_psh();
   B_CHOICE.index('B_PREL');
   B_CHOICE.prefix(B_PREL.ref());
   {? B_CHOICE.first()
   || {!
      |? _next:=0;
         _ref_nxt:=null();
         B_CHOICE.cntx_psh();
         {? B_CHOICE.next()
         || _ref_nxt:=B_CHOICE.ref()
         ?};
         B_CHOICE.cntx_pop();
         _what:=B_CHOICE.NAME;
         _can_continue:=exec('delete','#b_choice',B_CHOICE.ref());
         {? _can_continue=0
         || KOMM.add('Nie udało się usunąć warunku: %1'@[_what],2,,1)
         ?};

         {? _ref_nxt<>null()
         || _next:=B_CHOICE.seek(_ref_nxt)
         ?};
         _next>0
      !}
   || _can_continue:=0
   ?};
   B_CHOICE.cntx_pop()
?};
B_PREL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\elements_choice_table
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS:
::----------------------------------------------------------------------------------------------------------------------
_tab:=exec('elements_table','#desktop');
_tab.ID_SYS:='separator@choice'; _tab.NAME:='Właściwości warunku'@; _tab.add();
_tab.ID_SYS:='condition@choice'; _tab.NAME:='Warunek'@; _tab.add();
_tab.ID_SYS:='operator@choice'; _tab.NAME:='Operator'@; _tab.add();
_tab.ID_SYS:='formula@choice'; _tab.NAME:='Formuła'@; _tab.add();
_tab.ID_SYS:='value@choice'; _tab.NAME:='Wartość'@; _tab.add();
_tab.ID_SYS:='caps@choice'; _tab.NAME:='Uwzględniaj wielkość liter'@; _tab.add();
_tab.ID_SYS:='add@choice'; _tab.NAME:='Dołącz'@; _tab.add();
_tab


\create_port4gate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [19.02]
:: OPIS: Tworzy porty dynamiczne dla bram warunkowych
::   WE: _a - B_PROC.ref()
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;

_buffer:=exec('buffer','#b_choice');

B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_b_proc,'B_GATE');
_loop:=B_PREL.first();
{!
|? _loop
|!
   {? exec('is_gate_prel','#b_gate',B_PREL.ref(),exec('type_or','#b_gate'),exec('kind_split','#b_gate'))
      | exec('is_gate_prel','#b_gate',B_PREL.ref(),exec('type_xor','#b_gate'),exec('kind_split','#b_gate'))
   ||
      B_POCONN.cntx_psh();
      B_POCONN.index('PREL_DST');
      B_POCONN.prefix(B_PREL.ref());
      _loop:=B_POCONN.first();
      {!
      |? _loop
      |!
         _next:=null();
         {? B_POCONN.next() || _next:=B_POCONN.ref(); B_POCONN.prev() ?};
         exec('delete','#b_poconn',B_POCONN.ref());
         _loop:=B_POCONN.seek(_next)
      !};
      B_POCONN.cntx_pop();
      B_CHOICE.cntx_psh();
      B_CHOICE.index('B_PREL');
      B_CHOICE.prefix(B_PREL.ref());
      _loop:=B_CHOICE.first();
      {!
      |? _loop
      |!
         _buffer.get();
         B_CONN.cntx_psh();
         B_CONN.index('TO');
         B_CONN.prefix(B_PREL.B_PROC,B_PREL.ref());
         _loop:=B_CONN.first();
         {!
         |? _loop
         |!
            exec('route_prelPorts2gate','#b_proute',_buffer,B_CONN.ref());
            _loop:=B_CONN.next()
         !};
         B_CONN.cntx_pop();
         _loop:=B_CHOICE.next()
      !};
      B_CHOICE.cntx_pop()
   ?};
   _loop:=B_PREL.next()
!};
B_PREL.cntx_pop()


\fld_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Po redakcji pól w tabeli B_CHOICE
::----------------------------------------------------------------------------------------------------------------------
_afld:=cur_afld();
_result:=1;

{? _afld='OPERATOR'
|| exec('efld_opt','#b_choice')
?};

_result


\efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Opcje pól redagowanych w tabeli B_CHOICE
::----------------------------------------------------------------------------------------------------------------------
{? B_CHOICE.OPERATOR=exec('oper_empty','#b_choice',2) |
   B_CHOICE.OPERATOR=exec('oper_noempty','#b_choice',2)
|| _options:='enable=0'
|| _options:='enable=1'
?};
B_CHOICE.efld_opt('RED_STR',_options,,'VALUE');
B_CHOICE.efld_opt('RED_STR',_options,,'CASE_SEN');
~~


\combo_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Po redakcji pola Combo w kontrolce
::   WE: _a - _env - środowisko designera exec('env','#b_choice')
::       _b - _tab
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=_b;

{? _tab='Tekst'
||
:: Zakładka 'Tekst'
   _operator:=exec('get_value','#desktop','',_env.cid_str,_env.c_s_oper);
   {? _operator=exec('oper_empty','#b_choice',2) | _operator=exec('oper_noempty','#b_choice',2)
   || _visible:=0
   || _visible:=1
   ?};
   exec('set_visible','#desktop','',_env.cid_str,'value@choice',_visible);
   exec('set_visible','#desktop','',_env.cid_str,'txt@choice',_visible);
   exec('set_visible','#desktop','',_env.cid_str,'caps@choice',_visible)
?};
~~

:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 899853e7c2448835eba46bf44bd79a7db5fe839edef17645c1d00ea88386708eb7ece118fdd525676216e49142ae8ddbcae90b5dab429c80584cc8654a63ebb417a20c2efe4d9dc92545b33b6d3e7797413222731bc6ea19ee40bf6244f1ef015ffeb825271663608faa74ca548c47b16a825444323678625bfedcbabdd64350
