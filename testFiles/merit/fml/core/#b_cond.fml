:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b_cond.fml
:: Utworzony: 25.01.2016
:: Autor: AWI
::======================================================================================================================
:: Zawartość: Obsługa predefiniowanych warunków czynności
::======================================================================================================================


\import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wczytuje predefiniowane warunki czynności
::   WE: [_a] - [1]-z komunikatami 0-bez
::       [_b] - B_DOMAIN.ref - obszar którego czynności aktualizować, jeśli nie podane to wszystkie obszary
::       [_c] - INTEGER - [0]/1 - czy wyświetlać progress
::----------------------------------------------------------------------------------------------------------------------
_komm:={? var_pres('_a')>0 || _a || 1 ?};
{? _komm>0
|| KOMM.init(,,'Import uprawnień do danych czynności')
?};

_b_domain:=null();
{? var_pres('_b')=type_of(B_DOMAIN.ref())
|| _b_domain:=_b
?};

_progress:=0;
{? var_pres('_c')=type_of(0)
|| _progress:=_c
?};

B_DOMAIN.index('SYMBOL');
B_DOMAIN.prefix();
B_ACTION.index('B_DOMAIN');

{? _b_domain=null()
||
:: Wszystkie obszary
   {? B_DOMAIN.first()
   ||
      _lp:=1;
      {? _progress>0
      || FUN.prg_start(B_DOMAIN.size(),'Import predefiniowanych warunków bram...'@,1,,1)
      ?};
      {!
      |? {? _progress>0
         || FUN.prg_next()
         ?};
         B_ACTION.prefix('T',B_DOMAIN.ref());
         {? B_ACTION.first()
         || {!
            |? {? B_ACTION.MANUAL<>'T'
               || exec('imp4act','#b_cond')
               ?};
               B_ACTION.next()
            !}
         ?};
         B_DOMAIN.next()
      !};
      {? _progress>0
      || FUN.prg_stop()
      ?}
   ?}
||
:: Wybrany obszar
   B_ACTION.prefix('T',_b_domain);
   {? B_ACTION.first()
   ||
      {? _progress>0
      || FUN.prg_start(B_ACTION.size(),'Import predefiniowanych warunków bram...'@,1,,1)
      ?};
      {!
      |? {? _progress>0
         || FUN.prg_next()
         ?};
         {? B_ACTION.MANUAL<>'T'
         || exec('imp4act','#b_cond')
         ?};
         B_ACTION.next()
      !};
      {? _progress>0
      || FUN.prg_stop()
      ?}
   ?}
?};
{? _komm & ~KOMM.empty()
|| KOMM.select()
?}


\imp4act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wczytuje formuły na PARSES
::   WE: [_a] - [1]-z komunikatami 0-bez
::----------------------------------------------------------------------------------------------------------------------
_b_ele:=B_ACTION.B_ELE;
_fun_g:='main';
_plik:=exec('filename','#b_action');
{? exec('is_fun','#file',_plik,_fun_g)
|| B_COND.cntx_psh();
   B_COND.index('B_ELE');
   B_COND.prefix(_b_ele);
   _Tab:=tab_tmp(1
      ,'WSK',  'INTEGER',     'Lp'
      ,'TXT',  'STRING[10]',  'Tekst');
   _fun_str:=exec('string_fun','#file',_plik,_fun_g,'::# condition=');
   _split:=spli_str(_fun_str,'\n');

   B_COND.prefix(_b_ele);
   _loop:=B_COND.first();
   {!
   |? _loop
   |!
      _loop:=B_COND.del()
   !};

   {? obj_len(_split)>0
   || var:=obj_new('name','act_uid','auto','formula');
      {! _it:=1..obj_len(_split)
      |!
         _wiersz:=_split[_it];
         {? _wiersz<>'\n' & _wiersz<>''
         ||
            {! _ii:=1..obj_len(var) |! var[_ii]:='' !};

            _Tab.TXT:='act_uid='; _wsk:=_wiersz*_Tab.TXT-1; _Tab.WSK:=_wsk; _Tab.add();
            _Tab.TXT:='auto=';    _wsk:=_wiersz*_Tab.TXT-1; _Tab.WSK:=_wsk; _Tab.add();
            _Tab.TXT:='formula='; _wsk:=_wiersz*_Tab.TXT-1; _Tab.WSK:=_wsk; _Tab.add();
            _fld:='name';
            _loop:=_Tab.first();
            {!
            |? _loop
            |!
               _wsk:=_wiersz*_Tab.TXT-1; _var:=form(_wsk+_wiersz)-1; _wiersz:=_wsk++_Tab.TXT-_wiersz;
               ($('var.'+_fld))():=_var;
               _fld:=_Tab.TXT-1;
               _loop:=_Tab.next()
            !};
            ($('var.'+_fld))():=_wiersz;
            {? var.name<>''
            ||
               _put:=B_COND.find_key(var.name,);
               B_COND.B_ELE:=_b_ele;
               B_COND.NAME:=var.name;
               B_COND.ACT_UID:=var.act_uid;
               B_COND.AUTO:=var.auto;
               B_COND.FORMULA:=var.formula;
               {? _put || B_COND.put(1) || B_COND.add(1) ?}
            ?};
            _loop:=_Tab.first();
            {!
            |? _loop
            |! _loop:=_Tab.del()
            !}
         ?}
      !};
      VAR_DEL.delete('var')
   ?};
:: Warunki dla czynności z własnością LOOP
   _name:=exec('str_continue_loop','#b_cond');
   _put:=B_COND.find_key(_name,);
   {? B_ACTION.LOOP='T'
   || B_COND.B_ELE:=_b_ele;
      B_COND.NAME:=_name;
      B_COND.ACT_UID:=B_ACTION.UID;
      B_COND.AUTO:='T';
      B_COND.FORMULA:=$"_a.LOOP='T'";
      {? _put || B_COND.put(1) || B_COND.add(1) ?}
   |? _put
   || B_COND.del()
   ?};
   _name:=exec('str_end_loop','#b_cond');
   _put:=B_COND.find_key(_name,);
   {? B_ACTION.LOOP='T'
   || B_COND.B_ELE:=_b_ele;
      B_COND.NAME:=_name;
      B_COND.ACT_UID:='';
      B_COND.AUTO:='N';
      B_COND.FORMULA:=$"_a.LOOP<>'T'";
      {? _put || B_COND.put(1) || B_COND.add(1) ?}
   |? _put
   || B_COND.del()
   ?};
   B_COND.cntx_pop()
?}


\create_cond4gate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Automatycznie tworzy warunki na bramach rozdzielających OR, XOR.
::   WE: _a - B_PROC.ref()
::       _b - B_PREL.ref()
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_b_proc:={? var_pres('_a')=type_of(null()) || _a || null() ?};
_b_prel:={? var_pres('_b')=type_of(null()) || _b || null() ?};

{? _b_proc=null() & _b_prel=null() || return() ?};

{? _b_prel
|| _b_ele:=exec('FindAndGet','#table',B_PREL,_b_prel,,"B_ELE",null());
   {? exec('is_gate','#b_gate',_b_ele,,exec('kind_split','#b_gate'))<1
         |
      (exec('is_gate','#b_gate',_b_ele,exec('type_or','#b_gate'))<1
       & exec('is_gate','#b_gate',_b_ele,exec('type_xor','#b_gate'))<1)

   || return()
   ?};
   _b_proc:=exec('FindAndGet','#table',B_PREL,_b_prel,,"B_PROC",null())
?};

{? _b_proc=null() || return() ?};

B_PREL.cntx_psh();

{! _ii:=1 .. {? _b_prel || 1 || 2 ?}
|!
   {? _b_prel=null()
:: bramy w procesie
   || _type:={? _ii=1 || exec('type_or','#b_gate') || exec('type_xor','#b_gate') ?};
      _b_ele:=exec('FindInSet','#table','B_GATE','TYP',exec('kind_split','#b_gate'),_type,"B_GATE.B_ELE",,,null());
      B_PREL.index('PREL');
      B_PREL.prefix(_b_proc,_b_ele)
:: wybrana brama
   || B_PREL.index('UID');
      B_PREL.prefix(_b_proc,exec('FindAndGet','#table',B_PREL,_b_prel,,"UID",''))
   ?};
   _loop:=B_PREL.first();
   {!
   |? _loop
   |!
::    środowisko
      {? var_pres('_env')=type_of(obj_new('a')) || obj_del(_env) ?};
      _env:=exec('env','#b_cond');
::    wyznaczenie warunków z czynności przed bramą
      exec('prev_cond','#b_cond',_env,B_PREL.ref());
::    wyznaczenie dla każdej ścieżki za bramą czynności pierwszej
      exec('next_act','#b_cond',_env,B_PREL.ref());
::    utworzenie warunków dla bramy
      exec('update_cond4gate','#b_cond',_env,B_PREL.ref());
      _loop:=B_PREL.next()
   !}
!};

B_PREL.cntx_pop()


\env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Środowisko mechanizmu wyznaczania warunków dla bramy rozdzielającej OR, XOR
::   WE:
::   WY: uchwyt do środowiska
::----------------------------------------------------------------------------------------------------------------------
obj_new('PREV_COND','NEXT_ACT')


\prev_cond
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wyznaczenie warunków zdefiniowanych w czynnościach poprzedzających bramę ...
::   WE: _a - środowisko
::       _b - B_PREL.ref() - wyjściowy element procesu
::       _c - B_PREL.ref() - aktualnie przetwarzany element procesu
::       _d - B_PREL.ref()-y - odwiedzone elementy procesu
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
           _env:=_a;
   _b_prel_root:=_b;
        _b_prel:={? var_pres('_c')=type_of(null()) || _c   || null() ?};
_b_prel_visited:={? var_pres('_d')=type_of('')     || _d   || ''     ?};
         _level:={? var_pres('_e')=type_of(1)      || _e+1 || 0      ?};

{? var_pres('PREV_COND',_env)<100
|| _env.PREV_COND:=tab_tmp(2
      ,'ACT_UID'  ,'STRING[12]'  ,'B_ACTION.UID'
      ,'LEVEL'    ,'INTEGER'     ,'Poziom zagłębienia'
      ,'B_COND'   ,'STRING[16]'  ,'$B_COND.ref()'
      ,'B_PREL'   ,'STRING[16]'  ,'$B_PREL.ref()')
?};

_result:=0;
_first_call:=_b_prel=null();
{? _first_call || _b_prel:=_b_prel_root ?};
_can_continue:=1;
B_PREL.cntx_psh(); B_PREL.clear();
B_COND.cntx_psh();
B_ELE.cntx_psh();
B_COND.index('AUTO');
B_CONN.cntx_psh();

{? B_PREL.seek(_b_prel)
||
:: Podczytanie B_ELE
   B_PREL.B_ELE();

:: Analiza wszystkich elementów poprzedzających
   B_ELE.cntx_psh();
   B_CONN.index('TO');
   B_CONN.prefix(B_PREL.B_PROC,B_PREL.ref());
   {? B_CONN.first()
   || {!
      |?
         {? B_CONN.FROM<>_b_prel_root & (_b_prel_visited*($B_CONN.FROM))=0
::       Poszukujemy wcześniejszych czynności !!! REKRURENCJA !!!
         || exec('prev_cond','#b_cond',_env,_b_prel_root,B_CONN.FROM,_b_prel_visited+$_b_prel,_level)
         ?};
         B_CONN.next()
      !}
   ?};
   B_ELE.cntx_pop();

:: Ładowanie portów czynności i zdarzeń przechwytujących
   {? _first_call=0
         &
      B_ELE.CLASS='B_ACTION'
   || _Tab:=_env.PREV_COND;
      B_COND.prefix(B_ELE.ref(),'T');
      _loop:=B_COND.first();
      {!
      |? _loop
      |!
         _Tab.ACT_UID:=B_COND.ACT_UID;
         _Tab.LEVEL:=_level;
         _Tab.B_COND:=$B_COND.ref();
         _Tab.B_PREL:=$B_PREL.ref();
         _can_continue:=_Tab.add();
         _loop:=_can_continue & B_COND.next()
      !}
   ?}
?};
B_CONN.cntx_pop();
B_ELE.cntx_pop();
B_COND.cntx_pop();
B_PREL.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\next_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wyznaczenie dla każdej ścieżki za bramą ... czynności pierwszej
::   WE: _a - środowisko
::       _b - B_PREL.ref() - wyjściowy element procesu
::       _c - B_PREL.ref() - aktualnie przetwarzany element procesu
::       _d - B_PREL.ref()-y - odwiedzone elementy procesu
::       _e - B_CONN.ref() - połączenie bezpośrednio za bramą
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
           _env:=_a;
   _b_prel_root:=_b;
        _b_prel:={? var_pres('_c')=type_of(null()) || _c   || null() ?};
_b_prel_visited:={? var_pres('_d')=type_of('')     || _d   || ''     ?};
         _level:={? var_pres('_e')=type_of(1)      || _e+1 || 0      ?};
          _conn:={? var_pres('_f')=type_of(null()) || _f   || null() ?};

{? var_pres('NEXT_ACT',_env)<100
|| _env.NEXT_ACT:=tab_tmp(1
      ,'B_CONN'   ,'STRING[16]'  ,'$B_CONN.ref()'
      ,'ACT_UID'  ,'STRING[12]'  ,'B_ACTION.UID'
      ,'B_PREL'   ,'STRING[16]'  ,'$B_PREL.ref()')
?};
_Tab:=_env.NEXT_ACT;

_result:=0;
_first_call:=_b_prel=null();
{? _first_call || _b_prel:=_b_prel_root ?};
_can_continue:=1;
B_PREL.cntx_psh(); B_PREL.clear();
B_COND.cntx_psh();
B_ELE.cntx_psh();
B_COND.index('B_ELE');
B_CONN.cntx_psh();

{? B_PREL.seek(_b_prel)
||
:: Podczytanie B_ELE
   B_PREL.B_ELE();

:: Analiza wszystkich elementów poprzedzających
   B_ELE.cntx_psh();
   B_CONN.index('FROM');
   B_CONN.prefix(B_PREL.B_PROC,B_PREL.ref());
   {? B_CONN.first()
   || {!
      |?
         {? _level=0 || _conn:=B_CONN.ref() ?};
         {? _level=0 & B_CONN.DEFAULT='T'
::       pomijamy analizę połączenia domyślnego, dla niego nie definiuje się warunków
         || 1
         |? B_CONN.TO().CLASS='B_ACTION'
               &
            exec('FindInSet','#table','B_ACTION','B_ELE',B_PREL.B_ELE,,"B_ACTION.MANUAL",,,'')<>'T'
::       zapamiętanie czynności dla połączenia
         || _Tab.B_CONN:=$_conn;
            _Tab.ACT_UID:=exec('FindInSet','#table','B_ACTION','B_ELE',B_PREL.B_ELE,,"B_ACTION.UID",,,'');
            _Tab.B_PREL:=$exec('FindAndGet','#table',B_CONN,_conn,,"B_CONN.TO",null());
            _can_continue:=_Tab.add()
         |? B_CONN.TO<>_b_prel_root & (_b_prel_visited*($B_CONN.TO))=0
::       Poszukujemy następnych czynności !!! REKRURENCJA !!!
         || _conn:={? _level=0 || B_CONN.ref() || _conn ?};
            exec('next_act','#b_cond',_env,_b_prel_root,B_CONN.TO,_b_prel_visited+$_b_prel,_level,_conn)
         ?};
         B_CONN.next()
      !}
   ?};
   B_ELE.cntx_pop();

:: Usuwanie połączeń dla których ustalono więcej niż jedną czynność
   {? _first_call
   || _conn:='';
      _conn2del:='';
      _loop:=_Tab.first();
      {!
      |? _loop
      |!
         {? _conn=_Tab.B_CONN
::       więcej niż jedna czynność
         || {? _conn2del*_Tab.B_CONN=0 || _conn2del+=_Tab.B_CONN ?}
         ?};
         _conn:=_Tab.B_CONN;
         _loop:=_Tab.next()
      !};
      _Tab.cntx_psh();
      {!
      |? _conn:=16+_conn2del; _conn<>''
      |!
         _conn2del:=16-_conn2del;
         _Tab.prefix(_conn);
         _loop:=_Tab.first();
         {!
         |? _loop
         |!
            _loop:=_Tab.del()
         !}
      !};
      _Tab.cntx_pop()
   ?}
?};
B_CONN.cntx_pop();
B_ELE.cntx_pop();
B_COND.cntx_pop();
B_PREL.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\update_cond4gate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Aktualizuje automatyczne warunki na bramie
::   WE: _env - exec('env','#b_cond')
::       _b - B_PREL.ref() - brama OR, XOR
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   _env:=_a;
_b_prel:=_b;

_do_state:=do_state();

{? _do_state=0 || do() ?};

:: Usunięcie istniejących automatycznie utworzonych warunków
B_CHOICE.index('B_PREL');
B_CHOICE.prefix(_b_prel);
_loop:=B_CHOICE.first();
{!
|? _loop
|!
   _loop:={? B_CHOICE.AUTO='G' || B_CHOICE.del() || B_CHOICE.next() ?}
!};

_Cond:=_env.PREV_COND;
_Act:=_env.NEXT_ACT;

_buffer:=exec('buffer','#b_choice');

B_CHOICE.cntx_psh();
B_CHOICE.index('B_CONN');
_loop:=_Act.first();
{!
|? _loop
|!
   _del:=0;
   _conn:=exec('FindAndGet','#table',B_CONN,_Act.B_CONN,,,null());
   B_CHOICE.index('B_CONN');
   B_CHOICE.prefix(_conn);
   _loop:=B_CHOICE.first();
   {!
   |? _loop
   |!
      _del:=B_CHOICE.AUTO<>'G';
      _loop:=_del=0 & B_CHOICE.next()
   !};
   _loop:={? _del || _Act.del() || _Act.next() ?}
!};
B_CHOICE.cntx_pop();

_loop:=_Act.first();
{!
|? _loop
|!
   _Cond.prefix(_Act.ACT_UID);
   _loop:=_Cond.first();
   {!
   |? _loop
   |!
      _buffer.NAME:=exec('FindAndGet','#table',B_COND,_Cond.B_COND,,"NAME",'');
      _buffer.B_PREL:=_b_prel;
      _buffer.B_CONN:=exec('FindAndGet','#table',B_CONN,_Act.B_CONN,,,null());
      _buffer.VALUE:='';
      _buffer.B_PORT:=null();
      _buffer.FORMULA:=exec('FindAndGet','#table',B_COND,_Cond.B_COND,,"FORMULA",'');
      _buffer.OPERATOR:='';
      _buffer.KIND:='F';
      _buffer.PREL_SRC:=exec('FindAndGet','#table',B_PREL,_Cond.B_PREL,,,null());
      _buffer.PREL_DST:=exec('FindAndGet','#table',B_CONN,_Act.B_CONN,,"B_CONN.TO",null());
      _buffer.CASE_SEN:='';
      _buffer.AUTO:='G';
      _buffer.ORDER:=exec('bl_order','#b_choice',B_CHOICE.B_PREL);

      _continue:=1;

      {? _buffer.NAME<>exec('str_continue_loop','#b_cond')
         | _Cond.LEVEL=1
      ||
         _continue:=exec('add','#b_choice',_buffer);

         {? _continue
         ||
::          Tworzymy trasy portów wyjściowych elementu źródłowego do bramy
            B_CONN.cntx_psh();
            B_CONN.index('TO');
            B_CONN.prefix(exec('FindAndGet','#table',B_PREL,_b_prel,,"B_PREL.B_PROC"),_b_prel);
            _loop:=B_CONN.first();
            {!
            |? _loop
            |!
               exec('route_prelPorts2gate','#b_proute',_buffer,B_CONN.ref());
               _loop:=B_CONN.next()
            !};
            B_CONN.cntx_pop()
         ?}
      ?};

      _loop:=_continue & _Cond.next()
   !};
   _loop:=_Act.next()
!};

{? _do_state=0 || end() ?}


\str_continue_loop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: tekst - 'Kontynuacja pętli'
::   WE:
::   WY: 'Kontynuacja pętli'
::----------------------------------------------------------------------------------------------------------------------
'Kontynuacja pętli'


\str_end_loop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: tekst - 'Koniec pętli'
::   WE:
::   WY: 'Koniec pętli'
::----------------------------------------------------------------------------------------------------------------------
'Koniec pętli'

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:08 cc14ae4b2e9d8c249ee59214cabd5474ac5cbacd4c036a0c336446c163614f2cc4fcd4f0a76738171528dc0fed72af81e60042e1a7f002424666bb436fa73d07457de89ce065bd4b274c5d43e0de763f322fbb02a64e8d229dcc2a2870feb52ed8e63bfb867ed59d263fb5c1e182dc21ccdcb19c41d0cf4c53570263d951352f
