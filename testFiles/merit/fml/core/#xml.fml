:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #xml.fml
:: Utworzony: 28.01.2015
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły do obsługi plików XML
::======================================================================================================================


\get_cfg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [GS] [2008]
:: OPIS: Definicja i inicjalizacja obiektu ułatwiajacego wywoływanie aplikacji Java
::       Obiekt tworzy plik XML w którym można przekazać różne parametry
::       UWAGA! ze względu na czysto techniczny charakter obiektu (wykorzystanie wyłącznie przez programistów) nie jest
::              sprawdzana poprawność jego utworzenia i wykorzystania
::   WE: _a - nazwa aplikacji (bez rozszerzenia)
::       _b - nazwa klasy obiektu konfiguracji w aplikacji Java
::       [_c] - 0 / 1 ściągac common.jar na terminal czy nie (domyslnie 1)
::       [_d] - 0 / [1] - 0 - uruchamiać po stronie serwera
::                        1 - uruchamiać po stronie klienta
:;       [_e] - STRING - nazwa klasy głównej
::   WY: alias do obiektu obslugujacego konfiguracje
::  OLD: \get_cfg/skid_jar.fml
::  TAG: <PUBLICZNA><XML>
:: ~OST: INBLGET,INFCOPY,INFEXISTS,INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_c') <> type_of(0) || _common:=1 || _common:=_c ?};
{? var_pres('_d') <> type_of(0) || _thin:=1 || _thin:=_d ?};
{? var_pres('_e') <> type_of('') || _mainclass:='' || _mainclass:=_e ?};

{? var_pres('JAR_CFG',@.CLASS)>=100
|| return(obj_new(@.CLASS.JAR_CFG,_a,_b,_common,_thin,_mainclass))
?};

obj_decl('JAR_CFG',

   obj_fld('JAVA_APP',''),
   obj_fld('JAVA_OBJ',''),
   obj_fld('JAVA_CFG',''),
   obj_fld('JAVA_MAINCLASS',''),
   obj_fld('UI_SCALE',1),

   obj_fld('THIN',1),
   obj_fld('TMP_DIR',1),
   obj_fld('TMP_DIR_OBJ',1),

::  utworzenie obiektu
::  wymagane argumenty:
::  _b - nazwa aplikacji (bez rozszerzenia)
::  _c - nazwa klasy obiektu konfiguracji
::  [_d] - 0 / 1 sciagac common.jar na terminal czy nie
::  [_e] - 0 / 1 cieńki czy gruby klient
::  [_f] - STRING - nazwa klasy głównej
::  [_g] - INTEGER - czy możliwe skalowanie UI
   obj_meth('__init',"
      .JAVA_APP:=_b;
      .JAVA_OBJ:=_c;
      _common:=1;
      {? _>3
      || _common:=_d
      ?};
      {? _common
      || .std_lib()
      ?};
      .THIN:=1;
      .TMP_DIR:='';
      .TMP_DIR_OBJ:=~~;
      {? _>4 & _e=0
      || .THIN:=0
      ?};
      .JAVA_MAINCLASS:='';
      {? var_pres('_f')=type_of('')
      || .JAVA_MAINCLASS:=_f
      ?};
      .UI_SCALE:=1;
      {? var_pres('_g')=type_of(0)
      || .UI_SCALE:=_g
      ?};
      ~~
   "),

::  kopiuje standardowy zestaw plikow
   obj_meth('std_lib',"
      .add_blob('common.jar')
   "),

::  uruchamia aplikacje
   obj_meth('execute',"
      {? var_pres('_a')=type_of('') || _param1:=_a || _param1:='' ?};
      {? var_pres('_b')=type_of('') || _param2:=_b || _param2:='' ?};
      {? var_pres('_c')=type_of('') || _param3:=_c || _param3:='' ?};
      _result:=.executeR10(_param1,_param2,_param3);
      _result
   "),

   obj_meth('executeR10',"
      {? var_pres('_a')=type_of('') || _param1:=_a || _param1:='' ?};
      {? var_pres('_b')=type_of('') || _param2:=_b || _param2:='' ?};
      {? var_pres('_c')=type_of('') || _param3:=_c || _param3:='' ?};
      _result:=0;

      {? 1+_param1='""' & _param1+1='""'
      || _param1:=1-_param1-1
      ?};
      {? 1+_param2='""' & _param2+1='""'
      || _param2:=1-_param2-1
      ?};
      {? 1+_param3='""' & _param3+1='""'
      || _param3:=1-_param3-1
      ?};
      {? .THIN
      || {? exec('cli_functions','#system')=0
         || FUN.emsg(exec('indevice_nacc_msg','#system'));
            return(0)
         ?};
         _separator:=exec('sep','#file');
         _console:=exec('get','#params',1200,,exec('operatorUser','#users'));
         _ram:=exec('get','#params',1201,,exec('operatorUser','#users'));
         _wait:=exec('get','#params',1202,,exec('operatorUser','#users'));

         _options:='runOnAppServer=0,';
         _params:=~~;

         {? _console='T'
         || _options+='console=1,'
         ||
::          tylko jeżeli nie ma konsoli przekierowujemy standardowe wyjścia do pliku
            _options+='stderr=%1_stderr.log,stdout=%1_stdout.log,'[.JAVA_APP]
         ?};
         {? _wait='T'
         || _options+='wait=1,'
         ?};
         _tmp_dir:=tmp_dir();

         {? app_info('is_4k') & .JAVA_MAINCLASS<>'' & .UI_SCALE>0
         || _options+='4k=1,';
            _params:=obj_new('encoding','xmx','path','mainclass','p1','p2','p3');
            _params.encoding:='-Dfile.encoding=utf-8';
            _params.xmx:='-Xmx'+$_ram+'M';
            _params.path:='-Djava.class.path=\"'+tmp_dir()+_separator+.JAVA_APP+'.jar\"';
            _params.mainclass:=.JAVA_MAINCLASS;
            _params.p1:=_param1;
            _params.p2:=_param2;
            _params.p3:=_param3;
            ~~
         || _params:=obj_new('encoding','uiscale','xmx','jar','jarfile','p1','p2','p3');
            _params.encoding:='-Dfile.encoding=utf-8';
            {? .UI_SCALE=0
            || _params.uiscale:='-Dsun.java2d.uiScale=1'
            || _params.uiscale:=''
            ?};
            _params.xmx:='-Xmx'+$_ram+'M';
            _params.jar:='-jar';
            _params.jarfile:=_tmp_dir+_separator+.JAVA_APP+'.jar';
            _params.p1:=_param1;
            _params.p2:=_param2;
            _params.p3:=_param3;
            ~~
         ?};
         _result:=jexec(_tmp_dir,_options,_params);
         ~~
      ||
         _separator:=exec('sep','#file',2);
         _options:='runOnAppServer=1,wait=1,stderr=%1_stderr.log,stdout=%1_stdout.log'[.JAVA_APP];
         _jarpath:=.tmp_dir()+_separator+.JAVA_APP+'.jar';
         _result:=jexec(.tmp_dir(),_options,'-Dfile.encoding=utf-8','-jar',_jarpath,_param1,_param2,_param3)
      ?};
      _result
   "),

::  pobiera plik konfiguracyjny
   obj_meth('getXML',"

      _xml_name:=.JAVA_APP+'.xml';
      {? var_pres('_a')=type_of('')
      || {? _a<>''
         || _xml_name:=_a
         ?}
      ?};
      _xml_file:=fopen(_xml_name,'uw',1);
      {? _xml_file>0
      || fwrite(_xml_file,.prolog());
         fwrite(_xml_file,.JAVA_CFG);
         fwrite(_xml_file,.epilog());
         fclose(_xml_file);
         {? .add_file(_xml_name)
         || ferase(_xml_name,1)
         || FUN.emsg('\nBłąd dostępu do pliku %1\n'@[_xml_name]);
            return(0)
         ?}
      || FUN.emsg('\nBłąd dostępu do pliku %1\n'@[_xml_name]);
         return(0)
      ?};
      return(1)
   ",type_of('')),

   obj_meth('getXML',".getXML('')",-1),


::  dodaje parametr
::  wymagane argumenty:
::  _a - nazwa parametru (STRING)
::  _b - typ parametru (STRING)
::  _c - wartosc parametru (STRING)
::  wstawia przekazany tekst doslownie
   obj_meth('add_param',"
      .add_param(_a,_b,_c,0)
   ",type_of(''),type_of(''),type_of(''),-1),


::  dodaje parametr
::  wymagane argumenty:
::  _a - nazwa parametru (STRING)
::  _b - typ parametru (STRING)
::  _c - wartosc parametru (STRING)
::  _d - 0 - wstawia tekst doslownie, 1 - wstawia tekst w znacznikach <![CDATA[ ]]>
   obj_meth('add_param',"
      _name:=_a;
      _type:=_b;
      _value:=_c;
      _cdata:=_d;

      .JAVA_CFG+=
         '<void property=\"'+_name+'\">'+
         '<'+_type+'>'+{? _cdata || '<![CDATA[' || '' ?}+_value+{? _cdata || ']]>' || '' ?}+'</'+_type+'>'+
         '</void>'
   ",type_of(''),type_of(''),type_of(''),type_of(0)),


::  dodaje parametr
::  wymagane argumenty:
::  _a - nazwa parametru (STRING)
::  _b - typ parametru (STRING)
::  _c - wartosc parametru (tablica)
::  _d - 0 - dodaje do xml jako Array, 1 - dodaje do xml jako Vector
::  wstawia przekazany tekst doslownie
   obj_meth('add_param',"
      .add_param(_a,_b,_c,_d,0)
   ",type_of(''),type_of(''),type_of(obj_new(1)),type_of(0),-1),

::  dodaje parametr
::  wymagane argumenty:
::  _a - nazwa parametru (STRING)
::  _b - typ parametru (STRING)
::  _c - wartosc parametru (tablica)
::  _d - 0 - dodaje do xml jako Array, 1 - dodaje do xml jako Vector
::  _e - 0 - wstawia teksty doslownie, 1 - wstawia teksty w znacznikach <![CDATA[ ]]>
   obj_meth('add_param',"
      _name:=_a;
      _type:=_b;
      _array:=_c;
      _size:=obj_len(_array);
      _mode:=_d;
      _cdata:=_e;

      .JAVA_CFG+='<void property=\"'+_name+'\">';
      {? _mode=0
      || .JAVA_CFG+=exec('array','#xml',_type,_array,1,_cdata)
      ?};
      {? _mode=1
      || .JAVA_CFG+=exec('vector','#xml',_type,_array,2,_cdata)
      ?};
      .JAVA_CFG+='</void>'
   ",type_of(''),type_of(''),type_of(obj_new(1)),type_of(0),type_of(0)),

::  folder tymczasowy na grubym kliencie
   obj_meth('tmp_dir',"
      {? .TMP_DIR=''
      ||
         {? .THIN
         || {? exec('cli_functions','#system')
            || .TMP_DIR:=tmp_dir()
            || FUN.emsg(exec('indevice_nacc_msg','#system'))
            ?}
         || .TMP_DIR_OBJ:= fmk_tmp_dir(0);
            {? type_of(.TMP_DIR_OBJ)<>type_of(~~)
            || .TMP_DIR:=.TMP_DIR_OBJ.get_path()
            ?}
         ?}
      ?};
      .TMP_DIR
   "),

::  kopiuje plik do miejsca wywolania aplikacji
::  wymagane argumenty:
::  _a - nazwa pliku
::  _b - czy NIE wyswietlac komunikatu bledu (<>0)
   obj_meth('add_file',"
      {? {? .THIN
         || {? exec('cli_functions','#system')
            || _separator:=exec('sep','#file');
               ~fcopy(_a,'@'+tmp_dir()+_separator+_a,1,0,1,1)
            || FUN.emsg(exec('indevice_nacc_msg','#system'));
               1
            ?}
         || _separator:=exec('sep','#file',2);
            ~fcopy(_a,.tmp_dir()+_separator+_a,1,0,1)
         ?}
      || {? _b=0 || FUN.emsg('\nBłąd dostępu do pliku %1\n'@[_a]) ?}; 0
      || 1
      ?}
   ",type_of(''),type_of(0)),

::  kopiuje plik do miejsca wywolania aplikacji
::  wymagane argumenty:
::  _a - nazwa pliku
   obj_meth('add_file',"
      .add_file(_a,0)
   ",type_of('')),

::  kopiuje plik z BLOBa do miejsca wywolania aplikacji
::  wymagane argumenty:
::  _a - identyfikator BLOBa
::  _b - czy NIE wyswietlac komunikatu bledu (<>0)
   obj_meth('add_blob',"
      {? sys_name(0)='U_LINUX'
      || _separator:='/'
      || _separator:='\\\\'
      ?};

      {? exec('cli_functions','#system')=0
      || FUN.emsg(exec('indevice_nacc_msg','#system'));
         return(0)
      ?};

      _result:=0;
      exec('add','#blob',_a,_b);
      SKID_BLB.index('ID');
      SKID_BLB.prefix(_a,_a);
      {? SKID_BLB.first()
      || _name:=SKID_BLB.bl_info('BLOB','NAME');
         {? fexists('@'+tmp_dir()+_separator+_name,0)=0
         || {? ~SKID_BLB.bl_get('BLOB','@'+tmp_dir()+_separator+_name,0)
            || {? _b=0 || FUN.emsg('\nBłąd dostępu do pliku %1\n'@[_name]) ?};
               _result:=0
            || _result:=1
            ?}
         || _result:=0
         ?}
      ||
         {? _b=0 || FUN.emsg('\nBrak BLOBa o identyfikatorze %1'@[_a]) ?};
         _result:=0
      ?};
      _result
   ",type_of(''),type_of(0)),

::  kopiuje plik do miejsca wywolania aplikacji
::  wymagane argumenty:
::  _a - identyfikator BLOBa
   obj_meth('add_blob',"
      .add_blob(_a,0)
   ",type_of('')),

::  zwraca fraze otwierajaca plik parametrow
   obj_meth('prolog',"exec('prolog','#xml',.JAVA_OBJ)"),

::  zwraca fraze zamykajaca plik parametrow
   obj_meth('epilog',"exec('epilog','#xml')")
);

obj_new(@.CLASS.JAR_CFG,_a,_b,_common,_thin,_mainclass)


\property
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca XMLowa reprezentacje parametru prostego
::   WE: _a - STRING - nazwa pola po stronie java
::       _b - STRING - typ parametru po stronie java
::       _c - STRING - wartosc parametru
::       [_d] - STRING - wcięcie które dodawać dla każdej linii
::       [_e] - INTEGER -  [0] - wstawia tekst doslownie
::                          1 - wstawia tekst w znacznikach <![CDATA[ ]]>
::   WY: STRING - XML owy zapis parametru np:
::       <void property="planDept">
::          <string>PR1</string>
::       </void>
::  OLD: \get_XML_property/skid_jar.fml
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
_field:=_a;
_type:=_b;
_value:=_c;

_indent:='';
{? var_pres('_d')=type_of('')
|| _indent:=_d
?};
_cdata:=0;
{? var_pres('_e')=type_of(0)
|| _cdata:=_e
?};

_result:='';

_my_ind:=exec('indent','#xml');
_result:=_indent+'<void property=\"'+_field+'\">\n';
_result+=_indent+_my_ind+'<'+_type+'>'+{? _cdata || '<![CDATA[' || '' ?}+_value+{? _cdata || ']]>' || '' ?}+'</'+_type+'>\n';
_result+=_indent+'</void>\n';
_result


\vector
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca XMLowa reprezentację tablicy formułowej jako wektor javowa
::   WE: _a - STRING - typ parametru UWAGA! Wielkość liter ma znaczenie, typ podajemy małymi literami
::       _b - obj_new() - tablica którą zamieniam
::       _c - INTEGER - 0/1/2 - czy dodawać identyfikatory typów:
::                                                                0 - nie dodawać w ogóle
::                                                                1 - dodawać tylko wektora
::                                                                2 - dodawać również dla elementów wektora
::       _d - INTEGER - sposób umieszczania tekstu: 0 - wstawia tekst dosłownie
::                                                  1 - wstawia tekst w znacznikach <![CDATA[ ]]>
::   WY: STRING - XMLowa reprezentacja tablicy jako wektora
::  OLD: \get_XML_vector/skid_jar.fml
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
{? _<3
|| return('')
?};
_wyn:='';

_size:=obj_len(_b);
_type:=_a;
_end_type:=_type;
::obcinam type do pierwszej spacji
_spacja_pos:=_type*' ';
{? _spacja_pos>0
|| _end_type:=_spacja_pos+_type
?};

_array:=_b;
_add_id:=_c;
_cdata:=_d;
{? _size>0
|| {? _add_id=1
   || _wyn:='<object class=\"java.util.Vector\">'
   ?};
   {! _it:=1.._size
   |! _value:=_array[_it];
      _wyn+='<void method=\"add\">';
      {? _add_id=2
      || _wyn+='<'+_type+'>'
      ?};
      _wyn+={? _cdata || '<![CDATA[' || '' ?}+_value+{? _cdata || ']]>' || '' ?};
      {? _add_id=2
      || _wyn+='</'+_end_type+'>'
      ?};
      _wyn+='</void>'
   !};
   {? _add_id=1
   || _wyn+='</object>'
   ?}
?};
_wyn


\array
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca XMLowa reprezentacje tablicy formułowej jako tablica javowa
::   WE: _a - STRING - typ parametru UWAGA! Wielkość liter ma znaczenie, typ podajemy małymi literami
::       _b - obj_new() - tablica którą zamieniam
::       _c - INTEGER - 0/1 - czy dodawać identyfikator typu
::       _d - INTEGER - sposób umieszczania tekstu: 0 - wstawia tekst dosłownie
::                                                  1 - wstawia tekst w znacznikach <![CDATA[ ]]>
::   WY: STRING - XMLowa reprezentacja tablicy
::  OLD: \get_XML_array/skid_jar.fml
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
{? _<3
|| return('')
?};
_wyn:='';

_size:=obj_len(_b);
_type:=_a;
_array:=_b;
_add_id:=_c;
_cdata:=_d;
{? _size>0
|| {? _add_id=1
   || _wyn:='<array class=\"java.lang.'+_type+'\" length=\"'+$_size+'\">'
   ?};
   {! _it:=1.._size
   |! _value:=_array[_it];
      _wyn+='<void index=\"'+$(_it-1)+'\">';
      _wyn+='<'+_type+'>'+$_value+'</'+_type+'>';
      _wyn+='<'+_type+'>'+{? _cdata || '<![CDATA[' || '' ?}+_value+{? _cdata || ']]>' || '' ?}+'</'+_type+'>';
      _wyn+='</void>'
   !}
?};
{? _add_id=1
|| _wyn+='</array>'
?};
_wyn


\prolog
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca prolog dla XMLa
::   WE: _a - STRING - akronim obiektu który będzie tworzony po stronie java
::       [_b] - INTEGER - 1/[2] - rodzaj prologu:
::                                                1  - dodawać cząstkowy
::                                               [2] - dodawać pełny
::       [_c] - STRING - wcięcie które dodawać dla każdej linii
::   WY: STRING
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
_java_obj:=_a;
_kind:=2;
{? var_pres('_b')=type_of(0)
|| _kind:=_b
?};
_indent:=exec('indent','#xml');
{? var_pres('_c')=type_of('')
|| _indent:=_c
?};

_result:='';
{? _kind=2
|| _result+='<?xml version=\"1.0\" encoding=\"UTF-8\" ?>';
   _result+='<java class=\"java.beans.XMLDecoder\">\n'
?};
_result+=_indent+'<object class=\"'+_java_obj+'\">\n';
_result


\epilog
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca epilog dla XMLa
::   WE: [_a] - INTEGER - 1/[2] - rodzaj epilogu:
::                                                1  - dodawać cząstkowy
::                                               [2] - dodawać pełny
::       [_b] - STRING - wcięcie które dodawać dla każdej linii
::   WY: STRING
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
_kind:=2;
{? var_pres('_a')=type_of(0)
|| _kind:=_a
?};
_indent:=exec('indent','#xml');
{? var_pres('_b')=type_of('')
|| _indent:=_b
?};

_result:='';

_result+=_indent+'</object>\n';
{? _kind=2
|| _result+='</java>\n'
?};
_result


\indent
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca wcięcie które stosować w plikach XML
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
' '


\args_xml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Argumenty dla funkcji przekształcających rekordy/obiekty do postaci XML
::   WY: obj_new()
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
:: obj_new() - bufor tabeli który ma zostać zamieniony na XMLa
   'BUFFER'
:: TABLE - akronim tabeli której rekord przekształcać
   ,'TABLE'
:: Ref rekordu
   ,'REF'
:: STRING - akronim obiektu który będzie tworzony po stronie java
   ,'JAVA_OBJ'
:: STRING - ścieżka do pakietu w którym są zadeklarowane klasy odpowiadające nazwom tabel
   ,'JAVA_PATH'
:: INTEGER - 0/[1]/2 - czy dodawać prolog i epilog:
::                                                                 0 - nie dodawać
::                                                                 1 - dodawać cząstkowy
::                                                                [2] - dodawać pełny
   ,'PROLOG'
:: STRING - wcięcie które dodawać dla każdej linii
   ,'INDENT'
:: obj_new - tablica refów zawierajaca rekordy które już zostały przekształcone do XML,
::                        potrzebna do tego żeby się nie zapętlic w rekurencyjnych wywołaniach
   ,'CONVERTED'
:: STRING - dla wywołań rekurencyjnych - nadrzędny akronim pola który spowodował uruchomienie rekurencji
   ,'PARENT_FLD'
:: Poziom wywołania rekurencyjnego
   ,'REC'
:: Maksymalny poziom rekurencji który można osiągnąć
   ,'MAX_REC'
);
_args.BUFFER:=~~;
_args.TABLE:=~~;
_args.REF:=null();
_args.JAVA_OBJ:='';
_args.JAVA_PATH:='';
_args.PROLOG:=2;
_args.INDENT:=exec('indent','#xml');
_args.CONVERTED:=exec('ref_table','#table');
_args.PARENT_FLD:='';
_args.REC:=0;
_args.MAX_REC:=0;
_args


\buffer2XML
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przekształca podany bufor tabeli do STRINGa który reprezentuje javową XMLową reprezentację tego bufora
::   WE: _a - obj_new - argumenty funkcji - wynik działania exec('args_xml','#xml')
::   WY: STRING
::  TAG: <PUBLICZNA><XML><BUFOR>
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_buffer:=_args.BUFFER;

_xml:='';

{? _args.PROLOG>0
|| {? _args.JAVA_PATH<>''
   || _object_pth:=_args.JAVA_PATH+'.'+_args.JAVA_OBJ
   || _object_pth:=_args.JAVA_OBJ
   ?};
   _xml+=exec('prolog','#xml',_object_pth,_args.PROLOG,_args.INDENT)
?};

:: Sprawdzam czy rekord już został przekształcony
{? _args.CONVERTED.r_find(_buffer.ref())=0
||
:: Nie przekształcałem jeszcze takiego rekordu wiec to robię
   _args.CONVERTED.add(_buffer.ref());

:: Dla pól przetwarzanej tabeli zwiększam wcięcie o jeden
   _ind_fld:=_args.INDENT+exec('indent','#xml');
:: Dla pól będących rekordami innych tabel zwiekszam wcięcie o dwa
   _ind_obj:=_args.INDENT+exec('indent','#xml')+exec('indent','#xml');

   _typeconv:=exec('java_types_conv','#xml',_args.JAVA_PATH);

:: Iteruje po polach bufora
   _types:=_buffer.types();
   _acr:=_buffer.acronyms();
   _size:=obj_len(_types);

   _args_zl:=exec('args_xml','#xml');
   obj_del(_args_zl.CONVERTED);
   _args_zl.CONVERTED:=_args.CONVERTED;

   {! _it:=1.._size
   |! _macrotype:=_types[_it];
      {? _acr[_it]='Ref'
      || _macrotype:='STRING'
      ?};

      _jtype:=_typeconv.javaType(_macrotype);
      {? 1+_macrotype<>'_'
      ||
::       Typ prosty
         _xml+=exec('val2xml','#xml',_acr[_it],_jtype,_buffer[_it],_ind_fld)
      ||
::       Typ złączeniowy
         _xml+=_ind_fld+'<void property=\"'+_acr[_it]+'\">\n';

         _tab_acr:=1-_macrotype;
         {? var_pres('_tab_zl')>100
         || obj_del(_tab_zl)
         ?};
         _tab_zl:=($_tab_acr)();

         _ref:=_buffer[_it];

         _tab_zl.cntx_psh();
         _tab_zl.clear();
         {? _tab_zl.seek(_ref)
         ||
            {? var_pres('TABLE',_args_zl)>100
            || obj_del(_args_zl.TABLE)
            ?};
            _args_zl.TABLE:=_tab_zl;
            _args_zl.JAVA_OBJ:=_tab_acr;
            _args_zl.JAVA_PATH:=_args.JAVA_PATH;
            _args_zl.PROLOG:=1;
            _args_zl.INDENT:=_ind_obj;
            _args_zl.PARENT_FLD:=_acr[_it];
            _args_zl.REC:=_args.REC+1;
            _args_zl.MAX_REC:=_args.MAX_REC;
            _xml+=exec('record2XML','#xml',_args_zl)
         ||
::          Rekord jest nullem lub go nie znaleziono
            _xml+=exec('null','#xml',_acr[_it],_ind_obj,0)
         ?};
         _tab_zl.cntx_pop();
         _xml+=_ind_fld+'</void>\n';
         ~~
      ?}
   !};
   _args.CONVERTED.r_del(_buffer.ref())
||
:: Był już taki rekord więc go nie dodaje, tylko robię nulla
   {? _args.PARENT_FLD<>''
   || _xml+=exec('null','#xml',_args.PARENT_FLD,_args.INDENT)
   ?}
?};
{? _args.PROLOG>0
|| _xml+=exec('epilog','#xml',_args.PROLOG,_args.INDENT)
?};
_xml


\record2XML
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przekształca podany rekord tabeli do STRINGa który reprezentuje javową XMLową reprezentację tego rekordu
::   WE: _a - obj_new - argumenty funkcji - wynik działania exec('args_xml','#xml')
::       [_b] - obj_new - tablica nazwana ze strukturami tabel - każdy element to wynik działania exec('mbTabFields_tab','#table')
::   WY: STRING
::  TAG: <PUBLICZNA><XML>
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_tab:=_args.TABLE;

_fields:=~~;
_fld_obj:=~~;
{? var_pres('_b')>100
|| _fld_obj:=_b;
   _tab_acr:=2-(!_tab);
   {? var_pres(_tab_acr,_fld_obj)>100
   || _rule:='_obj:=_a;_obj.'+_tab_acr;
      _fields:=($_rule)(_fld_obj)
   ?}
?};
{? type_of(_fields)=0
|| _fields:=exec('mbTabFields_tab','#table',_tab)
?};

_xml:='';

_can_continue:=1;

_tab.cntx_psh();
{? _args.REF<>null()
|| _tab.clear();
   {? _tab.seek(_args.REF)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? _args.PROLOG>0
   || {? _args.JAVA_PATH<>''
      || _object_pth:=_args.JAVA_PATH+'.'+_args.JAVA_OBJ
      || _object_pth:=_args.JAVA_OBJ
      ?};
      _xml+=exec('prolog','#xml',_object_pth,_args.PROLOG,_args.INDENT)
   ?};
:: Sprawdzam czy rekord już został przekształcony
   {? _args.CONVERTED.r_find(_tab.ref())=0
   ||
::    Nie przekształcałem jeszcze takiego rekordu wiec to robię
      _args.CONVERTED.add(_tab.ref());

::    Dla pól przetwarzanej tabeli zwiększam wcięcie o jeden
      _ind_fld:=_args.INDENT+exec('indent','#xml');
::    Dla pól będących rekordami innych tabel zwiekszam wcięcie o dwa
      _ind_obj:=_args.INDENT+exec('indent','#xml')+exec('indent','#xml');

      _typeconv:=exec('java_types_conv','#xml',_args.JAVA_PATH);

::    Zawsze jako pierwszy element dodaje Ref
      _xml+=exec('val2xml','#xml','Ref','string',_tab.ref(),_ind_fld);

::    Iteruje po polach tabeli

      _fields.prefix('F');

      {? _fields.first()
      ||
         _args_zl:=exec('args_xml','#xml');
         obj_del(_args_zl.CONVERTED);
         _args_zl.CONVERTED:=_args.CONVERTED;
         {!
         |? _macrotype:=_fields.FLD_TRAW;
            _jtype:=_typeconv.javaType(_macrotype);

            {? 1+_macrotype<>'_'
            ||
::             Typ prosty
               {? _macrotype='SYSMEMO' | _macrotype='MEMO'
               || _value:=_tab.memo_txt(,1,_fields.FLD_ACR)
               |? _macrotype='BLOBRAW' | _macrotype='BLOBIMAGE'
               || _value:=''
               || _value:=($('_a.'+_fields.FLD_ACR))(_tab)
               ?};

               _xml+=exec('val2xml','#xml',_fields.FLD_ACR,_jtype,_value,_ind_fld)
            ||
::             Typ złączeniowy
               _xml+=_ind_fld+'<void property=\"'+_fields.FLD_ACR+'\">\n';

               _tab_acr:=1-_macrotype;
               {? var_pres('_tab_zl')>100
               || obj_del(_tab_zl)
               ?};
               _tab_zl:=($_tab_acr)();

               _ref:=($('_a.'+_fields.FLD_ACR))(_tab);

               _tab_zl.cntx_psh();
               _tab_zl.clear();
               {? _tab_zl.seek(_ref)
               ||
::                !!! REKURENCJA !!!
                  {? var_pres('TABLE',_args_zl)>100
                  || obj_del(_args_zl.TABLE)
                  ?};
                  _args_zl.TABLE:=_tab_zl;
                  _args_zl.JAVA_OBJ:=_tab_acr;
                  _args_zl.JAVA_PATH:=_args.JAVA_PATH;
                  _args_zl.PROLOG:=1;
                  _args_zl.INDENT:=_ind_obj;
                  _args_zl.PARENT_FLD:=_fields.FLD_ACR;
                  _args_zl.REC:=_args.REC+1;
                  _args_zl.MAX_REC:=_args.MAX_REC;

                  _can_rec:=1;
                  {? _args.MAX_REC>0 & _args.REC>=_args.MAX_REC
                  || _can_rec:=0
                  ?};
                  {? _can_rec>0
                  || _xml+=exec('record2XML','#xml',_args_zl,_fld_obj)
                  || _xml+=exec('null','#xml',_fields.FLD_ACR,_ind_obj,0)
                  ?}
               ||
::                Rekord jest nullem lub go nie znaleziono
                  _xml+=exec('null','#xml',_fields.FLD_ACR,_ind_obj,0)
               ?};
               _tab_zl.cntx_pop();
               _xml+=_ind_fld+'</void>\n';
               ~~
            ?};
            _fields.next()
         !}
      ?};
      _args.CONVERTED.r_del(_tab.ref())
   ||
::    Był już taki rekord wiec go nie dodaje, tylko robię nulla
      {? _args.PARENT_FLD<>''
      || _xml+=exec('null','#xml',_args.PARENT_FLD,_args.INDENT)
      ?}
   ?};
   {? _args.PROLOG>0
   || _xml+=exec('epilog','#xml',_args.PROLOG,_args.INDENT)
   ?}
?};
_tab.cntx_pop();
_xml


\java_types_conv
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca tablicę nazwaną która umożliwia przejście z typów MacroBASE na typy Java
::   WE: [_a] - STRING - ścieżka do pakietu w którym są zadeklarowane klasy odpowiadające nazwom tabel
::   WY: obj_new
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
_path:='';
{? var_pres('_a')=type_of('')
|| _path:=_a
?};

_result:=obj_new(
   'NUMBER'
   ,'STRING'
   ,'RULE'
   ,'DATE'
   ,'TIME'
   ,'REFERENCE'

   ,'REAL'
   ,'INTEGER'
   ,'MEMO'
   ,'TREE_REF'
   ,'SYSMEMO'
   ,'IDTIME'
   ,'IDADD'
   ,'IDPUT'
   ,'BLOBRAW'
   ,'BLOBIMAGE'

   ,'javaPath'
:: metody
   ,'javaType'
   );

_result.NUMBER:='int';
_result.STRING:='string';
_result.RULE:='string';
_result.DATE:='java.sql.Date';
_result.TIME:='java.sql.Time';
_result.REFERENCE:='string';

_result.REAL:='double';
_result.INTEGER:='int';
_result.MEMO:='string';
_result.TREE_REF:='double';
_result.SYSMEMO:='string';
_result.IDTIME:='string';
_result.IDADD:='string';
_result.IDPUT:='string';
_result.BLOBRAW:='string';
_result.BLOBIMAGE:='string';

_result.javaPath:=_path;

_result.javaType:="
   _macroType:=_a;

   _result:='';

   {? 1+_macroType='_'
   ||
::    Jeśli typ jest tabelą, to zwracam ścieżkę do klasy reprezentującej tą tabelę po stronie java
      _result:=.javaPath+'.'+(1-_macroType)
   ||
::    Typ prosty
      _ff:='.'+_macroType;
      _result:=($_ff)()
   ?};
   _result
";
_result


\val2xml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Konwertuje dowolną wartość na postać zapisywalną w XML
::   WE: _a - STRING - nazwa pola po stronie java
::       _b - STRING - typ parametru po stronie java
::       _c - ANY - wartosc parametru
::       [_d] - STRING - wcięcie które dodawać dla każdej linii
::   WY: STRING
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
_field:=_a;
_type:=_b;
_value:=_c;

_result:='';
_indent:='';

{? var_pres('_d')=type_of('')
|| _indent:=_d
?};

_vp:=var_pres('_value');
{? _vp=type_of('')
|| _result:=exec('property','#xml',_field,_type,_value,_indent,1)
|? _vp=type_of(0)
|| _result:=exec('property','#xml',_field,_type,gsub($_value,',','.'),_indent)
|? _vp=type_of(null())
|| _result:=exec('property','#xml',_field,_type,$_value,_indent)
|? _vp=type_of(date())
|| _result:=exec('date','#xml',_field,_value,_indent)
|? _vp=type_of(time())
|| _result:=exec('time','#xml',_field,_value,_indent)
?};
_result


\date
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Konwertuje przekazaną datę na postać zapisywalną w XML
::   WE: _a - STRING - nazwa pola w klasie po stronie java
::       _b - DATE - data którą przekształcić
:;       [_c] - STRING - wcięcia które dodawać do każdego elementu
::   WY: STRING
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
_field:=_a;
_date:=_b;

_result:='';
_indent:='';
{? var_pres('_c')=type_of('')
|| _indent:=_c
?};
_my_ind:=exec('indent','#xml');
_tm_stamp:=exec('create','#tm_stamp',_date,time(0,0,0));

_javatype:=exec('java_types_conv','#xml').javaType('DATE');

:: Przekształcam podanego tm_stampa do formatu java
_tm_stamp:=exec('to_java','#tm_stamp',_tm_stamp);
_result:=_indent+'<void property=\"'+_field+'\">\n'+
         _indent+_my_ind+'<object class=\"'+_javatype+'\">\n'+
         _indent+_my_ind+_my_ind+'<long>'+$_tm_stamp+'</long>\n'+
         _indent+_my_ind+'</object>\n'+
         _indent+'</void>\n';
_result


\time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Konwertuje przekazany czas na postać zapisywalną w XML
::   WE: _a - STRING - nazwa pola w klasie po stronie java
::       _b - TIME - czas który przekształcić
:;       [_c] - STRING - wcięcia które dodawać do każdego elementu
::   WY: STRING
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
_field:=_a;
_time:=_b;

_result:='';
_indent:='';
{? var_pres('_c')=type_of('')
|| _indent:=_c
?};
_my_ind:=exec('indent','#xml');
_tm_stamp:=exec('create','#tm_stamp',date(0,0,0),_time);

_javatype:=exec('java_types_conv','#xml').javaType('TIME');

:: Przekształcam podanego tm_stampa do formatu java
_tm_stamp:=exec('to_java','#tm_stamp',_tm_stamp);
_result:=_indent+'<void property=\"'+_field+'\">\n'+
         _indent+_my_ind+'<object class=\"'+_javatype+'\">\n'+
         _indent+_my_ind+_my_ind+'<long>'+$_tm_stamp+'</long>\n'+
         _indent+_my_ind+'</object>\n'+
         _indent+'</void>\n';
_result


\null
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca XMLowa reprezentacje pustego parametru
::   WE: _a - STRING - nazwa pola po stronie java
::       [_b] - STRING - wcięcie które dodawać dla każdej linii
::       [_c] - INTEGER - 0/[1] - czy dodawać sekcję property
::   WY: STRING - XML owy zapis parametru np:
::       <void property="planDept">
::          <null\>
::       </void>
::  TAG: <PRYWATNA><XML>
::----------------------------------------------------------------------------------------------------------------------
_field:=_a;

_result:='';
_indent:='';

{? var_pres('_b')=type_of('')
|| _indent:=_b
?};
_property:=1;
{? var_pres('_c')=type_of(0)
|| _property:=_c
?};

_my_ind:=exec('indent','#xml');

{? _property>0
|| _result:=_indent+'<void property=\"'+_field+'\">\n'
?};
_result+=_indent+_my_ind+'<null/>\n';
{? _property>0
|| _result+=_indent+'</void>\n'
?};
_result


\string_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Oczyszcza przekazany string z niedozwolonych znaków, po to żeby się struktura pliku XML nie rozwaliła
::   WE: _a - STRING - napis który oczyścić
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
_string:=_a;

_string:=gsub(_string,'&','&amp;');
_string:=gsub(_string,'>','&gt;');
_string:=gsub(_string,'<','&lt;');
_string:=gsub(_string,'\'','&apos;');
_string:=gsub(_string,'\"','&quot;');
_string

:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 ce8f60238a3d720504a9ecf47a25f95a917f5c348413444dd2b8036b54221d028dd7ea49c51a840e263d763d056717d718c49ccb55e2bbe469c6850783e180437595ab0aba44f0009766cd2aaf9e97e9ee08771614305cd251c559e0a0eec9cffa9ec1ba8e468a5462e7c5aefbe322c3c805d9638264a362d9ed75bf13358459
