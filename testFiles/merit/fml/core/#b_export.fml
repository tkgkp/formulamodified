:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b_export.fml
:: Utworzony: 10.02.2016
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły do obsługi importu i eksportu procesów
::======================================================================================================================


\env_imex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PS [17.14]
:: OPIS: Zwraca zmienną środowiskową do obsługi importów
::   WY: obj_new - tablica nazwana zawierajaca wszystko co potrzebne
::  TAG: <MODELER><PROCES><WERTOWANIE><PARAMETR><WEJŚCIE><INICJOWANIE><WŁAŚCIWOŚCI>
::----------------------------------------------------------------------------------------------------------------------

::UWAGA: _fld, i _mth to formułki pomocnicze, zeby wygodniej tworzyć tablicę i komentować poszczególne jej elementy
::       powiedzmy, że to bedzie pole
         _fld:="31+form(_a)";
::       powiedzmy, że to bedzie metoda
         _mth:="31+form(_a)";

_env:=obj_new(
::             Zmienne pomocnicze
               _fld('IMPORT_FILEPROC','Nazwa pliku proc po stronie serwera')
               ,_fld('IMPORT_GML_DATA','Uchwyt do pliku zawierający treść MBASE odczytaną z graphml')
               ,_fld('EXCEL_FILEPROC','Uchwyt do pliku procesyNNNNNNN.proc podczas importu z Excela')
               ,_fld('EXCEL_PATHPROC','Ścieżka do pliku procesyNNNNNNN.proc podczas importu z Excela')
               ,_fld('OVERWRITE','Czy nadpisywać procesy w trakcie imporu - na razie używane tylko z Excela z pewnymi wyjatkami')
               ,_fld('POPRAW_VER','Wersja dla grupowego poprawiania')
               ,_fld('ENV_FAST','Środowisko modelera dla szybkiego importu')
               ,_fld('OBJECTS','Tablica z obiektami odczytana z plików .graphml')
               ,_fld('KOMM_OMIT','Podczas importu komunikaty nie oznaczają procesu jako błędnie zaimportowanego')
               ,_fld('CURRENT_FILEPATH','Aktualna ścieżka odczytywanego pliku .graphml')
               ,_fld('PREFIX_SYM','Prefiks dla symbolu procesów')
               ,_fld('PREFIX_VER','Prefiks dla wersji procesów')
               ,_fld('ACTIVE_CRUCIAL','Czy aktywowować tylko procesy niezbędne?')

::             identyfikatory okienek
               ,_fld('wid_proc','ID okienka z procesami odczytanymi z pliku')

::             tytuły okienek
               ,_fld('tit_proc','Tytuł okienka zawierającego procesy odczytane z pliku')

::             tabele tymczasowe
               ,_fld('TAB_FILE','Tabela tymczasowa zawierająca zawartość pliku .proc')
               ,_fld('TAB_PROC','Tabela tymczasowa zawierająca procesy odczytane z pliku')
               ,_fld('DOMAIN_LIC','Tabela z licencjonowanymi dziedzinami')

::             indeksy tymczasowych tabel
               ,_fld('NDX_PROC_IDADD','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_SYMBOL','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_SELECTED','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_OVERHAS','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_OVERMODE','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_VER','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_VER2','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_VER_NUM','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_FILE','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_CRUCIAL','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_PROC_N_CRUCIAL','Indeks tabeli tymczasowej .TAB_PROC')
               ,_fld('NDX_FILE_IDADD','Indeks tabeli tymczasowej .TAB_FILE')
               ,_fld('NDX_FILE_PATH','Indeks tabeli tymczasowej .TAB_FILE')
               ,_fld('NDX_FILE_STAMP','Indeks tabeli tymczasowej .TAB_FILE')

::             uchwyty do okien
               ,_fld('WIN_PROC','Tabela tymczasowa zawierająca odczytane procesy odczytane z pliku')

::             METODY
               ,_mth('select','Wyświetla okno z odczytanymi procesami')
             );
_env.IMPORT_FILEPROC:='';
_env.IMPORT_GML_DATA:=~~;
_env.PREFIX_SYM:='';
_env.PREFIX_VER:='';

_env.wid_proc:='#b_import_proc';
_env.tit_proc:='Wybór procesów do importu'@;
_env.TAB_PROC:=exec('tab_proc','#b_export',_env);
_env.TAB_FILE:=exec('tab_file','#b_export',_env);
_env.DOMAIN_LIC:=exec('domain_lic','#b_domain',0);

_env.EXCEL_FILEPROC:=0;
_env.EXCEL_PATHPROC:='';
_env.OVERWRITE:=0;
_env.KOMM_OMIT:=0;
_env.CURRENT_FILEPATH:='';
_env.POPRAW_VER:='';
_env.ENV_FAST:=exec('env','#b_design');
_env.select:="
   params_set(params_get());
   .WIN_PROC:=exec('win_proc','#b_export',.);

   .TAB_PROC.win_sel(.WIN_PROC);

   {? .PREFIX_SYM<>'' & .PREFIX_VER<>''
   || {? #.PREFIX_VER<>0
      ||
         .TAB_PROC.index(.NDX_PROC_SYMBOL);
         .TAB_PROC.prefix(.PREFIX_SYM);
         {? .TAB_PROC.first()
         || _can_continue:=1;
            {!
            |? _next:=0;
               _ref_nxt:=null();
               .TAB_PROC.cntx_psh();
               {? .TAB_PROC.next()
               || _ref_nxt:=.TAB_PROC.ref()
               ?};
               .TAB_PROC.cntx_pop();

               {? .TAB_PROC.VER_NUM=0 | (.TAB_PROC.VER_NUM>0 & .TAB_PROC.VER_NUM<#.PREFIX_VER)
               || _can_continue:=.TAB_PROC.del(,1)
               ?};

               {? _ref_nxt<>null()
               || _next:=.TAB_PROC.seek(_ref_nxt)
               ?};
               _next>0 & _can_continue>0
            !}
         ?};
         .TAB_PROC.prefix(.PREFIX_SYM);
         .TAB_PROC.first()
      || .TAB_PROC.index(.NDX_PROC_VER2);
         .TAB_PROC.prefix(.PREFIX_VER,.PREFIX_SYM)
      ?}
   |? .PREFIX_SYM<>''
   || .TAB_PROC.index(.NDX_PROC_SYMBOL);
      .TAB_PROC.prefix(.PREFIX_SYM)
   |? .PREFIX_VER<>''
   || .TAB_PROC.index(.NDX_PROC_VER2);
      .TAB_PROC.prefix(.PREFIX_VER)
   ?};

   .TAB_PROC.select();

   {? .IMPORT_FILEPROC<>''
   || _erase:=ferase(.IMPORT_FILEPROC,1);
      {? _erase=0
      || FUN.emsg('Nie udało się usunąć pliku: %1 z serwera.'@[.IMPORT_FILEPROC])
      ?}
   ?};
   ~~
";
_env


\separator
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca separator używany w imporcie/eksporcie procesów
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
'`sep`'


\export_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Inicjalizacja eksportu procesu. Przygotowuje plik tekstowy z danymi MacroBASE, który następnie
::       zostanie przekazany do modelera celem opakowania go w plik graphml
::   WE: _a - STRING - Ścieżka do pliku docelowego na terminalu klienckim wraz z nazwą i rozszerzeniem
::       _b - STRING - nazwa pliku docelowego - bez scieżki i bez rozszerzenia
::       _c - STRING - katalog pliku docelowego
::   WY: '0' - porażka
::       '1' - sukces
::  TAG: <YWORKS><MODELER><EKSPORT>
:: ~OST: INFERASE,INFEXISTS
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_filepath:=_a;
_filename:=_b;
_dir:=_c;

_can_continue:=1;

B_PROC.cntx_psh();
B_PROC.prefix();
{? B_PROC.seek(_env.SEL_PROC)
||
   {? _env.TM_MOD>B_PROC.TM_SAVE
   || _msg:='Istnieją niezapisane zmiany na diagramie. Aby rozpocząć eksport należy najpierw zapisać proces.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(_msg,2,,1)
      || FUN.emsg(_msg)
      ?};
      _can_continue:=0
   ?};

   {? _can_continue>0 & _filepath=''
   || _msg:='Przekazana ścieżka pliku docelowego jest pusta.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(_msg,2,,1)
      || FUN.emsg(_msg)
      ?};
      _can_continue:=0
   ?};

   {? _can_continue>0 & _filename=''
   || _msg:='Przekazana nazwa pliku docelowego jest pusta.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(_msg,2,,1)
      || FUN.emsg(_msg)
      ?};
      _can_continue:=0
   ?};

   {? _can_continue>0 & _dir=''
   || _msg:='Przekazany katalog dla pliku docelowego jest pusty.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(_msg,2,,1)
      || FUN.emsg(_msg)
      ?};
      _can_continue:=0
   ?};

   {? _can_continue>0 & B_PROC.IMP_ERR='T'
   ||
      _msg:='Proces: %1 zawiera błędnie zaimportowane elementy. Eksport takiego procesu jest niemożliwy.'@[exec('B_PROC','#to_string')];
      {? VAR.GRUPA='T'
      || KOMM.add(_msg,2,,1)
      || FUN.emsg(_msg)
      ?};
      _can_continue:=0
   ?}
|| _can_continue:=0;
   _msg:='Nie znaleziono procesu do eksportu'@;
   {? VAR.GRUPA='T'
   || KOMM.add(_msg,2,,1)
   || FUN.emsg(_msg)
   ?}
?};

_result:='0';

{? _can_continue>0
||
:: Znikam przyciski na dolnej belce modelera
   exec('set_visible','#desktop','',_env.ctr_id,'przyciski',0);
   {? VAR.GRUPA='T'
   || _what:=exec('record','#to_string',_env.SEL_PROC);
      exec('set_value','#desktop','#',_env.ctr_id,_env.ctr_bpmn,'loading_text=%1'['Eksportowanie procesu %1'@[_what]])
   || KOMM.init(250,,'Eksport procesu')
   ?};
:: Uruchamiam eksportowanie dodatkowych informacji
   _can_continue:=exec('export_file_mbase','#b_export',_filename,_dir);
   {? _can_continue>0
   || _command:='export_main='+_filepath;
      exec('set_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,_command)
   ?}
?};
{? _can_continue>0
|| _result:='1'
||
:: Jeśli się coś nie udało a istnieje plik .svg na terminalu klienta to go usuwam
   _svg_path:=gsub(_filepath,'.graphml','.svg');
   {? fexists('@'+_svg_path,0)>0
   || ferase('@'+_svg_path,0)
   ?}
?};
B_PROC.cntx_pop();
_result


\export_file_mbase
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przygotowuje plik z rozszerzeniem .proc zawierający dodatkowe informacje o procesie
::       które zostaną wciągnięte do pliku graphml
::   WE: _a - STRING - nazwa pliku docelowego
::       [_b] - STRING - ścieżka (katalog) na terminalu
::       [_c] - file - uchwyt do pliku na serwerze lub w pamięci
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA><MODELER><EKSPORT>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_filename:=_a;
_dir_terminal:='';
{? var_pres('_b')=type_of('')
|| _dir_terminal:=_b
?};
_close:=1;
_file:=~~;
{? var_pres('_c')>100
|| _file:=_c;
   _close:=0
?};

_result:=0;
_can_continue:=1;
_env.LAST_ID:='id:0';

_pth:=1;
_file_server:=_filename+$SYSLOG.tm_stamp()+'.proc';
_filepath_term:='';
{? _dir_terminal<>''
|| _filepath_term:='@'+_dir_terminal+exec('sep','#file')+_filename+'.proc'
?};

:: Otwieram plik na serwerze z zgodnie z deklaracją ścieżek w pth

:: Ponieważ w java 11 panelplus.jar zaczął dopisywać do plików .graphml BOM w sekcji CDATA
:: co powoduje problem przy imporcie tutaj lepiej tworzyć plik .proc bez BOMa
{? type_of(_file)=0
|| _file:=fopen(_file_server,'Uw!',_pth,1,1)
?};
{? var_pres('_file')>100
||
::   {? _env.EXPORT_MODELER=0
::   || fwrite(_file,'<![CDATA[')
::   ?};

   {? _env.MEGA_PROC>0
   || _tab:=_env.MEGA_PROCESY.tab
   ?};

:: Zapisuje do pliku kolejne elementy

:: 1. Właściwości kontrolne
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_control','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_control','#b_export',_file)
      ?}
   ?};

:: 2. Role używane w procesie
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_roles','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_roles','#b_export',_file)
      ?}
   ?};

:: 3. Interwały czasowe (planowane czasy trwania)
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_ivals','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_ivals','#b_export',_file)
      ?}
   ?};

:: 4. Elementy procesu
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_bprels','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_bprels','#b_export',_file)
      ?}
   ?};

:: 5. Połączenia elementów
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_bconn','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_bconn','#b_export',_file)
      ?}
   ?};

:: 6. Właściwości procesu
   {? _can_continue>0
   || _can_continue:=exec('export_proc','#b_export',_file)
   ?};

:: 7. Dynamiczne B_PORTY
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_dynamic_ports','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_dynamic_ports','#b_export',_file)
      ?}
   ?};

:: 8. Warunki na bramach
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_choices','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_choices','#b_export',_file)
      ?}
   ?};

:: 9. Powiązania argumentów
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_poconns','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_poconns','#b_export',_file)
      ?}
   ?};

:: 10. Harmonogramy elementów
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_timers','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_timers','#b_export',_file)
      ?}
   ?};

:: 11. Komunikaty dla elementów
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_msg','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_msg','#b_export',_file)
      ?}
   ?};

:: 12. Wartości ustawione na procesie
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_values','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_values','#b_export',_file)
      ?}
   ?};

:: 13. Sygnały
   {? _can_continue>0
   || {? _env.MEGA_PROC>0
      ||
         {? _tab.first()
         || {!
            |? _b_proc:=exec('FindAndGet','#table',B_PROC,_tab.SQL,,,null());
               _can_continue:=exec('export_signal','#b_export',_file,_b_proc);
               _tab.next() & _can_continue>0
            !}
         ?}
      || _can_continue:=exec('export_signal','#b_export',_file)
      ?}
   ?};

::   {? _env.EXPORT_MODELER=0
::   || fwrite(_file,']]>')
::   ?};

   {? _close>0
   || fclose(_file)
   ?};
   {? _can_continue>0 & _filepath_term<>''
   ||
::    Ściągam plik na terminal klienta
      _can_continue:=fcopy(_file_server,_filepath_term,1,0,1);

::    Kasuje plik z serwera
      {? _can_continue>0
      || ferase(_file_server,1)
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\export_control
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Umieszcza w pliku eksportowym elementy wspólno-kontrolne
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.SEL_PROC
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

:: Wersja modelera

_obj_ver:=exec('obj_version','#b_export');
{? _env.EXPORT_MODELER>0
|| _obj_ver.MODELER_VER:=exec('get_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'version')
|| _obj_ver.MODELER_VER:='14.10'
?};
exec('write_object','#b_export',_file,_obj_ver);

:: Wersje czynności i hashe z ich formuł głównych
B_ACTION.cntx_psh();
B_ACTION.index('B_ELE');
B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_b_proc,'B_ACTION');
{? B_PREL.first()
|| _obj_actchk:=exec('obj_actchk','#b_export');
   {!
   |? B_ACTION.prefix(B_PREL.B_ELE);
      {? B_ACTION.first()
      ||
         _plik_act:=exec('filename','#b_action');
         _action_hash:=exec('hash_params2','#b_action');
::       Pobieram wersję czynności
::         _ver_act:=exec('string_fun','#file',_plik_act,'main','::# version=');
::         _ver_act:=gsub(_ver_act,'\n','');
::         {? _ver_act=''
::         ||
::          Jeśli nie podana to przyjmuję 14.10
::            _ver_act:='14.10'
::         ?};

         _obj_actchk.ACTION_UID:=B_ACTION.UID;
         _obj_actchk.ACTION_VER:='14.10';
         _obj_actchk.ACTION_HASH:=_action_hash;

         _can_continue:=exec('write_object','#b_export',_file,_obj_actchk)
      ?};
      B_PREL.next() & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
B_ACTION.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje dodatkowe właściwości procesu (pola tabeli B_PROC)
::   WE: _a - INTEGER - uchwyt do pliku .proc
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_PROC.cntx_psh();
B_PROC.clear();
{? B_PROC.seek(_env.SEL_PROC)
|| _result:=exec('export_bproc','#b_export',_file)
?};
B_PROC.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_roles
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje role znajdujące się w procesie
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_ROLE.cntx_psh();
B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_b_proc,'B_LANE');
{? B_PREL.first()
|| _buffer:=exec('B_ROLE','#buffer');
   {!
   |? {? B_PREL.B_ROLE<>null()
      ||
         _buffer.cntx_get(B_PREL.B_ROLE);
         exec('buffer_nullize','#b_export',_buffer);
         _can_continue:=exec('write_object','#b_export',_file,_buffer)
      ?};
      B_PREL.next() & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
B_ROLE.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_bprels
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje właściwości elementów procesu
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_b_proc);
{? B_PREL.first()
|| _buffer:=exec('B_PREL','#buffer');
   {!
   |? _buffer.get();
      exec('formulizer','#b_export',_buffer,'ref_create_save_element');
      exec('buffer_nullize','#b_export',_buffer);
      _can_continue:=exec('write_object','#b_export',_file,_buffer);
      B_PREL.next() & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_choices
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje warunki na bramach
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_CHOICE.cntx_psh();
B_CHOICE.index('B_PREL');
B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_b_proc);
{? B_PREL.first()
|| _buffer:=exec('B_CHOICE','#buffer');
   {!
   |? {? B_PREL.CLASS='B_GATE'
      ||
         B_CHOICE.prefix(B_PREL.ref());
         {? B_CHOICE.first()
         || {!
            |? _buffer.get();
               exec('formulizer','#b_export',_buffer,'ref_create_save_done');
               exec('buffer_nullize','#b_export',_buffer);
               _can_continue:=exec('write_object','#b_export',_file,_buffer);
               B_CHOICE.next() & _can_continue>0
            !}
         ?}
      ?};
      B_PREL.next() & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
B_CHOICE.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_dynamic_ports
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje dynamiczne porty wszystkich elementów procesu
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_PORT.cntx_psh();
B_PREL.cntx_psh();
B_PREL.index('PROC');
B_PREL.prefix(_b_proc);
{? B_PREL.first()
|| _buffer:=exec('B_PORT','#buffer');
   {!
   |?
      B_PORT.index('EXPORT');
      B_PORT.prefix('T',null(),B_PREL.ref(),null());
      {? B_PORT.first()
      || {!
         |? _buffer.get();
            exec('formulizer','#b_export',_buffer,'ref_create_save_done');
            exec('buffer_nullize','#b_export',_buffer);
            _can_continue:=exec('write_object','#b_export',_file,_buffer);
            B_PORT.next() & _can_continue>0
         !}
      ?};
      B_PREL.next() & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
B_PORT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_poconns
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje powiązania argumentów
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;


B_PREL.cntx_psh();
B_PORT.cntx_psh();
B_POCONN.cntx_psh();
B_POCONN.index('PROC');
B_POCONN.prefix(_b_proc);
{? B_POCONN.first()
|| _buffer:=exec('B_POCONN','#buffer');
   {!
   |? _can_export:=1;
      {? B_POCONN.TO().ACTIVE='N' | B_POCONN.FROM().ACTIVE='N'
            |
         exec('is_event','#b_event',B_POCONN.PREL_SRC().B_ELE,'startowe','nieokreślone')>0
      || _can_export:=0
      ?};
      {? _can_export>0
      ||
         _buffer.get();
         exec('formulizer','#b_export',_buffer,'ref_create_save_done');
         exec('buffer_nullize','#b_export',_buffer);
         _can_continue:=exec('write_object','#b_export',_file,_buffer)
      ?};
      B_POCONN.next() & _can_continue>0
   !}
?};
B_POCONN.cntx_pop();
B_PORT.cntx_pop();
B_PREL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_ivals
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje interwały czasowe
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_TIMER.cntx_psh();
B_TIMER.index('B_PREL');
B_PROC.cntx_psh();
B_PROC.clear();
B_PREL.cntx_psh();
B_PREL.index('PROC');
{? B_PROC.seek(_b_proc)
||
   _buffer:=exec('buffer','#interval');

:: Interwał dla procesu
   {? B_PROC.IVAL_DEF<>null()
   || _buffer.cntx_get(B_PROC.IVAL_DEF);
      exec('formulizer','#b_export',_buffer,'ref_create_init');
      exec('buffer_nullize','#b_export',_buffer);
      _can_continue:=exec('write_object','#b_export',_file,_buffer)
   ?};
   {? _can_continue>0
   ||
      B_PREL.prefix(B_PROC.ref());
      {? B_PREL.first()
      ||
         {!
         |?
::          Interwał dla elementu
            {? B_PREL.IVAL_DEF<>null()
            ||
               _buffer.cntx_get(B_PREL.IVAL_DEF);
               exec('formulizer','#b_export',_buffer,'ref_create_init');
               exec('buffer_nullize','#b_export',_buffer);
               _can_continue:=exec('write_object','#b_export',_file,_buffer)
            ?};


            {? _can_continue>0
            || B_TIMER.prefix(B_PREL.ref());
               {? B_TIMER.first()
               || {!
                  |? {? B_TIMER.IVAL_DEF<>null()
                     ||
::                      Interwał dla harmonogramu elementu
                        _buffer.cntx_get(B_TIMER.IVAL_DEF);
                        exec('formulizer','#b_export',_buffer,'ref_create_init');
                        exec('buffer_nullize','#b_export',_buffer);
                        _can_continue:=exec('write_object','#b_export',_file,_buffer)
                     ?};
                     B_TIMER.next() & _can_continue>0
                  !}
               ?}
            ?};
            B_PREL.next() & _can_continue>0
         !}
      ?}
   ?}
?};
B_PREL.cntx_pop();
B_PROC.cntx_pop();
B_TIMER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_timers
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje harmonogramy elementów
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_TIMER.cntx_psh();
B_TIMER.index('B_PREL');
B_PREL.cntx_psh();
B_PREL.index('PROC');
_buffer:=exec('buffer','#b_timer');
B_PREL.prefix(_b_proc);
{? B_PREL.first()
||
   _can_continue:=1;
   {!
   |? {? _can_continue>0
      || B_TIMER.prefix(B_PREL.ref());
         {? B_TIMER.first()
         || {!
            |?
               _buffer.get();
               exec('formulizer','#b_export',_buffer,'ref_create_save_done');
               exec('buffer_nullize','#b_export',_buffer);
               _can_continue:=exec('write_object','#b_export',_file,_buffer);
               B_TIMER.next() & _can_continue>0
            !}
         ?}
      ?};
      B_PREL.next() & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
B_TIMER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje komunikaty dla elementów
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_MSG.cntx_psh();
B_MSG.index('B_PREL');
B_PREL.cntx_psh();
B_PREL.index('PROC');
_buffer:=exec('buffer','#b_msg');
B_PREL.prefix(_b_proc);
{? B_PREL.first()
||
   _can_continue:=1;
   {!
   |? {? _can_continue>0
      || B_MSG.prefix(B_PREL.ref());
         {? B_MSG.first()
         || {!
            |?
               _buffer.get(1);
::             Tworzę identyfikator dla notatek SYSMEMO
               _sys_id:=_env.next_id();

               {? _can_continue>0
               || _can_continue:=exec('write_memo','#b_export',_file,_buffer,_sys_id)
               ?};
               exec('formulizer','#b_export',_buffer,'ref_create_save_done',_sys_id);
               exec('buffer_nullize','#b_export',_buffer,0);
               {? _can_continue>0
               || _can_continue:=exec('write_object','#b_export',_file,_buffer)
               ?};
               {? _can_continue>0
               ||
                  {? B_MSG.BI_BLOBA<>null() | B_MSG.BI_BLOBE<>null()
                  ||
::                   Dodaję komunikat mówiący o tym że załączniki nie zostały wyeksportowane
                     _msg:='Załączniki przypięte do zdarzenia: %1 nie zostały wyeksportowane.'@[B_PREL.SYMBOL];
                     exec('import_komm','#b_export',_msg,7)
                  ?}
               ?};
               B_MSG.next() & _can_continue>0
            !}
         ?}
      ?};
      B_PREL.next() & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
B_MSG.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_values
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje wartości parametrów ustawione ręcznie na procesie
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_PORT.cntx_psh();
B_TYPE.cntx_psh();
B_VALPRT.cntx_psh();
B_VALPRT.index('EXPORT');
B_PREL.cntx_psh();
B_PREL.index('PROC');
_buffer:=exec('buffer','#b_valprt');
B_PREL.prefix(_b_proc);
{? B_PREL.first()
||
   _can_continue:=1;
   {!
   |? {? _can_continue>0
      || B_VALPRT.prefix(B_PREL.ref(),'T');
         {? B_VALPRT.first()
         || {!
            |?
               _can_export:=1;
               _buffer.get(1);

               {? B_VALPRT.B_PORT().B_TYPE().SYMBOL<>'MEMO'
               || _buffer.SYS_MEMO:=''
               ?};

               {? 1+B_VALPRT.B_PORT().B_TYPE().SYMBOL='_'
               ||
::                Jeśli zredagowana wartość dotyczy typu złączeniowego to sprawdzam
::                czy parametr ma zdefiniowaną formułę na eksport
                  {? B_PORT.FML_EXP=''
                  || _can_export:=0;
                     _msg:='Wartość parametru: %1 ustawiona w procesie na czynności: %2 nie została wyeksportowana, ponieważ parametr nie obsługuje eksportu.'@[B_PORT.SYMBOL,B_PREL.SYMBOL];
                     exec('import_komm','#b_export',_msg,7,_b_proc)
                  ||
                     _fml:=$B_PORT.FML_EXP;

::                   Wykonuje formułę na eksport wartości
                     _value:=($B_VALPRT.FORMULA)();
                     {? type_of(_value)=type_of(~~)
                     || _msg:='Nie znaleziono w bazie danych ręcznie ustawionej wartości parametru: %1. Parametr nie został prawidłowo wyeksportowany.'@[B_PORT.B_TYPE().SYMBOL];
                        exec('import_komm','#b_export',_msg,7,_b_proc)
                     ||
                        _new_formula:=_fml(_value);
                        {? type_of(_new_formula)=type_of('') & _new_formula<>''
                        || _buffer.FORMULA:=_new_formula
                        || _sym:=B_PREL.SYMBOL;
                           {? _sym=''
                           || _action_buf:=exec('findAction4Ele','#b_proman',B_PREL.B_ELE);
                              {? _action_buf.UID<>''
                              || _sym:='Czynność: %1'@[_action_buf.UID]
                              ?}
                           ?};
                           {? _sym<>''
                           || _msg:='Formuła na eksport wartości parametru: %1 zwróciła niepoprawny typ wartości (element procesu: %2)'@[B_PORT.SYMBOL,_sym]
                           || _msg:='Formuła na eksport wartości parametru: %1 zwróciła niepoprawny typ wartości'@[B_PORT.SYMBOL]
                           ?};
                           exec('import_komm','#b_export',_msg,7,_b_proc)
                        ?}
                     ?}
                  ?}
               ?};
               {? B_VALPRT.B_PORT().ACTIVE='N'
               || _can_export:=0
               ?};

               {? _can_export>0
               || {? B_VALPRT.BI_BLOB<>null()
                  ||
::                   Dodaję komunikat mówiący o tym że załączniki nie zostały wyeksportowane
                     _msg:='Załączniki przypięte do parametru: %1 w elemencie procesu: %2 nie zostały wyeksportowane.'@[B_PORT.SYMBOL,B_PREL.SYMBOL];
                     exec('import_komm','#b_export',_msg,7,_b_proc)
                  ?};

::                Tworzę identyfikator dla notatek SYSMEMO
                  _sys_id:=_env.next_id();

                  {? _can_continue>0 & _buffer.SYS_MEMO<>''
                  || _can_continue:=exec('write_memo','#b_export',_file,_buffer,_sys_id)
                  ?};
                  exec('formulizer','#b_export',_buffer,'ref_create_save_done',_sys_id);
                  exec('buffer_nullize','#b_export',_buffer,0);
                  {? _can_continue>0
                  || _can_continue:=exec('write_object','#b_export',_file,_buffer)
                  ?}
               ?};
               B_VALPRT.next() & _can_continue>0
            !}
         ?}
      ?};
      B_PREL.next() & _can_continue>0
   !}
?};
B_PORT.cntx_pop();
B_TYPE.cntx_pop();
B_PREL.cntx_pop();
B_VALPRT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_bconn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Eksportuje połączenia elementów
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_CONN.cntx_psh();
B_CONN.index('UID');
B_PREL.cntx_psh();
_buffer:=exec('buffer','#b_conn');
B_CONN.prefix(_b_proc);
{? B_CONN.first()
||
   {!
   |? _buffer.get(1);
      exec('formulizer','#b_export',_buffer,'ref_create_save_done');
      exec('buffer_nullize','#b_export',_buffer,0);
      {? _can_continue>0
      || _can_continue:=exec('write_object','#b_export',_file,_buffer)
      ?};
      B_CONN.next() & _can_continue>0
   !}
?};
B_PREL.cntx_pop();
B_CONN.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_signal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje sygnały
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - B_PROC.ref() - proces, jeśli nie podany to wartość brana z _env.
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_b_proc:=_env.SEL_PROC;
{? var_pres('_b')=type_of(B_PROC.ref())
|| _b_proc:=_b
?};

_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

B_SIGTYP.cntx_psh();
B_SIGTYP.index('PARAMETR');
B_PORT.cntx_psh();
B_TYPE.cntx_psh();
B_SIGPRT.cntx_psh();
B_SIGPRT.index('S1');
B_PREL.cntx_psh();
B_PREL.index('PROC');
_buf_sig:=exec('buffer','#b_signal');
_this_sig:=_buf_sig.this;
_buf_typ:=exec('buffer','#b_sigtyp');
_this_typ:=_buf_typ.this;
_buf_prt:=exec('buffer','#b_sigprt');

_tab_sig:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'SIGNAL','STRING[100]','Nazwa pola 1'
);

B_PREL.prefix(_b_proc);
{? B_PREL.first()
||
   _can_continue:=1;
   {!
   |? {? _can_continue>0
      || {? B_PREL.B_SIGNAL<>null()
         ||
            _tab_sig.prefix(B_PREL.B_SIGNAL().SYMBOL,);
            {? _tab_sig.first()=0
            ||
               _sig_id:=_env.next_id();
::             Dodaję tylko taki sygnał którego jeszcze nie przetwarzałem
               _tab_sig.blank();
               _tab_sig.SIGNAL:=B_SIGNAL.SYMBOL;
               _tab_sig.add();

::             Eksport definicji sygnału
               _buf_sig.cntx_get(B_PREL.B_SIGNAL);

::             Do formuły tworzącej obiekt doklejam identyfikator, żeby łatwiej mi było
::             znaleźć powiązane rekordy
               _buf_sig.this:=$('\''+_sig_id+'\';'+_this_sig);
               exec('buffer_nullize','#b_export',_buf_sig,0);
               {? _can_continue>0
               || _can_continue:=exec('write_object','#b_export',_file,_buf_sig)
               ?};

::             Eksport parametrów sygnału
               B_SIGTYP.prefix(B_PREL.B_SIGNAL);
               {? B_SIGTYP.first()
               || {!
                  |? _buf_typ.get();

::                   Do formuły tworzącej obiekt doklejam identyfikator, żeby łatwiej mi było
::                   znaleźć powiązane rekordy
                     _buf_typ.this:=$('\''+_sig_id+'\';'+_this_typ);
                     exec('formulizer','#b_export',_buf_typ,'ref_create_signal');
                     exec('buffer_nullize','#b_export',_buf_typ,0);
                     {? _can_continue>0
                     || _can_continue:=exec('write_object','#b_export',_file,_buf_typ)
                     ?};
                     B_SIGTYP.next()
                  !}
               ?}
            ?};

::          Eksport powiązań parametrów sygnału z B_PORTami
            B_SIGPRT.prefix(B_PREL.ref());
            {? B_SIGPRT.first()
            || {!
               |? _buf_prt.get();
                  exec('formulizer','#b_export',_buf_prt,'ref_create_save_done');
                  exec('buffer_nullize','#b_export',_buf_prt,0);
                  {? _can_continue>0
                  || _can_continue:=exec('write_object','#b_export',_file,_buf_prt)
                  ?};
                  B_SIGPRT.next()
               !}
            ?}
         ?}
      ?};
      B_PREL.next() & _can_continue>0
   !}
?};
B_SIGTYP.cntx_pop();
B_PORT.cntx_pop();
B_TYPE.cntx_pop();
B_PREL.cntx_pop();
B_SIGPRT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\export_bproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Eksportuje procesy
::   WE: _a - INTEGER - uchwyt do pliku .proc
::       [_b] - obj_new - bufor B_PROC, jeżeli nie podany to tworzę na podstawie aktualnego
::                        kontekstu B_PROC
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_file:=_a;
_buffer:=~~;
{? var_pres('_b')>100
|| _buffer:=_b
|| _buffer:=exec('B_PROC','#buffer');
   _buffer.get(1)
?};
_sep:=exec('separator','#b_export');

_result:=0;
_can_continue:=1;

:: Tworzę identyfikator dla notatek SYSMEMO
_sys_id:=_env.next_id();
{? _can_continue>0 & (_buffer.DESC<>'' | _buffer.TARGET<>'')
|| _can_continue:=exec('write_memo','#b_export',_file,_buffer,_sys_id)
?};
_buffer.IVAL_DEF:=null();
_buffer.TM_SAVE:=0;
_buffer.TM_IMP:=0;
_buffer.A_IDTIME:='';
_buffer.MODIFIED:='N';
exec('formulizer','#b_export',_buffer,'ref_create_save_done',_sys_id);
exec('buffer_nullize','#b_export',_buffer,0);
{? _can_continue>0
|| _can_continue:=exec('write_object','#b_export',_file,_buffer)
?};

{? _can_continue>0
|| _result:=1
?};
_result


\export_done
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła wykonywana po zakończeniu eksportu
::   WE: _a - STRING - ścieżka do eksportowanego pliku .proc na terminalu klienta
::  TAG: <YWORKS><MODELER><EKSPORT>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_filepath:=_a;

{? VAR.GRUPA<>'T'
||
:: Pojawiam przyciski na dolnej belce modelera
   exec('set_visible','#desktop','',_env.ctr_id,'przyciski',1);
   KOMM.select()
?};
'1'


\import_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Inicjalizuje import procesu, wysyła odzyskany plik .proc na serwer do katalogu work
::   WE: _a - STRING - ścieżka do pliku .proc na terminalu klienta
::       _b - STRING - nazwa pliku bez rozszerzenia
::       _c - STRING - katalog pliku docelowego
::   WY: '' - porażka
::       STRING - nazwa pliku .proc który został wciągnięty do worka
::  TAG: <YWORKS><MODELER><IMPORT>
:: ~OST: INFCOPY,INFERASE
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;

{? exec('interm','#system')
|| FUN.emsg(exec('interm_nacc_msg','#system'));
   return('')
?};

{? _env.IMPORT_GR=0
||
:: Znikam przyciski na dolnej belce modelera
   exec('set_visible','#desktop','',_env.ctr_id,'przyciski',0)
?};

_filepath:=_a;
_filename:=_b;

_dir:=_c;

_result:='0';
_can_continue:=1;

{? _can_continue>0
||
:: Doklejam do nazwy pliku .proc tm_stampa żeby był unikalny po stronie serwera
   _filename:=(40+_filename)+$SYSLOG.tm_stamp()+'.proc';

:: Wysyłam plik z terminalu na serwer gdzie będzie obrabiany
   _can_continue:=fcopy('@'+_filepath,_filename,0,1,1)
?};
{? _can_continue>0
||
   _env.IMPORT_FILEPROC:=_filename;
:: Kasuję plik z terminalu
   _can_continue:=ferase('@'+_filepath,0)
?};
{? _can_continue>0
|| _result:=_filename
?};
_result


\import_file_mbase
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przetwarza plik z rozszerzeniem .proc. Zawarte w nim informacje dopisuje do bazy danych
::   WE: _a - STRING - nazwa pliku który przetworzyć
::  TAG: <YWORKS><MODELER><IMPORT>
::----------------------------------------------------------------------------------------------------------------------
_filename:=_a;

FUN.info(_filename);
~~


\import_done
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła wykonywana po zakończeniu importu
::   WE: _a - STRING - ścieżka do importowanego pliku .proc na terminalu klienta
::  TAG: <YWORKS><MODELER><IMPORT>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_filepath:=_a;
_result:='1';
{? _env.IMPORT_GR=0
||
:: Pojawiam przyciski na dolnej belce modelera
   exec('set_visible','#desktop','',_env.ctr_id,'przyciski',1);

:: Oznaczam diagram jako zmodyfikowany
   exec('diagram_changed','#b_bpmn','import')
|| _result:='2';
   echo('Rozpoczęcie zapisu importowanego procesu z pliku: %1'@[_filepath])
?};
_result


\procfile_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Pierwsza analiza pliku .proc. Wykonuje następujące rzeczy:
::       1. Sprawdza czy wersje modelera są zgodne z obecnym systemem.
::       2. Dodaje do środowiska w tabelce tymczasowej wersje czynności i ich sumy kontrolne
::       3. Dodaje do systemu role
::   WE: [_a] - STRING - nazwa pliku .proc którego szukać po stronie serwera
::       [_b] - tab_tmp - uchwyt do tabeli zawierającej importowaną zawartość
::       [_c] - STRING - prefix do tabeli zawierajacej importowaną zawartość
::       [_d] - STRING  indeks w tabeli zawierającej importowaną zawartość
::       [_e] - INTEGER - prefiksować tabelkę _b tylko sygnałami
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_fileproc:='';
{? var_pres('_a')=type_of('')
|| _fileproc:=_a
?};

_tab_imex:=~~;
{? var_pres('_b')>100
|| _tab_imex:=_b
|| _tab_imex:=_env.TAB_IMEX_PROC
?};

_tab_prefix:='';
{? var_pres('_c')=type_of('')
|| _tab_prefix:=_c
?};

_tab_index:='';
{? var_pres('_d')=type_of('')
|| _tab_index:=_d
?};

_signals_only:=0;
{? var_pres('_e')=type_of(0)
|| _signals_only:=_e
?};

_formulizer_command:='ref_create_init';

_can_continue:=1;
_result:=1;

B_PROC.cntx_psh();
B_PROC.clear();
{? B_PROC.seek(_env.SEL_PROC)
||
   {? _fileproc<>''
   ||
::    Jeżeli nazwa pliku .proc podana, to zapamiętuję ją w procesie, żeby w przypadku
::    kiedy import się wykrzaczy móc ponownie zaimportować ten sam plik
      B_PROC.PROCFILE:=_fileproc;
      B_PROC.put()
   ||
::    Nazwa pliku .proc nie przyszła z modelera, więc ją odczytuję z procesu
      _fileproc:=B_PROC.PROCFILE
   ?}
?};
B_PROC.cntx_pop();

_sep:=exec('separator','#b_export');

_tab_imex.clear();

{? _fileproc<>''
||
:: Otwieram plik na serwerze z zgodnie z deklaracją ścieżek w pth
   _file:=fopen(_fileproc,'ur',1,1);

:: czyszczę tab_imex.erase
   _result:=exec('env_clean','#b_export');

   {? _result>0
   ||
      {? _file>0
      ||
::       Czytam plik .proc i całą jego zawartość umieszczam w tabeli tymczasowej z polem SYS_MEMO
::       Każda linia to nowy rekord w tej tabeli
         _obj_txt:='';
         {!
         |?
            _line:=fread(_file);

::          Zabezpieczenie przed BOMem wewnątrz pliku (nie jako pierwszym znakiem)
            {? ^(1+form(_line))=65279
            || _line:=1-form(_line)
            ?};

            {? var_pres('_split')>100
            || obj_del(_split)
            ?};
            _split:=spli_str(_line,_sep);
            _uid:=_split[1];
            {? _uid<>'SYSMEMO'
            ||
               _obj_txt+=_line;
::             Sprawdzam czy linia kończy się separatorem
               {? (_obj_txt+(+_sep))=_sep
               ||
::                Linia kończy się separatorem, więc dodaję rekord do tabeli
                  _tab_imex.blank();
                  {? var_pres('_split2')>100
                  || obj_del(_split2)
                  ?};
                  _split2:=spli_str(_obj_txt,_sep);
                  _uid:=_split2[1];
                  _uid:=exec('get_uid','#b_export',_uid);
                  _tab_imex.UID:=_uid;
                  _tab_imex.memo_set(_obj_txt,'LINE');
                  {? _can_continue>0
                  || _can_continue:=_tab_imex.add()
                  ?};
                  {? _can_continue>0
                  || _can_continue:=_tab_imex.memo_put()
                  ?};
                  _obj_txt:=''
               ||
::                Linia nie kończy się separatorem, więc jest pewnie złamana, dodaję znak końca linii
                  _obj_txt+='\n'
               ?}
            ?};
            _line<>'\n' & _can_continue>0
         !};
         fclose(_file)
      ||
         _msg:='Nie udało się otworzyć pliku z właściwościami importowanego procesu: %1'@[_fileproc];
         exec('import_komm','#b_export',_msg);
         _result:=0
      ?}
   || {? _file>0
      || fclose(_file)
      ?}
   ?}
?};

{? _result>0
||
:: Przetwarzam odczytany plik iterując po tabeli tymczasowej
   {? _tab_prefix<>''
   ||
      {? _signals_only>0
      || {? _tab_index<>''
         || _tab_imex.index(_tab_index)
         ?};
         _tab_imex.prefix(_tab_prefix,'B_SIGNAL',)
      || _tab_imex.prefix(_tab_prefix,)
      ?}
   || _tab_imex.prefix()
   ?};
   {? _tab_imex.first()
   || {!
      |?
         {? var_pres('_obj')>100
         || obj_del(_obj)
         ?};
         {? var_pres('_read_res')>100
         || obj_del(_read_res)
         ?};
         _next:=0;
         _ref_nxt:=null();
         _tab_imex.cntx_psh();
         {? _tab_imex.next()>0
         || _ref_nxt:=_tab_imex.ref()
         ?};
         _tab_imex.cntx_pop();

         _line:=_tab_imex.memo_txt(,1);

         _komm:=0;

::       Dla B_PRELi włączam komunikaty, bo tam mogą być ważne rzeczy
         {? (30+_line)*'B_PREL'>0
         || _komm:=1
         ?};

         {? var_pres('_split')>100
         || obj_del(_split)
         ?};
         _split:=spli_str(_line,_sep);
         _uid:=_split[1];

         {? _uid<>'SYSMEMO'
         ||
            _read_res:=exec('read_object','#b_export',_line,_formulizer_command,_komm);

            {? _read_res.RESULT>0
            || _obj:=_read_res.OBJ;
               {?  var_pres('_obj')>100
               || _result:=exec('procfile_init_core','#b_export',_obj,_tab_imex)
               ?}
            ||
::             Jeżeli obiekt nie został odczytany prawidłowo to znak że nie ma jakiś powiązanych
::             rekordów i pora przerwać import
               _result:=0
            ?}
         ?};
         {? _ref_nxt<>null()
         || _next:=_tab_imex.seek(_ref_nxt)
         ?};
         _next>0
      !};
::    Jeszcze raz pętlę żeby sprawdzić sygnały
      {? _tab_prefix<>''
      || {? _tab_index<>''
         || _tab_imex.index(_tab_index)
         ?};
         _tab_imex.prefix(_tab_prefix,'B_SIGNAL',)
      || _tab_imex.prefix('B_SIGNAL',)
      ?};
      {? _result>0 & _tab_imex.first()
      || {!
         |?
            {? var_pres('_obj')>100
            || obj_del(_obj)
            ?};
            {? var_pres('_read_res')>100
            || obj_del(_read_res)
            ?};

            _line:=_tab_imex.memo_txt(,1);
            _read_res:=exec('read_object','#b_export',_line,_formulizer_command);
            _obj:=_read_res.OBJ;
            {? _read_res.RESULT>0
            ||
               {? _obj.this*'B_SIGNAL'>0
               ||
                  B_SIGTYP.cntx_psh();
                  B_SIGTYP.index('PARAMETR');
                  B_SIGNAL.cntx_psh();
                  B_SIGNAL.index('SYMBOL');
                  B_SIGNAL.prefix(_obj.SYMBOL,);
                  {? B_SIGNAL.first()
                  ||
::                   Jest już taka definicja sygnału - sprawdzam czy ma taką samą strukturę
                     B_SIGTYP.prefix(B_SIGNAL.ref());

                     _tab_imex.cntx_psh();
                     {? _tab_prefix<>''
                     || {? _tab_index<>''
                        || _tab_imex.index(_tab_index)
                        ?};
                        _tab_imex.prefix(_tab_prefix,'B_SIGTYP',_tab_imex.UID2,)
                     || _tab_imex.prefix('B_SIGTYP',_tab_imex.UID2,)
                     ?};

                     {? _tab_imex.size()=B_SIGTYP.size()
                     ||
::                      Struktura sygnału ma tyle samo elementów
                        {? _tab_imex.first()
                        || {!
                           |?
                              {? var_pres('_obj2')>100
                              || obj_del(_obj2)
                              ?};
                              {? var_pres('_read_res2')>100
                              || obj_del(_read_res2)
                              ?};

                              _line_loc:=_tab_imex.memo_txt(,1);
                              _read_res2:=exec('read_object','#b_export',_line_loc,'ref_create_signal',0);
                              _obj2:=_read_res2.OBJ;
                              {? _read_res2.RESULT>0
                              ||
                                 B_SIGTYP.prefix(B_SIGNAL.ref(),_obj2.PARAMETR,);
                                 {? B_SIGTYP.first()
                                 ||
::                                  Znalazłem B_SIGTYP o takiej samej nazwie, sprawdzam czy typ taki sam
                                    {? B_SIGTYP.B_TYPE<>_obj2.B_TYPE
                                    || _env.TAB_IMEX_SIG.blank();
                                       _env.TAB_IMEX_SIG.SYMBOL:=_obj.SYMBOL;
                                       _env.TAB_IMEX_SIG.add();
                                       _msg:='Sygnał o symbolu %1 ma inną strukturę parametrów. Nie udało się zaimportować niektórych zdarzeń sygnałowych.'@[_obj.SYMBOL];
                                       exec('import_komm','#b_export',_msg)
                                    ?}
                                 || _env.TAB_IMEX_SIG.blank();
                                    _env.TAB_IMEX_SIG.SYMBOL:=_obj.SYMBOL;
                                    _env.TAB_IMEX_SIG.add();
                                    _msg:='Sygnał o symbolu %1 ma inną strukturę parametrów. Nie udało się zaimportować niektórych zdarzeń sygnałowych.'@[_obj.SYMBOL];
                                    exec('import_komm','#b_export',_msg)
                                 ?}
                              ?};
                              _tab_imex.next()
                           !}
                        ?}
                     ||
::                      Struktura sygnału różni się, więc dodaje info i zwracam 0 żeby przerwać
::                      import pozostałych rzeczy dot. sygnałów
                        _env.TAB_IMEX_SIG.blank();
                        _env.TAB_IMEX_SIG.SYMBOL:=_obj.SYMBOL;
                        _env.TAB_IMEX_SIG.add();
                        _msg:='Sygnał o symbolu %1 ma inną strukturę parametrów. Nie udało się zaimportować niektórych zdarzeń sygnałowych.'@[_obj.SYMBOL];
                        exec('import_komm','#b_export',_msg)
                     ?};
                     _tab_imex.cntx_pop();
                     ~~
                  ||
::                   Brak definicji sygnału, więc ją zakładam
                     B_SIGNAL.cntx_psh();
                     B_SIGNAL.clear();
                     {? exec('add','#b_signal',_obj)<>null()
                     || _can_continue:=1
                     || _can_continue:=0;
                        _symbol:=_obj.SYMBOL;
                        {? _symbol<>''
                        || _msg:='Nie udało się zaimportować definicji sygnału: %1'@[_symbol];
                           _env.TAB_IMEX_SIG.blank();
                           _env.TAB_IMEX_SIG.SYMBOL:=_symbol;
                           _env.TAB_IMEX_SIG.add()
                        || _msg:='Nie udało się zaimportować niektórych definicji sygnałów.'@
                        ?};
                        exec('import_komm','#b_export',_msg)
                     ?};
                     {? _can_continue>0
                     ||
::                      Dodaje parametry dla sygnału (B_SIGTYP)
                        _tab_imex.cntx_psh();
                        {? _tab_prefix<>''
                        || {? _tab_index<>''
                           || _tab_imex.index(_tab_index)
                           ?};
                           _tab_imex.prefix(_tab_prefix,'B_SIGTYP',_tab_imex.UID2,)
                        || _tab_imex.prefix('B_SIGTYP',_tab_imex.UID2,)
                        ?};
                        {? _tab_imex.first()
                        || {!
                           |?
                              {? var_pres('_obj2')>100
                              || obj_del(_obj2)
                              ?};
                              {? var_pres('_read_res2')>100
                              || obj_del(_read_res2)
                              ?};

                              _line_loc:=_tab_imex.memo_txt(,1);
                              _read_res2:=exec('read_object','#b_export',_line_loc,'ref_create_signal',0);
                              _obj2:=_read_res2.OBJ;
                              {? _read_res2.RESULT>0
                              || B_SIGTYP.cntx_psh();
                                 {? exec('add','#b_sigtyp',_obj2)<>null()
                                 || _can_continue:=1
                                 || _can_continue:=0;
                                    _result:=0;

                                    _symbol:=_obj.SYMBOL;
                                    {? _symbol<>''
                                    || _msg:='Nie udało się zaimportować parametrów dla sygnału: %1'@[_symbol];
                                       _env.TAB_IMEX_SIG.blank();
                                       _env.TAB_IMEX_SIG.SYMBOL:=_symbol;
                                       _env.TAB_IMEX_SIG.add()
                                    || _msg:='Nie udało się zaimportować parametrów dla niektórych sygnałów.'@
                                    ?};
                                    exec('import_komm','#b_export',_msg)
                                 ?};
                                 B_SIGTYP.cntx_pop()
                              ?};
                              _tab_imex.next()
                           !}
                        ?};
                        _tab_imex.cntx_pop();
                        ~~
                     ?};
                     B_SIGNAL.cntx_pop();
                     ~~
                  ?};
                  B_SIGNAL.cntx_pop();
                  B_SIGTYP.cntx_pop();
                  ~~
               || _msg:='Sygnał o identyfikatorze: %1 nie jest rekordem tabeli B_SIGNAL'@[_tab_imex.UID+' '+_tab_imex.UID2];
                  exec('import_komm','#b_export',_msg)
               ?}
            || _msg:='Nie powiodło się odczytanie sygnału o identyfikatorze: %1'@[_tab_imex.UID+' '+_tab_imex.UID2];
               exec('import_komm','#b_export',_msg)
            ?};
            _tab_imex.next()
         !}
      ?}
   ?}
?};
_result


\procfile_init_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Jądro funkcji procfile_init
::   WE: _a - obj_new - obiekt odczytany z pliku
::       [_b] - tab_tmp - uchwyt do tabeli zawierającej importowaną zawartość
::   WY:
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_obj:=_a;

_tab_imex:=~~;
{? var_pres('_b')>100
|| _tab_imex:=_b
|| _tab_imex:=_env.TAB_IMEX_PROC
?};

_sep:=exec('separator','#b_export');
_tab_act:=_env.TAB_IMEX_ACT;

_result:=1;

{? _obj.this*'obj_version'>0
||
:: Kontrola wersji modelera
   {? _env.ctr_id<>''
   ||
      _modeler_imp:=exec('get_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'version');
      _modeler_imp:=gsub(_modeler_imp,',','.');

      _modeler_exp:=gsub(_obj.MODELER_VER,',','.');

      _ver_exp:=#_modeler_exp;
      _ver_imp:=#_modeler_imp;

      {? _ver_exp>_ver_imp
      ||
::       Wersja modelera którym wyeksportowano proces jest większa niż ta do której importuję
         _result:=0;
         _msg:='Modeler, którym proces został wyeksportowany jest nowszy niż w systemie docelowym. Import niemożliwy.'@;
         exec('import_komm','#b_export',_msg)
      ?}
   ?}
|? _obj.this*'obj_actchk'>0
||
:: Dodaje do środowiska info kontrolne o czynnościach
   B_ACTION.cntx_psh();
   B_ACTION.index('UNIK');
   B_ACTION.prefix(_obj.ACTION_UID);
   {? B_ACTION.first()
   ||
      _tab_act.prefix($_env.SEL_PROC,B_ACTION.UID);
      {? _tab_act.size()=0
      ||
         _tab_act.blank();
         _tab_act.B_PROC:=$_env.SEL_PROC;
         _tab_act.ACT_UID:=B_ACTION.UID;
         _tab_act.ACT_VER:=_obj.ACTION_VER;
         _tab_act.ACT_HASH:=_obj.ACTION_HASH;
         _tab_act.add()
      ?}
   ?};
   B_ACTION.cntx_pop()
|? _obj.this*'B_ROLE'>0
||
:: Import ról
   B_ROLE.cntx_psh();
   B_ROLE.index('UNIK');
   B_ROLE.prefix(REF.FIRMA,_obj.NAME,);
   {? B_ROLE.first()=0
   || B_ROLE.blank();
      B_ROLE.FIRMA:=REF.FIRMA;
      B_ROLE.NAME:=_obj.NAME;
      {? B_ROLE.add()
      || _msg:='Podczas importu została dodana nowa rola: %1. Przed uruchomieniem procesu należy jej przydzielić użytkowników.'@[B_ROLE.NAME];
         exec('import_komm','#b_export',_msg,7,,'info')
      ?}
   ?};
   B_ROLE.cntx_pop();
   ~~
|? _obj.this*'B_PREL'>0
||
:: B_PRELa będę przetwarzał przy zapisie, ale tutaj zmodyfikuję UID w tabelce
:: tymczasowej zawierającej treść pliku .proc żeby później łatwo do niego trafić
   _tab_imex.cntx_psh();
   _tab_imex.UID:=_obj.UID;
   _tab_imex.put();
   _tab_imex.cntx_pop()
|? _obj.this*'IVAL_DEF'>0
||
   IVAL_DEF.cntx_psh();
   IVAL_DEF.clear();
   {? exec('add','#interval',_obj)<>null()
   || _can_continue:=1
   || _can_continue:=0;
      {? _obj.TM_STAMP>0
      || _symbol:=exec('to_string','#interval',_obj.TM_STAMP);
         _msg:='Nie udało się zaimportować interwału czasowego: %1'@[_symbol]
      || _msg:='Nie udało się zaimportować niektórych interwałów czasowych.'@
      ?};
      exec('import_komm','#b_export',_msg)
   ?};
   IVAL_DEF.cntx_pop()
|? (_tab_imex.UID*'B_SIGNAL'>0 | _tab_imex.UID*'B_SIGTYP'>0) & _tab_imex.UID*';'>0
||
   {? var_pres('_split')>100
   || obj_del(_split)
   ?};
   _split:=spli_str(_tab_imex.UID,';');
   _id:=_split[1];
   _tab_imex.cntx_psh();
   _tab_imex.UID:=_split[2];
   _tab_imex.UID2:=_split[1];
   _tab_imex.put();
   _tab_imex.cntx_pop();
   ~~
?};
_result


\procfile_done
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Końcowa analiza pliku .proc. Wykonuje następujące rzeczy:
::       1. Importuje warunki na bramach
::       2. Importuje powiązania elementów
::       3. Importuje dynamiczne B_PORTy
::       4. Importuje dodatkowe właściwości procesu
::   WE: _a - STRING - prefix dla tabeli _env.TAB_IMEX_PROC
::       [_b] - STRING - identyfikator dla zamieniaczki formuły na prawdziwe refy
::       [_c] - tab_tmp - tabela zawierająca zawartość importowanego procesu
::       [_d] - INTEGER - czy usuwać nieużywane role
::       [_e] - INTEGER - czy wykonywać procfile_init
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_prefix:='';
{? var_pres('_a')=type_of('')
|| _prefix:=_a
?};

_formulizer_command:='ref_create_save_done';
{? var_pres('_b')=type_of('')
|| _formulizer_command:=_b
?};

_tab_imex:=~~;
{? var_pres('_c')>100
|| _tab_imex:=_c
|| _tab_imex:=_env.TAB_IMEX_PROC
?};

_role_del:=1;
{? var_pres('_d')=type_of(0)
|| _role_del:=_d
?};

_procfile_init:=0;
{? var_pres('_e')=type_of(0)
|| _procfile_init:=_e
?};

_env_imex:=~~;
{? var_pres('env_imex',params_get())>100
|| _env_imex:=params_get().env_imex
?};

_tab_imex.cntx_psh();

_result:=1;
_can_continue:=1;

{? _prefix<>''
|| _tab_imex.prefix(_prefix)
|| _tab_imex.prefix()
?};
{? _tab_imex.first()
|| {!
   |?
      _can_continue:=1;
      {? var_pres('_obj')>100
      || obj_del(_obj)
      ?};
      {? var_pres('_read_res')>100
      || obj_del(_read_res)
      ?};

      _line:=_tab_imex.memo_txt(,1);

      _komm:=0;

::    Dla B_PRELi włączam komunikaty, bo tam mogą być ważne rzeczy
      {? (30+_line)*'B_PREL'>0
      || _komm:=1
      ?};

      _read_res:=exec('read_object','#b_export',_line,_formulizer_command,_komm);
      _obj:=_read_res.OBJ;

      {? var_pres('_obj')>100
      ||
         {? _read_res.RESULT>0
         ||
            {? _procfile_init>0
            || _can_continue:=exec('procfile_init_core','#b_export',_obj,_tab_imex)
            ?};

            {? _can_continue=0
            || _result:=0
            ||
               {? _obj.this*'B_PREL'>0
               ||
                  B_PREL.cntx_psh();
                  B_PREL.index('UID');
                  B_PREL.prefix(_env.SEL_PROC,_obj.UID,);
                  {? B_PREL.first()=0
                  ||
                     _obj.B_PROC:=_env.SEL_PROC;
                     _prel_sym:=_obj.SYMBOL;
                     {? _prel_sym='' & _obj.B_ELE<>null()
                     || _prel_sym:=exec('FindAndGet','#table',B_ELE,_obj.B_ELE,,"SYMBOL",'')
                     ?};
                     {? _prel_sym=''
                     || _prel_sym:=_obj.UID
                     ?};
                     {? _obj.CLASS='B_ACTION'
                     || _can_continue:=exec('action_chk','#b_export',_obj.B_ELE)
                     ?};

                     {? _can_continue
                     ||
                        {? _obj.B_SIGNAL<>null()
                        ||
                           _signal_sym:=exec('FindAndGet','#table',B_SIGNAL,_obj.B_SIGNAL,,"SYMBOL",'');
::                         Sprawdzam czy sygnał znajduje się na czarnej liście
                           _env.TAB_IMEX_SIG.cntx_psh();
                           _env.TAB_IMEX_SIG.prefix(_signal_sym);
                           {? _env.TAB_IMEX_SIG.first()
                           ||
::                            Był jakiś problem z tym sygnałem więc nie importuję tego zdarzenia
                              _can_continue:=0;
                              _msg:='Nie udało się zaimportować sygnału: %1, więc zdarzenie: %2 również nie zostało zaimportowane.'@[_signal_sym,_prel_sym]
                           ?};
                           _env.TAB_IMEX_SIG.cntx_pop()
                        ?}
                     ?};

                     {? _can_continue>0
                     ||
                        {? exec('add','#b_prel',_obj,0)<>null()
                        || _can_continue:=1
                        || _can_continue:=0
                        ?}
                     ?};

                     {? _can_continue=0
                     ||
                        _msg:='Nie udało się zaimportować elementu procesu: %1'@[_prel_sym];
                        exec('import_komm','#b_export',_msg)
                     ?}
                  ?};
                  B_PREL.cntx_pop();
                  ~~
               |? _obj.this*'B_CONN'>0
               ||
                  B_CONN.cntx_psh();
                  B_CONN.index('UID');
                  B_CONN.prefix(_env.SEL_PROC,_obj.UID);
                  {? B_CONN.first()=0
                  || _obj.B_PROC:=_env.SEL_PROC;
                     {? exec('add','#b_conn',_obj)<>null()
                     || _can_continue:=1
                     || _can_continue:=0;
                        _name:=_obj.NAME;
                        {? _name='' & _obj.B_ELE<>null()
                        || _name:=exec('FindAndGet','#table',B_ELE,_obj.B_ELE,,"SYMBOL",'')
                        ?};
                        {? _name=''
                        || _name:=_obj.UID
                        ?};
                        _msg:='Nie udało się zaimportować połączenia: %1'@[_name];
                        exec('import_komm','#b_export',_msg)
                     ?}
                  ?};
                  B_CONN.cntx_pop();
                  ~~
               |? _obj.this*'B_CHOICE'>0
               ||
                  B_CHOICE.cntx_psh();
                  B_CHOICE.clear();
                  {? exec('add','#b_choice',_obj)<>null()
                  || _can_continue:=1
                  || _can_continue:=0;
                     _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
                     {? _prel_sym<>''
                     || _msg:='Nie udało się zaimportować warunku: %1 do bramy %2'@[_obj.NAME,_prel_sym]
                     || _msg:='Nie udało się zaimportować warunku: %1'@[_obj.NAME]
                     ?};
                     exec('import_komm','#b_export',_msg)
                  ?};
                  B_CHOICE.cntx_pop()
               |? _obj.this*'B_PORT'>0
               ||
                  B_PORT.cntx_psh();
                  B_PORT.clear();
                  {? exec('add','#b_port',_obj)<>null()
                  || _can_continue:=1
                  || _can_continue:=0;

                     _port_sym:=_obj.SYMBOL;
                     _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
                     {? _prel_sym<>'' & _prel_sym<>''
                     || _msg:='Nie udało się zaimportować dynamicznego parametru: %1 do czynności %2'@[_port_sym,_prel_sym]
                     || _msg:='Nie udało się zaimportować dynamicznego parametru: %1'@[_port_sym]
                     ?};
                     exec('import_komm','#b_export',_msg)
                  ?};
                  B_PORT.cntx_pop()

               |? _obj.this*'B_ROLE'>0
               ||
                  {? _role_del>0
                  ||
::                   Sprawdzam czy rola została faktycznie użyta w procesie
                     B_ROLE.cntx_psh();
                     B_ROLE.index('UNIK');
                     B_ROLE.prefix(REF.FIRMA,_obj.NAME,);
                     {? B_ROLE.first()
                     ||
                        B_PREL.cntx_psh();
                        B_PREL.index('PROCROLE');
                        B_PREL.prefix(_env.SEL_PROC,'B_LANE',B_ROLE.ref());
                        {? B_PREL.size()=0
                        ||
::                         Roli ostatecznie nie użyto w procesie więc ją usuwam (np ktoś ją zamienił na inną)
                           {? exec('can_delete','#b_role',,0)>0
                           ||
                              {? exec('delete','#b_role',B_ROLE.ref())>0
                              ||
::                               Udało się usunąć, wiec usuwam z KOMMa niepotrzebny komunikat jeżeli jest
                                 _msg:='Podczas importu została dodana nowa rola: %1. Przed uruchomieniem procesu należy jej przydzielić użytkowników.'@[B_ROLE.NAME];
                                 KOMM.del(_msg)
                              ||
                                 _msg:='Nie udało się usunąć nieużywanej roli w procesie: %1'@[B_ROLE.NAME];
                                 exec('import_komm','#b_export',_msg)
                              ?}
                           ?}
                        ?};
                        B_PREL.cntx_pop()
                     ?};
                     B_ROLE.cntx_pop()
                  ?};
                  ~~
               |? _obj.this*'B_POCONN'>0
               || B_POCONN.cntx_psh();
                  B_POCONN.clear();
                  _obj.B_PROC:=_env.SEL_PROC;
                  {? exec('add','#b_poconn',_obj)<>null()
                  || _can_continue:=1
                  || _can_continue:=0;

                     _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.PREL_DST,,"SYMBOL",'');
                     _port_sym:=exec('FindAndGet','#table',B_PORT,_obj.TO,,"SYMBOL",'');
                     {? _prel_sym<>'' & _port_sym<>''
                     || _msg:='Nie udało się zaimportować powiazania parametru: %1 do czynności %2'@[_port_sym,_prel_sym]
                     |? _port_sym<>''
                     || _msg:='Nie udało się zaimportować powiazania parametru: %1'@[_port_sym]
                     |? _prel_sym<>''
                     || _msg:='Nie udało się zaimportować niektórych powiązań parametrów do czynności: %1'@[_prel_sym]
                     || _msg:='Nie udało się zaimportować niektórych powiązań parametrów'@
                     ?};
                     exec('import_komm','#b_export',_msg)
                  ?};
                  B_POCONN.cntx_pop()
               |? _obj.this*'B_PROC'>0
               || IVAL_DEF.cntx_psh();
                  B_PROC.cntx_psh();
                  B_PROC.clear();
                  {? B_PROC.seek(_env.SEL_PROC)
                  ||
                     {? _obj.IVAL_DEF<>null()
                     ||
                        {? IVAL_DEF.seek(_obj.IVAL_DEF)
                        ||
                           _icon:=2;
                           {? exec('interval_update','#b_design','B_PROC',B_PROC.ref())>0
                           || _icon:=7;
                              _msg:='Procesowi: %1 podczas importu został nadany nowy planowany czas trwania.'@[B_PROC.NAME]
                           || _msg:='Nie udało się nadać procesowi: %1 nowego planowanego czasu trwania.'@[B_PROC.NAME]
                           ?}
                        ||  _msg:='Nie udało się nadać procesowi: %1 nowego planowanego czasu trwania.'@[B_PROC.NAME]
                        ?};
                        exec('import_komm','#b_export',_msg,_icon)
                     ?}
                  ?};
                  B_PROC.cntx_pop();
                  IVAL_DEF.cntx_pop()
               |? _obj.this*'B_TIMER'>0
               ||
                  B_TIMER.cntx_psh();
                  {? exec('add','#b_timer',_obj)<>null()
                  || _can_continue:=1
                  || _can_continue:=0;
                     _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
                     {? _prel_sym<>''
                     || _msg:='Nie udało się zaimportować harmonogramu do elementu procesu: %1'@[_prel_sym]
                     || _msg:='Nie udało się zaimportować harmonogramów do niektórych elementów procesu.'@
                     ?};
                     exec('import_komm','#b_export',_msg)
                  ?};
                  B_TIMER.cntx_pop()
               |? _obj.this*'B_MSG'>0
               ||
                  B_MSG.cntx_psh();
                  {? exec('add','#b_msg',_obj)<>null()
                  || _can_continue:=1
                  || _can_continue:=0;
                     _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
                     {? _prel_sym<>''
                     || _msg:='Nie udało się zaimportować komunikatu do elementu procesu: %1'@[_prel_sym]
                     || _msg:='Nie udało się zaimportować komunikatów do niektórych elementów procesu.'@
                     ?};
                     exec('import_komm','#b_export',_msg)
                  ?};
                  B_MSG.cntx_pop()
               |? _obj.this*'B_VALPRT'>0
               || B_VALPRT.cntx_psh();
                  B_VALPRT.index('UNIK');
::                Wykonuję formułę zwracającą wartość i przerabiam tą wartość z powrotem
::                na formułę żeby nie został ślad po imporcie
                  {? var_pres('_res')>100
                  || obj_del(_res)
                  ?};
::                Przestawiam komunikaty które mogą powstać podczas importowania wartości portów
::                żeby nie oznaczały procesu jako błędnie zaimportowanego, bo są z reguły nie groźne
                  {? type_of(_env_imex)>100
                  || _env_imex.KOMM_OMIT:=1
                  ?};

                  _res:=($_obj.FORMULA)('',_obj);

                  {? type_of(_env_imex)>100
                  || _env_imex.KOMM_OMIT:=0
                  ?};

                  {? type_of(_res)>0 & _obj.SYS_MEMO=''
                  ||
                     _formula:='';
                     {? type_of(_res)>100
                     || _tab:=2-!ref_tab(_res.REF);
                        _formula:=exec('val2fml','#convert',_res.REF,type_of(_res.REF),_tab);
                        _obj.VALUE:=exec('val2display','#convert',_res.REF)
                     |? type_of(_res)=type_of(null)
                     || _tab:=2-!ref_tab(_res);
                        _formula:=exec('val2fml','#convert',_res,type_of(_res),_tab);
                        _obj.VALUE:=exec('val2display','#convert',_res)
                     || _formula:=exec('val2fml','#convert',_res,type_of(_res));
                        _obj.VALUE:=exec('val2display','#convert',_res)
                     ?};
                     {? _formula<>''
                     || _obj.FORMULA:=_formula
                     ?}
                  ?};

                  B_VALPRT.prefix(_obj.B_PREL,_obj.B_PORT);
                  {? B_VALPRT.first()=0
                  ||
                     {? exec('add','#b_valprt',_obj)<>null()
                     || _can_continue:=1
                     || _can_continue:=0;
                        _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
                        {? _prel_sym<>''
                        || _msg:='Nie udało się zaimportować wartości parametrów do elementu procesu: %1'@[_prel_sym]
                        || _msg:='Nie udało się zaimportować wartości parametrów do niektórych elementów procesu.'@
                        ?};
                        exec('import_komm','#b_export',_msg)
                     ?}
                  ?};
                  B_VALPRT.cntx_pop()
               |? _obj.this*'B_SIGPRT'>0
               ||
                  B_SIGPRT.cntx_psh();
                  {? exec('add','#b_sigprt',_obj)<>null()
                  || _can_continue:=1
                  || _can_continue:=0;
                     _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
                     {? _prel_sym<>''
                     || _msg:='Nie udało się zaimportować parametrów sygnału do elementu procesu: %1'@[_prel_sym]
                     || _msg:='Nie udało się zaimportować parametrów sygnałów do niektórych elementów procesu.'@
                     ?};
                     exec('import_komm','#b_export',_msg)
                  ?};
                  B_SIGPRT.cntx_pop()
               ?}
            ?}
         ||
::          Obsługa błędów
            {? _obj.this*'B_PREL'>0
            ||
               _prel_sym:=_obj.SYMBOL;
               {? _prel_sym='' & _obj.B_ELE<>null()
               || _prel_sym:=exec('FindAndGet','#table',B_ELE,_obj.B_ELE,,"SYMBOL",'')
               ?};
               {? _prel_sym=''
               || _prel_sym:=_obj.UID
               ?};
               _msg:='Nie udało się zaimportować elementu procesu: %1'@[_prel_sym];
               exec('import_komm','#b_export',_msg)
            |? _obj.this*'B_CONN'>0
            ||
               _name:=_obj.NAME;
               {? _name='' & _obj.B_ELE<>null()
               || _name:=exec('FindAndGet','#table',B_ELE,_obj.B_ELE,,"SYMBOL",'')
               ?};
               {? _name=''
               || _name:=_obj.UID
               ?};
               _msg:='Nie udało się zaimportować połączenia: %1'@[_name];
               exec('import_komm','#b_export',_msg)
            |? _obj.this*'B_CHOICE'>0
            ||
               _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
               {? _prel_sym<>''
               || _msg:='Nie udało się zaimportować warunku: %1 do bramy %2'@[_obj.NAME,_prel_sym]
               || _msg:='Nie udało się zaimportować warunku: %1'@[_obj.NAME]
               ?};
               exec('import_komm','#b_export',_msg)
            |? _obj.this*'B_POCONN'>0
            ||
               _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.PREL_DST,,"SYMBOL",'');
               _port_sym:=exec('FindAndGet','#table',B_PORT,_obj.TO,,"SYMBOL",'');
               {? _prel_sym<>'' & _port_sym<>''
               || _msg:='Nie udało się zaimportować powiazania parametru: %1 do czynności %2'@[_port_sym,_prel_sym]
               |? _port_sym<>''
               || _msg:='Nie udało się zaimportować powiazania parametru: %1'@[_port_sym]
               |? _prel_sym<>''
               || _msg:='Nie udało się zaimportować niektórych powiązań parametrów do czynności: %1'@[_prel_sym]
               || _msg:='Nie udało się zaimportować niektórych powiązań parametrów'@
               ?};
               exec('import_komm','#b_export',_msg)

            |? _obj.this*'B_PORT'>0
            ||
               _port_sym:=_obj.SYMBOL;
               _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
               {? _prel_sym<>'' & _prel_sym<>''
               || _msg:='Nie udało się zaimportować dynamicznego parametru: %1 do czynności %2'@[_port_sym,_prel_sym]
               || _msg:='Nie udało się zaimportować dynamicznego parametru: %1'@[_port_sym]
               ?};
               exec('import_komm','#b_export',_msg)
            |? _obj.this*'B_PROC'>0
            || _proc_sym:=exec('FindAndGet','#table',B_PROC,_env.SEL_PROC,,"NAME",'');
               _msg:='Nie udało się nadać procesowi: %1 nowego planowanego czasu trwania.'@[_proc_sym];
               exec('import_komm','#b_export',_msg)
            |? _obj.this*'B_TIMER'
            || _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
               {? _prel_sym<>''
               || _msg:='Nie udało się zaimportować harmonogramu do elementu procesu: %1'@[_prel_sym]
               || _msg:='Nie udało się zaimportować harmonogramów do niektórych elementów procesu.'@
               ?};
               exec('import_komm','#b_export',_msg)
            |? _obj.this*'B_MSG'>0
            ||
               _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
               {? _prel_sym<>''
               || _msg:='Nie udało się zaimportować komunikatu do elementu procesu: %1'@[_prel_sym]
               || _msg:='Nie udało się zaimportować komunikatów do niektórych elementów procesu.'@
               ?};
               exec('import_komm','#b_export',_msg)
            |? _obj.this*'B_VALPRT'>0
            || _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
               {? _prel_sym<>''
               || _msg:='Nie udało się zaimportować wartości parametrów do elementu procesu: %1'@[_prel_sym]
               || _msg:='Nie udało się zaimportować wartości parametrów do niektórych elementów procesu.'@
               ?};
               exec('import_komm','#b_export',_msg)
            |? _obj.this*'B_SIGPRT'>0
            ||
               _prel_sym:=exec('FindAndGet','#table',B_PREL,_obj.B_PREL,,"SYMBOL",'');
               {? _prel_sym<>''
               || _msg:='Nie udało się zaimportować parametrów sygnału do elementu procesu: %1'@[_prel_sym]
               || _msg:='Nie udało się zaimportować parametrów sygnałów do niektórych elementów procesu.'@
               ?};
               exec('import_komm','#b_export',_msg)
            ?}
         ?}
      ||
::       Jeżeli obiekt nie został odczytany prawidłowo to znak, że coś się wykrzaczyło
         {? 7+_line='SYSMEMO'
         || ~~
         || _result:=0
         ?}
      ?};
      _tab_imex.next()
   !}
?};

_tab_imex.cntx_pop();
_result


\procfile_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprząta plik .proc
::   WE: [_a] - STRING - nazwa pliku .proc po stronie serwera, jeżeli nie podana to odczytywana
::                       z tabeli B_PROC.PROCFILE
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_fileproc:='';
{? var_pres('_a')=type_of('')
|| _fileproc:=_a
?};
params_set(params_get());
_env:=params_get().env;
B_PROC.cntx_psh();
B_PROC.clear();
{? B_PROC.seek(_env.SEL_PROC)
||
:: Pytam modelera czy są jakieś błędy importu
   _errors:=exec('get_value','#desktop','',_env.ctr_id,_env.ctr_bpmn,'importError');
   {? _errors<>'true'
   ||
::    Brak błędów więc usuwam plik proc po stronie serwera i czyszczę jego nazwę na procesie
      {? _fileproc=''
      || _fileproc:=B_PROC.PROCFILE
      ?};
      _erase:=0;
      {? _fileproc<>''
      || _erase:=ferase(_fileproc,1)
      ?};

      {? _erase>0
      || B_PROC.PROCFILE:='';
         B_PROC.put();
         _env.IMPORT_FILEPROC:=''
      ?}
   |? _errors='true'
   ||
::    Są błędy, ustawiam znacznik na procesie
      B_PROC.IMP_ERR:='T';
      B_PROC.put()
   ?}
?};
B_PROC.cntx_pop();
~~


\obj_version
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tablica nazwana reprezentująca wiersz w sekcji 'control'
::   WY: obj_new
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new('MODELER_VER'
               ,'acronyms'
               ,'types'
               ,'this'
               ,'name'
);
_obj.MODELER_VER:='';

_obj.acronyms:="
   _tab:=obj_new(1);
   _tab[1]:='MODELER_VER';
   _tab
";
_obj.types:="
   _tab:=obj_new(1);
   _tab[1]:='STRING';
   _tab
";
_obj.this:="exec('obj_version','#b_export')";
_obj.name:="'obj_version'";
_obj


\obj_actchk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tablica nazwana reprezentująca wiersz w sekcji 'control'
::   WY: obj_new
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new('ACTION_UID'
               ,'ACTION_VER'
               ,'ACTION_HASH'

               ,'acronyms'
               ,'types'
               ,'this'
               ,'name'
);
_obj.ACTION_UID:='';
_obj.ACTION_VER:='';
_obj.ACTION_HASH:='';

_obj.acronyms:="
   _tab:=obj_new(3);
   _tab[1]:='ACTION_UID';
   _tab[2]:='ACTION_VER';
   _tab[3]:='ACTION_HASH';
   _tab
";
_obj.types:="
   _tab:=obj_new(3);
   _tab[1]:='STRING';
   _tab[2]:='STRING';
   _tab[3]:='STRING';
   _tab
";
_obj.this:="exec('obj_actchk','#b_export')";
_obj.name:="'obj_actchk'";
_obj


\write_object
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przekształca przekazany obiekt w linię, którą zapisuje do podanego pliku.act_icn
::       Uwaga - obiekt musi mieć pole 'this' które jest formułą tworzącą instancję tego obiektu
::   WE: _a - INTEGER - uchwyt do pliku
::       _b - obj_new() - obiekt który zapisać
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_file:=_a;
_obj:=_b;

_result:=0;

_acronyms:=_obj.acronyms();
_sep:=exec('separator','#b_export');
_line:=$_obj.this+_sep;
{! _it:=1..obj_len(_acronyms)
|!
:: Zawsze najpierw akronim pola, później wartość
   _line+=_acronyms[_it]+_sep;

   _tab:='';
   _val:=($('_a.'+_acronyms[_it]))(_obj);
   {? type_of(_val)=type_of(null())
   || _tab:=2-!ref_tab(_val)
   ?};
   _value:=exec('val2fml','#convert',_val,type_of(_val),_tab);
   {? type_of(_val)=type_of('')
   || _value:=gsub(_value,'\"','\\"')
   ?};

   _line+=_value+_sep
!};
{? _line<>''
|| _line+='\n';
   errno();
   _resw:=fwrite(_file,_line);
   {? type_of(_resw)>0
   || {? _resw>0
      || _result:=1
      || _result:=0
      ?}
   || {? errno()=0
      || _result:=1
      || _result:=0
      ?}
   ?}
?};
_result


\read_object
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Odczytuje linię z pliku i przerabia ją na obiekt - uwaga, pierwszy element w linii
::       określa formułę która utworzy instancję obiektu
::   WE: _a - STRING - tekst który przerobić na obiekt
::       [_b] - STRING - identyfikator który mówi którym polom złączeniowym uruchamiać przypisanie prawdziwych refów
::       [_c] - INTEGER - czy błędy dodawać do KOMMa
::   WY: obj_new() - obiekt zawierający wynik działania funkcji - wynik exec('import_result','#b_export')
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_line:=_a;
_formulizer_command:='';
{? var_pres('_b')=type_of('')
|| _formulizer_command:=_b
?};
_komm:=1;
{? var_pres('_c')=type_of(0)
|| _komm:=_c
?};

params_set(params_get());

_result:=exec('import_result','#b_export');
_result.RESULT:=1;

_obj:=~~;
_can_continue:=1;

{? _line<>'\n' & _line<>''
||
   _sep:=exec('separator','#b_export');

   _split:=spli_str(_line,_sep);

   {? obj_len(_split)>1
   ||
::    Na pierwszym miejscu zawsze powinna być formuła tworząca obiekt
      _formula:=_split[1];

      {? _formula<>'' & _formula<>'SYSMEMO'
      || _obj:=($_formula)()
      ?};

      {? type_of(_obj)>100
      ||
         {! _it:=2//2..obj_len(_split)
         |? _can_continue>0
         |!
::          Pobieram wartość kolumny i jej wartość
            _column:=_split[_it];
            {? _column<>''
            ||
               _tab:='';
               _fml:=$_split[_it+1];
               _val:=_fml();
               {? exec('obj_has_field','#array',_obj,_column)>0
               ||
                  _rule_set:='params_set(params_get());_obj:=_a;_obj.'+_column+':=_b';
                  ($_rule_set)(_obj,_val);

                  {? type_of(_val)=type_of("")
                  ||
::                   Jeżeli typ jest formułowy to zawiera prawdopodobnie formułę która ma zwrócić refa
::                   więc trzeba ją wykonać i wartość przypisać do
                     {? _formulizer_command<>'' & _val*_formulizer_command>0
                     ||
                        _rule_get:='params_set(params_get());_obj:=_a;_komm:=_b;_res_obj:=_obj.'+_column+'(_komm,_obj)';
                        {? var_pres('_res')>100
                        || obj_del(_res)
                        ?};
                        _res:=($_rule_get)(_obj,_komm);

                        {? type_of(_res)>100
                        ||
                           {? _res.RESULT>0 & type_of(_res.REF)=type_of(null())
                           || ($_rule_set)(_obj,_res.REF)
                           |? _res.RESULT>0
                           ||
::                            Jesli wynik formuły wiekszy od zera ale nie zwróciła refa to nic nie robie
                              ~~
                           || _result.RESULT:=0;
                              ($_rule_set)(_obj,null())
                           ?}
                        ||
::                         Formuła nie zwróciła obiektu więc to co zwróciła wpisuję do pola
                           ($_rule_set)(_obj,_res)
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         !}
      ?}
   || _result.RESULT:=0
   ?}
?};
_result.OBJ:=_obj;
_result


\env_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Czyści tabelki i zmienne pomocnicze w środowisku modelera przed rozpoczęciem importu
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_result:=0;
_can_continue:=1;

:: Czyszczę tabelkę w której trzymamy wersje i hashe czynności
_tab:=_env.TAB_IMEX_ACT;
_tab.cntx_psh();
_tab.clear();
{? _tab.first()
|| {!
   |? _can_continue:=_tab.del(,1);
      _tab.first() & _can_continue>0
   !}
?};
_tab.cntx_pop();

:: Czyszczę tabelkę w której trzymam całą treść pliku .proc
obj_del(_tab);
_tab:=_env.TAB_IMEX_PROC;
_tab.cntx_psh();
_tab.clear();
{? _tab.first()
|| {!
   |? _can_continue:=_tab.del(,1);
      _tab.first() & _can_continue>0
   !}
?};
_tab.cntx_pop();

:: Czyszczę tabelkę w której trzymam czarną listę sygnałów
obj_del(_tab);
_tab:=_env.TAB_IMEX_SIG;
_tab.cntx_psh();
_tab.clear();
{? _tab.first()
|| {!
   |? _can_continue:=_tab.del(,1);
      _tab.first() & _can_continue>0
   !}
?};
_tab.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\action_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy można dodać czynność do bazy
::   WE: [_a] - B_ELE.ref lub bieżący rekord
::   WY: 0 - nie można dodać tej czynności do bazy
::       1 - można dodać tę czynność do bazy
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_ref:=null();
{? var_pres('_a')=type_of(B_ELE.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

B_ELE.cntx_psh();
{? _ref<>null()
|| B_ELE.prefix();
   {? B_ELE.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

FIRMA.cntx_psh();
_czapa:='N';
{? REF.FIRMA().TYP='C'
|| _czapa:='T'
?};
{? _can_continue>0
||
   B_ACTION.cntx_psh();
   {? _czapa='T'
   || B_ACTION.index('B_ELE2');
      B_ACTION.prefix(_czapa,B_ELE.ref())
   || B_ACTION.index('B_ELE');
      B_ACTION.prefix(B_ELE.ref())
   ?};
   {? B_ACTION.first()
   ||
      _plik_act:=exec('filename','#b_action');
::    Pobieram wersję czynności w systemie źródłowym
      _ver_exp:=0;
      _ver_str_e:='';
      _ver_str_i:='';
      _hash_exp:='';
      _hash_imp:='';
      _tab:=_env.TAB_IMEX_ACT;
      _tab.prefix($_env.SEL_PROC,B_ACTION.UID);
      {? _tab.first()
      || _ver_str_e:=_tab.ACT_VER;
         _ver_exp:=#_ver_str_e;
         _hash_exp:=_tab.ACT_HASH
      || _can_continue:=0
      ?};

      {? _can_continue>0
      ||
::       Obliczam hash w systemie docelowym
         _hash_imp:=~~;
         {? var_pres('HASHES',_env)>100
         || _hashes:=_env.HASHES;

            {? var_pres(B_ACTION.UID,_hashes)>0
            || _rule:='_hashes:=_a;_hashes.'+B_ACTION.UID;
               _hash_imp:=($_rule)(_hashes)
            ?}
         ?};
         {? type_of(_hash_imp)=0
         || _hash_imp:=exec('hash_params2','#b_action');
            {? var_pres('HASHES',_env)>100
            || _rule:='_hashes:=_a;_hashes.'+B_ACTION.UID+':=_b';
               ($_rule)(_env.HASHES,_hash_imp)
            ?}
         ?};

::       Sprawdzam czy czynność ma aktualną listę parametrów
         {? _hash_imp<>B_ACTION.PAR_HASH
         || _can_continue:=0;
            _msg:='Czynność \'%1\' jest nieaktualna, należy wykonać aktualizację elementów modelera.'@[B_ACTION.NAME];
            exec('import_komm','#b_export',_msg)
         ?};
::       Pobieram wersję czynności w systemie docelowym
         _ver_imp:='';
::         _ver_imp:=exec('string_fun','#file',_plik_act,'main','::# version=');
::         _ver_imp:=gsub(_ver_imp,'\n','');
         {? _ver_imp=''
         ||
::          Jeśli nie podana to przyjmuję 17.00
            _ver_imp:='17.00'
         ?};
::         _ver_str_i:=_ver_imp;
::         _ver_imp:=#_ver_imp;
::         {? _ver_exp>_ver_imp
::         ||
::::          Wersja czynności w wyeksportowanym procesie jest większa niż ta w systemie importującym
::            _can_continue:=0;
::            _msg:='Czynność \'%1\' w systemie docelowym jest w starszej wersji'
::                  '(%2) niż w systemie źródłowym (%3)'@[B_ACTION.NAME,_ver_str_i,_ver_str_e];
::            exec('import_komm','#b_export',_msg)
::         ?};

         {? _env.ACTION_CHK>0 & _hash_imp<>_hash_exp
         ||
::            _can_continue:=0;
            _msg:='Proces powstał w systemie ze starszą wersją czynności: \'%1 %2\'. Zaleca się przetestowanie procesu po imporcie.'@[B_ACTION.UID,B_ACTION.NAME];
            exec('import_komm','#b_export',_msg,5,,'warning')
         ?}
      ?}
   || _can_continue:=0;
      _msg:='Nie znaleziono czynności: \'%1\' w systemie docelowym w firmie: \'%2\'.'@[B_ACTION.NAME,REF.FIRMA().OPIS];
      exec('import_komm','#b_export',_msg)
   ?};
   B_ACTION.cntx_pop();
   ~~
?};
B_ELE.cntx_pop();
FIRMA.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\buffer_nullize
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przekazanemu buforowi tabeli nulluję wszystkie pola złączeniowe
::   WE: _a - obj_new - przekazany bufor
::       [_b] - INTEGER - czy nullować pola SYSMEMO
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_nulize_memo:=1;
{? var_pres('_b')=type_of(0)
|| _nulize_memo:=_b
?};

_types:=_obj.types();

{! _it:=1..obj_len(_types)
|! _type:=_types[_it];
   {? 1+_type='_'
   ||
::    Jestem na typie złączeniowym, więc nuluję wartość pola
      {? type_of(_obj[_it])=type_of(null) | type_of(_obj[_it])=type_of(~~)
      ||
::       Sprawdzam czy w wartości pola jest faktyczne złączenie i dopiero wtedy nulluję,
::       bo może tam być np formuła, która w swoim rezultacie da refa i tego bym nie chciał
::       nadpisać
         _obj[_it]:=null()
      ?}
   |? _type='BLOBRAW'
   || _obj[_it]:=null()
   |? _type='SYSMEMO' & _nulize_memo>0
   || _obj[_it]:=null()
   |? _type='IDADD'
   || _obj[_it]:=''
   |? _type='IDPUT'
   || _obj[_it]:=''
   ?}
!};
~~


\formulizer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przekazanemu buforowi wybrane pola złączeniowe zamienia na typ formułowy
::       Wykonana w ten sposób formuła powinna zwrócić w systemie w którym zostanie
::       uruchomiona właściwy ref. Każda formuła przypisana do pola musi mieć w swojej treści
::       _formulized:=1 - na tej podstawie zostanie zidentyfikowana i wykonana po drugiej stronie
::   WE: _a - obj_new - przekazany bufor
::       _b - STRING - identyfikator dla zamieniaczki formuły na prawdziwe refy
::       [_c] - STRING - identyfikator którym zostaną opatrzone pola typu SYSMEMO
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_formulizer_command:=_b;

params_set(params_get());
_env:=params_get().env;

_memo_id:='';
{? var_pres('_c')=type_of('')
|| _memo_id:=_c
?};

_types:=_obj.types();
_acronyms:=_obj.acronyms();

:: UWAGA!!! Podczas importu używane są indeksy. Te indeksy nie powinny być nigdy modyfikowane
:: ponieważ mogą zepsuć import pomiędzy wersjami systemu

:: B_DOMAIN.index('SYMBOL')
:: B_PREL.index('UID')
:: B_CONN.index('UID')
:: B_PORT.index('PREL')
:: B_PORT.index('SYMBOL')
:: B_TYPE.index('SYMBOL')
:: IVAL_NAM.index('NR')
:: IVAL_NAM.index('NAME')
:: B_WORKER.index('KOD')
:: B_ROLE.index('UNIK')
:: B_SIGNAL.index('SYMBOL')
:: B_SIGTYP.index('B_SIGNAL')
:: ISTDEF.index('LP')

{! _it:=1..obj_len(_types)
|! _type:=_types[_it];
   _acronym:=_acronyms[_it];
   {? _acronym<>'Ref'
   ||
      {? _type='SYSMEMO'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of('') & _value<>''
         ||
            _fml:=exec('formulizer_common','#b_export',_formulizer_command);
            _fml+='
               _result.REF:=~~;
               {? exec(\'read_memo\',\'#b_export\',\''+_memo_id+'\',_obj,\''+_acronym+'\')>0
               || _result.RESULT:=1
               ?};
               _result
            ';
            _fml:=exec('formulizer_clean','#b_export',_fml);
            _obj[_it]:=$_fml
         ?}
      |? _type='_B_DOMAIN'
      ||
         _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         ||
            _id:=exec('FindAndGet','#table',B_DOMAIN,_value,,"SYMBOL",'');
            _fml:=exec('formulizer_common','#b_export',_formulizer_command);
            _fml+='
               B_DOMAIN.cntx_psh();
               B_DOMAIN.index(\'SYMBOL\');
               B_DOMAIN.prefix(\''+_id+'\',);
               {? B_DOMAIN.first()
               || _result.REF:=B_DOMAIN.ref();
                  _result.RESULT:=1
               || _result.RESULT:=0;
                  _result.REF:=null();
                  {? _komm>0
                  ||
                     _msg:=\'Nie znaleziono obszaru o symbolu: %1\'@[\''+_id+'\'];
                     exec(\'import_komm\',\'#b_export\',_msg)
                  ?}
               ?};
               B_DOMAIN.cntx_pop();
               _result
            ';
            _fml:=exec('formulizer_clean','#b_export',_fml);
            _obj[_it]:=$_fml
         ?}
      |? _type='_B_PREL'
      ||
         _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         ||
            B_PREL.cntx_psh(); B_PREL.prefix();
            {? B_PREL.seek(_value)
            || _id:=exec('formulizer_uid','#b_export',B_PREL.UID);
               _sym:=exec('formulizer_symbol','#b_export',B_PREL.SYMBOL);
                _fml:=exec('formulizer_common','#b_export',_formulizer_command);
               _fml+='
                  B_PREL.cntx_psh();
                  B_PREL.index(\'UID\');
                  B_PREL.prefix(_env.SEL_PROC,\''+_id+'\');
                  {? B_PREL.first
                  || _result.RESULT:=1;
                     _result.REF:=B_PREL.ref()
                  || _result.RESULT:=0;
                     {? _komm>0
                     ||
                        _msg:=\'Nie znaleziono elementu procesu: %1\'@[\''+_sym+'\'];
                        exec(\'import_komm\',\'#b_export\',_msg)
                     ?}
                  ?};
                  B_PREL.cntx_pop();
                  _result
               ';
               _fml:=exec('formulizer_clean','#b_export',_fml)
            ?};
            B_PREL.cntx_pop();
            _obj[_it]:=$_fml
         ?}
      |? _type='_B_CONN'
      ||
         _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         ||
            B_CONN.cntx_psh();
            B_CONN.clear();
            {? B_CONN.seek(_value)
            ||
               _id:=B_CONN.UID;
               _id:=exec('formulizer_uid','#b_export',_id);

               _sym:=B_CONN.NAME;
               {? _sym=''
               || B_PREL.cntx_psh();
                  _sym:=B_CONN.FROM().SYMBOL+'->'+B_CONN.TO().SYMBOL;
                  B_PREL.cntx_pop();
                  ~~
               ?};
               _sym:=exec('formulizer_symbol','#b_export',_sym);

               _fml:=exec('formulizer_common','#b_export',_formulizer_command);
               _fml+='
                  B_CONN.cntx_psh();
                  B_CONN.index(\'UID\');
                  B_CONN.prefix(_env.SEL_PROC,\''+_id+'\');
                  {? B_CONN.first
                  || _result.RESULT:=1;
                     _result.REF:=B_CONN.ref()
                  || _result.RESULT:=0;
                     {? _komm>0
                     || _msg:=\'Nie znaleziono połączenia: %1\'@[\''+_sym+'\'];
                        exec(\'import_komm\',\'#b_export\',_msg)
                     ?}
                  ?};
                  B_CONN.cntx_pop();
                  _result
               ';
               _fml:=exec('formulizer_clean','#b_export',_fml);
               _obj[_it]:=$_fml
            ?};
            B_CONN.cntx_pop();
            ~~
         ?}
      |? _type='_B_PORT'
      ||
         _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         ||
            _sym_port:='';
            _sym_bele:='';
            _sym_type:='';
            _kind:='';
            _uid_prel:='';
            _sym_prel:='';

            B_PREL.cntx_psh();
            B_ELE.cntx_psh();
            B_PORT.cntx_psh();
            B_PORT.clear();
            {? B_PORT.seek(_value)
            || _sym_port:=B_PORT.SYMBOL;
               _sym_bele:=B_PORT.B_ELE().SYMBOL;
               _sym_type:=B_PORT.B_TYPE().SYMBOL;
               _kind:=B_PORT.KIND;
               _uid_prel:=B_PORT.B_PREL().UID;
               _sym_prel:=B_PORT.B_PREL().SYMBOL
            ?};

            _sym_prel:=exec('formulizer_symbol','#b_export',_sym_prel);
            B_PORT.cntx_pop();
            B_ELE.cntx_pop();
            B_PREL.cntx_pop();

            _fml:=exec('formulizer_common','#b_export',_formulizer_command);

            {? _uid_prel<>''
            ||
::             Port dynamiczny
               _uid_prel:=exec('formulizer_uid','#b_export',_uid_prel);
               _fml+='
                  B_PORT.cntx_psh();
                  B_PORT.index(\'PREL\');
                  B_PORT.prefix(_env.SEL_PROC,\''+_uid_prel+'\',\''+_sym_port+'\',\''+_sym_type+'\',\''+_kind+'\');
                  {? B_PORT.first()
                  || _result.RESULT:=1;
                     _result.REF:=B_PORT.ref()
                  || _result.RESULT:=0;
                     {? _komm>0
                     || _msg:=\'Nie znaleziono parametru: %1\ dla elementu procesu: %2\'@[\''+_sym_port+'\',\''+_sym_prel+'\'];
                        exec(\'import_komm\',\'#b_export\',_msg)
                     ?}
                  ?};
                  B_PORT.cntx_pop();
                  _result
               '
            ||
::             Zwykły port
               _fml+='
                  B_PORT.cntx_psh();
                  B_PORT.index(\'SYMBOL\');
                  B_PORT.prefix(\''+_sym_bele+'\',\''+_sym_port+'\',\''+_sym_type+'\',\''+_kind+'\');
                  {? B_PORT.first()
                  || _result.RESULT:=1;
                     _result.REF:=B_PORT.ref()
                  || _result.RESULT:=0;
                     {? _komm>0
                     || _msg:=\'Nie znaleziono parametru: %1\ dla elementu procesu: %2\'@[\''+_sym_port+'\',\''+_sym_prel+'\'];
                        exec(\'import_komm\',\'#b_export\',_msg)
                     ?}
                  ?};
                  B_PORT.cntx_pop();
                  _result
               '
            ?};
            _fml:=exec('formulizer_clean','#b_export',_fml);
            _obj[_it]:=$_fml
         ?}
      |? _type='_B_TYPE'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         ||
            _sym_type:=exec('FindAndGet','#table',B_TYPE,_value,,"SYMBOL",'');
            _fml:=exec('formulizer_common','#b_export',_formulizer_command);
            _fml+='
               B_TYPE.cntx_psh();
               B_TYPE.index(\'SYMBOL\');
               B_TYPE.prefix(\''+_sym_type+'\',);
               {? B_TYPE.first()
               || _result.RESULT:=1;
                  _result.REF:=B_TYPE.ref()
               || _result.RESULT:=0;
                  {? _komm>0
                  || _msg:=\'Nie znaleziono typu danych o symbolu: %1\'@[\''+_sym_type+'\'];
                     exec(\'import_komm\',\'#b_export\',_msg)
                  ?}
               ?};
               B_TYPE.cntx_pop();
               _result
            ';
            _fml:=exec('formulizer_clean','#b_export',_fml);
            _obj[_it]:=$_fml
         ?}
      |? _type='_IVAL_NAM'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         || _nr:=exec('FindAndGet','#table',IVAL_NAM,_value,,"NR",'');
            _name:=exec('FindAndGet','#table',IVAL_NAM,_value,,"NAME",'');
            _fml:=exec('formulizer_common','#b_export',_formulizer_command);
            _fml+='
               exec(\'import_names\',\'#interval\');
               IVAL_NAM.cntx_psh();
               IVAL_NAM.index(\'NR\');
               IVAL_NAM.prefix('+$_nr+',\''+_name+'\');
               {? IVAL_NAM.first()
               || _result.RESULT:=1;
                  _result.REF:=IVAL_NAM.ref()
               || _result.RESULT:=0;
                  {? _komm>0
                  || _msg:=\'Nie znaleziono nazwy interwału czasowego: %1\'@[\''+_name+'\'];
                     exec(\'import_komm\',\'#b_export\',_msg)
                  ?}
               ?};
               IVAL_NAM.cntx_pop();
               _result
            ';
            _fml:=exec('formulizer_clean','#b_export',_fml);
            _obj[_it]:=$_fml
         ?}
      |? _type='_IVAL_DEF'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         || IVAL_DEF.cntx_psh();
            IVAL_DEF.clear();
            {? IVAL_DEF.seek(_value)
            ||
               _symbol:=exec('to_string','#interval',IVAL_DEF.TM_STAMP);
               _nr1:=-1;
               _nr2:=-1;
               _name1:='';
               _name2:='';
               IVAL_NAM.cntx_psh();
               IVAL_NAM.index('NAME');
               {? IVAL_DEF.TYPE1<>null()
               || _nr1:=IVAL_DEF.TYPE1().NR;
                  _name1:=IVAL_DEF.TYPE1().NAME
               ?};
               {? IVAL_DEF.TYPE2<>null()
               || _nr2:=IVAL_DEF.TYPE2().NR;
                  _name2:=IVAL_DEF.TYPE2().NAME
               ?};
               IVAL_NAM.cntx_pop();

               _fml:=exec('formulizer_common','#b_export',_formulizer_command);

               _fml+='
                  _type1:=null();
                  _type2:=null();
               ';
               {? _name1<>''
               || _fml+='
                     IVAL_NAM.cntx_psh();
                     IVAL_NAM.index(\'NR\');
                     IVAL_NAM.prefix('+$_nr1+',\''+_name1+'\');
                     {? IVAL_NAM.first()
                     || _type1:=IVAL_NAM.ref()
                     ?};
                     IVAL_NAM.cntx_pop();
                  '
               ?};
               {? _name2<>''
               || _fml+='
                     IVAL_NAM.cntx_psh();
                     IVAL_NAM.index(\'NR\');
                     IVAL_NAM.prefix('+$_nr2+',\''+_name2+'\');
                     {? IVAL_NAM.first()
                     || _type2:=IVAL_NAM.ref()
                     ?};
                     IVAL_NAM.cntx_pop();
                  '
               ?};
               {? IVAL_DEF.VALUE3<>time(0,0,0)
               || _value3:='time('+$(IVAL_DEF.VALUE3~1)+','+$(IVAL_DEF.VALUE3~2)+','+$(IVAL_DEF.VALUE3~3)+')'
               || _value3:='time(0,0,0)'
               ?};
               {? IVAL_DEF.TIME<>time(0,0,0)
               || _time:='time('+$(IVAL_DEF.TIME~1)+','+$(IVAL_DEF.TIME~2)+','+$(IVAL_DEF.TIME~3)+')'
               || _time:='time(0,0,0)'
               ?};

               _fml+='
                  IVAL_DEF.cntx_psh();
                  IVAL_DEF.index(\'UNIQ\');
                  {? IVAL_DEF.find_key(\''+IVAL_DEF.KIND+'\',_type1,_type2,'+$IVAL_DEF.VALUE1+','+$IVAL_DEF.VALUE2+','+_value3+','+_time+')
                  || _result.RESULT:=1;
                     _result.REF:=IVAL_DEF.ref()
                  || _result.RESULT:=0;
                     {? _komm>0
                     || _msg:=\'Nie znaleziono interwału czasowego: %1\'@[\''+_symbol+'\'];
                        exec(\'import_komm\',\'#b_export\',_msg)
                     ?}
                  ?};
                  IVAL_DEF.cntx_pop();
                  _result
               ';
               _fml:=exec('formulizer_clean','#b_export',_fml);
               _obj[_it]:=$_fml
            ?};
            IVAL_DEF.cntx_pop()
         ?}
      |? _type='_B_WORKER'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         || _kod:=exec('FindAndGet','#table',B_WORKER,_value,,"KOD",'');
            _fml:=exec('formulizer_common','#b_export',_formulizer_command);
            _fml+='
               B_WORKER.cntx_psh();
               B_WORKER.index(\'KOD\');
               B_WORKER.prefix(REF.FIRMA,\''+_kod+'\',);
               {? B_WORKER.first()
               || _result.RESULT:=1;
                  _result.REF:=B_WORKER.ref()
               || _result.RESULT:=1;
                  _prel_sym:=\'\';
                  {? _obj.this*\'B_PREL\'>0
                  || _prel_sym:=_obj.SYMBOL
                  ?};
                  {? _komm>0
                  || {? _prel_sym<>\'\'
                     || _msg:=\'Brak kolejki o kodzie: %1 dla: %2. Jeżeli skonfigurowano to zostanie przypisana domyślna.\'@[\''+_kod+'\',_prel_sym]
                     || _msg:=\'Brak kolejki o kodzie: %1. Jeżeli skonfigurowano to zostanie przypisana domyślna.\'@[\''+_kod+'\']
                     ?};
                     exec(\'import_komm\',\'#b_export\',_msg,\'xwin16.png:3\')
                  ?}
               ?};
               B_WORKER.cntx_pop();
               _result
            ';
            _fml:=exec('formulizer_clean','#b_export',_fml);
            _obj[_it]:=$_fml
         ?}
      |? _type='_B_ROLE'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         || _name:=exec('FindAndGet','#table',B_ROLE,_value,,"NAME",'');
            _fml:=exec('formulizer_common','#b_export',_formulizer_command);
            _fml+='
               B_ROLE.cntx_psh();
               B_ROLE.index(\'UNIK\');
               B_ROLE.prefix(REF.FIRMA,\''+_name+'\',);
               {? B_ROLE.first()
               || _result.RESULT:=1;
                  _result.REF:=B_ROLE.ref()
               || _result.RESULT:=0;
                  {? _komm>0
                  || _msg:=\'Nie znaleziono roli: %1.\'@[\''+_name+'\'];
                     exec(\'import_komm\',\'#b_export\',_msg,\'xwin16.png:3\')
                  ?}
               ?};
               B_ROLE.cntx_pop();
               _result
            ';
            _fml:=exec('formulizer_clean','#b_export',_fml);
            _obj[_it]:=$_fml
         ?}
      |? _type='_B_ELE'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         || _symbol:=exec('FindAndGet','#table',B_ELE,_value,,"SYMBOL",'');
            _fml:=exec('formulizer_common','#b_export',_formulizer_command);
            _fml+='
               B_ELE.cntx_psh();
               B_ELE.index(\'SYMBOL\');
               B_ELE.prefix(\''+_symbol+'\',);
               {? B_ELE.first()
               || _result.RESULT:=1;
                  _result.REF:=B_ELE.ref()
               || _result.RESULT:=0;
                  {? _komm>0
                  || _msg:=\'Nie znaleziono ogólnego elementu procesu: %1.\'@[\''+_symbol+'\'];
                     exec(\'import_komm\',\'#b_export\',_msg,\'xwin16.png:3\')
                  ?}
               ?};
               B_ELE.cntx_pop();
               _result
            ';
            _fml:=exec('formulizer_clean','#b_export',_fml);
            _obj[_it]:=$_fml
         ?}
      |? _type='_B_SIGNAL'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         ||
            _sym:=exec('FindAndGet','#table',B_SIGNAL,_value,,"SYMBOL",'');
            _fml:=exec('formulizer_common','#b_export',_formulizer_command);
            _fml+='
               B_SIGNAL.cntx_psh();
               B_SIGNAL.index(\'SYMBOL\');
               B_SIGNAL.prefix(\''+_sym+'\',);
               {? B_SIGNAL.first()
               || _result.RESULT:=1;
                  _result.REF:=B_SIGNAL.ref()
               || _result.RESULT:=0;
                  {? _komm>0
                  || _msg:=\'Nie znaleziono sygnału o symbolu: %1\'@[\''+_sym+'\'];
                     exec(\'import_komm\',\'#b_export\',_msg)
                  ?}
               ?};
               B_SIGNAL.cntx_pop();
               _result
            ';
            _fml:=exec('formulizer_clean','#b_export',_fml);
            _obj[_it]:=$_fml
         ?}
      |? _type='_B_SIGTYP'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         ||
            B_SIGNAL.cntx_psh();
            B_SIGTYP.cntx_psh(); B_SIGTYP.prefix();
            {? B_SIGTYP.seek(_value)
            ||
               _signal:=B_SIGTYP.B_SIGNAL().SYMBOL;
               _parametr:=B_SIGTYP.PARAMETR;
               _fml:=exec('formulizer_common','#b_export',_formulizer_command);
               _fml+='
                  B_SIGTYP.cntx_psh();
                  B_SIGTYP.index(\'B_SIGNAL\');
                  B_SIGTYP.prefix(\''+_signal+'\',\''+_parametr+'\');
                  {? B_SIGTYP.first()
                  || _result.RESULT:=1;
                     _result.REF:=B_SIGTYP.ref()
                  || _result.RESULT:=0;
                     {? _komm>0
                     || _msg:=\'Nie znaleziono parametru: %1 sygnału: %2\'@[\''+_parametr+'\',\''+_signal+'\'];
                        exec(\'import_komm\',\'#b_export\',_msg)
                     ?}
                  ?};
                  B_SIGTYP.cntx_pop();
                  _result
               ';
               _fml:=exec('formulizer_clean','#b_export',_fml);
               _obj[_it]:=$_fml
            ?};
            B_SIGNAL.cntx_pop();
            B_SIGTYP.cntx_pop();
            ~~
         ?}
      |? _type='_ISTDEF'
      || _value:=_obj[_it];
         {? type_of(_value)=type_of(null()) & _value<>null()
         ||
            _fml:=exec('istdef_export','edi_def',_value,_formulizer_command);
            _obj[_it]:=$_fml;
            ~~
         ?}
      ?}
   ?}
!};
~~


\import_result
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy obiekt który będzie zwracany przez wszystkie formuły importujące
::   WY: obj_new()
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new('RESULT'
               ,'REF'
               ,'OBJ');
_obj.RESULT:=1;
_obj.REF:=null();
_obj.OBJ:=~~;
_obj


\import_komm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Dodaje komunikat do KOMMa podczas importu
::   WE: _a - STRING - treść komunikatu
::       [_b] - INTEGER - numer ikony
::       [_c] - B_PROC.ref() - proces dla którego komunikat dodać
::       [_d] - STRING - rodzaj komunikatu, domyślnie: 'error'
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_env_imex:=~~;
{? var_pres('env_imex',params_get())>100
|| _env_imex:=params_get().env_imex
?};

_msg:=_a;

_icon:=2;
{? var_pres('_b')=type_of(0) | var_pres('_b')=type_of('')
|| _icon:=_b
?};

{? var_pres('_c')=type_of(B_PROC.ref())
|| _b_proc:=_c
?};

_kind:='error';
{? var_pres('_d')=type_of('')
|| _kind:=_d
?};

_nr_root:=0;
_b_proc:=null;
{? var_pres('env',params_get())
|| _nr_root:=_env.NR_ROOT;
   _b_proc:=_env.SEL_PROC
?};

_sect:='';
_sect_nr:=0;

_symbol:='';
_name:='';
_ver:='';
_found_proc:=0;


{? _b_proc<>null()
||
   B_PROC.cntx_psh();
   B_PROC.prefix();
   {? B_PROC.seek(_b_proc)
   ||
      _found_proc:=1;
      _symbol:=B_PROC.SYMBOL;
      _name:=B_PROC.NAME;
      _ver:=B_PROC.VER;

      _sect:=exec('B_PROC','#to_string');

      {? var_pres('XLS_PROC_KOMM')>100 & var_pres('EXCEL_ENV')>100 & EXCEL_ENV.KIND='EXPORT'
      || {? _sect<>''
         || _msg:=_sect+': '+_msg
         ?};
         exec('history_add_exp','#excel_imex',B_PROC,0,'T',EXCEL_ENV,_msg,$SYSLOG.tm_stamp());
         B_PROC.cntx_pop();
         return()
      ?};

      _sect_nr:=KOMM.find_msg(_sect,_nr_root);
      {? _sect_nr
      || KOMM.set_root(_sect,_nr_root)
      || _sect_nr:=KOMM.sect_beg(_sect)
      ?}
   ?};
   B_PROC.cntx_pop()
?};

{? _sect<>''
|| {? KOMM.find_msg(_msg,_sect_nr)=0
   || KOMM.add(_msg,_icon,,1)
   ?};
   KOMM.sect_end()
|| {? KOMM.find_msg(_msg)=0
   || KOMM.add(_msg,_icon,,1)
   ?}
?};

{? type_of(_env_imex)>100
||
   {? _env_imex.KOMM_OMIT=0 & _kind='error' & _found_proc>0
   ||
      _tab_proc:=_env_imex.TAB_PROC;
      _tab_proc.cntx_psh();
      _tab_proc.index(_env_imex.NDX_PROC_SYMBOL);
      _tab_proc.prefix(_symbol,_name,_ver,);
      {? _tab_proc.first()
      || _tab_proc.IMP_ERR:='T';
         _tab_proc.put()
      ?};
      _tab_proc.cntx_pop();
      _tab_proc.get();
      ~~
   ?}
?};
~~


\formulizer_common
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Część wspólna wszystkich formuł importujących wartości złączeniowe po drugiej stronie
::   WE: [_a] - STRING - identyfikator na podstawie którego formuły zwracające ref
::                       zostaną wywołane w odpowiednim momencie
::   WY: obj_new()
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_id:='ref_create_save_done';
{? var_pres('_a')=type_of('')
|| _id:=_a
?};
_fml:='
   _komm:=1;
   {? var_pres(\'_a\')=type_of(0)
   || _komm:=_a
   ?};

   _obj:=_b;

   _can_continue:=1;
   _command:=\''+_id+'\';
   params_set(params_get());
   _env:=params_get().env;
   _result:=exec(\'import_result\',\'#b_export\');
';
_fml


\formulizer_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przygotowuje formułę do zapisania w pliku
::   WE: _a - STRING - treść formuły
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_fml:=_a;
:: Usuwam znaki następnych linii żeby w eksportowanym pliku się nie podupczyło
_fml:=gsub(_fml,'\n','');
_fml:=gsub(_fml,%10,'');
_fml:=gsub(_fml,%13,'');
_fml


\formulizer_uid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przygotowuje uida do zapisania w pliku
::   WE: _uid - STRING - ciąg znaków
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;
_uid:=gsub(_uid,'\'','\'\'');
_uid:=gsub(_uid,'\"','\"\"');
_uid:=gsub(_uid,'\\','\\\\');
_uid


\formulizer_symbol
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Przygotowuje symbol do zapisania w pliku
::   WE: _uid - STRING - ciąg znaków
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_sym:=_a;
_sym:=gsub(_sym,'\'','\'\'');
_sym:=gsub(_sym,'\\','\\\\');
_sym:=gsub(_sym,'\"','\"\"\"\"');
_sym


\read_buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyszukuje w tabelce tymczasowej zawierającej tresć pliku .proc rekord o podanym
::       UID i robi z niego obiekt
::   WE: _a - STRING - UID - identyfikator obiektu
::       [_b] - STRING - identyfikator dla zamieniaczki formuły na prawdziwe refy
::   WY: obj_new() - obiekt zawierający wynik działania funkcji - wynik exec('import_result','#b_export')
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_uid:=_a;

_formulizer_command:='';
{? var_pres('_b')=type_of('')
|| _formulizer_command:=_b
?};

_result:=exec('import_result','#b_export');
_result.RESULT:=-1;

_tab:=_env.TAB_IMEX_PROC;
_tab.cntx_psh();
_tab.prefix(_uid);
{? _tab.first()
|| _line:=_tab.memo_txt(,1);
   {? var_pres('_result')>100
   || obj_del(_result)
   ?};
   _result:=exec('read_object','#b_export',_line,_formulizer_command)
?};
_tab.cntx_pop();
_result


\read_memo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła wykonywana po stronie importującej - ma za zadanie odczytać z pliku całą treść SYSMEMO o podanym id
::       przypisać ją do podanego pola typu SYSMEMO
::   WE: _a - STRING - identyfikator sysmemo
::       _b - obj_new - obiekt któremu przypisać treść notatki
::       _c - STRING - akronim pola któremu przypsać treść notatki
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_sys_id:=_a;
_obj:=_b;
_column:=_c;
_sep:=exec('separator','#b_export');

_can_continue:=1;
_result:=0;

:: Najpierw próbuję odczytać treść notatki z tabeli tymczasowej, jeżeli się uda (szybsze) to nie czytam z pliku
{? exec('read_memo2','#b_export',_sys_id,_obj,_column)>0
|| _can_continue:=0;
   _result:=1
?};

{? _can_continue>0
||
   _fileproc:=exec('FindAndGet','#table',B_PROC,_env.SEL_PROC,,"PROCFILE",'');

   {? _fileproc=''
   || _fileproc:=_env.IMPORT_FILEPROC
   ?};
   _content:='';
   _close:=0;
   {? _fileproc<>''
   || _file:=fopen(_fileproc,'ur',1,1);
      _close:=1;
      {? _file<=0
      || _can_continue:=0
      ?}
   ||
      {? var_pres('env_imex',params_get())>100
      || _env_imex:=params_get().env_imex;
         {? var_pres('IMPORT_GML_DATA',_env_imex)>100
         || _file:=_env_imex.IMPORT_GML_DATA.copy()
         || _can_continue:=0
         ?}
      ?}
   ?}
?};

:: Zbieram treść notatki
{? _can_continue>0
||
   {!
   |?
      _line:=fread(_file);
      {? var_pres('_split')>100
      || obj_del(_split)
      ?};
      _split:=spli_str(_line,_sep);
      _what:=_split[1];

      {? _what='SYSMEMO'
      ||
         _id:=_split[2];
         _field:=_split[3];
         {? _id=_sys_id & _field=_column
         || _content+=_split[4]+'\n'
         ?}
      ?};
      _line<>'\n' & _can_continue>0
   !};
   {? _close>0
   || fclose(_file)
   ?}
?};

{? _can_continue>0 & _content<>''
||
:: Usuwam nadmiarowy enter na końcu
   _content:=_content-1;

:: Zebraną treść przypisuję do pola obiektu
   _rule_set:='params_set(params_get());_obj:=_a;_obj.'+_column+':=_b';
   ($_rule_set)(_obj,_content)
?};
{? _can_continue>0
|| _result:=1
?};
_result


\read_memo2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Formuła wykonywana po stronie importującej - ma za zadanie odczytać z pliku całą treść SYSMEMO o podanym id
::       przypisać ją do podanego pola typu SYSMEMO
::   WE: _a - STRING - identyfikator sysmemo
::       _b - obj_new - obiekt któremu przypisać treść notatki
::       _c - STRING - akronim pola któremu przypsać treść notatki
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_sys_id:=_a;
_obj:=_b;
_column:=_c;
_sep:=exec('separator','#b_export');
_can_continue:=1;
_result:=0;

{? var_pres('env_imex',params_get())>100
|| _env_imex:=params_get().env_imex;

   _tab:=_env_imex.TAB_PROC;
   _tab_file:=_env_imex.TAB_FILE;

   _tab_file.cntx_psh();
   _tab_file.index(_env_imex.NDX_FILE_PATH);

   _filepath:=_tab.FILEPATH;
   {? _env_imex.CURRENT_FILEPATH<>''
   || _filepath:=_env_imex.CURRENT_FILEPATH
   ?};

   {? _filepath<>''
   || _tab_file.prefix(_filepath,'SYSMEMO',_sys_id,);

      _content:='';
::    Zbieram treść notatki
      {? _tab_file.first()
      || {!
         |? _line:=_tab_file.memo_txt(,1);
            {? var_pres('_split')>100
            || obj_del(_split)
            ?};
            _split:=spli_str(_line,_sep);
            _what:=_split[1];

            {? _what='SYSMEMO'
            ||
               _id:=_split[2];
               _field:=_split[3];

               {? _id=_sys_id & _field=_column
               || _content+=_split[4]+'\n'
               ?}
            ?};
            _tab_file.next() & _can_continue>0
         !};

         {? _can_continue>0 & _content<>''
         ||
::          Usuwam nadmiarowy enter na końcu
            _content:=_content-1;

::          Zebraną treść przypisuję do pola obiektu
            _rule_set:='params_set(params_get());_obj:=_a;_obj.'+_column+':=_b';
            ($_rule_set)(_obj,_content);
            _result:=1
         ?}
      ?}
   ?};
   _tab_file.cntx_pop();
   ~~
?};
_result


\write_memo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zapisuje treść notatki do pliku każdy wiersz opatrując identyfikatorem
::   WE: _a - INTEGER - uchwyt do pliku
::       _b - obj_new - bufor którego pola SYSMEMO zapisywać
::       _c - STRING - identyfikator sysmemo którym opatrzyć każdą linię zapisywanego sysmema
::   WY:
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_file:=_a;
_obj:=_b;
_sys_id:=_c;

_result:=1;

_acronyms:=_obj.acronyms();
_types:=_obj.types();
_sep:=exec('separator','#b_export');

{! _it:=1..obj_len(_types)
|? _result>0
|!
   _type:=_types[_it];
   {? _type='SYSMEMO'
   ||
::    Pobieram tekst z pola
      _val:=($('_a.'+_acronyms[_it]))(_obj);

      {? _val<>''
      ||
::       Dzielę go na linie
         {? var_pres('_split')>100
         || obj_del(_split)
         ?};
         _split:=spli_str(_val,'\n');
         {! _it2:=1..obj_len(_split)
         |!
::          Każda linia składa się z:
::          'SYSMEMO'
::          identyfikatora notatki
::          nazwy pola
::          właściwej treści

            _line:='SYSMEMO'+_sep+_sys_id+_sep+_acronyms[_it]+_sep+_split[_it2]+'\n';
            errno();
            _resw:=fwrite(_file,_line);
            {? type_of(_resw)>0
            || {? _resw>0
               || _result:=1
               || _result:=0
               ?}
            || {? errno()=0
               || _result:=1
               || _result:=0
               ?}
            ?}
         !}
      ?}
   ?}
!};
_result


\action_export
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Eksport' w obszarze roboczym obsługi procesów
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
:: ~OST: INFEXISTS
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRUPA<>'T'
||
   {? exec('interm','#system')
   || FUN.emsg(exec('interm_nacc_msg','#system'));
      return(0)
   ?};

   _filepath:=exec('export_dialog_path','#b_export');

   {? _filepath<>'' & ~fexists('@'+_filepath)
   || FUN.info('Nie znaleziono podanego katalogu.'@);
      return(~~)
   ?};

   {? _filepath<>''
   ||
      VAR_DEL.delete('EX_ENV');
      _env:=exec('env','#b_design');
      _env.SEL_PROC:=B_PROC.ref();
      EX_ENV:=_env;

      params_set('env',_env);
      _env.EXPORT_DIR:=_filepath;
::      _env.sel4export();
      exec('export_new','#b_export',_env);
      ~~
   ?}
?};
~~


\action_export_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja grupa przed 'Eksport' w obszarze roboczym obsługi procesów
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
:: ~OST: INFEXISTS
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;

VAR_DEL.delete('EX_ENV');
_env:=exec('env','#b_design');
EX_ENV:=_env;
params_set('env',_env);
_filepath:='';
_tmp_dir:=fmk_tmp_dir(0);
{? type_of(_tmp_dir)<>type_of(~~)
|| _filepath_server:=_tmp_dir.get_path();
   _env.EXPORT_SERVER_DIR:=_filepath_server;
   {? _filepath_server=''
   || _can_continue:=0;
      FUN.emsg('Nie udało się utworzenie katalogu tymaczasowego na serwerze.'@)
   ?}
?};


{? exec('interm','#system')=0
||
   {? _can_continue>0
   ||
::    Dialog z pytaniem o ścieżkę
      _filepath:=exec('export_dialog_path','#b_export');
      ~~
   ?};

   {? _filepath<>'' & ~fexists('@'+_filepath)
   || FUN.info('Nie znaleziono podanego katalogu.'@);
      _can_continue:=0
   ?};
   {? _can_continue>0
   ||
      {? _filepath<>''
      || _env.EXPORT_DIR:=_filepath
      || _can_continue:=0
      ?}
   ?}
?};
{? _can_continue>0
|| VAR.GRUPA:='T';
   _selected:=B_PROC.sel_aget();
   _env.EXPORT_SEL:=_selected;
::   _env.sel4export();
   exec('export_new','#b_export',_env);
   B_PROC.sel_adel();
   VAR_DEL.delete('EX_ENV');
   VAR.GRUPA:='N';
   ~~
?};
0


\action_export_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja grupa po 'Eksport' w obszarze roboczym obsługi procesów
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
~~


\export_dialog_path
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyświetla dialog z pytaniem gdzie mają być eksportowane procesy
::   WY: STRING - ścieżka lub '' jeżeli użytkownik zrezygnował
::  TAG: <PUBLICZNA>
:: ~OST: INFILECHOOSER
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? exec('interm','#system')>0
|| FUN.emsg(exec('interm_nacc_msg','#system'));
   return('')
?};
ctr_set('!application', 'filechooser','reset');
ctr_set('!application', 'filechooser','setMultiSelectionEnabled',0);
ctr_set('!application', 'filechooser','setFileSelectionMode','DIRECTORIES_ONLY');
ctr_set('!application', 'filechooser','setDialogTitle','Eksport procesów');
_can_continue:=ctr_call('!application', 'filechooser','showSaveDialog');
{? _can_continue>0
|| _result:=ctr_call('!application', 'filechooser','getSelectedFile')
?};
_result


\export_group_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Uruchamia grupowy eksport procesów. Ta formuła jest wywołana po pojawieniu się i wczytaniu elementów
::       modelera-eksportera.
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;
echo('Eksportowanie procesów...'@);

:: Wystawiam dane dla kontrolki modelera
_data_id:=$SYSLOG.tm_stamp();
_tab_sel:=exec('export_file_group','#b_export',_env.EXPORT_DIR);
{? var_pres('_tab_sel')>100 & _tab_sel.first()
||
   _fml_prfx:='';
   exec('fetch_data','#desktop',_data_id,_env.ctr_id,_tab_sel,'SEL_REF,FILENAME,DIR',_fml_prfx);
   exec('set_value','#desktop','#',_env.ctr_id,_env.ctr_bpmn,'export_separator='+exec('separator','#b_export'));
   exec('set_value','#desktop','#',_env.ctr_id,_env.ctr_bpmn,'export_batch='+_data_id)
|| FUN.emsg('Nie znaleziono zaznaczonych procesów. Eksport niemożliwy.'@);
   sel_exit()
?};
~~


\export_file_group
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przygotowuje plik z rozszerzeniem .proc zawierający informacje o grupowym eksporcie
::   WE: _a - STRING - katalog docelowy
::   WY: tab_tmp - tabela tymczasowa z procesami do eksportu
::  TAG: <PRYWATNA><MODELER><EKSPORT>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_dir:=_a;

_result:=~~;
_can_continue:=1;

_tab:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'SEL_REF','STRING[16]','Ref procesu',
   'FILENAME','STRING[255]','Nazwa pliku z procesem',
   'DIR','STRING[255]','Katalog docelowy'
);

:: Zapisuje do pliku kolejne elementy
{? VAR.GRUPA='T'
||
:: Akcja grupowa
   _selected:=_env.EXPORT_SEL;
   B_PROC.cntx_psh();
   B_PROC.clear();
   {? _selected.first()
   ||
      {!
      |? {? B_PROC.seek(_selected.REF,)
         ||
            _graphml:=exec('export_gen_filename','#b_export');
            _tab.blank();
            _tab.SEL_REF:=$B_PROC.ref();
            _tab.FILENAME:=_graphml;
            _tab.DIR:=_dir;

            {? var_pres('FILE',_selected)>0
            || _selected.FILE:=_graphml;
               _selected.put()
            ?};

            _can_continue:=_tab.add()
         ?};
         _selected.next() & _can_continue>0
      !}
   ?};
   B_PROC.cntx_pop()
||
:: Akcja pojedyńcza
   _graphml:=exec('export_gen_filename','#b_export');
   _tab.blank();
   _tab.SEL_REF:=$B_PROC.ref();
   _tab.FILENAME:=_graphml;
   _tab.DIR:=_dir;
   _can_continue:=_tab.add()
?};
_tab.prefix();
{? _can_continue>0
|| _result:=_tab
?};
_result


\load_proc4export
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ładuje proces w celu jego wyeksportowania - używane podczas grupowego exportu
::   WE: _a - STRING - $B_PROC.ref
::   WY: '0' - porażka
::       '1' - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;
_ref:=_a;

_result:='0';
B_PROC.cntx_psh(); B_PROC.prefix();
_what:='';
{? B_PROC.seek(_a)
|| _what:=exec('B_PROC','#to_string');
   _env.SEL_PROC:=B_PROC.ref();
   _args:=exec('load_args','#b_bpmn');
   _args.CTR_ID:=_env.ctr_id;
   _args.BPMN_ID:=_env.ctr_bpmn;
   _args.B_PROC:=B_PROC.ref();
   _args.EDITABLE:=0;
   _args.POPUP_MENU:=0;
   _args.EXPORT_GR:=_env.EXPORT_GR;
   _result:=$exec('load_diagram4proc','#b_bpmn',_args)
?};
B_PROC.cntx_pop();
echo('Załadowany proces do eksportu: %1. Wynik ładowania: %2'@[_what,_result]);
_result


\load_proc4import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ładuje proces w celu jego wyeksportowania - używane podczas grupowego importu
::   WE: _a - STRING - $B_PROC.ref
::   WY: '' lub ścieżka do pliku który należy załadować i zaimportować
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;
_ref:=_a;

_result:='0';
_what:='';
B_PROC.cntx_psh(); B_PROC.prefix();
{? B_PROC.seek(_a)
|| _what:=exec('B_PROC','#to_string');
   _env.SEL_PROC:=B_PROC.ref();
   _args:=exec('load_args','#b_bpmn');
   _args.CTR_ID:=_env.ctr_id;
   _args.BPMN_ID:=_env.ctr_bpmn;
   _args.B_PROC:=B_PROC.ref();
   _args.EDITABLE:=0;
   _args.POPUP_MENU:=0;
   _args.IMPORT_GR:=1;
   _result:=exec('load_imported4proc','#b_bpmn',_args,0)
?};
B_PROC.cntx_pop();
echo('Załadowany proces do importu: %1. Wynik ładowania: %2'@[_what,_result]);
_result


\export_gen_filename
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podczas grupowego eksportowania procesów generuję nazwę pliku dla aktualnego
::       rekordu tabeli B_PROC
::   WE: [_a] - STRING - rozszerzenie pliku, domyslnie - .graphml
::   WY: STRING - nazwa pliku
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ext:='.graphml';
{? var_pres('_a')=type_of('')
|| _ext:=_a
?};

_result:=B_PROC.SYMBOL+' - '+B_PROC.NAME+' (wersja '+B_PROC.VER+')'+_ext;
_result:=gsub(_result,'\'','');
_result:=gsub(_result,'\"','');
_result:=gsub(_result,'\\','');
_result:=gsub(_result,':','');
_result:=gsub(_result,'/','');
_result:=gsub(_result,'*','');
_result:=gsub(_result,'?','');
_result:=gsub(_result,'>','');
_result:=gsub(_result,'<','');
_result:=gsub(_result,'|','');
_result


\export_error
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła wykonywana w przypadku jak się eksport gdzieś niepowiedzie na jakimś etapie
::   WE: _a - STRING - nazwa procesu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_name:=_a;
_msg:='Eksport procesu: %1 zakończony niepowodzeniem.'@[_name];
{? VAR.GRUPA='T'
|| KOMM.add(_msg,2,,1)
|| FUN.emsg(_msg)
?};
~~


\can_import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy można wykonać import procesu na aktualnym procesie
::   WY: '0' - porażka
::       '1' - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_result:='0';
_can_continue:=1;

{? _can_continue>0
|| B_PREL.cntx_psh();
   B_PREL.index('PROC');
   B_PREL.prefix(_env.SEL_PROC);
   {? B_PREL.size()>0
   || _can_continue:=0;
      _what:=exec('record','#to_string',_env.SEL_PROC);
      FUN.emsg('Proces: %1 zawiera już jakieś elementy.\n\nAby rozpocząć import należy najpierw usunąć dotychczasową zawartość procesu.'@[_what])
   ?};
   B_PREL.cntx_pop()
?};

{? _env.IMPORT_GR=0
||
   {? _can_continue>0 & _env.TM_MOD>B_PROC.TM_SAVE
   || FUN.emsg('Istnieją niezapisane zmiany na diagramie. Aby rozpocząć import należy najpierw zapisać proces.'@);
      _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _result:='1'
?};
_what:=exec('B_PROC','#to_string');
echo('Sprawdzenie czy proces: %1 można importować zwróciło wynik: %2'@[_what,_result]);
_result


\import_group_prepare2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Uruchamia mechanizm grupowego importu procesów
::   WE: [_a] - STRING - ścieżka do folderu z plikami .graphml
::       [_b] - INTEGER - tryb działania: [0] - normalny import
::                                         1  - obsługa excela, plik procesy.proc jest wczytywany, ale nie jest dalej
::                                              obrabiany
::       [_c] - obj_new - środowisko importu
::       [_d] - INTEGER - [1]/2 - czy importować wszystkie procesy (1), czy tylko ważne (2)
::       [_e] - obj_new() - obiekt multiprogress
::       [_f] - INTEGER - 0/[1] - czy pokazywać progressy
::       [_g] - INTEGER - [0]/1 - czy ścieżka z plikami .graphml jest lokalna czy na serwerze
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
:: ~OST: INFILECHOOSER
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env_imex:=~~;
{? var_pres('_c')>100
|| _env_imex:=_c
|| _env_imex:=params_get().env_imex
?};

_dir:='';
{? var_pres('_a')=type_of('')
|| _dir:=_a
?};

_mode:=0;
{? var_pres('_b')=type_of(0)
|| _mode:=_b
?};

_all:=1;
{? var_pres('_d')=type_of(0)
|| _all:=_d
?};

_argsprog:=~~;
{? var_pres('_e')>100
|| _argsprog:=_e
|| _argsprog:=exec('init','#progress')
?};

_progress:=1;
{? var_pres('_f')=type_of(0)
|| _progress:=_f
?};
_dir_on_server:=0;
{? var_pres('_g')=type_of(0)
|| _dir_on_server:=_g
?};

_can_continue:=1;
_result:=0;
{? _dir=''
|| _dir:=exec('filechooser','#file','Folder do importu procesów'@,0,'',,0,'DIRECTORIES_ONLY')
?};
{? _dir=''
|| _can_continue:=0
?};


_sep:=exec('separator','#b_export');
_tab:=_env_imex.TAB_PROC;
_tab.cntx_psh();
_tab_file:=_env_imex.TAB_FILE;
{? _can_continue>0
||
   B_PROC.cntx_psh();
   B_PROC.index('SYM');
   _msg:='Odczytywanie zawartości folderu'@;
   {? _mode=0
   || KOMM.init(250,,'Analizowanie zawartości folderu'@)
   ?};
   {? _progress>0 & _mode=0
   || progress(,_msg+'…',exec('nazwa','#system'),1)
   ?};
   _fdir:=_dir;
   {? _dir_on_server=0
   || _fdir:='@'+_dir
   ?};

   _files:=exec('dir','#file',_fdir);
   {? _progress>0 & _mode=0
   || prgs_clr()
   ?};
   {? _env_imex.PREFIX_SYM<>''
   || _i2:=_files.ndx_tmp(,,'EXT',,,'FILENAME',,);
      _files.index(_i2);
      _files.prefix('graphml',_env_imex.PREFIX_SYM)
   ||
      _i2:=_files.ndx_tmp(,,'EXT',,);
      _files.index(_i2);
      _files.prefix('graphml',)
   ?};
   {? _files.first()
   ||
      {? _progress>0
      ||
         {? _mode=0
         ||
            _argsprog.TITLE:='Import procesów z folderu: %1'@[_dir];
            _argsprog.HEIGHT:=10;
            _argsprog.add_progress('Procesy, wczytywanie...'@,_files.size());
            exec('start','#progress',_argsprog)
         |? _mode=1
         ||
            _argsprog.ph_ssize(2,_files.size());
            _argsprog.ph_start(2);
            _argsprog.ph_sname(2,'Procesy, wczytywanie...'@)
         ?}
      ?};

      {!
      |?
         {? _progress>0
         || {? _mode=0
            || _can_continue:=exec('next_step','#progress',_argsprog,1)
            |? _mode=1
            || _can_continue:=exec('next_step','#progress',_argsprog,2)
            ?}
         ?};

         _can_import:=1;
         {? _files.FILENAME*'.graphml'=0
         || _can_import:=0
         ?};
::       Tniemy nazwę pliku żeby wydłubać wersję
         _wersja:='';
         _wer_org:='';
         {? var_pres('_split')>100
         || obj_del(_split)
         ?};
         _split:=spli_str(_files.FILENAME,'(wersja');
         {? obj_len(_split)>=2
         ||
            {? var_pres('_split2')>100
            || obj_del(_split2)
            ?};

            _split2:=spli_str(_split[2],')');

            {? obj_len(_split2)>=1
            || _wersja:=_split2[1]
            ?};
            _wersja:=form(_wersja);
            _wer_org:=_wersja;

            {? -_wersja='rr.xx'
            || _wersja:=(4+$date())+2+'.00'
            ?};

            {? exec('isLetter','#string',_wersja+1)
            || _wersja:=_wersja-1
            ?};

            {? _wersja*'.'=0 & +_wersja>2
            || _wersja:=2+_wersja+'.'+(_wersja+(+_wersja-2))
            ?}
         ?};

::       Na tym etapie wersja już powinna być konwertowalna na liczbę
::       jeżeli nie, to zgłaszam error
         {? #_wersja=0
         || FUN.emsg('Nieprawidłowa wersja procesu w pliku: %1. Import został przerwany.'@[_files.FILENAME]);
            _can_continue:=0
         ?};
::       Jeżeli _env_imex.PREFIX_VER podane, to ograniczamy procesy z tej wersji
::       plus wszystkie przyszłościowe tzn że jeżeli PREFIX_VER=22.26 to zaczytane zostaną procesy:
::       1. W wersji 22.26
::       2. W wersji 2226a..2226z
::       3. W wersji 22.26a..22.26z
::       4. W wersji 24.16 i wszystkich przyszłych: 25.40 itp
         {? _can_import>0 & _env_imex.PREFIX_VER<>''
         || _can_import:=0;
            {? _wersja=_env_imex.PREFIX_VER
            || _can_import:=1
            ?};
            {? _can_import=0 & #_env_imex.PREFIX_VER>0
            || {? #_env_imex.PREFIX_VER<=#_wersja
               || _can_import:=1
               ?}
            ?};
            {? _can_import=0 & _wer_org<>'' & _env_imex.PREFIX_VER=_wer_org
            || _can_import:=1
            ?}
         ?};

         {? _can_continue>0 & _can_import>0
         || _has_proc:=0;
            {? _progress>0
            || {? _mode=0
               || _argsprog.ph_sname(1,'Procesy, wczytywanie: %1'@[_files.FILENAME])
               |? _mode=1
               || _argsprog.ph_sname(2,'Procesy, wczytywanie: %1'@[_files.FILENAME])
               ?}
            ?};
            _obj_txt:='';
            {? var_pres('_gml_data')>100
            || obj_del(_gml_data)
            ?};
            _filepath:=_files.FILEPATH;
            _gml_data:=exec('get_info','#b_export',_filepath,2,_dir_on_server);
            {? type_of(_gml_data)>100
            || {? var_pres('IMPORT_GML_DATA',_env_imex)>100
               || obj_del(_env_imex.IMPORT_GML_DATA)
               ?};
               _env_imex.IMPORT_GML_DATA:=_gml_data;
               {!
               |?
                  _env_imex.CURRENT_FILEPATH:=_filepath;
                  _line:=fread(_gml_data);
                  {? _line<>''
                  ||
                     {? var_pres('_split')>100
                     || obj_del(_split)
                     ?};
                     _split:=spli_str(_line,_sep);
                     _uid:=_split[1];

                     _obj_txt+=_line;
                     {? _uid='SYSMEMO'
                     ||
                        _tab_file.blank();
                        _tab_file.UID:=_uid;
                        _tab_file.UID2:=_split[2];
                        _tab_file.TM_STAMP:=SYSLOG.tm_stamp();
                        _tab_file.FILEPATH:=_filepath;
                        _tab_file.IDADD:=_split[2];
                        _tab_file.memo_set(_obj_txt,'LINE');
                        {? _can_continue>0
                        || _can_continue:=_tab_file.add()
                        ?};
                        {? _can_continue>0
                        || _can_continue:=_tab_file.memo_put()
                        ?};
                        _obj_txt:=''
                     |? _uid<>'SYSMEMO'
                     ||
::                      Sprawdzam czy linia kończy się separatorem
                        {? (_obj_txt+(+_sep))=_sep
                        ||
::                         Linia kończy się separatorem, więc dodaję rekord do tabeli
                           _tab_file.blank();
                           _tab_file.TM_STAMP:=SYSLOG.tm_stamp();
                           {? var_pres('_split2')>100
                           || obj_del(_split2)
                           ?};
                           _split2:=spli_str(_obj_txt,_sep);
                           _uid:=_split2[1];
                           _uid:=exec('get_uid','#b_export',_uid);

::                         Sygnały muszą mieć oba UIDy już na tym etapie, więc dzielę tego uida
                           {? (_uid*'B_SIGNAL'>0 | _uid*'B_SIGTYP'>0) & _uid*';'>0
                           ||
                              {? var_pres('_split3')>100
                              || obj_del(_split3)
                              ?};
                              _split3:=spli_str(_uid,';');
                              _id:=_split3[1];
                              _uid:=_split3[2];
                              _tab_file.UID2:=_id;
                              ~~
                           ?};

                           _tab_file.UID:=_uid;
                           _tab_file.FILEPATH:=_filepath;
                           _tab_file.memo_set(_obj_txt,'LINE');
                           {? _can_continue>0
                           || _can_continue:=_tab_file.add()
                           ?};
                           {? _can_continue>0
                           || _can_continue:=_tab_file.memo_put()
                           ?};
                           {? _uid*'B_PROC'>0
                           || _has_proc:=1;
::                            Wykonuję formułę na bufor B_PROC i dodaję info od razu do tabelki
::                            TAB_PROC
                              {? var_pres('_read_res')>100 || obj_del(_read_res) ?};
                              {? var_pres('_obj')>100 || obj_del(_obj) ?};
                              _read_res:=exec('read_object','#b_export',_obj_txt,'ref_create_save_done',0);
                              {? _read_res.RESULT>0
                              || _obj:=_read_res.OBJ;
                                 _can_add:=1;
                                 {? _can_add>0
                                 ||
                                    {? _obj.IDADD=''
                                    || _obj.IDADD:=time_ident(date(),time());
                                       _uid:=exec('uid','#blank');
                                       _obj.IDADD:=gsub(_obj.IDADD,'##########',_uid)
                                    ?};
                                    _tab.IDADD:=_obj.IDADD;
                                    _tab_file.IDADD:=_obj.IDADD;
                                    _tab_file.put();
                                    _tab.SYMBOL:=_obj.SYMBOL;
                                    _tab.NAME:=_obj.NAME;
                                    _tab.VER:=_obj.VER;
                                    {? #_obj.VER=0
                                    || _tab.VER_NUM:=#_wersja
                                    || _tab.VER_NUM:=#_obj.VER
                                    ?};
                                    _crucial:='N';
                                    {? var_pres('CRUCIAL',_obj)=type_of('')
                                    || _crucial:=_obj.CRUCIAL
                                    ?};
                                    _tab.SELECTED:='N';
                                    _tab.FAST:='N';
                                    _tab.DIR:=_dir;
                                    _tab.FILEPATH:=_filepath;
                                    _tab.FILENAME:=_files.FILENAME;
                                    _tab.SVG_PATH:='';
                                    _tab.SVG_NAME:='';
                                    _tab.IMP_ERR:='N';

                                    _svg_path:=gsub(_tab.FILEPATH,'.graphml','.svg');
                                    _svg_name:=gsub(_tab.FILENAME,'.graphml','.svg');
                                    {? _dir_on_server=0
                                    || _fsvg:='@'+_svg_path
                                    || _fsvg:=_svg_path
                                    ?};
                                    {? fexists(_fsvg,0)
                                    || _tab.SVG_PATH:=_svg_path;
                                       _tab.SVG_NAME:=_svg_name
                                    ?};
                                    B_PROC.cntx_psh();
                                    B_PROC.index('SYM');
                                    B_PROC.prefix('N',REF.FIRMA,_obj.SYMBOL,_obj.VER,);
                                    {? B_PROC.first()
                                    || _tab.EXISTS:='T'
                                    || _tab.EXISTS:='N'
                                    ?};
                                    B_PROC.index('ACCEPTED');
                                    B_PROC.prefix('N','T','T',REF.FIRMA,_obj.SYMBOL,);
                                    _tab.MODI_HAS:='N';
                                    {? B_PROC.first()
                                    || _tab.OVERHAS:='T';

                                       _break:=0;
                                       {!
                                       |? {? B_PROC.MODIFIED='T'
                                          || _tab.MODI_HAS:='T';
                                             _break:=1
                                          ?};
                                          B_PROC.next() & _break=0
                                       !}
                                    || _tab.OVERHAS:='N'
                                    ?};
                                    B_PROC.cntx_pop();

                                    {? var_pres('CRUCIAL',_obj)=type_of('')
                                    ||
                                       {? _tab.SVG_PATH<>''
                                       || _tab.FAST:='T'
                                       ?};
                                       _tab.CRUCIAL:=_obj.CRUCIAL
                                    || _tab.CRUCIAL:='N'
                                    ?};
                                    _can_continue:=_tab.add();
                                    {? _can_continue>0
                                    ||
                                       {? type_of(_obj.TARGET)=type_of('')
                                       || _tab.memo_set(_obj.TARGET,'TARGET');
                                          _can_continue:=_tab.memo_put(,'TARGET')
                                       || _obj.TARGET:=''
                                       ?};
                                       {? type_of(_obj.DESC)=type_of('')
                                       || _tab.memo_set(_obj.DESC,'DESC');
                                          _can_continue:=_tab.memo_put(,'DESC')
                                       || _obj.DESC:=''
                                       ?}
                                    ?}
                                 ?}
                              ?}
                           ?};
                           _obj_txt:=''
                        ||
::                         Linia nie kończy się separatorem, więc jest pewnie złamana, dodaję znak końca linii
                           _obj_txt+='\n'
                        ?}
                     ?}
                  ?};
                  _line<>'\n' & _can_continue>0
               !}
            || _can_continue:=0;
               _msg:='Błąd odczytu zawartości z pliku: %1'@[_files.FILENAME];
               KOMM.add(_msg,2,,1)
            ?};
            {? _has_proc=0
            || _msg:='Plik: %1 nie zawiera procesu w formacie %2'@[_files.FILENAME,'Macrologic'];
               KOMM.add(_msg,2,,1)
            ?}
         ?};
         _files.next() & _can_continue>0
      !};
      {? _progress>0
      || {? _mode=0
         || _argsprog.ctr_stop()
         |? _mode=1
         || _argsprog.ph_sname(2,'Procesy, wczytywanie: %1'@['OK'@])
         ?}
      ?};
::      exec('objects_create','#b_export');

::    Kasuję uchwyt do pliku żeby nie zostawały śmieci
      {? var_pres('IMPORT_GML_DATA',_env_imex)>100
      || obj_del(_env_imex.IMPORT_GML_DATA)
      ?};
      _env_imex.CURRENT_FILEPATH:='';

::    Na końcu aktualizuję problemy w .TAB_PROC
      {? _mode=0
      ||
         _tab.clear();
         {? _tab.first()
         || {!
            |? exec('update_problems','#b_export');
               _can_continue:=_tab.put();
               _tab.next() & _can_continue>0
            !}
         ?}
      ?};

::    Pokazujemy okno selekcji
      {? _mode=0
      || KOMM.select();
         _env_imex.select()
      ?}
   || FUN.emsg('Brak plików .graphml w folderze: %1'@[_dir])
   ?};
   B_PROC.cntx_pop();
   ~~
?};
_tab.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\win_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PS] [17.14]
:: OPIS: Tworzy okno tymczasowe zawierające zaimportowane procesy z pliku
::   WE: _a - env - srodowisko designera - wynik dzialania exec('env_imex','#b_export')
::   WY: STRING - uchwyt do okna
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=_a;
_tab:=_env.TAB_PROC;

_sel:=_tab.mk_sel(_env.tit_proc,'P',,,,,,,'U');
_tab.win_fld(_sel,,'SELECTED',,,,,1,'Zaznaczony?'@,,'Czy wybrano proces do importu? (T/N)'@,2,,"'T'","'N'");
_tab.win_fld(_sel,,'CRUCIAL',,,,,1,'Wymagany'@,,'Proces jest wymagany (T/N)'@,2,,"'T'","'N'");
::_tab.win_fld(_sel,,'EXISTS',,,,,1,'Już istnieje'@,,'Czy proces już istnieje w systemie? (T/N)'@,2,,"'T'","'N'");
_tab.win_fld(_sel,,'SYMBOL',,,30,,,'Symbol'@,,'Symbol procesu'@);
_tab.win_fld(_sel,,'NAME',,,40,,,'Nazwa'@,,'Nazwa procesu'@);
_tab.win_fld(_sel,,'VER',,,10,,,'Wersja'@,,'Wersja procesu'@);
_tab.win_fld(_sel,,'PROBLEM',,,40,,1,'Problem'@,,'Problem uniemożliwiający import procesu'@);

_gr1:="
   params_set(params_get());
   exec('proc_popraw_action_gr1','#b_export')

";
_gr2:="
   params_set(params_get());
   exec('proc_popraw_action_gr2','#b_export')
";

_fb:="
   params_set(params_get());
   exec('proc_popraw_action','#b_export')
";

_tab.win_act(_sel,,'Formuła','&Popraw'@@,,'Zmienia symbol, nazwę, lub wersję procesu'@,_fb,,,1,_gr1,_gr2);

_fb:="
   _tab:=cur_tab();
   {? _tab.PROBLEM=''
   || _tab.SELECTED:='T';
      _tab.put()
   || {? _tab.sel_size()>0
      || KOMM.add('Nie można zaznaczyć procesu: %1 - %2 wersja: %3, ponieważ istnieje problem uniemożliwiający import.'@[_tab.SYMBOL,_tab.NAME,_tab.VER],2)
      ?}
   ?};
   1
";
_gr1:="
   KOMM.init(250,,'Importowanie procesów.'@);
   1
";
_gr2:="
   KOMM.select()
";
_tab.win_act(_sel,,'Formuła','&Zaznacz'@@,,'Zaznacz proces'@,_fb,,,1,_gr1,_gr2,'Z');
_fb:="
   _tab:=cur_tab();
   _tab.SELECTED:='N';
   _tab.put()
";
_tab.win_act(_sel,,'Formuła','&Odznacz'@@,,'Odznacz proces'@,_fb,,,1,,,'O');

_fb:="
   params_exec('import_group_accept','#b_export')
";
_tab.win_act(_sel,,'Formuła','&Akceptuj'@@,,,_fb,,,,,,'A');


_fb:="
   params_exec('find_ver','#b_export')
";
_gr1:="
   KOMM.init(250,,'Importowanie procesów.'@);
   _result:=FUN.ask('Zaznaczonych procesów: %1. Znaleść im nowe numery wersji?'@[$cur_tab(1,1).sel_size()]);
   _result
";
_gr2:="
   KOMM.select()
";
_tab.win_act(_sel,,'Formuła','Znajdź wolną &wersję'@@,,,_fb,,,1,_gr1,_gr2,'W');

_tab.win_btn(_sel,'text=%1,btn_label_align=center,panel=bottom,align=end'['&Akceptuj'@],'menu:A',,,,,,'noempty');
_tab.win_btn(_sel,'text=%1,btn_label_align=center,panel=bottom,align=end'['A&nuluj'@],'key:Esc');

_fb:="
   _lastdraw:=1;
   {? var_pres('_a')=type_of(0)
   || _lastdraw:=_a
   ?};
   params_exec('rek_proc','#b_export',_lastdraw)
";
_tab.win_act(_sel,,'Rekord',,,,_fb);
_fb:="exec('legenda','color','@B_IMEX#01')";
_tab.win_act(_sel,,'Formuła','Legenda'@@,,,_fb);

_tab.win_act(_sel,,'Szukaj');
_tab.win_act(_sel,,'Kolejność');
_fb:="
   params_exec('proc_display','#b_export')
";
_tab.win_act(_sel,,'Wyświetl',,,,_fb);
_sel


\tab_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PS] [17.14]
:: OPIS: Tworzy tabelkę tymczasową zawierającą zaimportowane procesy z pliku
::   WE: _a - env - srodowisko designera - wynik dzialania exec('env_imex','#b_export')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp(3,'SYMBOL','STRING[100]','Symbol',
                'NAME','STRING[45]','Nazwa procesu',
                'VER','STRING[10]','Wersja procesu',
                'VER_NUM','REAL','Wersja procesu, numeryczna',
                'IDADD','STRING[35]','ID',
                'FILEPATH','STRING[255]','Ścieżka do pliku',
                'FILENAME','STRING[255]','Nazwa pliku',
                'DIR','STRING[255]','Katalog',
                'SELECTED','STRING[1]','Czy zaznaczono',
                'PROBLEM','STRING[100]','Czy są jakieś problemy?',
                'EXISTS','STRING[1]','Czy istnieje',
                'TARGET','SYS_MEMO','Cel procesu',
                'DESC','SYS_MEMO','Opis procesu',
                'B_PROC','STRING[16]','Ref procesu',
                'REF','STRING[16]','Ref procesu',
                'CRUCIAL','STRING[1]','Czy proces ważny?',
                'FAST','STRING[1]','Czy szybki import dostępny?',
                'IMP_ERR','STRING[1]','Czy problem podczas importu?',
                'SVG_PATH','STRING[255]','Ścieżka do pliku SVG',
                'SVG_NAME','STRING[255]','Nazwa pliku SVG',
                'OVERHAS','STRING[1]','Czy są w systemie procesy w innych wersjach?',
                'OVERMODE','STRING[20]','Sposób rozwiązania problemu innych wersji',
                'MODI_HAS','STRING[1]','Czy procesy w innych wersjach są zmodyfikowane?'
                );
_env.NDX_PROC_SYMBOL:=_tab.ndx_tmp(,,'SYMBOL',,,'NAME',,,'VER',,);
_env.NDX_PROC_IDADD:=_tab.ndx_tmp(,,'IDADD',,);
_env.NDX_PROC_SELECTED:=_tab.ndx_tmp(,,'SELECTED',,,'SYMBOL',,,'NAME',,,'VER',,);
_env.NDX_PROC_VER:=_tab.ndx_tmp(,,'SYMBOL',,,'VER',,);
_env.NDX_PROC_VER2:=_tab.ndx_tmp(,,'VER',,,'SYMBOL',,);
_env.NDX_PROC_VER_NUM:=_tab.ndx_tmp(,,'VER_NUM',,,'SYMBOL',,);
_env.NDX_PROC_FILE:=_tab.ndx_tmp(,,'FILENAME',,,'SELECTED',,);
_env.NDX_PROC_CRUCIAL:=_tab.ndx_tmp(,,'CRUCIAL',,,'SELECTED',,,'IMP_ERR',,,'SYMBOL',,,'NAME',,,'VER',,);
_env.NDX_PROC_N_CRUCIAL:=_tab.ndx_tmp(,,'SELECTED',,,'IMP_ERR',,,'SYMBOL',,,'NAME',,,'VER',,);
_env.NDX_PROC_OVERHAS:=_tab.ndx_tmp(,,'SELECTED',,,'OVERHAS',,,'MODI_HAS',,,'SYMBOL',,,'VER',,);
_env.NDX_PROC_OVERMODE:=_tab.ndx_tmp(,,'SELECTED',,,'OVERMODE',,,'SYMBOL',,,'VER',,);
_tab


\rek_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PS] [17.14]
:: OPIS: Akcja na rekord w oknie zawierającym zaimportowane proccesy z pliku
::   WE: _a - INTEGER - oznacza czy rekord jest ostatnim odrysowywanym rekordem
::----------------------------------------------------------------------------------------------------------------------
_lastdraw:=_a;

_tab:=cur_tab();
_sel:=cur_win();

_grayed:='';
_result:='';

{? _lastdraw>0
||
   {? _tab.sel_size()=0
   ||
::    Pojedyncze zaznaczenie
      {? _tab.PROBLEM*'Konflikt symbolu'=0
      || _grayed+='W'
      ?};
      {? _tab.PROBLEM<>''
      || _grayed+='OZ';
         _tab.actions(_sel,,'P',1)
      |? _tab.SELECTED='T'
      || _tab.actions(_sel,,'O',1);
         _grayed+='Z'
      |? _tab.SELECTED='N'
      || _tab.actions(_sel,,'Z',1);
         _grayed+='O'
      ?}
   ||
::    Zaznaczenie grupowe
      _tab.actions(_sel,,'Z',1)
   ?};

   _anyselected:=0;
   _current:=_tab.ref();
   _tab.first();
   {!
   |? _anyselected:=(_tab.SELECTED='T');
      _tab.next() & ~_anyselected
   !};
   _tab.seek(_current);
   _tab.actions_grayed(_sel,_grayed)
?};
{? _tab.PROBLEM<>''
|| _result:=Color.fnd_kol('B_IMEX#01#01')
?};
_result


\import_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Akcja 'Importuj' w oknie wertowania B_PROC
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_env_imex:=exec('env_imex','#b_export');
:: Obiekt środowiska modelera potrzebny do mechanizmu przekształcania plików tekstowych w obiekty
_env:=exec('env','#b_design');
params_set('env_imex',_env_imex,'env',_env);
B_PROC.cntx_psh();
exec('import_group_prepare2','#b_export');
B_PROC.cntx_pop();
~~


\import_develop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja 'Importuj' dla developera - nie sprawdza sum kontrolnych czynności (importuje niezgodne procesy)
::  TAG: <PUBLIC>
::----------------------------------------------------------------------------------------------------------------------
_msg:='Uwaga! Funkcja służy do awaryjnego importowania procesów i może powodować nieoczekiwane błędy.\n\n'
      'Czy na pewno wiesz co robisz?';
{? FUN.ask(_msg)>0
||
   _env_imex:=exec('env_imex','#b_export');
   _env_imex.ENV_FAST.ACTION_CHK:=0;
:: Obiekt środowiska modelera potrzebny do mechanizmu przekształcania plików tekstowych w obiekty
   _env:=exec('env','#b_design');
   _env.ACTION_CHK:=0;
   params_set('env_imex',_env_imex,'env',_env);
   B_PROC.cntx_psh();
   exec('import_group_prepare2','#b_export');
   B_PROC.cntx_pop()
?};
~~


\tab_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Tworzy tabelkę tymczasową zawierającą wszystkie linie czytanego podczas importu pliku .proc
::   WE: _a - env - środowisko importu - wynik działania exec('env_imex','#b_export')
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tab:=tab_tmp( 2
               ,'UID'     ,'STRING[100]' ,'Identyfikator linii'
               ,'UID2'    ,'STRING[100]' ,'Identyfikator linii2'
               ,'IDADD'   ,'STRING[35]'  ,'Identyfikator rekordu'
               ,'LINE'    ,'SYS_MEMO'    ,'Linia pliku'
               ,'FILEPATH','STRING[255]' ,'Ścieżka do pliku'
               ,'TM_STAMP','REAL'        ,'Czas utworzenia rekordu'
               );
_env.NDX_FILE_IDADD:=_tab.ndx_tmp(,,'UID',,,'IDADD',,);
_env.NDX_FILE_PATH:=_tab.ndx_tmp(,,'FILEPATH',,,'UID',,,'UID2',,,'TM_STAMP',,);
_env.NDX_FILE_STAMP:=_tab.ndx_tmp(,,'FILEPATH',,,'TM_STAMP',,);
_tab


\update_problems
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Dla aktualnego rekordu tabeli .TAB_PROC aktualizuje pole PROBLEM
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;

_tab:=_env.TAB_PROC;

_tab.PROBLEM:='';

B_PROC.cntx_psh();
B_PROC.prefix('N',REF.FIRMA,_tab.SYMBOL,_tab.VER,);
{? B_PROC.first()
|| _tab.EXISTS:='T';
   _tab.SELECTED:='N'
|| _tab.EXISTS:='N'
?};
B_PROC.cntx_pop();

{? _tab.EXISTS='T'
|| _tab.PROBLEM:='Konflikt symbolu i wersji procesu.'@
?};
{? _tab.FILEPATH=''
|| _tab.PROBLEM:='Brak ścieżki do pliku .graphml.'@
?};
{? _tab.FILEPATH<>''
|| _fff:=_tab.FILEPATH;
   {? (1+_fff)<>'@'
   || _fff:='@'+_fff
   ?};
   {? fexists(_fff,0)=0
   || _tab.PROBLEM:='Brak pliku .graphml w wybranym folderze.'@
   ?}
?};
~~


\import_group_accept
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Akceptacja grupowego importu - akcja w oknie
::   WE: [_a] - INTEGER - 0/[1] - czy inicjować i wyświetlać obiekt KOMM
::       [_b] - INTEGER - 0/[1] - czy wykonywać sel_exit pod koniec
::       [_c] - FORMULA - formuła na zamknięcie okienka z importem
::       [_d] - obj_new() - obiekt multiprogress
::       [_e] - INTEGER - mode - 0 - wywołanie z obszaru roboczego, 1 - przez import procesów
::       [_f] - INTEGER - [0]/1 - czy ścieżka z plikami .graphml jest lokalna czy na serwerze
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;
_komm:=1;
{? var_pres('_a')=type_of(0)
|| _komm:=_a
?};
_sel_exit:=1;
{? var_pres('_b')=type_of(0)
|| _sel_exit:=_b
?};

_close:="";
{? var_pres('_c')=type_of("")
|| _close:=_c
?};

_argsprog:=~~;
{? var_pres('_d')>100
|| _argsprog:=_d
|| _argsprog:=exec('init','#progress')
?};

_mode:=0;
{? var_pres('_e')=type_of(0)
|| _mode:=_e
?};
_dir_on_server:=0;
{? var_pres('_f')=type_of(0)
|| _dir_on_server:=_f
?};

_tab:=_env.TAB_PROC;

_result:='';
_can_continue:=1;

{? _komm>0
|| KOMM.init(250,,'Import grupowy procesów')
?};

{? _komm>0 & BPMN.MY_PROC='T'
|| FUN.info('Bieżący zakres wyświetla procesy zalogowanego użytkownika. Aby zobaczyć zaimportowane procesy należy go zmienić.'@)
?};

_tab.cntx_psh();
_tab.index(_env.NDX_PROC_SELECTED);
_tab.prefix('T');
:: Najpierw kontrole
{? _tab.size()=0
|| _can_continue:=0;
   KOMM.add('Nie wybrano żadnego procesu do zaimportowania.'@,2,,1)
?};

_no_import_modified:='N';
_env.ACTIVE_CRUCIAL:='T';
{? _can_continue>0
|| _tab.index(_env.NDX_PROC_OVERHAS);
   _tab.prefix('T','T');
   {? _tab.first()
   || _overmode:=1;
      {? _komm>0
      ||
          _msg:='Zaznaczono co najmniej jeden proces, który w innej wersji funkcjonuje już w systemie.\n'
               'Wybierz jedną z opcji:\n\n'
               '* Pozostaw oba - w systemie będą procesy w różnych wersjach\n'
               '* Nie akceptuj importowanych - zaznaczone procesy się zaimportują, ale nie będą akceptowane (nawet jeżeli są wymagane)\n'
               '* Dezaktywuj istniejące - zaznaczone procesy się zaimportują, a procesy w innych wersjach zostaną dezaktywowane\n'@;

         _mchoice:=FUN.multichoice(_msg,
               'Dezaktywuj istniejące'@,,,12,
               'text=%1;selected=%2'['Nie importuj nowych wersji dla istniejących w systemie procesów zmodyfikowanych'@,_no_import_modified],
               'text=%1;selected=N;kind=button'['Pozostaw oba'@],
               'text=%1;selected=N;kind=button'['Nie akceptuj importowanych'@],
               'text=%1;selected=%2'['Przy dezaktywacji istniejących, akceptuj tylko procesy wymagane'@,_env.ACTIVE_CRUCIAL]
         );

         {? _mchoice[1]<>''
         ||
            {? _mchoice[1]='2'
            || ~~
            |? _mchoice[1]='3'
            || _overmode:=2
            || _overmode:=3
            ?};
            {? _mchoice[2]<>''
            || _no_import_modified:='T'
            || _no_import_modified:='N'
            ?};
            {? _mchoice[5]<>''
            || _env.ACTIVE_CRUCIAL:='T'
            || _env.ACTIVE_CRUCIAL:='N'
            ?}
         || _overmode:=0
         ?}
      ?};
      {? _overmode=0
      || _can_continue:=0
      ?};
      {? _overmode>1
      || {? _tab.first()
         || {!
            |? {? _overmode=2
               || _tab.OVERMODE:='NO_AKC'
               |? _overmode=3
               || _tab.OVERMODE:='DEACT'
               ?};
               _can_continue:=_tab.put();
               _tab.next() & _can_continue>0
            !}
         ?}
      ?}
   ?};

   {? _can_continue>0 & _no_import_modified='T'
   || _tab.prefix('T','T','T');
      {? _tab.first()
      || {!
         |? _can_continue:=_tab.del(,1);
            _tab.first() & _can_continue>0
         !}
      ?}
   ?}
?};

_tab.index(_env.NDX_PROC_SELECTED);
_tab.prefix('T');

{? _can_continue>0
||
   {? _tab.first()
   || {? _mode=0
      || _argsprog.TITLE:='Import procesów'@;
         _argsprog.HEIGHT:=10;
         _argsprog.add_progress('Import procesu'@,_tab.size());
         exec('start','#progress',_argsprog)
      ||
         _argsprog.ph_ssize(2,_tab.size());
         _argsprog.ph_start(2);
         _argsprog.ph_sname(2,'Analizowanie zawartości folderu...'@)
      ?};

      _mydo:=do_state()=0;
      {? _mydo || do() ?};

      {!
      |? _next:=0;
         _ref_nxt:=null();
         _tab.cntx_psh();
         {? _tab.next()
         || _ref_nxt:=_tab.ref()
         ?};
         _tab.cntx_pop();

         {? _mode=0
         || _can_continue:=exec('next_step','#progress',_argsprog,1);
            _argsprog.ph_sname(1,'Import procesu: %1 (wersja: %2)'@[_tab.SYMBOL,_tab.VER])
         || _can_continue:=exec('next_step','#progress',_argsprog,2);
            _argsprog.ph_sname(2,'Import procesu: %1 (wersja: %2)'@[_tab.SYMBOL,_tab.VER])
         ?};

::       Sprawdzam czy nie ma żadnych problemów
         _can_import:=1;
         {? _tab.PROBLEM<>''
         || _can_import:=0;
            KOMM.add('Procesu: %1 - %2 wersja: %3 nie można zaimportować, ponieważ istnieją problemy uniemożliwiające import'@[_tab.SYMBOL,_tab.NAME,_tab.VER],2,,1)
         ?};
         {? _can_import>0
         || _b_proc:=exec('import_group_single','#b_export',_dir_on_server);
            {? _b_proc<>null()
            || _tab.cntx_psh();
               _tab.prefix();
               _tab.B_PROC:=$_b_proc;
               _tab.REF:=$_b_proc;
               _tab.put();
               _tab.cntx_pop();
               _tab.get()
            || _can_continue:=0
            ?}
         ?};
         {? _ref_nxt<>null()
         || _next:=_tab.seek(_ref_nxt)
         ?};
         _next>0 & _can_continue>0
      !};
      {? _mode=0
      || _argsprog.ctr_stop()
      || _argsprog.ph_sname(2,'Import procesu: %1'@['OK'@])
      ?};

      {? _can_continue<=0
      || undo()
      ?};
      {? _mydo || end() ?};
      ~~
   || {? _komm>0
      || FUN.emsg('Żaden proces nie został zaimportowany.'@)
      ?}
   ?};
   ~~
?};
_tab.cntx_pop();

{? _can_continue>0
||
   _tab.index(_env.NDX_PROC_SELECTED);
   _tab.prefix('T');
   {? _tab.size()>0
   ||
      _env_modeler:=exec('env','#b_design');
      _env_modeler.IMPORT_GR:=1;
      _env_modeler.IMPORTED:='1';
      params_set('env',_env_modeler,'env_imex',_env);
      _env_modeler.sel4import(,_close)
   ?}
?};

{? _can_continue>0
||
:: Przeputowuje iksy, czyli procesy ktore zostały zaimportowane nową metodą, z powrotem na zaznaczone
   _tab.index(_env.NDX_PROC_SELECTED);
   _tab.prefix('X');
   {? _tab.first()
   || {!
      |? _next:=0;
         _ref_nxt:=null();
         _tab.cntx_psh();
         {? _tab.next()
         || _ref_nxt:=_tab.ref()
         ?};
         _tab.cntx_pop();

         _tab.prefix();
         _tab.SELECTED:='T';
         _can_continue:=_tab.put();

         {? _ref_nxt<>null()
         || _next:=_tab.seek(_ref_nxt)
         ?};
         _next>0 & _can_continue>0
      !}
   ?}
?};

{? _can_continue>0 & _sel_exit>0
|| sel_exit();
   {? var_pres('_env_modeler')>100
   || _env_modeler.ctr_bpmn:=~~
   ?}
?};
_break:=0;

{? var_pres('__IMP_BREAK')>0 & __IMP_BREAK>0
|| _break:=1
?};
{? _break=0
||
:: Uruchamiam akceptację procesów ważnych
   exec('accept_crucial','#b_export',0)
?};

{? _break=0
||
:: Uruchamiam dezaktywację procesów w innych wersjach
   exec('deactivate_ver','#b_export')
?};

{? _komm>0
|| KOMM.select()
?};

~~


\import_group_single
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Importuje jeden proces na podstawie rekordu w tabeli .TAB_PROC
::   WE: [_a] - INTEGER - [0]/1 - czy ścieżka z plikami .graphml jest lokalna czy na serwerze
::   WY: null() lub B_PROC.ref
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;

_dir_on_server:=0;
{? var_pres('_a')=type_of(0)
|| _dir_on_server:=_a
?};

_monkey:='@';
{? _dir_on_server>0
|| _monkey:=''
?};

_env_design:=params_get().env;
_env_design.IMPORT_FILEPROC:=_env.IMPORT_FILEPROC;

_tab:=_env.TAB_PROC;
_tab_file:=_env.TAB_FILE;

_result:=null();
_can_continue:=1;

B_PROC.cntx_psh();
B_PROC.clear();
_tab_file.cntx_psh();
_tab_file.index(_env.NDX_FILE_IDADD);

{? _tab.IDADD=''
|| _can_continue:=0;
   _msg:='Nie przekazany identyfikator: %1'@['IDADD'];
   exec('import_komm','#b_export',_msg)
?};

{? _can_continue>0
||
   _tab_file.prefix('B_PROC',_tab.IDADD);
   {? _tab_file.first()
   ||
      _line:=_tab_file.memo_txt(,1);
      {? var_pres('_read_res')>100 || obj_del(_read_res) ?};
      {? var_pres('_obj')>100 || obj_del(_obj) ?};
      _read_res:=exec('read_object','#b_export',_line,'ref_create_save_done',0);
      {? _read_res.RESULT>0
      || _obj:=_read_res.OBJ;

::       Sprawdzam czy takiego już przypadkiem nie ma
         _exists:=0;
         B_PROC.index('SYM');
         B_PROC.prefix('N',REF.FIRMA,_tab.SYMBOL,_tab.VER,);
         {? B_PROC.first()
         || _exists:=1
         ?};
         B_PROC.clear();

         {? _exists=0
         ||
            B_PROC.blank();

            {? type_of(_obj.TARGET)<>type_of('')
            || _obj.TARGET:=''
            ?};
            {? type_of(_obj.DESC)<>type_of('')
            || _obj.DESC:=''
            ?};
            _obj.set();
            B_PROC.SYMBOL:=_tab.SYMBOL;
            B_PROC.NAME:=_tab.NAME;
            B_PROC.VER:=_tab.VER;
            B_PROC.FIRMA:=REF.FIRMA;
            B_PROC.TM_SAVE:=0;
            B_PROC.TM_PLAN:=0;
            B_PROC.PROCFILE:='';
            B_PROC.IMP_ERR:='N';
            B_PROC.ACCEPTED:='N';
            B_PROC.ACTIVE:='T';
            B_PROC.MODIFIED:='N';
            B_PROC.IVAL_DEF:=null();
            B_PROC.memo_set(_tab.memo_txt(,1,'TARGET'),'TARGET');
            B_PROC.memo_set(_tab.memo_txt(,1,'DESC'),'DESC');
            ~~
         ?};

         _filepath:=_tab.FILEPATH;
         _svgpath:=_tab.SVG_PATH;
         _newfilepath:='';
         _newfilename:='';
         _separator:=exec('sep','#file');
         {? +_tab.FILENAME>63
         ||
::          Nazwa pliku za długa, to muszę ją skrócić żeby wrzucić do bloba
            _filename:=_tab.FILENAME;
            _filename:=gsub(_filename,'.graphml','');
            _newfilename:=(38+_filename)+$SYSLOG.tm_stamp()+'.graphml';
            {? (_tab.DIR+1)=_separator
            || _newfilepath:=_tab.DIR+_newfilename
            || _newfilepath:=_tab.DIR+_separator+_newfilename
            ?};
            _can_continue:=fcopy(_monkey+_filepath,_monkey+_newfilepath,0,0,1)
         ?};

         {? _can_continue>0
         ||
            {? _exists=1 & _env.OVERWRITE>0
            || _can_continue:=B_PROC.put()
            |? _exists=0
            || _can_continue:=B_PROC.add()
            ?}
         || _msg:='Nie udało się utworzenie pliku tymczasowego: %1'@[_newfilepath];
            exec('import_komm','#b_export',_msg)
         ?};
         {? _can_continue>0
         || {? _newfilename<>''
            || _can_continue:=B_PROC.bl_put('IMEX_GML',_monkey+_newfilepath,0);
               {? _can_continue>0
               || _can_continue:=ferase(_monkey+_newfilepath,0);
                  {? _can_continue=0
                  || _msg:='Nie udało się usunięcie pliku tymczasowego: %1'@[_newfilepath];
                     exec('import_komm','#b_export',_msg,,B_PROC.ref())
                  ?}
               ?}
            || _can_continue:=B_PROC.bl_put('IMEX_GML',_monkey+_tab.FILEPATH,0)
            ?}
         ?};
         {? _can_continue>0
         || B_PROC.memo_put(,'TARGET');
            B_PROC.memo_put(,'DESC')
         ?};

         {? _can_continue>0 & _tab.FAST='T'
         ||
::          Ścieżka szybkiego importu, bez konieczności uruchamiania modelera
            _env_modeler:=_env.ENV_FAST;
            _env_modeler.SEL_PROC:=B_PROC.ref();
            _env_modeler.ctr_id:='';
            _env_modeler.ctr_bpmn:='';
            params_set('env',_env_modeler,'env_imex',_env);

            _tab_file.cntx_psh();
            _tab_file.index(_env.NDX_FILE_STAMP);
            _tab_file.prefix(_tab.FILEPATH,);
            _can_continue:=exec('procfile_init','#b_export',,_tab_file,_tab.FILEPATH,_env.NDX_FILE_PATH,1);

            _tab_file.index(_env.NDX_FILE_STAMP);
            _tab_file.prefix(_tab.FILEPATH,);
            {? _can_continue>0
            || _can_continue:=exec('procfile_done','#b_export',_tab.FILEPATH,'ref_create_',_tab_file,0,1)
            ?};

            {? _can_continue>0
            ||
::             Usuwamy porty dynamiczne bez powiązań
               _can_continue:=exec('clean_dynamic','#b_port',B_PROC.ref())
            ?};

            {? _can_continue>0
            ||
::             Iterujemy po warunkach bram i dla połączeń z nimi powiązanymi nawijamy pole B_CONN.NAME_MOD:=
               _can_continue:=exec('proc_name_mod','#b_conn',B_PROC.ref())
            ?};

            {? _can_continue>0
            ||
::             Iterujemy po czynnościach typu EDI i jeżeli komunikat im się nie zaimportował to mu odtwarzamy porty
               _can_continue:=exec('edi_rebuild_ports','#b_port',B_PROC.ref())
            ?};

::          Jeżeli udał się szybki import, to odznaczam proces, żeby nie złapał go normalny
::          import
::          Tu nie musi być put, bo jest robiony poziom wyżej
            _tab.SELECTED:='X';

            B_PROC.TM_SAVE:=exec('create','#tm_stamp');
::          Ustawiam czas kiedy proces był zaimportowany
            B_PROC.TM_IMP:=exec('create','#tm_stamp');

            _imp_error:=0;
            {? _tab.IMP_ERR='T'
            || B_PROC.IMP_ERR:='T'
            ?};
::          Usuwam bloba z grupowego importu procesów
            {? B_PROC.IMEX_GML<>null()
            || B_PROC.IMEX_GML:=null()
            ?};
            B_PROC.put();

            {? _can_continue>0
            ||
               _newfilepath:='';
               _newfilename:='';

               _newsvgpath:='';
               _newsvgname:='';

               _separator:=exec('sep','#file');
               {? +_tab.FILENAME>63
               ||
::                Nazwa pliku za długa, to muszę ją skrócić żeby wrzucić do bloba
                  _filename:=_tab.FILENAME;
                  _filename:=gsub(_filename,'.graphml','');
                  _newfilename:=(38+_filename)+$SYSLOG.tm_stamp()+'.graphml';
                  {? (_tab.DIR+1)=_separator
                  || _newfilepath:=_tab.DIR+_newfilename
                  || _newfilepath:=_tab.DIR+_separator+_newfilename
                  ?};
                  _can_continue:=fcopy(_monkey+_filepath,_monkey+_newfilepath,0,0,1);

                  {? _can_continue>0
                  || _newsvgpath:=gsub(_newfilepath,'.graphml','.svg');
                     _newsvgname:=gsub(_newfilename,'.graphml','.svg');
                     _can_continue:=fcopy(_monkey+_svgpath,_monkey+_newsvgpath,0,0,1)
                  ?}
               ?};

               {? _can_continue>0
               || {? _newfilename<>'' & _newsvgname<>''
                  ||
::                   Dodaję diagram do bazy
                     {? exec('save_diagram','#b_bpmn',_newfilepath,_newsvgpath,,_dir_on_server)='0'
                     || _can_continue:=0
                     ?};
                     {? _can_continue>0
                     || _can_continue:=ferase(_monkey+_newfilepath,0);
                        {? _can_continue=0
                        || _msg:='Nie udało się usunięcie pliku tymczasowego: %1'@[_newfilepath];
                           exec('import_komm','#b_export',_msg,,B_PROC.ref())
                        ?}
                     ?};
                     {? _can_continue>0
                     || _can_continue:=ferase(_monkey+_newsvgpath,0);
                        {? _can_continue=0
                        || _msg:='Nie udało się usunięcie pliku tymczasowego: %1'@[_newsvgpath];
                           exec('import_komm','#b_export',_msg,,B_PROC.ref())
                        ?}
                     ?}
                  ||
::                   Dodaję diagram do bazy
                     {? exec('save_diagram','#b_bpmn',_tab.FILEPATH,_tab.SVG_PATH,,_dir_on_server)='0'
                     || _can_continue:=0
                     ?}
                  ?}
               ?}
            ?};
            _tab_file.cntx_pop()
         ?};

         {? _can_continue>0
         || _result:=B_PROC.ref()
         ?}
      ?}
   ?}
?};
_tab_file.cntx_pop();
B_PROC.cntx_pop();

_result


\import_group_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Uruchamia grupowy eksport procesów. Ta formuła jest wywołana po pojawieniu się i wczytaniu elementów
::       modelera-eksportera.
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;
_env_imex:=params_get().env_imex;
echo('Importowanie procesów...'@);

:: Wystawiam dane dla kontrolki modelera
_data_id:=$SYSLOG.tm_stamp();
_tab_proc:=_env_imex.TAB_PROC;
_tab_proc.cntx_psh();
_tab_proc.index(_env_imex.NDX_PROC_SELECTED);
_tab_proc.prefix('T');
{? _tab_proc.first()
||
   _fml_prfx:='';
   exec('fetch_data','#desktop',_data_id,_env.ctr_id,_tab_proc,'SYMBOL,NAME,VER,IDADD,FILEPATH,FILENAME,DIR,SELECTED,PROBLEM,EXISTS,B_PROC',_fml_prfx);
   exec('set_value','#desktop','#',_env.ctr_id,_env.ctr_bpmn,'export_separator='+exec('separator','#b_export'));
   exec('set_value','#desktop','#',_env.ctr_id,_env.ctr_bpmn,'import_batch='+_data_id)
|| FUN.emsg('Nie znaleziono zaznaczonych procesów. Import niemożliwy.'@);
   sel_exit()
?};
_tab_proc.cntx_pop();
~~


\proc_popraw_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Akcja 'Popraw' w okienku wertowania .TAB_PROC
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;

_tab:=_env.TAB_PROC;

_result:=0;

_group:=0;
{? _tab.sel_size()>0
|| _group:=1
?};

{? _group=0
||
   _red:=_tab.mk_edit('Właściwości procesu'@,,'imex_proc_edit');
   _tab.win_esep(_red,'Dane podstawowe'@);
   _tab.win_efld(_red,,'SYMBOL',,,50,,,'Symbol procesu'@);
   _tab.win_efld(_red,,'NAME'  ,,,50,,,'Nazwa procesu'@);
   _tab.win_efld(_red,,'VER'   ,,,10,,,'Wersja procesu'@);

   _tab.efld_opt(_red,'mark=1',,'SYMBOL');
   _tab.efld_opt(_red,'mark=1',,'NAME');
   _tab.efld_opt(_red,'mark=1',,'VER');

   _tab.win_edit(_red);

   _valid:="
      _result:='';
      _tab:=cur_tab(1,1);
      {? _tab.SYMBOL=''
      || FUN.emsg('Symbol procesu nie może być pusty.'@);
         _result:='SYMBOL'
      ?};
      {? _tab.NAME=''
      || FUN.emsg('Nazwa procesu nie może być pusta.'@);
         _result:='NAME'
      ?};
      {? _tab.VER=''
      || FUN.emsg('Wersja procesu nie może być pusta.'@);
         _result:='VER'
      ?};
      _result
   ";
   exec('ok_esc','#window',_tab,_red);

   {? _tab.edit(_valid)
   || params_exec('update_problems','#b_export');
      _result:=_tab.put()
   ?}
|| _tab.VER:=_env.POPRAW_VER;
   params_exec('update_problems','#b_export');
   _result:=_tab.put()
?};
_result


\proc_popraw_action_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Akcja grupa przed 'Popraw' w okienku wertowania .TAB_PROC
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;

_result:=0;

_tab:=_env.TAB_PROC;
_red:=_tab.mk_edit('Właściwości procesu'@,,'imex_proc_edit2');
_tab.win_esep(_red,'Dane podstawowe'@);
_tab.win_efld(_red,,'VER'   ,,,10,,,'Wersja procesu'@);

_tab.win_edit(_red);

_valid:="
   _result:='';
   _tab:=cur_tab(1,1);
   {? _tab.VER=''
   || FUN.emsg('Wersja procesu nie może być pusta.'@);
      _result:='VER'
   ?};
   _result
";
exec('ok_esc','#window',_tab,_red);

{? _tab.edit(_valid)
|| _env.POPRAW_VER:=_tab.VER;
   _result:=1
?};
_result


\proc_popraw_action_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Akcja grupa po 'Popraw' w okienku wertowania .TAB_PROC
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
~~


\find_ver
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Akcja 'Znajdź wolną wersję' w .TAB_PROC
::   WE: [_a] - INTEGER,STRING - numer wersji który jest potencjalnym kandydatem
::       [_b] - INTEGER - czy wywołanie rekurencyjne?
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;

_ver:='';
_nr:=~~;
{? var_pres('_a')=type_of(0)
|| _nr:=_a
?};
{? var_pres('_a')=type_of('')
|| _ver:=_a
?};

_rec:=0;
{? var_pres('_b')=type_of(0)
|| _rec:=_b
?};

_tab:=_env.TAB_PROC;
_group:=0;
{? _tab.sel_size()>0
|| _group:=1
?};

_can_continue:=1;
{? _group=0 & _rec=0
|| _can_continue:=FUN.ask('Znaleźć pierwszy wolny nr wersji dla procesu: %1 - %2 wersja: %3?'@[_tab.SYMBOL,_tab.NAME,_tab.VER])
?};

{? _can_continue>0
||
   B_PROC.cntx_psh();
   B_PROC.index('SYM');
   _symbol:=_tab.SYMBOL;
   {? _ver=''
   || _ver:=_tab.VER
   ?};

   _precision:=-1;
   _ver4prec:=_ver;
   {? exec('isLetter','#string',_ver4prec+1)>0
   || _ver4prec:=_ver4prec-1
   ?};
   {? _ver4prec*'.'>0
   || _fract_pos:=_ver4prec*'.';
      _precision:=(+_ver4prec)-_fract_pos
   |? _ver4prec*','>0
   ||
      _fract_pos:=_ver4prec*',';
      _precision:=(+_ver4prec)-_fract_pos
   ?};

   {? type_of(_nr)=type_of(0)
   || _str:='';
      {? _precision>-1
      || _str:=form(_nr,,_precision,'..')
      || _str:=form(_nr,,,'..')
      ?};
      B_PROC.prefix('N',REF.FIRMA,_symbol,_str,)
   || B_PROC.prefix('N',REF.FIRMA,_symbol,_ver,)
   ?};

   _tab.cntx_psh();
   _tab.index(_env.NDX_PROC_VER);
   {? type_of(_nr)=type_of(0)
   || _tab.prefix(_symbol,form(_nr,,,'..'),)
   || _tab.prefix(_symbol,_ver,)
   ?};
   _local:=_tab.first();
   _tab.cntx_pop();

   {? B_PROC.first() | _local
   ||
::    Jest konflikt wyznaczam nowy numer
      {? type_of(_nr)=type_of(0)
      || _nr:=exec('next_value','#math',_nr,,_precision)
      |? #_ver>0
      || _nr:=#_ver;
         _nr:=exec('next_value','#math',_nr,,_precision)
      |? exec('isLetter','#string',_ver+1) & #(_ver-1)>0
      ||
::       Jeżeli na końcu litera to proponuję kolejną literę
         _next_letter:=exec('next_letter','#string',_ver+1);

         {? _next_letter<>''
         || _nr:=(_ver-1)+_next_letter
         ||
            _wersja:=_ver-1;
            {? _wersja*'.'=0 & +_wersja>2
            || _wersja:=2+_wersja+'.'+(_wersja+(+_wersja-2))
            ?};
            _nr:=#_wersja;
            _nr:=exec('next_value','#math',_nr,,2);
            _nr:=form(_nr,,2,'9.')
         ?}
      || _nr:=exec('next_value','#math',0,,_precision)
      ?};
::    !!! REKURENCJA !!!
      exec('find_ver','#b_export',_nr,1)
   ||
::    Brak konfliktu biore to co przyszło
      {? type_of(_nr)=type_of(0)
      || {? _precision>-1
         || _tab.VER:=form(_nr,,_precision,'9.')
         || _tab.VER:=form(_nr,,,'9.')
         ?};
         exec('update_problems','#b_export');
         _tab.put()
      |? type_of(_ver)=type_of('') & _ver<>''
      || _tab.VER:=form(_ver);
         exec('update_problems','#b_export');
         _tab.put()
      ?}
   ?};
   B_PROC.cntx_pop();
   ~~
?};
~~


\proc_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Akcja na wyświetl w oknie .TAB_PROC
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;

_tab:=_env.TAB_PROC;
_tab.memo_get(,'DESC');
_tab.memo_get(,'TARGET');

_result:=0;

_red:=_tab.mk_edit('Właściwości procesu'@,,'imex_proc_edit');
_tab.win_esep(_red,'Dane podstawowe'@);
_tab.win_efld(_red,,'SYMBOL',,,50,,,'Symbol procesu'@);
_tab.win_efld(_red,,'NAME'  ,,,50,,,'Nazwa procesu'@);
_tab.win_efld(_red,,'VER'   ,,,10,,,'Wersja procesu'@);

_tab.win_esep(_red,'Opis procesu'@);
_tab.win_efld(_red,,'TARGET',,,50,-10,,'Cel'@);
_tab.win_efld(_red,,'DESC'  ,,,50,-10,,'Opis'@);

_tab.win_edit(_red);
_tab.display();
~~


\get_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Pobiera informacje o procesie z pliku graphml
::   WE: _a - nazwa lokalnego pliku graphml (pełna ścieżka)
::       [_b] - INTEGER - [1]/2 - komunikaty na ekran albo do KOMMa
::       [_c] - INTEGER - [0]/1 - czy ścieżka z plikami .graphml jest lokalna czy na serwerze
::----------------------------------------------------------------------------------------------------------------------
_filename:=_a;
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_dir_on_server:=0;
{? var_pres('_c')=type_of(0)
|| _dir_on_server:=_c
?};

_result:=~~;

{? _dir_on_server=0
|| _fpth:={? 1+_filename='@' || '' || '@' ?}+_filename
|| _fpth:=_filename
?};

_file:=fopen(_fpth,'ur',0,,1);

{? _file.is_open()
|| _obj:=obj_new('LEVEL','ELEMENT','INFO','LINE');
   _obj.LEVEL:=0;
   _obj.ELEMENT:='';
   _obj.INFO:=fopen(null(),'Uw',,1,1);
   _obj.LINE:='';
   params_set('obj',_obj);
::   _no_msg:=no_msg(1);
   xml_sax_parse(_file,
::    Start document
      ,
::    End document
      "  _obj:=params_get().obj;
         {? _obj.LINE<>''
         || _obj.INFO.fwrite(_obj.LINE)
         ?};
         1
      ",
::    Start element
      "  _obj:=params_get().obj;
         _result:=1;
         {? _obj.LEVEL=0
         || {? _a='graphml'
            || _obj.LEVEL:=1
            || _msg:='Błędny plik: %1 (na pierwszym poziomie może być tylko element ''graphml'').'@[_filename];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               ?};
               _result:=0
            ?}
         |? _obj.LEVEL=1
         || {? _a='data' | _a='graph'
            || _obj.LEVEL:=2;
               _obj.ELEMENT:=_a
            ?}
         |? _obj.LEVEL=2
         || _result:=0
         ?};
         _result
      ",
::    End element
      "  _obj:=params_get().obj;
         {? (_a='data' | _a='graph') & _obj.LEVEL=2
         || _obj.LEVEL:=1
         |? _a='graphml'
         || _obj.LEVEL:=0
         ?};
         _obj.ELEMENT:='';
         1
      ",
::    Text
      "  _obj:=params_get().obj;
         {? _obj.ELEMENT='data'
         || _nl:=_a*'\n';
            {? _nl=0
            || _obj.LINE+=_a
            || {!
               |? {? _nl>0
                  || _obj.INFO.fwrite(_obj.LINE+((_nl-1)+_a));
                     _obj.LINE:=''
                  ?};
                  _a:=_nl-_a;
                  _nl:=_a*'\n';
                  _nl>0
               !};
               _obj.LINE:=_a
            ?}
         ?};
         1
      "
   );
::   no_msg(_no_msg);
   _result:=_obj.INFO.copy()
?};
_result


\accept_crucial
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Akceptacja procesów 'ważnych'
::   WE: [_a] - INTEGER - 0/[1] - wyświetlać obiekt KOMM
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;
_komm:=1;
{? var_pres('_a')=type_of(0)
|| _komm:=_a
?};

_env2:=params_get().env;
{? var_pres('ctr_bpmn',_env2)=type_of('')
|| _env2.ctr_bpmn:=~~
?};

_tab:=_env.TAB_PROC;

_result:='';
_can_continue:=1;

_tab.cntx_psh();
:: czy akceptować tylko procesy wymagane czy wszystkie
{? _env.ACTIVE_CRUCIAL='N'
|| _tab.index(_env.NDX_PROC_N_CRUCIAL);
   _tab.prefix('T','N')
|| _tab.index(_env.NDX_PROC_CRUCIAL);
   _tab.prefix('T','T','N')
?};

:: Usuwam te procesy z tabeli, co do których zdecycowano podczas importu
:: że mają być nieakceptowane (bo np w systemie istniał już taki proces, ale w innej wersji)
{? _tab.first()
|| {!
   |? _next:=0;
      _ref_nxt:=null();
      _tab.cntx_psh();
      {? _tab.next()
      || _ref_nxt:=_tab.ref()
      ?};
      _tab.cntx_pop();

      {? _tab.OVERMODE='NO_AKC'
      || _can_continue:=_tab.del(,1)
      ?};

      {? _ref_nxt<>null()
      || _next:=_tab.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};

{? _tab.size()>0
|| exec('proc_akc_act','#b_design',0,_tab,0,_env.DOMAIN_LIC,_komm,0)
?};

_tab.cntx_pop();
~~


\deactivate_ver
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Deaktywacja procesów w innych wersjach
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;

_tab:=_env.TAB_PROC;

_result:=0;
_can_continue:=1;


B_PROC.cntx_psh();
B_PROC.index('ACCEPTED');
_tab.cntx_psh();
_tab.index(_env.NDX_PROC_OVERMODE);
_tab.prefix('T','DEACT',);
_can_continue:=1;
{? _tab.first()
|| {!
   |?  B_PROC.prefix('N','T','T',REF.FIRMA,_tab.SYMBOL,);
       {? B_PROC.first()
       || {!
          |? _next:=0;
             _ref_nxt:=null();
             B_PROC.cntx_psh();
             {? B_PROC.next()
             || _ref_nxt:=B_PROC.ref()
             ?};
             B_PROC.cntx_pop();

             {? B_PROC.VER<>_tab.VER
             || _can_continue:=exec('set_active','#b_proc',,'N',0)
             ?};

             {? _ref_nxt<>null()
             || _next:=B_PROC.seek(_ref_nxt)
             ?};
             _next>0 & _can_continue>0
          !}
       ?};
      _tab.next() & _can_continue>0
   !}
?};
B_PROC.cntx_pop();
_tab.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\objects_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Na podstawie tabeli .tab_file tworzę tablicę nazwaną z obiektami
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_imex;

_tab_file:=_env.TAB_FILE;

_tab_file.cntx_psh();
_tab_file.prefix();
{? _tab_file.first()
||
   _rule:='obj_new(\'EMPTY\'';
   {!
   |? _rule+=',\''+$_tab_file.TM_STAMP+'\'';
      _tab_file.next()
   !};
   _rule+=')';
   _env.OBJECTS:=($_rule)();

   {! _it:=1..obj_len(_env.OBJECTS)
   |! _env.OBJECTS[_it]:=~~
   !}
?};
_tab_file.cntx_pop();
~~


\get_uid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Zwraca UID dla .TAB_FILE. Z przekazanego tekstu wygrzebuje nazwę tabeli procesowej B_*
::   WE: _a - STRING - tekst identyfikacyjny buffera (treść metody _buffer.this())
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;

_result:=_uid;

:: Specjalna obsługa dla sygnałów - w uid znajduje się TM_STAMP który trzeba zachować
_tm_stamp:='';
{? (_uid*'B_SIGNAL'>0 | _uid*'B_SIGTYP'>0) & _uid*';'>0
|| _split:=spli_str(_uid,';');
   _tm_stamp:=_split[1]
?};

_pos1:=_uid*'\'B_';

{? _pos1=0
|| _pos1:=_uid*'\'IVAL_'
?};

{? _pos1>0
|| _part:=_pos1-_uid;

   _pos2:=_part*'\'';

   {? _pos2>0
   || _result:=(_pos2-1)+_part
   ?}
?};

{? _tm_stamp<>''
|| _result:=_tm_stamp+';'+_result
?};

_result


\export_new
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Eksport procesów wyłącznie po stronie MacroBASE
::   WE: _a - obj_new - wynik działania exec('env','#b_design');
::       [_b] - INTEGER - 0/[1]/2 - czy wyświetlać progress
::       [_c] - INTEGER - 0/[1] - czy folder docelowy: 0 - na serwerze, 1 - na terminalu klienta
::       [_d] - INTEGER - 0/[1] - czy inicjować i wyświetlać KOMM
::       [_e] - obj_new - obiekt multiprogress któremu nawijać nazwę dla etapu nr 2
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
params_set(params_get());

_progress:=1;
{? var_pres('_b')=type_of(0)
|| _progress:=_b
?};

_monkey:='@';
_client:=1;
{? var_pres('_c')=type_of(0)
|| _client:=_c
?};
{? _client=0
|| _monkey:=''
?};
_komm_init:=1;
{? var_pres('_d')=type_of(0)
|| _komm_init:=_d
?};
_argsprog:=~~;
{? var_pres('_e')>100
|| _argsprog:=_e
?};

_can_continue:=1;
_result:=0;

{? _komm_init>0
|| KOMM.init(250,,'Eksport procesów')
?};

B_PROC.cntx_psh();
B_PROC.prefix();

_tab:=_env.EXPORT_SEL;
{? var_pres('_tab')=0
|| _tab:=tab_tmp(1,'REF','STRING[16]','Nazwa pola 1');
   _tab.blank();
   _tab.REF:=$_env.SEL_PROC;
   _tab.add()
?};

_env.EXPORT_MODELER:=0;
:: Tworzę katalog tymczasowy po stronie serwera i jeżeli go nie ma
{? _env.EXPORT_SERVER_DIR=''
||
   _tmp_dir:=fmk_tmp_dir(0);
   {? type_of(_tmp_dir)<>type_of(~~)
   || _pth:=_tmp_dir.get_path();
      _env.EXPORT_SERVER_DIR:=_pth
   ?}
|| _pth:=_env.EXPORT_SERVER_DIR
?};

{? _pth=''
|| _can_continue:=0;
   _msg:='Nie udało się utworzenie katalogu tymczasowego po stronie serwera.'@;
   exec('import_komm','#b_export',_msg,4)
?};
_sep_server:=exec('sep','#file',2);
_sep_output:=exec('sep','#file',{? _client || 0 || 2 ?});
_tab.prefix();
{? _can_continue>0 & _tab.first()
|| {? _progress=1
   || FUN.prg_start(_tab.size(),'Eksportowanie procesów...',,,1)
   ?};
   {!
   |? {? B_PROC.seek(_tab.REF)
      || _what:=exec('B_PROC','#to_string');
         {? _progress=1
         || FUN.prg_next(,'Eksport procesu: %1'@[_what])
         |? _progress=2 & var_pres('_argsprog')>100
         || _argsprog.ph_sname(_argsprog.PHASE,'Eksport: %1 (rekord: %2)'@['Procesy'@,_what])
         ?};
         {? B_PROC.GRAPHMLZ<>null()
         ||
            _name:=B_PROC.bl_info('GRAPHMLZ','NAME');
            _ext:=B_PROC.bl_info('GRAPHMLZ','EXTENSION');
            _file:=_pth+_sep_server+_name;
            {? _ext='graphmlz'
            || _can_continue:=0;
              _file_dest:=gsub(_file,'graphmlz','graphml');
::            _file:='p:\\test\\a.zip';
               _can_continue:=B_PROC.bl_get('GRAPHMLZ',_file,0);
               {? _can_continue>0
               || _gzipfile:=exec('graphmlz_unpack','#b_export',_file,_file_dest);
                  {? _gzipfile<>''
                  || _file:=_gzipfile
                  || _can_continue:=0;
                     _msg:='Nie udało się rozpakowanie pliku: %1'@[_file];
                     exec('import_komm','#b_export',_msg,4,B_PROC.ref())
                  ?}
               ?}
            |? _ext='graphml'
            ||
               _can_continue:=B_PROC.bl_get('GRAPHMLZ',_file,0);
               {? _can_continue=0
               || _msg:='Nie udało się pobranie pliku: %1 na serwer.'@[_file];
                  exec('import_komm','#b_export',_msg,4,B_PROC.ref())
               ?}
            || _can_continue:=0;
               _msg:='Nieprawidłowe rozszerzenie pliku: %1. Proces nie został wyeksportowany.'@[_file];
               exec('import_komm','#b_export',_msg,4,B_PROC.ref())
            ?}
         || _can_continue:=0;
            _msg:='Proces: %1 nie zawiera diagramu. Eksport niemożliwy.'@[_what];
            exec('import_komm','#b_export',_msg,4,B_PROC.ref())
         ?};

         {? _can_continue>0
         ||
            {? var_pres('_file_tparse')>100
            || obj_del(_file_tparse)
            ?};
            _file_tparse:=fopen(_file,'Ur',0,,1);
            {? var_pres('_tparse')>100
            || obj_del(_tparse)
            ?};
            _tparse:=xml_tparse(_file_tparse,100,100);
            {? type_of(_tparse) = type_of(~~)
            || _can_continue:=0;
               _msg:='Nie udało się parsowanie pliku: %1'@[_file];
               exec('import_komm','#b_export',_msg,4,B_PROC.ref())
            ?}
         ?};
         {? _can_continue>0
         ||
::            _w:=_tparse.mk_sel(,'P',1,'xml_view',1,1,,1);
::            _tparse.win_act(_w,,'Szukaj');
::            _tparse.win_act(_w,,'Kolejność');
::            _tparse.win_sel(_w);
::            _tparse.select();

            _ndx_name:=_tparse.ndx_tmp('',1,'NAME',,);
            _ndx_index:=_tparse.ndx_tmp('',1,'INDEX',,);
            _ndx_tree:=_tparse.ndx_tmp('',1,'TREE',,,'INDEX',,);
            _tparse.prefix();
            {? _tparse.first()
            ||
               _root:=null();
               _tparse.cntx_psh();
               _tparse.index(_ndx_name);
               _tparse.prefix('graphml',);
               {? _tparse.first()
               || _root:=_tparse.ref()
               || _can_continue:=0;
                  _msg:='Nie znaleziono elementu: %1 w pliku: %2.'@['graphml',_file];
                  exec('import_komm','#b_export',_msg,4,B_PROC.ref())
               ?};
               _tparse.cntx_pop();
               _tparse.prefix();

               _id_data:='';
               {? _can_continue>0
               ||
                  _par_mbdata:=exec('tparse_find_val','#b_export',_tparse,,'macrobase-data',2);
                  {? _par_mbdata<>null()
                  || _id_data:=exec('tparse_get_val','#b_export',_tparse,_par_mbdata,'id')
                  ?};

                  {? _id_data=''
                  ||
                     _tparse.cntx_psh();
::                   Robię miejsce na dwa nowe elementy przed graph
                     _tparse.index(_ndx_name);
                     _tparse.prefix('graph',);
                     {? _tparse.first()
                     || _index:=_tparse.INDEX;
                        _ref:=_tparse.ref();

                        _tparse.index(_ndx_tree);
                        _tparse.prefix(_root);
                        {? var_pres('_visited')>100
                        || obj_del(_visited)
                        ?};
                        _visited:=exec('ref_table','#table');
                        {? _tparse.seek(_ref)
                        || {!
                           |? _next:=0;
                              _ref_nxt:=null();
                              _tparse.cntx_psh();
                              {? _tparse.next()
                              || _ref_nxt:=_tparse.ref()
                              ?};
                              _tparse.cntx_pop();

                              _tparse.INDEX+=2;
                              _can_continue:=_tparse.put();
                              _visited.add(_tparse.ref());

                              {? _ref_nxt<>null()
                              || _next:=_tparse.seek(_ref_nxt)
                              ?};
                              _next>0 & _can_continue>0 & _visited.r_find(_tparse.ref())=0
                           !}
                        || _can_continue:=0
                        ?};
                        {? _can_continue=0
                        || _msg:='Nie udało się parsowanie przenumerować elementów w pliku: %1'@[_file];
                           exec('import_komm','#b_export',_msg,4,B_PROC.ref())
                        ?}
                     || _tparse.index(_ndx_tree);
                        _tparse.prefix(_root);
                        {? _tparse.last()
                        || _index:=_tparse.INDEX
                        ?}
                     ?};
                     _tparse.cntx_pop();
                     _tparse.prefix();

                     {? _can_continue>0
                     ||
::                      Zakładam brakujące rekordy w drzewie
                        _tparse.blank();
                        _tparse.TREE:=_root;
                        _tparse.NAME:='key';
                        _tparse.NAMESPC:=2;
                        _tparse.NTRUNC:='N';
                        _tparse.TYPE:='E';
                        _tparse.VAL:='';
                        _tparse.VTRUNC:='N';
                        _tparse.INDEX:=_index;
                        _can_continue:=_tparse.add();

                        _parent:=null();
                        {? _can_continue>0
                        || _parent:=_tparse.ref();

                           _tparse.blank();
                           _tparse.TREE:=_parent;
                           _tparse.NAME:='attr.name';
                           _tparse.NAMESPC:=0;
                           _tparse.NTRUNC:='N';
                           _tparse.TYPE:='A';
                           _tparse.VAL:='macrobase-data';
                           _tparse.VTRUNC:='N';
                           _tparse.INDEX:=1;
                           _can_continue:=_tparse.add();

                           {? _can_continue>0
                           ||
                              _tparse.blank();
                              _tparse.TREE:=_parent;
                              _tparse.NAME:='attr.type';
                              _tparse.NAMESPC:=0;
                              _tparse.NTRUNC:='N';
                              _tparse.TYPE:='A';
                              _tparse.VAL:='string';
                              _tparse.VTRUNC:='N';
                              _tparse.INDEX:=2;
                              _can_continue:=_tparse.add()
                           ?};
                           {? _can_continue>0
                           || _tparse.blank();
                              _tparse.TREE:=_parent;
                              _tparse.NAME:='id';
                              _tparse.NAMESPC:=0;
                              _tparse.NTRUNC:='N';
                              _tparse.TYPE:='A';
                              _id_data:='d500';
                              _tparse.VAL:=_id_data;
                              _tparse.VTRUNC:='N';
                              _tparse.INDEX:=3;
                              _can_continue:=_tparse.add()
                           ?};

                           {? _can_continue>0
                           || _index+=1;
                              _tparse.blank();
                              _tparse.TREE:=_root;
                              _tparse.NAME:='data';
                              _tparse.NAMESPC:=2;
                              _tparse.NTRUNC:='N';
                              _tparse.TYPE:='E';
                              _tparse.VAL:='';
                              _tparse.VTRUNC:='T';
                              _tparse.INDEX:=_index;
                              _can_continue:=_tparse.add();

                              {? _can_continue>0
                              || _parent:=_tparse.ref();

                                 _tparse.blank();
                                 _tparse.TREE:=_parent;
                                 _tparse.NAME:='key';
                                 _tparse.NAMESPC:=0;
                                 _tparse.NTRUNC:='N';
                                 _tparse.TYPE:='A';
                                 _tparse.VAL:=_id_data;
                                 _tparse.VTRUNC:='N';
                                 _tparse.INDEX:=1;
                                 _can_continue:=_tparse.add()
                              ?}
                           ?}
                        ?};
                        {? _can_continue<=0
                        || _msg:='Nie udało się dodać do struktury pliku .graphml nowych elementów.'@;
                           exec('import_komm','#b_export',_msg,4,B_PROC.ref())
                        ?}
                     ?};
                     ~~
                  ?}
               ?};

               {? _id_data<>''
               ||
::                Ustawiam się na rekordzie który ma zawierać dane o procesie
                  _par_blob:=exec('tparse_find_val','#b_export',_tparse,'data',_id_data,2);
                  _tparse.cntx_psh();
                  _tparse.index(_ndx_tree);
                  _tparse.prefix();
                  {? _tparse.seek(_par_blob)
                  ||
                     {? var_pres('_fileproc')>100
                     || obj_del(_fileproc)
                     ?};
                     _fileproc:=fopen(null(),'Uw!',,,1);
::                   Tworzę zawartość MacroBASE
                     _env.SEL_PROC:=B_PROC.ref();
                     _can_continue:=exec('export_file_mbase','#b_export','aaa',,_fileproc);

                     {? _can_continue>0
                     ||
::                      Czyszczę wartość skróconą żeby bl_put bloba się udał
                        _tparse.VAL:='';
                        _can_continue:=_tparse.put()
                     ?};

                     {? _can_continue>0
                     ||

                        _tparse.bl_put('BVAL',_fileproc.copy('br'),,,'value.txt');
                        _fileproc.fclose();
::                        _tparse.select();
                        _name:=exec('export_gen_filename','#b_export');
                        _file:=_pth+_sep_server+_name;
                        {? var_pres('_file_final')>100
                        || obj_del(_file_final)
                        ?};
                        _file_final:=fopen(_file,'Uw!',0,,1);
                        _tparse.first();
                        {? _tparse.xml_twrite(_file_final,0,0,'order=datanodes')
                        || fclose(_file_final);

::                         Kopiowanie pliku .graphml do docelowego katalogu
                           _file_client:=_monkey+_env.EXPORT_DIR+_sep_output+_name;
                           _can_continue:=fcopy(_file,_file_client,0,0,1);

                           {? _can_continue>0
                           ||
                              {? var_pres('FILE',_tab)>0
                              || _tab.FILE:=_name;
                                 _tab.put()
                              ?}
                           |? _can_continue=0
                           || _msg:='Nie udało się kopiowanie pliku %1 na terminal klienta: %2'@[_file,_file_client];
                              exec('import_komm','#b_export',_msg,4,B_PROC.ref())
                           ?}
                        || fclose(_file_final);
                           _can_continue:=0;
                           _msg:='Nie udało się zapis do pliku: %1'@[_file];
                           exec('import_komm','#b_export',_msg,4,B_PROC.ref())
                        ?};

                        {? _can_continue>0
                        || {? B_PROC.SVG<>null
                           ||
::                            Kopiowanie pliku SVG
                              _filename_svg:=exec('export_gen_filename','#b_export','.svg');
                              _path_svg:=_pth+_sep_server+_filename_svg;
                              _can_continue:=B_PROC.bl_get('SVG',_path_svg,0);
                              {? _can_continue>0
                              ||
::                               Kopiowanie pliku na terminal klienta
                                 _file_client:=_monkey+_env.EXPORT_DIR+_sep_output+_filename_svg;
                                 _can_continue:=fcopy(_path_svg,_file_client,0,0,1);
                                 {? _can_continue=0
                                 || _msg:='Nie udało się kopiowanie pliku SVG: %1 na terminal klienta'@[_path_svg];
                                    exec('import_komm','#b_export',_msg,4,B_PROC.ref())
                                 ?}
                              || _msg:='Nie udało się kopiowanie pliku SVG na serwer.'@;
                                 exec('import_komm','#b_export',_msg,4,B_PROC.ref())
                              ?}
                           ?}
                        ?}
                     || _msg:='Nie udało się utworzenie zawartości MacroBASE.'@;
                        exec('import_komm','#b_export',_msg,4,B_PROC.ref())
                     ?};
                     ~~
                  || _msg:='Nie znaleziono elementu z zawartością MacroBASE w pliku: %1'@[_file];
                     exec('import_komm','#b_export',_msg,4,B_PROC.ref())
                  ?};
                  _tparse.cntx_pop()
               ?};
               ~~
            ?};
            ~~
         ?}
      ?};
      _tab.next()
   !};
   {? _progress>0
   || FUN.prg_stop()
   ?}
?};
{? _komm_init>0
|| KOMM.select()
?};
B_PROC.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\tparse_find_val
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Szuka wewnątrz tabelki _tparse elementu w drzewie
::   WE: _a - tab_tmp - tabelka
::       [_b] - ANY - nazwa rodzica lub jego ref
::       _c - STRING - szukana wartość elementu
::       [_d] - INTEGER - [1]/2 - czy zwrócić ref elementu czy jego rodzica
::   WY: ref() znalezionego elementu lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tparse:=_a;
_parent_name:='';
{? var_pres('_b')=type_of('')
|| _parent_name:=_b
?};
_parent_ref:=null();
{? var_pres('_b')=type_of(null())
|| _parent_ref:=_b
?};
_value:=_c;
_result_type:=1;
{? var_pres('_d')=type_of(0)
|| _result_type:=_d
?};
_result:=null();

_tparse.cntx_psh();
_ndx_name:=_tparse.ndx_tmp('',1,'NAME',,);
_ndx_val:=_tparse.ndx_tmp('',1,'VAL',,);
_ndx_tree:=_tparse.ndx_tmp('',1,'TREE',,,'VAL',,);
{? _parent_name<>''
|| _tparse.index(_ndx_name);
   _tparse.prefix(_parent_name,);
   {? _tparse.first()
   || {!
      |?
         _result:=exec('tparse_find_val','#b_export',_tparse,_tparse.ref(),_value,_result_type);
         _tparse.next() & _result=null()
      !}
   ?}
|? _parent_ref<>null()
|| _tparse.index(_ndx_tree);
   _tparse.prefix(_parent_ref,_value,);
   {? _tparse.first()
   || {? _result_type=1
      || _result:=_tparse.ref()
      |? _result_type=2
      || _tparse.cntx_psh(); _tparse.prefix();
         {? _tparse.seek(_tparse.TREE)
         || _result:=_tparse.ref()
         ?};
         _tparse.cntx_pop()
      ?}
   ?}
|| _tparse.index(_ndx_val);
   _tparse.prefix(_value,);
   {? _tparse.first()
   || {? _result_type=1
      || _result:=_tparse.ref()
      |? _result_type=2
      || _tparse.cntx_psh(); _tparse.prefix();
         {? _tparse.seek(_tparse.TREE)
         || _result:=_tparse.ref()
         ?};
         _tparse.cntx_pop()
      ?}
   ?}
?};
_tparse.ndx_drop(_ndx_name);
_tparse.ndx_drop(_ndx_val);
_tparse.ndx_drop(_ndx_tree);
_tparse.cntx_pop();
_result


\tparse_get_val
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Szuka wewnątrz tabelki _tparse elementu w drzewie
::   WE: _a - tab_tmp - tabelka
::       _b - ANY - nazwa rodzica lub jego ref
::       _c - STRING - szukana nazwa wewnątrz rodzica
::   WY: STRING - wartość o szukanej nazwie wewnątrz rodzica
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tparse:=_a;
_parent_name:='';
{? var_pres('_b')=type_of('')
|| _parent_name:=_b
?};
_parent_ref:=null();
{? var_pres('_b')=type_of(null())
|| _parent_ref:=_b
?};
{? var_pres('_b')=type_of(0)
|| _parent_ref:=_b
?};
_name:=_c;
_result:='';

_tparse.cntx_psh();
_ndx_name:=_tparse.ndx_tmp('',1,'NAME',,);
_ndx_tree:=_tparse.ndx_tmp('',1,'TREE',,,'NAME',,);
{? _parent_name<>''
|| _tparse.index(_ndx_name);
   _tparse.prefix(_parent_name,);
   {? _tparse.first()
   || {!
      |?
         _result:=exec('tparse_get_val','#b_export',_tparse,_tparse.ref(),_name);
         _tparse.next() & _result=''
      !}
   ?}
|? _parent_ref<>null()
|| _tparse.index(_ndx_tree);
   _tparse.prefix(_parent_ref,_name,);
   {? _tparse.first()
   || _result:=_tparse.VAL
   ?}
?};
_tparse.ndx_drop(_ndx_name);
_tparse.ndx_drop(_ndx_tree);
_tparse.cntx_pop();
_result


\graphmlz_unpack
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Rozpakowuje plik .graphmlz
::   WE: _a - STRING - ścieżka do pliku .graphmlz na serwerze
::       _b - STRING - ścieżka do katalogu na serwerze gdzie ma się znaleźć rozpakowany plik
::       _c - STRING - nazwa docelowego pliku
::   WY: STRING - ścieżka do pliku na serwerze lub '' jeżeli coś się nie udało
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_src:=_a;
_dest:=_b;
_can_continue:=1;
_result:='';
_sep_server:=exec('sep','#file',2);
_file_src:=fopen(_src,'br',0,,1);
_file_dst:=fopen(_dest,'bw',0,,1);

_can_continue:=base64('gunzip',_file_src,_file_dst);
{? _can_continue>0
|| _result:=_dest
?};
fclose(_file_src);
fclose(_file_dst);
_result


:Sign Version 2.0 jowisz:1045 2023/07/27 11:26:01 934d3ed6039a45ee36d6cf68ea16385dfba2724a8ca8a855a58f182ee3a1a038c293555b4a0a0222a7040c1097b90bf6e42e0b219b29f56d6ac9d84e9f33e0e2e9ba0088313ca09039ea4f1bc649a0e977ce9ec3171ecbe87f7ec4c918997e9175b18a514e8f37f0aac154e3d5311ea3212a52b3b9b4717152f1be0fcea5d04f
