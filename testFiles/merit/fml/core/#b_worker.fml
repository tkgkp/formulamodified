:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b_worker.fml [17.00]
:: Utworzony: 10.02.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa zarządcy kolejek - przetwarzanie w procesach CGI (tabele: B_WORKER, B_WRKHST)
::======================================================================================================================


\ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca ref kolejki o danym kodzie (w bieżącej firmie)
::   WE: _a - B_WORKER.KOD
::   WY: B_WORKER.ref()
::  TAG: <PROCES>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
B_WORKER.cntx_psh();
B_WORKER.index('KOD');
B_WORKER.prefix(REF.FIRMA,_a,);
{? B_WORKER.first() || _ref:=B_WORKER.ref() ?};
B_WORKER.cntx_pop();
_ref


\start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Wywołanie systemu z poziomu MacroCGI
::   WE: _a - identyfikator kolejki - B_WORKER.KOD
::       [_b] - interwał kolejki - B_WORKER.PAUZA (parametr uwzględniany, gdy zakładana jest nowa kolejka)
::       [_c] - czy kolejka techniczna [0]/1 -> B_WORKER.TECH (parametr uwzględniany, gdy zakładana jest nowa kolejka)
::  OLD: \cgi_start/skid_eml.fml
::  TAG: <PROCES>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('')
||
:: W przypadku błędnego parametru sekunda wstrzymania systemu przed wyjściem
   delay(1);
   return()
?};

:: Standardowy interwał 15 sekund
{? var_pres('_b')=type_of(0) || _pauza:=_b || _pauza:=15 ?};
:: Standardowa kolejka zwykła
{? var_pres('_c')=type_of(0) || _tech:=(_c<>0) || _tech:=0 ?};
exec('con_firm','#firma');
:: W przypadku braku kolejki jest ona inicjowana (opis nadany automatycznie)
B_WORKER.index('KOD');
REF.FIRMA:=exec('firma','#firma',exec('firma_symbol','#firma'));
B_WORKER.prefix(REF.FIRMA,_a,);
{? ~B_WORKER.first()
|| B_WORKER.blank();
   B_WORKER.KOD:=_a;
   B_WORKER.OPIS:=exec('worker_description','#b_worker',_a);
   B_WORKER.PAUZA:=_pauza;
   B_WORKER.TECH:={? _tech || 'T' || 'N' ?};
   B_WORKER.add(1)
?};

:: Właściwe przetwarzanie
exec('work','#b_worker',_a,0);
~~


\work
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.40]
:: OPIS: Przetwarza zdarzenia czasowe, zdarzenia warunkowe, zadania serwisowe i wysyła wiadomości
::   WE: _a - kod kolejki zadań - B_WORKER.KOD
::       [_b] - jeśli istnieje parametr _b=0 to od razu uruchamiamy przetwarzanie ciągłe
::       [_c] - obsługa pętli dla serwisu notyfikacyjnego (kolejka nie wykonuje innych akcji) 1/[0]
::   WY: 1 - ok, 0 - błąd przetwarzania (brak kolejki)
::  OLD: \em_work/skid_eml.fml
::  TAG: <PROCES>
::----------------------------------------------------------------------------------------------------------------------
exec('use','#b_worker');

B_WORKER.cntx_psh();
B_WORKER.index('KOD');
B_WORKER.prefix(REF.FIRMA,_a,);
{? ~B_WORKER.first()
|| FUN.error('Brak kolejki o identyfikatorze %1.'@[_a]);
   B_WORKER.cntx_pop();
   return(0)
?};

_abc_notify:=exec('notify_on','#notify');

:: Jeżeli spełnione warunki, uruchomienie usługi Qlik2Img
{? B_WORKER.FIRMA().SYMBOL='001' & B_WORKER.KOD='event'
|| exec('setParentProcessId','analizy_bi');
   _port:=exec('getPortQlik2Img','analizy_bi');
   {? _port>0
   || exec('runJQlik2Img','analizy_bi')
   ?}
?};

{? _>1 & _b=0
|| _loop:=2
|| _loop:=FUN.choice(
             'Czy program ma przetwarzać zadania z kolejki \'%1\'?\n\n'
             'Uwaga: przetwarzanie będzie można przerwać\n'
             'naciskając klawisz <Ctrl-Break> nieparzystą liczbę razy.'@[_a],,
             'Jednokrotnie'@,'Tryb ciągły'@)
?};
{? _loop=0
|| B_WORKER.cntx_pop();
   return(1)
?};

:: sprawdzamy czy nie ma żądania przerwania przetwarzania i je usuwamy, bo tutaj go nie powinno być
:: dodatkowo ustawiana informacja o tym, że uruchomienie nastąpiło po wymuszonym restarcie kolejki
_forced_restart:=0;
{? B_WORKER.get()
|| {? B_WORKER.STOP='T'
   || B_WORKER.STOP:='N';
      B_WORKER.put()
   |? B_WORKER.STOP='X'
   || B_WORKER.STOP:='N';
      _forced_restart:=1;
      B_WORKER.put()
   ?}
?};

_tryb:=B_WORKER.TRYB;
_pauza:=B_WORKER.PAUZA;
_aborted:=0;

_progress:=-1;

:: Zablokowanie kolejki
{? exec('blk_lock','#table','B_WORKER',B_WORKER.ref(),,1)
||
   {? var_pres('ECHO') < 0
   || exec('echo_decl','#b_worker');
      ECHO:=obj_new(@.CLASS.O_ECHO)
   ?};
   _progress:=ECHO.open();

:: Start odbierania notyfikacji
   {? _abc_notify=0 || ~~ || exec('delay','#notify',1) ?};

:: parametry - potem też czytane w pętli, aby uwzględnić zmiany podczas działania systemu
   _p100920:=exec('get','#params',100920,2);
   _p100921:=exec('get','#params',100921,2);
   _p100922:=exec('get','#params',100922,2);
   _p100923:=exec('get','#params',100923,2);
   _p100924:=exec('get','#params',100924,2);
   _p100925:=exec('get','#params',100925,2);
   _p100930:=exec('get','#params',100930,1);
   _p100931:=exec('get','#params',100931,2);
   _p100932:=exec('get','#params',100932,1);
   _p100933:=exec('get','#params',100933,1);
   _p100934:=exec('get','#params',100934,1);

:: logowanie startu przetwarzania
   {? _p100931='T' || exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_begin','#b_worker')) ?};
   exec('worker_act_info','#b_worker',exec('hist_type_begin','#b_worker'));
   exec('worker_act_info','#b_worker',exec('hist_type_pause','#b_worker'));

:: sprawdzenie limitu restartów kolejki
   {? B_WORKER.get() & _p100930>0 & B_WORKER.RESTARTS>_p100930
   || B_WORKER.ENABLED:='N';
      B_WORKER.put()
   ?};

:: ---------------------------------------------------------------------------------------------------------------------
:: Jeżeli kolejka techniczna, to wywołanie tylko zadań specjalnych - nie są realizowane elementy procesów
:: Tutaj miejsce na elementy do wykonania jednokrotnie po starcie kolejki
   {? B_WORKER.TECH='T'
   ||
::    Kolejka musi być włączona
      {? B_WORKER.get() & B_WORKER.ENABLED<>'N'
      || {? B_WORKER.S_IDTIME<>server_start_idtime()
         || B_WORKER.RESTARTS:=0;
            _forced_restart:=1;
            B_WORKER.put();
            _context:=2
         || _context:=1
         ?};
         {? ~_forced_restart & cli_ver()='cgi'
         || B_WORKER.RESTARTS+=1;
            B_WORKER.put()
         ?};
         __Worker.run(_context)
      ?}
   ||
::    refy elementów startowych
      _event_start_condition:=exec('event_start_condition','#b_worker');
      _event_start_timer:=exec('event_start_timer','#b_worker');

::    refy statusów (wykorzystywane w pętli po BI_PREL-ach
      _bi_stat:=obj_new(3);
      _bi_stat[1]:=exec('OCZEKUJACA','#bi_stat');
      _bi_stat[2]:=exec('FL_KEEP','#bi_stat');
      _bi_stat[3]:=exec('FL_CANCEL','#bi_stat');

::    Przywrócenie zdarzeń warunkowych startowych, w kórych został zgłoszony błąd formuły
      B_PREL.cntx_psh();
      B_PREL.index('B_WORKER');
      B_PREL.prefix(B_WORKER.ref(),'T','T',_event_start_condition);
      {? B_PREL.first()
      || {!
         |? {? B_PREL.ERROR='T'
            || B_PREL.ERROR:='N';
               B_PREL.put()
            ?};
            B_PREL.next()
         !}
      ?};
      B_PREL.cntx_pop();

      exec('worker_act_info','#b_worker');

::    Przetwarzanie na starcie kolejki.
::    Zakładamy, że w tym miejscu nie przerywamy przetwarzania zanim nie zostaną wykonane wszystkie zadania startowe.

:: B_PREL =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
::    Przetwarza zdarzenia czasowe startowe po restarcie serwera w zaakceptowanych i aktywnych procesach
::    Kolejka musi być włączona
      {? B_WORKER.get() & B_WORKER.ENABLED<>'N' & B_WORKER.S_IDTIME<>server_start_idtime()
      || B_WORKER.S_IDTIME:=server_start_idtime();
         B_WORKER.RESTARTS:=0;
         _forced_restart:=1;
         B_WORKER.put();

         _b_prel:=tab_tmp(,
            'REF','STRING[16]','$B_PREL.ref()',
            'ELEMENT','STRING[100]','B_PREL.SYMBOL',
            'PROCES','STRING[100]','B_PROC.SYMBOL',
            'HAS_INST','INTEGER','Czy ma instancje? (0/-1)'
         );

         B_TIMER.cntx_psh(); B_PREL.cntx_psh(); B_PROC.cntx_psh();
         B_TIMER.index('B_WORKER');
         B_TIMER.prefix(B_WORKER.ref(),'S',_event_start_timer);
         {? B_TIMER.first()
         || {!
            |? B_TIMER.B_PREL().B_PROC();
               _has_instances:=exec('has_instances','#b_proc',B_PROC.ref());
               {? B_TIMER.ON='T' & B_PROC.ACCEPTED='T' & B_PROC.ACTIVE='T' & (B_TIMER.SINGLE<>'T' | _has_instances<1)
               || _b_prel.REF:=$B_PREL.ref();
                  _b_prel.ELEMENT:=B_PREL.SYMBOL;
                  _b_prel.PROCES:=B_PROC.SYMBOL;
                  _b_prel.HAS_INST:=_has_instances;
                  _b_prel.add()
               ?};
               B_TIMER.next()
            !}
         ?};
         B_TIMER.cntx_pop(); B_PREL.cntx_pop(); B_PROC.cntx_pop();

         {? _b_prel.first()
         || {!
            |?
               {? _p100925='T'
               || ECHO.display(
                     'Uruchomiono w harmonogramie po starcie serwera element ''%1'' procesu ''%2''.'
                     [_b_prel.ELEMENT,_b_prel.PROCES]
                  )
               ?};
               exec('proMan','#b_proman',
                  exec('FindAndGet','#table',B_PREL,_b_prel.REF),'',,
                  {? _b_prel.HAS_INST<0 || 'Proc_force' || 'Proc' ?},
                  B_WORKER.ref()
               );
               _aborted+=transaction_aborted();
               _b_prel.next()
            !}
         ?};
         obj_del(_b_prel)
      ?};

      exec('worker_act_info','#b_worker');

:: B_PREL =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
::    Przetwarza zdarzenia czasowe startowe po restarcie kolejki w zaakceptowanych i aktywnych procesach
::    Kolejka musi być włączona
      {? B_WORKER.get() & B_WORKER.ENABLED<>'N'
      || {? ~_forced_restart & cli_ver()='cgi' || B_WORKER.RESTARTS+=1 ?};
         B_WORKER.put();

         _b_prel:=tab_tmp(,
            'REF','STRING[16]','$B_PREL.ref()',
            'ELEMENT','STRING[100]','B_PREL.SYMBOL',
            'PROCES','STRING[100]','B_PROC.SYMBOL',
            'HAS_INST','INTEGER','Czy ma instancje? (0/-1)'
         );

         B_TIMER.cntx_psh(); B_PREL.cntx_psh(); B_PROC.cntx_psh();
         B_TIMER.index('B_WORKER');
         B_TIMER.prefix(B_WORKER.ref(),'Q',_event_start_timer);
         {? B_TIMER.first()
         || {!
            |? B_TIMER.B_PREL().B_PROC();
               _has_instances:=exec('has_instances','#b_proc',B_PROC.ref());
               {? B_TIMER.ON='T' & B_PROC.ACCEPTED='T' & B_PROC.ACTIVE='T' & (B_TIMER.SINGLE<>'T' | _has_instances<1)
               || _b_prel.REF:=$B_PREL.ref();
                  _b_prel.ELEMENT:=B_PREL.SYMBOL;
                  _b_prel.PROCES:=B_PROC.SYMBOL;
                  _b_prel.HAS_INST:=_has_instances;
                  _b_prel.add()
               ?};
               B_TIMER.next()
            !}
         ?};
         B_TIMER.cntx_pop(); B_PREL.cntx_pop(); B_PROC.cntx_pop();

         {? _b_prel.first()
         || {!
            |?
               {? _p100925='T'
               || ECHO.display(
                     'Uruchomiono w harmonogramie po restarcie kolejki element ''%1'' procesu ''%2''.'
                     [_b_prel.ELEMENT,_b_prel.PROCES]
                  )
               ?};
               {? _p100931='T'
               || _hist:=exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_element','#b_worker'),_b_prel.REF)
               ?};
               exec('worker_act_info','#b_worker',exec('hist_type_element','#b_worker'),_b_prel.REF);
               exec('proMan','#b_proman',
                  exec('FindAndGet','#table',B_PREL,_b_prel.REF),'',,
                  {? _b_prel.HAS_INST<0 || 'Proc_force' || 'Proc' ?},
                  B_WORKER.ref()
               );
               _one_aborted:=transaction_aborted();
               {? _p100931='T' || exec('put_hist','#b_worker',_hist,_p100933,_one_aborted) ?};
               _aborted+=_one_aborted;
               _b_prel.next()
            !}
         ?};
         obj_del(_b_prel)
      ?};

      exec('worker_act_info','#b_worker')
   ?};

:: -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
:: Przetwarzanie wszystkiego w pętli nieskończonej - wyjście tylko przez return()
   B_HARM.cntx_psh(); BI_PREL.cntx_psh();
   _args:=obj_new('time_proc');
   {!
   |?
::    początek bieżącego obrotu pętli
      _tm_start:=utc_get();
::    czas uruchomienia pętli
      _tm_run:=0;
      _sec_wait:=0;
::    czas przetwarzania pętli
      _tm_proc:=0;

::    sprawdzamy czy nie ma żądania przerwania przetwarzania
      {? B_WORKER.get()
      || {? B_WORKER.STOP='T'
         || B_WORKER.STOP:='X';
            B_WORKER.put();
            exec('worker_act_info','#b_worker',exec('hist_type_break','#b_worker'));
            B_WORKER.cntx_pop();
            B_HARM.cntx_pop();
            BI_PREL.cntx_pop();
            ECHO.close();
            FUN.info('Przetwarzanie przerwano.'@);
            {? _p100931='T'
            || exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_end','#b_worker'))
            ?};
            return()
         ?}
      ?};

      exec('worker_act_info','#b_worker');

::    parametry - czytane w pętli, aby uwzględnić zmiany podczas działania systemu
      _p100920:=exec('get','#params',100920,2);
      _p100921:=exec('get','#params',100921,2);
      _p100922:=exec('get','#params',100922,2);
      _p100923:=exec('get','#params',100923,2);
      _p100924:=exec('get','#params',100924,2);
      _p100925:=exec('get','#params',100925,2);
      _p100930:=exec('get','#params',100930,1);
      _p100931:=exec('get','#params',100931,2);
      _p100932:=exec('get','#params',100932,1);
      _p100933:=exec('get','#params',100933,1);
      _p100934:=exec('get','#params',100934,1);

::    usuwanie historii kolejki
      exec('del_hist','#b_worker',B_WORKER.ref(),_p100932);

::    Kolejka musi być włączona
      {? B_WORKER.ENABLED<>'N'
      ||
:: analiza listy todo =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
         {? exec('notify_on','#bi_todo') || exec('notify','#bi_todo') ?};

         exec('worker_act_info','#b_worker');

:: ---------------------------------------------------------------------------------------------------------------------
:: Jeżeli kolejka techniczna, to wywołanie tylko zadań specjalnych - nie są realizowane elementy procesów
:: Tutaj miejsce na elementy do wykonania w pętli
         {? B_WORKER.TECH='T'
         || __Worker.run(0)
         ||

:: B_PREL =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
::          Przetwarza zdarzenia czasowe startowe w każdej pętli przetwarzania w zaakceptowanych i aktywnych procesach
            _b_prel:=tab_tmp(,
               'REF','STRING[16]','$B_PREL.ref()',
               'ELEMENT','STRING[100]','B_PREL.SYMBOL',
               'PROCES','STRING[100]','B_PROC.SYMBOL',
               'HAS_INST','INTEGER','Czy ma instancje? (0,-1)'
            );

            B_TIMER.cntx_psh(); B_PREL.cntx_psh(); B_PROC.cntx_psh();
            B_TIMER.index('B_WORKER');
            B_TIMER.prefix(B_WORKER.ref(),'O',_event_start_timer);
            {? B_TIMER.first()
            || {!
               |? B_TIMER.B_PREL().B_PROC();
                  _has_instances:=exec('has_instances','#b_proc',B_PROC.ref());
                  {? B_TIMER.ON='T' & B_PROC.ACCEPTED='T' & B_PROC.ACTIVE='T' & (B_TIMER.SINGLE<>'T' | _has_instances<1)
                  || _b_prel.REF:=$B_PREL.ref();
                     _b_prel.ELEMENT:=B_PREL.SYMBOL;
                     _b_prel.PROCES:=B_PROC.SYMBOL;
                     _b_prel.HAS_INST:=_has_instances;
                     _b_prel.add()
                  ?};
                  B_TIMER.next()
               !}
            ?};
            B_TIMER.cntx_pop(); B_PREL.cntx_pop(); B_PROC.cntx_pop();

            {? _b_prel.first()
            || {!
               |?
                  {? _p100925='T'
                  || ECHO.display(
                        'Uruchomiono w harmonogramie element ''%1'' procesu ''%2''.'
                        [_b_prel.ELEMENT,_b_prel.PROCES]
                     )
                  ?};
                  {? _p100931='T'
                  || _hist:=exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_element','#b_worker'),_b_prel.REF)
                  ?};
                  exec('worker_act_info','#b_worker',exec('hist_type_element','#b_worker'),_b_prel.REF);
                  exec('proMan','#b_proman',
                     exec('FindAndGet','#table',B_PREL,_b_prel.REF),'',,
                     {? _b_prel.HAS_INST<0 || 'Proc_force' || 'Proc' ?},
                     B_WORKER.ref()
                  );
                  _one_aborted:=transaction_aborted();
                  {? _p100931='T' || exec('put_hist','#b_worker',_hist,_p100933,_one_aborted) ?};
                  _aborted+=_one_aborted;
                  _b_prel.next()
               !}
            ?};
            obj_del(_b_prel);

            exec('worker_act_info','#b_worker');

:: B_PREL =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
::          Przetwarza zdarzenia warunkowe startowe w zaakceptowanych i aktywnych procesach
            _b_prel:=tab_tmp(,
               'REF','STRING[16]','$B_PREL.ref()',
               'ELEMENT','STRING[100]','B_PREL.SYMBOL',
               'PROCES','STRING[100]','B_PROC.SYMBOL'
            );

            B_PREL.cntx_psh(); B_PROC.cntx_psh();
            B_PREL.index('B_WORKER');
            B_PREL.prefix(B_WORKER.ref(),'T','T',_event_start_condition);
            {? B_PREL.first()
            || {!
               |? {? B_PREL.ERROR='N'
                  || _b_prel.REF:=$B_PREL.ref();
                     _b_prel.ELEMENT:=B_PREL.SYMBOL;
                     _b_prel.PROCES:=B_PREL.B_PROC().SYMBOL;
                     _b_prel.add()
                  ?};
                  B_PREL.next()
               !}
            ?};
            B_PREL.cntx_pop(); B_PROC.cntx_pop();

            {? _b_prel.first()
            || {!
               |?
::                tu też sprawdzamy czy nie ma żądania przerwania przetwarzania
                  {? B_WORKER.get()
                  || {? B_WORKER.STOP='T'
                     || B_WORKER.STOP:='X';
                        B_WORKER.put();
                        exec('worker_act_info','#b_worker',exec('hist_type_break','#b_worker'));
                        B_WORKER.cntx_pop();
                        B_HARM.cntx_pop();
                        BI_PREL.cntx_pop();
                        ECHO.close();
                        FUN.info('Przetwarzanie przerwano.'@);
                        {? _p100931='T'
                        || exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_end','#b_worker'))
                        ?};
                        return()
                     ?}
                  ?};

                  _tm_stamp:=utc_get();
                  exec('FindAndGet','#table',B_PREL,_b_prel.REF,,"COUNTER+=1;put()");
                  {? _p100931='T'
                  || _hist:=exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_element','#b_worker'),_b_prel.REF)
                  ?};
                  exec('worker_act_info','#b_worker',exec('hist_type_element','#b_worker'),_b_prel.REF);
                  _out:=exec('obj_ntab_set','#array',,'OUT',~~);
                  params_set('in',~~,'int',~~,'out',_out);
                  _result:=exec('run_condition','#b_econd',_b_prel.REF);
                  _one_aborted:=transaction_aborted();
                  {? _p100931='T' || exec('put_hist','#b_worker',_hist,_p100933,_one_aborted) ?};
                  _aborted+=_one_aborted;
                  _tm_one:=utc_get()-_tm_stamp;
                  _tm_proc+=_tm_one;
                  _args.time_proc:=_tm_one;
                  _formula:="
                     _args:=_b;
                     TIMEPROC:=_args.time_proc;
                     TSUMPROC+=_args.time_proc;
                     TAVGPROC:=TSUMPROC/COUNTER;
                     put()
                  ";
                  exec('FindAndGet','#table',B_PREL,_b_prel.REF,,_formula,,_args);

                  {? _result.OK=1 & _result.RES>0
                  || {? _p100921='T'
                     || ECHO.display(
                           'Uruchomiono zdarzenie warunkowe startowe ''%1'' procesu ''%2''.'
                           [_b_prel.ELEMENT,_b_prel.PROCES]
                        )
                     ?};
                     _tm_stamp:=utc_get();
                     {? _p100931='T'
                     || _hist:=exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_element','#b_worker'),_b_prel.REF)
                     ?};
                     exec('worker_act_info','#b_worker',exec('hist_type_element','#b_worker'),_b_prel.REF);
                     exec('proMan','#b_proman',
                        exec('FindAndGet','#table',B_PREL,_b_prel.REF),'',,'Proc',B_WORKER.ref(),,,,_out.OUT
                     );
                     _one_aborted:=transaction_aborted();
                     {? _p100931='T' || exec('put_hist','#b_worker',_hist,_p100933,_one_aborted) ?};
                     _aborted+=_one_aborted;
                     _tm_one:=utc_get()-_tm_stamp;
                     _tm_proc+=_tm_one;
                     _args.time_proc:=_tm_one;
                     _formula:="
                        _args:=_b;
                        TIMEPROC:=_args.time_proc;
                        TSUMPROC+=_args.time_proc;
                        TAVGPROC:=TSUMPROC/COUNTER;
                        put()
                     ";
                     exec('FindAndGet','#table',B_PREL,_b_prel.REF,,_formula,,_args)
                  |? _result.OK=-1
                  || {? _p100922='T'
                     || ECHO.display(
                           'Błąd interpretacji formuły dla zdarzenia warunkowego startowego ''%1'' procesu ''%2''.'
                           [_b_prel.ELEMENT,_b_prel.PROCES]
                        )
                     ?};
                     exec('FindAndGet','#table',B_PREL,_b_prel.REF,,"ERROR:='T';put()")
                  |? _result.OK=-2
                  || {? _p100922='T'
                     || ECHO.display(_result.RES)
                     ?};
                     exec('FindAndGet','#table',B_PREL,_b_prel.REF,,"ERROR:='T';put()")
                  |? _result.OK=-3
                  || {? _p100922='T'
                     || ECHO.display(
                           'Błędny typ wyniku formuły dla zdarzenia warunkowego startowego ''%1'' procesu ''%2''.'
                           [_b_prel.ELEMENT,_b_prel.PROCES]
                        )
                     ?};
                     exec('FindAndGet','#table',B_PREL,_b_prel.REF,,"ERROR:='T';put()")
                  |? _result.OK=-4
                  || {? _p100922='T'
                     || ECHO.display(
                           'Błędna wartość wejściowego parametru złączeniowego dla zdarzenia warunkowego startowego ''%1'' procesu ''%2''.'
                           [_b_prel.ELEMENT,_b_prel.PROCES]
                        )
                     ?};
                     exec('FindAndGet','#table',B_PREL,_b_prel.REF,,"ERROR:='T';put()")
                  ?};
                  obj_del(_result);
                  obj_del(_out);
                  _b_prel.next()
               !}
            ?};
            obj_del(_b_prel);

            exec('worker_act_info','#b_worker');

::-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

:: B_HARM =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
::          Przetworzenie harmonogramu zdarzeń
            B_HARM.index('WORK_DT');
            B_HARM.prefix(B_WORKER.ref());
            {? B_HARM.first() & B_HARM.TM_STAMP<=B_HARM.tm_stamp()
            || {!
               |?
::                tu też sprawdzamy czy nie ma żądania przerwania przetwarzania
                  {? B_WORKER.get()
                  || {? B_WORKER.STOP='T'
                     || B_WORKER.STOP:='X';
                        B_WORKER.put();
                        exec('worker_act_info','#b_worker',exec('hist_type_break','#b_worker'));
                        B_WORKER.cntx_pop();
                        B_HARM.cntx_pop();
                        BI_PREL.cntx_pop();
                        ECHO.close();
                        FUN.info('Przetwarzanie przerwano.'@);
                        {? _p100931='T'
                        || exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_end','#b_worker'))
                        ?};
                        return()
                     ?}
                  ?};

                  {? _p100925='T'
                  || ECHO.display('Uruchomiono w harmonogramie element ''%1'' procesu ''%2''.'
                        [B_HARM.B_PREL().SYMBOL,B_HARM.B_PROC().SYMBOL])
                  ?};
                  _tm_stamp:=utc_get();
                  {? _p100931='T'
                  || _hist:=exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_element','#b_worker'),
                        {? B_HARM.B_PREL || B_HARM.B_PREL || B_HARM.BI_PREL ?}
                     )
                  ?};
                  exec('worker_act_info','#b_worker',exec('hist_type_element','#b_worker'),
                     {? B_HARM.B_PREL || B_HARM.B_PREL || B_HARM.BI_PREL ?}
                  );
                  exec('run','#b_harm',B_HARM.ref(),0);
                  _one_aborted:=transaction_aborted();
                  {? _p100931='T' || exec('put_hist','#b_worker',_hist,_p100933,_one_aborted) ?};
                  _aborted+=_one_aborted;
                  _tm_proc+=utc_get()-_tm_stamp;
                  B_HARM.next() & B_HARM.TM_STAMP<=B_HARM.tm_stamp()
               !}
            ?};

            exec('worker_act_info','#b_worker');

::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

:: BI_PREL =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            {!
            |?
::             Przetwarza oczekujące oraz przerwane elementy procesu:
::             - czynności usługowe
::             - zdarzenia warunkowe pośrednie
::             - zdarzenia czasowe startowe

               _bi_prel:=tab_tmp(,
                  'TM_BORN','REAL','BI_PREL.TM_BORN',
                  'REF','STRING[16]','$BI_PREL.ref()',
                  'ELEMENT','STRING[100]','B_PREL.SYMBOL',
                  'PROCES','STRING[100]','B_PROC.SYMBOL',
                  'CLASS','STRING[30]','B_PREL.CLASS',
                  'B_ELE','STRING[16]','$B_ELE.ref()'
               );

               BI_PREL.cntx_psh(); B_PREL.cntx_psh(); B_PROC.cntx_psh();
               BI_PREL.index('WORKER');
               {! _it:=1..3
               |! BI_PREL.prefix(B_WORKER.ref(),_bi_stat[_it]);
                  {? BI_PREL.first()
                  || {!
                     |? {? BI_PREL.C_DELAY=0
                        || _bi_prel.TM_BORN:=BI_PREL.TM_BORN;
                           _bi_prel.REF:=$BI_PREL.ref();
                           _bi_prel.ELEMENT:=BI_PREL.B_PREL().SYMBOL;
                           _bi_prel.PROCES:=B_PREL.B_PROC().SYMBOL;
                           _bi_prel.CLASS:=B_PREL.CLASS;
                           _bi_prel.B_ELE:=$B_PREL.B_ELE;
                           _bi_prel.add()
                        ?};
                        BI_PREL.next()
                     !}
                  ?}
               !};
               BI_PREL.cntx_pop(); B_PREL.cntx_pop(); B_PROC.cntx_pop();

               {? _bi_prel.first()
               || {!
                  |?
::                   tu też sprawdzamy czy nie ma żądania przerwania przetwarzania
                     {? B_WORKER.get()
                     || {? B_WORKER.STOP='T'
                        || B_WORKER.STOP:='X';
                           B_WORKER.put();
                           exec('worker_act_info','#b_worker',exec('hist_type_break','#b_worker'));
                           B_WORKER.cntx_pop();
                           B_HARM.cntx_pop();
                           BI_PREL.cntx_pop();
                           ECHO.close();
                           FUN.info('Przetwarzanie przerwano.'@);
                           {? _p100931='T'
                           || exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_end','#b_worker'))
                           ?};
                           return()
                        ?}
                     ?};

                     BI_PREL.cntx_psh(); {? BI_PREL.name()='' || BI_PREL.use('bi_e____') ?};
                     BI_PREL.index('UID'); BI_PREL.prefix();
                     {? BI_PREL.seek(_bi_prel.REF)
                     ||
::                      Ponowne sprawdzenie statusu, który mógł się zmienić od chwili pobrania elementów
                        {? BI_PREL.BI_STAT=_bi_stat[1] |
                           BI_PREL.BI_STAT=_bi_stat[2] |
                           BI_PREL.BI_STAT=_bi_stat[3]
                        ||
                           BI_PREL.COUNTER+=1;
                           BI_PREL.put();

                           _b_ele:=exec('FindAndGet','#table',B_ELE,_bi_prel.B_ELE);

                           {? _bi_prel.CLASS='B_ACTION' & _p100924='T'
                           || ECHO.display(
                                 'Uruchomiono czynność usługową ''%1'' procesu ''%2''.'
                                 [_bi_prel.ELEMENT,_bi_prel.PROCES]
                              )
                           |? _bi_prel.CLASS='B_EVENT' & _p100923='T'
                              & exec('is_event','#b_event',_b_ele,exec('type_intermed','#b_event'),exec('kind_condition','#b_event'))
                           || ECHO.display(
                                 'Uruchomiono zdarzenie warunkowe pośrednie ''%1'' procesu ''%2''.'
                                 [_bi_prel.ELEMENT,_bi_prel.PROCES]
                              )
                           |? _bi_prel.CLASS='B_EVENT' & _p100925='T'
                              & exec('is_event','#b_event',_b_ele,exec('type_start','#b_event'),exec('kind_timer','#b_event'))
                           || ECHO.display(
                                 'Uruchomiono zdarzenie czasowe startowe ''%1'' procesu ''%2''.'
                                 [_bi_prel.ELEMENT,_bi_prel.PROCES]
                              )
                           |? _bi_prel.CLASS<>'B_GATE' & _bi_prel.CLASS<>'B_EVENT' & _bi_prel.CLASS<>'B_ACTION'
                           || ECHO.display(
                                 'Uruchomiono nieznany element (%1) ''%2'' procesu ''%3''.'
                                 [_bi_prel.CLASS,_bi_prel.ELEMENT,_bi_prel.PROCES]
                              )
                           ?};

                           {? _p100931='T'
                           || _hist:=exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_element','#b_worker'),_bi_prel.REF)
                           ?};
                           exec('worker_act_info','#b_worker',exec('hist_type_element','#b_worker'),_bi_prel.REF);
                           _tm_stamp:=utc_get();
                           exec('proMan','#b_proman',BI_PREL.ref(),'',,'Proc',B_WORKER.ref());
                           _tm_one:=utc_get()-_tm_stamp;
                           _one_aborted:=transaction_aborted();
                           {? _p100931='T' || exec('put_hist','#b_worker',_hist,_p100933,_one_aborted) ?};
                           _aborted+=_one_aborted;
                           _tm_proc+=_tm_one;
                           _args.time_proc:=_tm_one;
                           _formula:="
                              _args:=_b;
                              TIMEPROC:=_args.time_proc;
                              TSUMPROC+=_args.time_proc;
                              TAVGPROC:=TSUMPROC/COUNTER;
                              put()
                           ";
                           exec('FindAndGet','#table',BI_PREL,_bi_prel.REF,,_formula,,_args)
                        ?}
                     ?};
                     BI_PREL.cntx_pop();

                     _bi_prel.next()
                  !}
               ?};
               obj_del(_bi_prel);

::          Jeżeli potencjalnie starczy czasu, to następuje powrót i ponowne podebranie zadań
::          (całość zajmie conajmniej 15 sekund)
               delay(1); _sec_wait+=1;
               exec('worker_act_info','#b_worker');
               utc_get()<_tm_start+15
            !}
::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
         ?}
      ?};

      exec('worker_act_info','#b_worker');

      _tm_run:=utc_get()-_tm_start;

      {? B_WORKER.get()
      ||
::       Czas przetwarzania i uruchomienia w ostatnim obrocie pętli
         B_WORKER.TIMEPROC:=_tm_proc;
         {? B_WORKER.TIMEPROC>B_WORKER.TMAXPROC || B_WORKER.TMAXPROC:=B_WORKER.TIMEPROC ?};
         B_WORKER.TIMERUN:=_tm_run-_sec_wait;
         {? B_WORKER.TIMERUN>B_WORKER.TMAXRUN || B_WORKER.TMAXRUN:=B_WORKER.TIMERUN ?};
::       Liczba wycofanych transakcji
         {? _aborted>0 || B_WORKER.ABORTED+=_aborted; _aborted:=0 ?};
::       Sprawdzenie limitu wycofanych transakcji
         {? _p100934>0 & B_WORKER.ABORTED>_p100934 || B_WORKER.ENABLED:='N' ?};
         B_WORKER.put()
      ?};

::    Wyznaczenie _delay w zalezności od trybu przetwarzania
      {? _tryb=1
::    Stała długość cyklu przetwarzania
      || _delay:=_pauza-_tm_run;
         {? _delay<1 || _delay:=1 ?}
::    Stała pauza między cyklami przetwarzania
      || _delay:=_pauza
      ?};

      {? _p100920='T' | cli_ver()<>'cgi'
      || _progress:=ECHO.display('Pauza: %1 [s]'[$_delay])
      || _progress:=-1
      ?};
      exec('worker_act_info','#b_worker');
      {? _progress<>-1
      || {? FUN.ask('Czy chcesz przerwać przetwarzanie?'@)
         || ECHO.close();
            FUN.info('Przetwarzanie przerwano.'@);
            {? _p100931='T' || exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_end','#b_worker')) ?};
            exec('worker_act_info','#b_worker',exec('hist_type_break','#b_worker'));
            0
         || exec('worker_act_info','#b_worker',exec('hist_type_pause','#b_worker'));
            {? _abc_notify=0 || delay(_delay) || exec('delay','#notify',_delay) ?};
            exec('worker_act_info','#b_worker');
            1
         ?}
      ||
         {? _loop=2
         || {? escape()
            || ECHO.close();
               FUN.info('Przetwarzanie przerwano.'@);
               {? _p100931='T' || exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_end','#b_worker')) ?};
               exec('worker_act_info','#b_worker',exec('hist_type_break','#b_worker'));
               0
            || exec('worker_act_info','#b_worker',exec('hist_type_pause','#b_worker'));
               {? _abc_notify=0 || delay(_delay) || exec('delay','#notify',_delay) ?};
               exec('worker_act_info','#b_worker');
               1
            ?}
         || ECHO.close();
            FUN.info('Przetwarzanie zakończono.'@);
            {? _p100931='T' || exec('add_hist','#b_worker',B_WORKER.ref(),exec('hist_type_end','#b_worker')) ?};
            exec('worker_act_info','#b_worker',exec('hist_type_end','#b_worker'));
            0
         ?}
      ?}
   !};
   B_HARM.cntx_pop(); BI_PREL.cntx_pop();

   exec('blk_unlock','#table','B_WORKER',B_WORKER.ref())

|| exec('ses_info','#b_worker',1)
?};

B_WORKER.cntx_pop();
1


\echo_decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: Deklaracja klasy do wyświetlania komunikatów
::  OLD: \echo_decl/skid_eml.fml
::  TAG: <PROCES>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('O_ECHO', @.CLASS) < 0
||
   obj_decl('O_ECHO',

      obj_meth('__init',"
         {? cli_ver()='cgi'
         ||
            -1
         ||
            prgs_clr();
            progress(,'~#'+form('',100),FUN.TYT,1,,,,'Przerwij'@)
         ?}
      "),

      obj_meth('__done',"
         .close()
      "),

      obj_meth('open',"
         .display('Zainicjowano przetwarzanie.'@)
      "),

      obj_meth('display',"
         {? cli_ver()='cgi'
         ||
            msg('[%1 %2] %3\n'[$date(),time()$3,_a]);
            -1
         ||
            progress(,'~#'+form((gsub(_a,'\n',' ')),100),FUN.TYT,1,,,,'Przerwij'@)
         ?}
      ", type_of('') ),

      obj_meth('close',"
         prgs_clr()
      ")
   )
?};
~~


\bi_prel_wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Definiuje okno BI_PREL dla selektora kolejek
::----------------------------------------------------------------------------------------------------------------------
_wer:=BI_PREL.mk_sel('Elementy oczekujące w kolejce'@,'P',,'biprelsel',,,,,'U');
BI_PREL.win_fld(_wer,VAR,'STRING',,,50,,,'Proces'@);
BI_PREL.win_fld(_wer,VAR,'STRING2',,,6,,,'Wersja'@);
BI_PREL.win_fld(_wer,VAR,'STRING3',,,49,,,'Element'@);
::BI_PREL.win_fld(_wer,,'COUNTER',,,-8,0);
::BI_PREL.win_fld(_wer,,'TIMEPROC',,,-8,4);
::BI_PREL.win_fld(_wer,,'TAVGPROC',,,-8,4);
_fb:="
   exec('select1','#bi_inst',BI_PROC.ref(),BI_PREL.ref());
   ~~
";
BI_PREL.win_act(_wer,,'Formuła','Podgląd &elementów procesu'@@,,,_fb,,,,,,'E');
_fb:="
   exec('select4biproc_alt','#b_design',BI_PROC.ref(),B_PREL.ref(),'bi_proc_todo');
   ~~
";
BI_PREL.win_act(_wer,,'Formuła','Pod&gląd procesu'@@,,,_fb,,,,,,'G');
_fb:="
   {? BI_PREL.sel_size()>0 | FUN.ask('Czy wyzerować liczniki?'@)
   || {? BI_PREL.get()
      || BI_PREL.COUNTER:=BI_PREL.TIMEPROC:=BI_PREL.TSUMPROC:=BI_PREL.TAVGPROC:=0;
         BI_PREL.put()
      ?}
   ?};
   ~~
";
_fbg:="
   FUN.ask('Czy wyzerować liczniki zaznacznonych czynności i zdarzeń?'@)
";
BI_PREL.win_act(_wer,,'Formuła','Zeruj liczniki'@@,,,_fb,,,1,_fbg,,'Z');

_fb:="
   exec('change_worker_act','#b_worker')
";
_gr1:="exec('change_worker_gr1','#b_worker')";
_gr2:="exec('change_worker_gr2','#b_worker')";
BI_PREL.win_act(_wer,,'Formuła','Z&mień kolejkę'@@,,,_fb,,,1,_gr1,_gr2,'M');

BI_PREL.win_act(_wer,,'Kolejność');
_fb:="
   VAR.STRING:=BI_PREL.BI_PROC().B_PROC().SYMBOL;
   VAR.STRING2:=B_PROC.VER;
   VAR.STRING3:=BI_PREL.B_PREL().SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']';
   ~~
";
BI_PREL.win_act(_wer,,'Rekord',,,,_fb);
_fb:="
   {? B_PREL.CLASS='B_ACTION'
   || _red:=BI_PREL.mk_edit('Czynność usługowa'@,,'act_srv');
      BI_PREL.win_esep(_red,'Proces'@);
      BI_PREL.win_efld(_red,B_PROC,'SYMBOL',,,100);
      BI_PREL.win_efld(_red,B_PROC,'VER',,,100);
      BI_PREL.win_esep(_red,'Czynność'@);
      BI_PREL.win_efld(_red,B_PREL,'B_ELE','SYMBOL',,100);
      BI_PREL.win_efld(_red,B_PREL,'SYMBOL',,,100,,,'Nazwa'@);
      BI_PREL.win_edit(_red);
      BI_PREL.display()
   |? B_PREL.CLASS='B_EVENT'
   || _red:=BI_PREL.mk_edit('Zdarzenie pośrednie warunkowe'@,,'event_condition');
      BI_PREL.win_esep(_red,'Proces'@);
      BI_PREL.win_efld(_red,B_PROC,'SYMBOL',,,100);
      BI_PREL.win_efld(_red,B_PROC,'VER',,,100);
      BI_PREL.win_esep(_red,'Zdarzenie'@);
      BI_PREL.win_efld(_red,B_PREL,'SYMBOL',,,100,,,'Nazwa'@);
      BI_PREL.win_efld(_red,B_PREL,'FCOND',,,100,,,'Formuła warunku'@);
      BI_PREL.win_edit(_red);
      BI_PREL.display()
   ?};
   ~~
";
BI_PREL.win_act(_wer,,'Wyświetl',,,,_fb);



_wer


\event_start_condition
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca ref() elementu będącego zdarzeniem warunkowym startowym
::   WY: B_ELE.ref()
::----------------------------------------------------------------------------------------------------------------------
_b_ele:=null();
B_EVENT.index('TYP');
B_EVENT.prefix(exec('type_start','#b_event'),exec('kind_condition','#b_event'),exec('category_catch','#b_event'));
{? B_EVENT.first()
|| _b_ele:=B_EVENT.B_ELE
?};
_b_ele


\b_prel_wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Definiuje okno B_PREL dla selektora kolejek
::----------------------------------------------------------------------------------------------------------------------
_wer:=B_PREL.mk_sel('Elementy startowe w kolejce'@,'P',,'bprelsel',,,,,'U');
B_PREL.win_fld(_wer,VAR,'STRING',,,50,,,'Proces'@);
B_PREL.win_fld(_wer,VAR,'STRING2',,,6,,,'Wersja'@);
B_PREL.win_fld(_wer,VAR,'STRING3',,,49,,,'Element'@);
::B_PREL.win_fld(_wer,,'COUNTER',,,-8,0);
::B_PREL.win_fld(_wer,,'TIMEPROC',,,-8,4);
::B_PREL.win_fld(_wer,,'TAVGPROC',,,-8,4);
_fb:="
   exec('select4proc','#b_design',B_PROC.ref(),0,B_PREL.ref());
   ~~
";
B_PREL.win_act(_wer,,'Formuła','Pod&gląd procesu'@@,,,_fb,,,,,,'G');
_fb:="
   {? B_PREL.sel_size()>0
   || {? B_PREL.ERROR='T'
      || B_PREL.ERROR:='N';
         B_PREL.put()
      ?}
   || {? B_PREL.ERROR='T'
      || {? FUN.ask('Czy przywrócić zdarzenie na którym został zgłoszony błąd?'@)
         || B_PREL.ERROR:='N';
            B_PREL.put()
         ?}
      || FUN.info('Na zdarzeniu nie został zgłoszony błąd.'@)
      ?}
   ?}
";
_fbg:="
   FUN.ask('Czy przywrócić zaznaczone zdarzenia?'@)
";
B_PREL.win_act(_wer,,'Formuła','Przywróć'@@,,'Przywraca zdarzenie, na którym został zgłoszony błąd.'@,_fb,,,1,_fbg,,'P');
_fb:="
   {? B_PREL.sel_size()>0 | FUN.ask('Czy wyzerować liczniki?'@)
   || B_PREL.COUNTER:=B_PREL.TIMEPROC:=B_PREL.TSUMPROC:=B_PREL.TAVGPROC:=0;
      B_PREL.put()
   ?};
   ~~
";
_fbg:="
   FUN.ask('Czy wyzerować liczniki zaznaczonych zdarzeń?'@)
";
B_PREL.win_act(_wer,,'Formuła','Zeruj liczniki'@@,,,_fb,,,1,_fbg,,'Z');

_fb:="
   exec('change_worker_act','#b_worker')
";
_gr1:="exec('change_worker_gr1','#b_worker')";
_gr2:="exec('change_worker_gr2','#b_worker')";
B_PREL.win_act(_wer,,'Formuła','Z&mień kolejkę'@@,,,_fb,,,1,_gr1,_gr2,'M');

B_PREL.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','B_PREL#01')",,,,,,'L');
B_PREL.win_act(_wer,,'Kolejność');
_fb:="
   VAR.STRING:=B_PREL.B_PROC().SYMBOL;
   VAR.STRING2:=B_PROC.VER;
   VAR.STRING3:=B_PREL.SYMBOL+' ['+B_PREL.B_ELE().SYMBOL+']';
   ~~
";
B_PREL.win_act(_wer,,'Rekord',,,,_fb);
B_PREL.win_fml(_wer,VAR,'STRING3',,'ICON_BEFORE',"{? B_PREL.ERROR='T' || 'xwin16.png:3' || exec('pusta','#icon') ?}");
_fb:="
   {? B_PREL.CLASS='B_EVENT'
   || _red:=B_PREL.mk_edit('Zdarzenie startowe warunkowe'@,,'event_condition');
      B_PREL.win_esep(_red,'Proces'@);
      B_PREL.win_efld(_red,B_PROC,'SYMBOL',,,100);
      B_PREL.win_efld(_red,B_PROC,'VER',,,100);
      B_PREL.win_esep(_red,'Zdarzenie'@);
      B_PREL.win_efld(_red,B_PREL,'SYMBOL',,,100,,,'Nazwa'@);
      B_PREL.win_efld(_red,B_PREL,'FCOND',,,100,,,'Formuła warunku'@);
      B_PREL.win_edit(_red);
      B_PREL.display()
   ?};
   ~~
";
B_PREL.win_act(_wer,,'Wyświetl',,,,_fb);
_wer


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Redagowanie kolejek
::  OLD: \aquee/skid_eml.fml
::  TAG: <PROCES><LISTA>
::----------------------------------------------------------------------------------------------------------------------
exec('use','#b_worker');

_env:=obj_new(
   'WER_B_HARM',
   'WER_BI_PREL',
   'WER_B_PREL',
   'EVENT_START_CONDITION'
);

_env.WER_B_HARM:='WERW';
_env.WER_BI_PREL:=exec('bi_prel_wer','#b_worker');
_env.WER_B_PREL:=exec('b_prel_wer','#b_worker');
_env.EVENT_START_CONDITION:=exec('event_start_condition','#b_worker');

params_set('env',_env);

_grp:=B_WORKER.grp_make('Kolejki'@,,'pocztaqgrp');
_ar:="
   _env:=params_get().env;
   B_HARM.index('WORK_DT');
   B_HARM.prefix(B_WORKER.ref());
   grp_disp(B_HARM,_env.WER_B_HARM);
   BI_PREL.index('WORKER');
   BI_PREL.prefix(B_WORKER.ref(),exec('OCZEKUJACA','#bi_stat'));
   grp_disp(BI_PREL,_env.WER_BI_PREL);
   B_PREL.index('B_WORKER');
   B_PREL.prefix(B_WORKER.ref(),'T','T',_env.EVENT_START_CONDITION);
   grp_disp(B_PREL,_env.WER_B_PREL);
   ~~
";
B_WORKER.grp_sel(_grp,,'WER',,_ar,,,,,,,,'maximized');
B_WORKER.grp_splt(_grp,,'vertical','b_harm');
B_WORKER.grp_sel(_grp,B_HARM,_env.WER_B_HARM,'Harmonogram zdarzeń dla kolejki'@,,,,8,,,,,'maximized');
B_WORKER.grp_splt(_grp,'b_harm','horizontal','bi_prel');
B_WORKER.grp_sel(_grp,BI_PREL,_env.WER_BI_PREL,'Czynności i zdarzenia oczekujące w kolejce'@,,,,8,,,,,'maximized');
_ar:="
   _env:=params_get().env;
   B_PREL.actions_grayed(_env.WER_B_PREL,{? B_PREL.ERROR='T' || '' || 'P' ?});
   ~~
";
B_WORKER.grp_sel(_grp,B_PREL,_env.WER_B_PREL,'Zdarzenia startowe warunkowe'@,_ar,,,,,,,,'maximized');
B_WORKER.win_sel(_grp);

B_WORKER.win_fml('WER',,'KOD',,'ICON_BEFORE',"exec('icon_kod','#b_worker')");

_dnd_harm:="
   B_HARM.cntx_psh(); B_WORKER.cntx_psh();
   B_HARM.clear();
   B_WORKER.seek(dnd_info('dest_record'));
   _tab:=dnd_info('dropped_records');
   {? _tab.first()
   || {!
      |? {? B_HARM.seek(_tab.REF,)
         || {? B_HARM.r_lock(1,1,1)
            || B_HARM.B_WORKER:=B_WORKER.ref();
               B_HARM.put();
               B_HARM.r_unlock()
            || FUN.emsg(
                  'Przesunięcie zdarzenia %1 do innej kolejki nie jest możliwe.\n'
                  'Rekord jest redagowany lub przetwarzany.'@[$B_HARM.ref()]
               )
            ?}
         ?};
         _tab.next()
      !}
   ?};
   B_HARM.cntx_pop(); B_WORKER.cntx_pop();
   ~~
";

_dnd_iprel:="
   BI_PREL.cntx_psh(); B_WORKER.cntx_psh();
   BI_PREL.clear();
   B_WORKER.seek(dnd_info('dest_record'));
   _tab:=dnd_info('dropped_records');
   {? _tab.first()
   || {!
      |? {? BI_PREL.seek(_tab.REF,)
         || {? BI_PREL.r_lock(1,1,1)
            || BI_PREL.B_WORKER:=B_WORKER.ref();
               BI_PREL.put();
               BI_PREL.r_unlock()
            || FUN.emsg(
                  'Przesunięcie elementu %1 do innej kolejki nie jest możliwe.\n'
                  'Rekord jest redagowany lub przetwarzany.'@[$BI_PREL.ref()]
               )
            ?}
         ?};
         _tab.next()
      !}
   ?};
   BI_PREL.cntx_pop(); B_WORKER.cntx_pop();
   ~~
";

_dnd_prel:="
   B_PREL.cntx_psh(); B_WORKER.cntx_psh();
   B_PREL.clear();
   B_WORKER.seek(dnd_info('dest_record'));
   _tab:=dnd_info('dropped_records');
   {? _tab.first()
   || {!
      |? {? B_PREL.seek(_tab.REF,)
         || {? B_PREL.r_lock(1,1,1)
            || B_PREL.B_WORKER:=B_WORKER.ref();
               B_PREL.put();
               B_PREL.r_unlock()
            || FUN.emsg(
                  'Przesunięcie elementu %1 do innej kolejki nie jest możliwe.\n'
                  'Rekord jest redagowany lub przetwarzany.'@[$B_PREL.ref()]
               )
            ?}
         ?};
         _tab.next()
      !}
   ?};
   B_PREL.cntx_pop(); B_WORKER.cntx_pop();
   ~~
";
_mode:=__UPG.get_mode();
__UPG.mode(3);

B_WORKER.index('KOD');
B_WORKER.prefix(REF.FIRMA);

B_WORKER.dnd_sel('WER',,'records.B_HARM',_dnd_harm);
B_WORKER.dnd_sel('WER',,'records.BI_PREL',_dnd_iprel);
B_WORKER.dnd_sel('WER',,'records.B_PREL',_dnd_prel);
B_WORKER.timer('sel',_grp,1,"win_disp()");
B_WORKER.select();
B_WORKER.dnd_sel('WER',,'records.B_HARM',"");
B_WORKER.dnd_sel('WER',,'records.BI_PREL',"");
B_WORKER.dnd_sel('WER',,'records.B_PREL',"");

__UPG.mode(_mode);
''


\select_slo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Słownik wyboru kolejek
::   WY: B_WORKER.ref lub null
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
B_WORKER.cntx_psh();
B_WORKER.index('KOD');
B_WORKER.prefix(REF.FIRMA);
_win:=B_WORKER.mk_sel('Kolejki'@,'P',0,'b_workslo',,,15,0,'U');
B_WORKER.win_fld(_win,B_WORKER,'KOD','','',10,0,0,'Kod'@@,0,'',,);
B_WORKER.win_fld(_win,B_WORKER,'OPIS','','',40,0,0,'Opis'@@,0,'',,);

_fb:="
   sel_exit()
";
B_WORKER.win_act(_win,,'Formuła','Wybierz'@@,,,_fb,,1,,,,'W');

B_WORKER.win_sel(_win);
{? B_WORKER.select(,1)
|| _result:=B_WORKER.ref()
?};
B_WORKER.cntx_pop();
_result


\init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Generuje standardowe kolejki
::  OLD: \std_quee/skid_eml.fml
::  TAG: <PROCES>
::----------------------------------------------------------------------------------------------------------------------
B_WORKER.clear();
:: Pole FIRMA wypełnia się wartością REF.FIRMA
B_WORKER.blank();

B_WORKER.KOD:='mail';
B_WORKER.OPIS:=exec('worker_description','#b_worker',B_WORKER.KOD);
B_WORKER.PAUZA:=300;
B_WORKER.TECH:='N';
B_WORKER.add(1);

B_WORKER.KOD:='task';
B_WORKER.OPIS:=exec('worker_description','#b_worker',B_WORKER.KOD);
B_WORKER.PAUZA:=60;
B_WORKER.TECH:='N';
B_WORKER.add(1);

B_WORKER.KOD:='event';
B_WORKER.OPIS:=exec('worker_description','#b_worker',B_WORKER.KOD);
B_WORKER.PAUZA:=15;
B_WORKER.TECH:='N';
B_WORKER.add(1);

B_WORKER.KOD:='blink';
B_WORKER.OPIS:=exec('worker_description','#b_worker',B_WORKER.KOD);
B_WORKER.PAUZA:=5;
B_WORKER.TECH:='T';
B_WORKER.add(1);
~~


\reset_worker
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Wymuszenie zatrzymania przetwarzania kolejki
::       System powinien automatycznie uruchomić ponownie przetwarzanie
::  OLD: \em_stoptask/skid_eml.fml
::       \stoptask/skid_eml.fml
::       \stoper/skid_eml.fml
::  TAG: <PROCES>
::----------------------------------------------------------------------------------------------------------------------
{? B_WORKER.sel_size()>0
      |
   FUN.ask('Czy na pewno zatrzymać i uruchomić ponownie przetwarzanie kolejki %1?'@[B_WORKER.KOD])
|| {? B_WORKER.get()
   || B_WORKER.STOP:='T';
      B_WORKER.put()
   ?}
?};
~~


\reset_worker_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wymuszenie zatrzymania przetwarzania kolejki - akcja przed grupą rekordów
::   WY: 0 / 1
::  TAG: <PROCES>
::----------------------------------------------------------------------------------------------------------------------
_dalej:=FUN.ask('Czy na pewno zatrzymać i uruchomić ponownie przetwarzanie zaznaczonych kolejek?'@);
{? _dalej || sel_nchk() ?};
_dalej


\display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyświetla informacje o kolejce
::----------------------------------------------------------------------------------------------------------------------
_red:=exec('worker_mk_edit','#b_worker');

B_WORKER.win_edit(_red);
B_WORKER.display();
B_WORKER.win_edit();
B_WORKER.win_edel(_red);
~~


\event_start_timer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Zwraca ref() elementu będącego zdarzeniem czasowym startowym
::   WY: B_ELE.ref()
::----------------------------------------------------------------------------------------------------------------------
_b_ele:=null();
B_EVENT.index('TYP');
B_EVENT.prefix(exec('type_start','#b_event'),exec('kind_timer','#b_event'),exec('category_catch','#b_event'));
{? B_EVENT.first()
|| _b_ele:=B_EVENT.B_ELE
?};
_b_ele


\chk_b_worker
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli B_WORKER (kolejki) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(B_WORKER,,'KOD','OPIS','PAUZA');
{? _chk=''
|| {? B_WORKER.PAUZA<0
   || FUN.info('Wartość parametru ''Pauza'' musi być większa od zera.'@);
      'PAUZA'
   || {? __CHK.index(B_WORKER,_a)='' || '' || 'KOD' ?}
   ?}
|| _chk
?}


\cgi_disable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Wyłącza przetwarzanie CGI na serwerze
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask(
      'Czy zatrzymać przetwarzanie CGI na serwerze dla wszystkich kolejek?\n\n'
      'Zostanie zatrzymane przetwarzanie we wszystkich firmach obsługiwanych przez tę instancję MacroSERVER-a.\n'
      'Po restarcie MacroSERVER-a przetwarzanie zostanie automatycznie uruchomione.'@
   )
|| exec('cgi_enable_disable','#b_worker',0)
?};
~~


\cgi_enable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Włącza przetwarzanie CGI na serwerze
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask(
      'Czy uruchomić przetwarzanie CGI na sewerze dla wszystkich kolejek?\n\n'
      'Zostanie uruchomione przetwarzanie we wszystkich firmach obsługiwanych przez tę instancję MacroSERVER-a.\n'
      'W zależności od konfiguracji serwera uruchomienie może potrwać do kilku minut.'@
   )
|| exec('cgi_enable_disable','#b_worker',1)
?};
~~


\cgi_enable_disable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Włącza/wyłącza przetwarzanie CGI - funkcja elementarna
::   WE: 1 - włącza, 0 - wyłącza
::----------------------------------------------------------------------------------------------------------------------
{? _a || _option:='r' || _option:='s' ?};

_sep:=exec('sep','#file',2);
_dsn:=jdbc_dsn(1);
_dsn_tab:=spli_str(_dsn,';');
_asport:='5580';
_ascertuse:='0';
_ascertpth:='';
{! _it:=1.. obj_len(_dsn_tab)
|! {? 7+_dsn_tab[_it]='ASPORT=' || _asport:=(7-_dsn_tab[_it])
   |? 10+_dsn_tab[_it]='ASCERTUSE=' || _ascertuse:=(10-_dsn_tab[_it])
   |? 10+_dsn_tab[_it]='ASCERTPTH=' || _ascertpth:=(10-_dsn_tab[_it])
   ?}
!};
_cmd:=
   {? sys_name(1)='U_LINUX'
   || '%1/MacroAppLOCKER -c%2 %3 %4'[exe_dir(1),_option,_asport,{? _ascertuse='1' || '-k %1'[_ascertpth] || '' ?}]
   || pth_dir('startx.exe')+_sep+'startx.exe /NOUI /B /RETURNERROR "'+
      '\"%1mblocker.exe\" -c%2 %3 %4'[exe_dir(1)+_sep,_option,_asport,{? _ascertuse='1' || '-k %1'[_ascertpth] || '' ?}]
   ?};
_err:=system(_cmd,1);
~~


\worker_enable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Wyłącza przetwarzanie kolejki - kolejka jest uruchomiona, ale pomija wszystkie zadania
::----------------------------------------------------------------------------------------------------------------------
{? B_WORKER.sel_size()>0
   | FUN.ask('Czy włączyć przetwarzanie zadań i zdarzeń przez kolejkę %1?'@[B_WORKER.KOD])
|| {? B_WORKER.get()
   || B_WORKER.ENABLED:='T';
      B_WORKER.put()
   ?}
?};
~~


\worker_enable_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Wyłącza przetwarzanie kolejki - kolejka jest uruchomiona, ale pomija wszystkie zadania
::       (akcja przed grupą rekordów)
::----------------------------------------------------------------------------------------------------------------------
_dalej:=FUN.ask('Czy włączyć przetwarzanie zadań i zdarzeń przez zaznaczone kolejki?'@);
{? _dalej || sel_nchk() ?};
_dalej


\worker_disable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Włącza przetwarzanie kolejki
::----------------------------------------------------------------------------------------------------------------------
{? B_WORKER.sel_size()>0
   | FUN.ask('Czy wyłączyć przetwarzanie zadań i zdarzeń przez kolejkę %1?'@[B_WORKER.KOD])
|| {? B_WORKER.get()
   || B_WORKER.ENABLED:='N';
      B_WORKER.put()
   ?}
?};
~~


\worker_disable_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Włącza przetwarzanie kolejki (akcja przed grupą rekordów)
::----------------------------------------------------------------------------------------------------------------------
_dalej:=FUN.ask('Czy wyłączyć przetwarzanie zadań i zdarzeń przez zaznaczone kolejki?'@);
{? _dalej || sel_nchk() ?};
_dalej


\clear
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Zeruje wartości pól: B_WORKER.TMAXPROC, B_WORKER.TMAXRUN, B_WORKER.RESTARTS
::----------------------------------------------------------------------------------------------------------------------
{? B_WORKER.sel_size()>0
   | FUN.ask(
        'Czy wyzerować maksymalne czasy uruchomienia i przetwarzania,\n'
        'liczbę restartów kolejki oraz liczbę wycofanych transakcji?'@
     )
|| {? B_WORKER.get()
   || B_WORKER.TMAXPROC:=0;
      B_WORKER.TMAXRUN:=0;
      B_WORKER.RESTARTS:=0;
      B_WORKER.ABORTED:=0;
      B_WORKER.put()
   ?}
?};
~~


\clear_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Zeruje wartości pól: B_WORKER.TMAXPROC, B_WORKER.TMAXRUN, B_WORKER.RESTARTS (akcja przed grupą rekordów)
::----------------------------------------------------------------------------------------------------------------------
_dalej:=FUN.ask(
   'Czy wyzerować maksymalne czasy uruchomienia i przetwarzania,\n'
   'liczbę restartów zaznaczonych kolejek oraz liczbę wycofanych transakcji?'@
);
{? _dalej || sel_nchk() ?};
_dalej


\select_history
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Wyświetla historię dla kolejki
::   WE: _a - B_WORKER.ref()
::----------------------------------------------------------------------------------------------------------------------
_wer:=B_WRKHST.mk_sel('Historia kolejki'@,'P',,'#wrkhst',,,,,'U');
B_WRKHST.win_fld(_wer,,'TYPE',,,30);
B_WRKHST.win_fld(_wer,VAR,'STRING2',,,50,,,'Element procesu'@);
B_WRKHST.win_fld(_wer,VAR,'STRING',,,-20,,,'Początek przetwarzania'@);
B_WRKHST.win_fld(_wer,,'TIMEPROC',,,10,6);
B_WRKHST.win_fld(_wer,,'ABORTED',,,-10,,,'Wycofana transakcja'@,,,2,,"1","0");
B_WRKHST.win_act(_wer,,'Usuń',,,,,,,1);
_fb:="
   {? B_WRKHST.ELEMENT=''
   || FUN.info('Pozycja nie jest elementem procesu.'@)
   |? ref_tab(B_WRKHST.ELEMENT)=BI_PREL
   || BI_PREL.cntx_psh();
      BI_PREL.prefix();
      {? BI_PREL.seek(B_WRKHST.ELEMENT)
      || BI_PREL.B_PREL();
         BI_PREL.BI_PROC();
         exec('select4biproc_alt','#b_design',BI_PROC.ref(),B_PREL.ref(),'bi_proc_todo')
      ?};
      BI_PREL.cntx_pop()
   |? ref_tab(B_WRKHST.ELEMENT)=B_PREL
   || B_PREL.cntx_psh();
      B_PREL.prefix();
      {? B_PREL.seek(B_WRKHST.ELEMENT)
      || B_PREL.B_PROC();
         exec('select4proc','#b_design',B_PROC.ref(),0,B_PREL.ref())
      ?};
      B_PREL.cntx_pop()
   ?};
   ~~
";
B_WRKHST.win_act(_wer,,'Formuła','Pod&gląd procesu'@@,,,_fb,,,,,,'G');
B_WRKHST.win_act(_wer,,'Kolejność');
_fb:="
   VAR.STRING:=gsub(iso_datetime_value_utc(B_WRKHST.START/1000000),'T',' ');
   VAR.STRING2:=exec('record','#to_string',B_WRKHST.ELEMENT);
   ~~
";
B_WRKHST.win_act(_wer,,'Rekord',,,,_fb);
B_WRKHST.win_act(_wer,,'Wyświetl',,,,"exec('display_hist','#b_worker')");

_tab:=tab_tmp(1
   ,'S1','STRING[50]','S1'
   ,'S2','STRING[50]','S2'
   ,'S3','STRING[50]','S3'
);
_red:=_tab.mk_edit('Informacje'@,,'#wrkhstinfo');
_tab.win_esep(_red,'Informacje o sposobie przetwarzania'@);
_tab.win_efld(_red,,'S1',,,5,,,'Zapisywanie historii przetwarzania kolejek'@,,,
   'check-box','check_label="%1"'['Historia przetwarzania kolejek będzie zapisywana'@],"'T'","'N'"
);
_tab.win_efld(_red,AH,'H',,,,,,'Usuwanie historii przetwarzania kolejek'@);
_tab.win_efld(_red,,'S2',,,5,,,'(liczba dni, przez które będzie pamiętana historia)'@);
_tab.win_efld(_red,AH,'H',,,,,,'Rejestrowanie historii dla elementów'@);
_tab.win_efld(_red,,'S3',,,5,,,'trwających dłużej niż [%1]'@['s']);

_grp:=B_WRKHST.grp_make('Historia kolejki'@,"grp_edisp(params_get().tab,params_get().red)",'#gwrkhist',,,,,'normal');
B_WRKHST.grp_sel(_grp,,_wer,,,,,,,,,,'maximized');
B_WRKHST.grp_splt(_grp,,'horizontal','info','24,70%');
B_WRKHST.grp_edit(_grp,_tab,_red,,,,,,'maximized');
B_WRKHST.win_sel(_grp);

_tab.S1:=exec('get','#params',100931);
_tab.S2:=$exec('get','#params',100932);
_tab.S3:=$exec('get','#params',100933);

B_WRKHST.index('START');
B_WRKHST.prefix(B_WORKER.ref());

params_set('tab',_tab,'red',_red);
B_WRKHST.select();
~~


\add_hist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Dodaje rekord historii kolejki
::   WE: _a - B_WORKER.ref()
::       _b - typ zapisu (wynik formuły \hist_type_*)
::       [_c] - B_PREL.ref(), $B_PREL.ref(), B_PREL.uidref() albo BI_PREL.ref(), $BI_PREL.ref(), BI_PREL.uidref()
::   WY: B_WRKHST.ref()
::----------------------------------------------------------------------------------------------------------------------
_worker:=_a;
_type:=_b;
{? var_pres('_c')>0
|| _element_uid:=exec('FindAndGet','#table',ref_tab(_c),_c,,"uidref()",'')
|| _element_uid:=''
?};

_result:=null();
B_WRKHST.cntx_psh();
B_WRKHST.prefix();
B_WRKHST.blank();
B_WRKHST.B_WORKER:=_worker;
B_WRKHST.TYPE:=_type;
B_WRKHST.ELEMENT:=_element_uid;
B_WRKHST.START:=utc_get()*1000000;
{? B_WRKHST.add() || _result:=B_WRKHST.ref() ?};
B_WRKHST.cntx_pop();
_result


\put_hist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Modyfikuje albo kasuje rekord historii kolejki (ustala czas przetwarzania)
::   WE: _a - B_WRKHST.ref()
::       _b - wartość parametru 100933
::       _c - czy wycofana transakcja (wtedy zapis zawsze, nawet jak czas realizacji mniejszy niż 100933)
::----------------------------------------------------------------------------------------------------------------------
_hist:=_a;
_p100933:=_b;
_aborted:=_c;

{? _hist
|| B_WRKHST.cntx_psh();
   B_WRKHST.prefix();
   {? B_WRKHST.seek(_hist)
   || B_WRKHST.TIMEPROC:=((utc_get()*1000000)-B_WRKHST.START)/exec('second','#tm_stamp');
      B_WRKHST.ABORTED:=_aborted;
      {? B_WRKHST.TIMEPROC>_p100933 | _aborted
      || B_WRKHST.put()
      || B_WRKHST.del()
      ?}
   ?};
   B_WRKHST.cntx_pop()
?};
~~


\display_hist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Wyświetla rekord historii (kontekstowo do zawartości)
::----------------------------------------------------------------------------------------------------------------------
{? B_WRKHST.ELEMENT='' & B_WRKHST.TYPE=exec('hist_type_begin','#b_worker')
|| FUN.info('Rozpoczęcie przetwarzania kolejki: %1'@[19+tm_form(B_WRKHST.START)])
|? B_WRKHST.ELEMENT='' & B_WRKHST.TYPE=exec('hist_type_end','#b_worker')
|| FUN.info('Zakończenie przetwarzania kolejki: %1'@[19+tm_form(B_WRKHST.START)])
|| FUN.info(
      'Element procesu: %1\n\n'
      'Rozpoczęcie przetwarzania: %2\n'
      'Czas przetwarzania: %3 s'@
      [exec('record','#to_string',B_WRKHST.ELEMENT),19+tm_form(B_WRKHST.START),$B_WRKHST.TIMEPROC]
   )
?};
~~


\hist_type_begin
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Stała tekstowa - Uruchomienie przetwarzania
::----------------------------------------------------------------------------------------------------------------------
'Uruchomienie przetwarzania'


\hist_type_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Stała tekstowa - Zakończenie przetwarzania
::----------------------------------------------------------------------------------------------------------------------
'Zakończenie przetwarzania'


\hist_type_element
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Stała tekstowa - Element procesu
::----------------------------------------------------------------------------------------------------------------------
'Element procesu'


\del_hist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Usuwanie historii kolejki w podanym zakresie czasowym
::   WE: _a - B_WORKER.ref()
::       _b - liczba dni wstecz zapamiętanej historii
::----------------------------------------------------------------------------------------------------------------------
_worker:=_a;
_remember:=SYSLOG.tm_stamp()-exec('day','#tm_stamp')*_b;
::_remember:=SYSLOG.tm_stamp()-exec('minute','#tm_stamp')*_b;

B_WRKHST.cntx_psh();
B_WRKHST.index('START');
B_WRKHST.prefix(_worker);
{? B_WRKHST.first()
|| {!
   |? {? B_WRKHST.START<_remember || B_WRKHST.del() ?};
      B_WRKHST.first() & B_WRKHST.START<_remember
   !}
?};
B_WRKHST.cntx_pop();
~~


\ses_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Dla bieżącego rekordu B_WORKER wyświetla info o sesji przetwarzającej
::   WE: _a - (0/1) czy wyświetlać informację o niedostępności funkcji
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _dod_info:=_a || _dod_info:=0 ?};

_ses_id:=exec('blk_lock','#table','B_WORKER',B_WORKER.ref(),,2);
_usersym:=B_WORKER.ses_info(_ses_id,'log_name');
USERS.cntx_psh();
USERS.clear();
USERS.index('USR_KKOD');
USERS.prefix(_usersym,);
{? USERS.first()
|| _userdata:=USERS.DANE
|| _userdata:=''
?};
USERS.cntx_pop();
_session_start:=$B_WORKER.ses_info(_ses_id,'log_date')+' - ';
_session_start+=$B_WORKER.ses_info(_ses_id,'log_time');
{? _usersym='html'
||
   FUN.emsg(
      {? _dod_info || 'Funkcja niedostępna.'@+'\n\n' || '' ?}+
      'Przetwarzanie CGI dla kolejki \'%1\' jest uruchomione.\n\n'
      'Terminal: %2\n'
      'Zalogowany od: %3'@[B_WORKER.KOD,B_WORKER.ses_info(_ses_id,'log_tty'),_session_start]
   )
||
   FUN.emsg(
      {? _dod_info || 'Funkcja niedostępna.'@+'\n\n' || '' ?}+
      'Przetwarzanie testowe kolejki \'%1\' jest uruchomione albo kolejka jest modyfikowana.\n\n'
      'Blokuje użytkownik: %2\n'
      'Pełna nazwa: %3\n'
      'Terminal: %4\n'
      'Zalogowany od: %5'@[B_WORKER.KOD,_usersym,_userdata,B_WORKER.ses_info(_ses_id,'log_tty'),_session_start]
   )
?}


\add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Formuła 'dołącz' w oknie B_WORKER.WER
::----------------------------------------------------------------------------------------------------------------------
_red:=exec('worker_mk_edit','#b_worker');
B_WORKER.win_edit(_red);
{? B_WORKER.edit("exec('chk_b_worker','#b_worker',0)")
|| B_WORKER.add()
?};
B_WORKER.win_edit();
B_WORKER.win_edel(_red);
~~


\modify_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Formuła 'popraw' w oknie B_WORKER.WER
::----------------------------------------------------------------------------------------------------------------------
{? exec('blk_lock','#table','B_WORKER',B_WORKER.ref(),,1)
|| {? B_WORKER.get()
   || _red:=exec('worker_mk_edit','#b_worker');
      B_WORKER.win_edit(_red);
      {? B_WORKER.edit("exec('chk_b_worker','#b_worker',1)")
      || B_WORKER.put()
      ?};
      B_WORKER.win_edit();
      B_WORKER.win_edel(_red)
   ?};
   exec('blk_unlock','#table','B_WORKER',B_WORKER.ref())
|| exec('ses_info','#b_worker',1);
   0
?}


\worker_mk_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Tworzy okienko redakcyjne kolejki
::----------------------------------------------------------------------------------------------------------------------
_red:=B_WORKER.mk_edit('Kolejka'@,,'workeredit');
_width:=50;
B_WORKER.win_esep(_red,'Dane podstawowe'@);
B_WORKER.win_efld(_red,,'KOD',,,_width);
B_WORKER.win_efld(_red,,'OPIS',,,_width);
B_WORKER.win_esep(_red,'Sterowanie'@);
B_WORKER.win_efld(_red,,'TRYB',,,,,,'Tryb przetwarzania'@,,,'radio-buttons',,
   'Stała długość cyklu przetwarzania'@,"1",
   'Stała pauza między cyklami przetwarzania'@,"0"
);
B_WORKER.win_efld(_red,,'PAUZA',,,,,,'Cykl przetwarzania [s]'@);
_formula:="
   exec('display_info','#b_worker');
   ''
";
B_WORKER.win_ebtn(_red,
   'text=%1,btn_label_align=center,panel=bottom,align=begin,display=1,edit=0'['Informacje'@],_formula
);
exec('ok_esc','#window',B_WORKER,_red);
_red


\display_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS:
::----------------------------------------------------------------------------------------------------------------------
{? exec('blk_lock','#table','B_WORKER',B_WORKER.ref(),,1)
|| FUN.info('Przetwarzanie kolejki \'%1\' nie jest uruchomione.'@[B_WORKER.KOD]);
   exec('blk_unlock','#table','B_WORKER',B_WORKER.ref())
|| exec('ses_info','#b_worker',0)
?};
~~


\delete_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Przed 'usuń' w oknie B_WORKER.WER
::----------------------------------------------------------------------------------------------------------------------
{? exec('blk_lock','#table','B_WORKER',B_WORKER.ref(),,1)
|| exec('blk_unlock','#table','B_WORKER',B_WORKER.ref());
   1
|| exec('ses_info','#b_worker',1);
   0
?}


\b_worker_br
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Przed rekord w oknie B_WORKER.WER
::   WE: _a - sysmowy parametr akcji
::----------------------------------------------------------------------------------------------------------------------
{? _a
|| {? B_WORKER.ENABLED='T'
   || {? B_WORKER.sel_size()>0 || _grayed:='' || _grayed:='N(W(W))' ?}
   || {? B_WORKER.sel_size()>0 || _grayed:='' || _grayed:='N(W(Y))' ?}
   ?};
   B_WORKER.actions_grayed('WER',_grayed)
?};
{? exec('blk_lock','#table','B_WORKER',B_WORKER.ref(),,1)
|| exec('blk_unlock','#table','B_WORKER',B_WORKER.ref());
   VAR.STRING:='N'
|| VAR.STRING:='T'
?};
VAR.STRING2:={? B_WORKER.TM_LAST>0 || '[%1 %2]'[$utc_date(B_WORKER.TM_LAST),utc_time(B_WORKER.TM_LAST)$3] || '' ?};
Color.rekprzed('B_WORKER#01')


\worker_log
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Wyświetla log kolejki
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;

_choice:=FUN.choice('Wybierz rodzaj wyświelanego loga'@,,'Log kolejki: %1'@[B_WORKER.KOD],'Log aplikacji (cgi)'@);
_file_log:='';
{? _choice=1
||
   _tab:=AppList.all.tab;
   _tab.cntx_psh();
   _it:=_tab.ndx_tmp('',1,'CGI_HTML',,,'APP_PAR1',,);
   _tab.index(_it);
   _htm_file:='cgi_'+B_WORKER.KOD+'.htm';
   _tab.prefix(_htm_file,REF.FIRMA().SYMBOL);
   {? _tab.first()
   || _file_log:=_tab.CGI_OUTP
   || _htm_file:='qcgi_'+B_WORKER.KOD+'.htm';
      _tab.prefix(_htm_file,REF.FIRMA().SYMBOL);
      {? _tab.first()
      || _file_log:=_tab.CGI_OUTP
      || _can_continue:=0;
         FUN.emsg(
            'Błędna konfiguracja systemu.\n'
            'Kolejka \'%1\' powinna startować z pliku %2 lub %3'@[B_WORKER.KOD,1-_htm_file,_htm_file]
         )
      ?}
   ?};
   _tab.ndx_drop(_it);
   _tab.cntx_pop();
   ~~
|? _choice=2
|| _file_log:='merit.log'
|| _can_continue:=0
?};

{? _can_continue>0
||
   _user:='html';
   _separator:=exec('sep','#file',2);
   _dir:=pth_dir(_file_log)-(+OPERATOR.USER().KOD);
   _filepath_user:=_dir+_separator+_user+_separator+_file_log;
   _handle_server:=fopen(_filepath_user,'br',0);
   _size_file:=0;
   {? _handle_server>0
   || _size_file:=fgetsize(_handle_server)
   || _can_continue:=0
   ?};
   {? _can_continue>0
   ||
      {? _size_file>510*1024
      || _size_file:=_size_file-510*1024
      || _size_file:=-1
      ?};
      fclose(_handle_server)
   ?};

   {? _can_continue>0
   ||
      _tmp_dir:=fmk_tmp_dir(0);
      {? type_of(_tmp_dir)<>type_of(~~)
      || _tmp_pth:=_tmp_dir.get_path();
         _file_tmp:=exec('track_file','#desktop',_file_log,$_size_file,_user,'1',_tmp_pth);
         {? _file_tmp<>''
         || _split:=spli_str(_file_tmp,'###');
            {? obj_len(_split)>1
            || _local:=B_WORKER.KOD+'_'+$SYSLOG.tm_stamp()+'.part';
               {? fcopy(_split[1],_local,0,1,1)
               || txt_view(_local,1);
                  ferase(_local,1)
               ?}
            ?}
         ?}
      || FUN.emsg('Nie udało się założyć folderu tymczasowego po stronie serwera.'@)
      ?}
   ?}
?};


~~


\use
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Otwiera tabele maskowalne
::----------------------------------------------------------------------------------------------------------------------
B_WRKHST.use('b_whs'+REF.FIRMA().SYMBOL);
~~


\log_pth_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Zwraca nazwę loga kolejki ze ścieżką
::   WE: _a - nazwa pliku bez ścieżki
::   WY: nazwa pliku ze ścieżką
::----------------------------------------------------------------------------------------------------------------------
_log_name:=_a;
_pth:=pth_dir(_log_name);
_pth:=exec('revert','#string',_pth);
_sep:=exec('sep','#file',1);
_pth:=(_pth*_sep)-_pth;
_pth:=exec('revert','#string',_pth);
_pth+_sep+'html'+_sep+_log_name


\del_b_wrkhst
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Usuwa zapis B_WRKHST skojarzony z podanym BI_PREL
::   WE: _a - BI_PREL.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
B_WRKHST.cntx_psh();
exec('use','#b_worker');
B_WRKHST.index('ELEMENT');
B_WRKHST.prefix(exec('FindAndGet','#table',BI_PREL,_a,,"uidref()",''),);
{? B_WRKHST.first()
|| _result:=(B_WRKHST.del(,1)>0)
?};
B_WRKHST.cntx_pop();
_result


\change_worker_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Akcja Zmień kolejkę dostępna w obszarze definiowania kolejek (dla paneli po prawej)
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);

_grupa:=0;
{? _tab.sel_size()>0
|| _grupa:=1
?};

_new_worker:='';
{? _grupa=0
|| _new_worker:=exec('change_worker_ask','#b_worker')
|| _new_worker:=VAR.TYMCZAS
?};

{? _new_worker<>''
|| B_WORKER.cntx_psh();
   B_WORKER.index('KOD');
   B_WORKER.prefix(REF.FIRMA,_new_worker,);
   {? B_WORKER.first()
   ||
      {? _tab.B_WORKER<>B_WORKER.ref()
      || _tab.cntx_psh();
         _tab.prefix();
         {? _tab.r_lock(1,1,1)
         || _tab.B_WORKER:=B_WORKER.ref();
            _tab.put();
            _tab.r_unlock()
         ||
            _msg:='Przesunięcie elementu %1 do innej kolejki nie jest możliwe.\n'
                  'Rekord jest redagowany lub przetwarzany.'@[$tab.ref()];
            {? _grupa>0
            || KOMM.add(_msg,2)
            || FUN.emsg(_msg)
            ?}
         ?};
         _tab.cntx_pop()
      ?}
   ?};
   B_WORKER.cntx_pop();
   ~~
?};
~~


\change_worker_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Grupa przed Zmien kolejke
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
VAR.TYMCZAS:='';
sel_nchk();
KOMM.init(250,,'Zmiana kolejki dla elementów procesu'@);
_new_worker:=exec('change_worker_ask','#b_worker');
{? _new_worker<>''
|| VAR.TYMCZAS:=_new_worker;
   _result:=1
?};
_result


\change_worker_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Grupa po Zmien kolejke
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
VAR.TYMCZAS:='';
KOMM.select();
~~


\change_worker_ask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Pytanie o docelową kolejkę
::   WE:
::   WY:
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_tab:=cur_tab(1,1);

_tymczas:=tab_tmp(1
   ,'KOD','STRING[20]','Kolejka'
);

_tymczas.blank();
_tymczas.KOD:=_tab.B_WORKER().KOD;
_tymczas.add();

_edit:=_tymczas.mk_edit('Zmiana kolejki'@,0,'#bwzmien');
_tymczas.win_efld(_edit,,'KOD',,,,,,'Kolejka'@@,,,,'F3_button=1');
_fml:="
   _result:=cur_tab(1,1).KOD;
   B_WORKER.cntx_psh();
   B_WORKER.index('KOD');
   B_WORKER.prefix();
   B_WORKER.win_sel('SLO');
   _ref:=exec('select_slo','#b_worker');
   {? _ref<>null() & B_WORKER.seek(_ref)
   || _result:=B_WORKER.KOD
   ?};
   B_WORKER.cntx_pop();
   _result
";
_tymczas.fld_fml('KOD','F3',_fml);

_fml:="
   _result:=0;
   B_WORKER.cntx_psh();
   B_WORKER.index('KOD');
   B_WORKER.prefix(REF.FIRMA,cur_tab(1,1).KOD);
   {? B_WORKER.first()
   || cur_tab(1,1).KOD:=B_WORKER.KOD;
      cur_tab(1,1).put();
      _result:=1
   || _result:=0;
      FUN.info('Brak pozycji w słowniku.'@)
   ?};
   B_WORKER.cntx_pop();
   _result
";
_tymczas.fld_fml('KOD','AFTER_EDIT',_fml);

exec('ok_esc','#window',_tymczas,_edit);

_tymczas.win_edit(_edit);
{? _tymczas.edit()
|| _result:=_tymczas.KOD
?};
_result


\worker_act_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Aktualizuje informacje o przetwarzaniu kolejki
::       Kontekst wywołania - bieżący rekord B_WORKER
::   WE: [_a] - typ zapisu (wynik formuły \hist_type_*)
::       [_b] - B_PREL.ref(), $B_PREL.ref(), B_PREL.uidref() albo BI_PREL.ref(), $BI_PREL.ref(), BI_PREL.uidref()
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>0
|| _type:=_a
|| _type:=''
?};
{? var_pres('_b')>0
|| _element:=_b
|| _element:=''
?};
{? _type<>''
|| B_WORKER.WRK_PREV:=B_WORKER.WRK_CURR;
   {? type_of(_element)=type_of('') & _element=''
   || B_WORKER.WRK_CURR:='[%1 %2] %3'[$date(),time()$3,_type]
   || B_WORKER.WRK_CURR:='[%1 %2] %3: %4'[$date(),time()$3,_type,exec('record','#to_string',_element)]
   ?}
?};
B_WORKER.TM_LAST:=utc_get();
B_WORKER.put();
~~


\hist_type_pause
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Stała tekstowa - Oczekiwanie
::----------------------------------------------------------------------------------------------------------------------
'Oczekiwanie'


\hist_type_break
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Stała tekstowa - Przerwanie przetwarzania
::----------------------------------------------------------------------------------------------------------------------
'Przerwanie przetwarzania'


\b_worker_color
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Kolorowanie rekordu B_WORKER
::----------------------------------------------------------------------------------------------------------------------
_hour:=60*60;
_interval:=B_WORKER.PAUZA;
_tm:=utc_get()$0;

{? VAR.STRING='N'
|| 'B_WORKER#01#03'
|? B_WORKER.TM_LAST=0
|| ~~
:: 2 godziny
|? B_WORKER.TM_LAST$0+(2*_hour)<_tm
|| 'B_WORKER#01#02'
:: Interwał skorygowany o 2 s
|? B_WORKER.TM_LAST$0+(2+_interval)<_tm
|| 'B_WORKER#01#01'
?}


\icon_kod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Formuła wyznaczająca ikonę w polu KOD kolejki
::   WY: ikonka
::----------------------------------------------------------------------------------------------------------------------
{? B_WORKER.TECH='T'
|| _icon:='xwin16.png:158'
|| _icon:=exec('pusta','#icon')
?};
_icon


\worker_description
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Zwraca opis kolejki na podstawie jej kodu
::   WE: _a - kod kolejki
::   WY: opis kolejki
::----------------------------------------------------------------------------------------------------------------------
_kod:=_a;
{? _kod='mail'  || 'Wysyłanie wiadomości'
|? _kod='task'  || 'Przetwarzanie zadań serwisowych'
|? _kod='event' || 'Przetwarzanie zdarzeń'
|? _kod='blink' || 'Businesslink'
                || 'Kolejka %1'[_kod]
?}


\worker_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Definicja obiektu wpomagającego obsługę zadań w kolejce specjalnej
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__Worker')<0
||
   __Worker:=_obj:=obj_new(
      'WORK', 'add_work',
      'run'
   );
   _obj.WORK:=tab_tmp(1
      ,'KOD','STRING[20]','Kod'
      ,'FORMULA','STRING[255]','Formuła'
      ,'RUN_SRV','INTEGER','Uruchamianie po starcie serwera'
      ,'RUN_QUE','INTEGER','Uruchamianie po starcie kolejki'
      ,'RUN_LOOP','INTEGER','Uruchamianie w pętli'
   );
   _obj.add_work:="
      .WORK.prefix(_a,);
      {? ~.WORK.first()
      || .WORK.KOD:=_a;
         .WORK.FORMULA:=_b;
         .WORK.RUN_SRV:=_c;
         .WORK.RUN_QUE:=_d;
         .WORK.RUN_LOOP:=_e;
         .WORK.add()
      ?};
      ~~
   ";
   _obj.run:="
::   WE: _a [0]/1/2 - kontekst wywołania:
::          2-zadania wykonywane po starcie serwera, 1-zadania wykonywane po starcie kolejki, 0-zadania w pętli
      {? var_pres('_a')=type_of(0) || _context:=_a || _context:=0 ?};
      .WORK.prefix();
      {? .WORK.first()
      || {!
         |? {? (_context=0 & .WORK.RUN_LOOP) |
               (_context=1 & .WORK.RUN_QUE) |
               (_context=2 & .WORK.RUN_SRV)
            || ($.WORK.FORMULA)()
            ?};
            .WORK.next()
         !}
      ?};
      ~~
   ";
   ~~
?};

__Worker

:Sign Version 2.0 jowisz:1045 2023/07/03 09:07:18 a873e7710f21077298b2397e02a2e08d2c7f54151fb73fbdc3c3a37cfc3a8755ea1bcd388ff5dc6481292d4cb786a71d572e305a16db5ed54eeaad02e936163688144686b2ddddb66ef0703f8b1d25c0812c0f2bf04bc4eec6e07e199dd520a2a3b0e3571b8e42b20a407ca330dd21af0c91b61a9229d182d658954ba75b1fd1
