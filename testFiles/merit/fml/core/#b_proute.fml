:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: #b_proute.fml
:: Utworzony: 14.01.2015 [17.00]
:: Autor: AWI
::======================================================================================================================
:: Zawartość: Obsługa tabeli B_PROUTE - procesowość - trasy portów wyjściowych
::======================================================================================================================


\route_create4bproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Tworzenie tras portów wyjściowych dla procesu _a
::   WE: _a - 0-tryb sprawdzenia ciągłości trasy, 1-tryb zapisu trasy
::       _b - B_PROC.ref()
::       [_c] - obj_new - argumenty funkcji dla komunikatów - wynik działania exec('komm_args','#b_proc')
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_mode:=_a;
_b_proc:=_b;

_args:=~~;
{? var_pres('_c')>100
|| _args:=exec('obj_ntab_set','#array',_c)
|| _args:=exec('komm_args','#b_proc')
?};

_wyn:=1;

_poconn_count:=0;

B_POCONN.cntx_psh();
B_CONN.cntx_psh();
B_PREL.cntx_psh();
B_PORT.cntx_psh();

B_POCONN.index('PROC');
B_POCONN.prefix(_b_proc);
:: Iteracja po połączeniach portów procesu
_loop:=B_POCONN.first();
{!
|? _loop
|!
   {? B_POCONN.PREL_SRC<>B_POCONN.B_CONN().FROM
:: Tworznie tras dla połączenia pośredniego
   || _poconn_count+=1;
      _wyn1:=exec('route_create4bpoconn','#b_proute'
         ,_mode,_b_proc,B_POCONN.B_CONN,B_POCONN.ref(),B_POCONN.PREL_SRC,B_POCONN.PREL_DST);
      {? _wyn1=0
      || _sect:='Powiązania argumentów, dla których brak połączenia pomiędzy źródłem a celem'@;

         _conn:=B_POCONN.FROM().NAME+' -> '+B_POCONN.TO().NAME;
         _src:=B_POCONN.PREL_SRC().SYMBOL;
         _dst:=B_POCONN.PREL_DST().SYMBOL;

         _msg:='Powiązanie: \'%1\' (źródło: %2, cel: %3).'@[_conn,_src,_dst];

         _args.SECT:=_sect;
         _args.MSG:=_msg;
         _args.GRAPH_UID:=B_POCONN.PREL_DST().UID;
         exec('komm_add','#b_proc',_args)
      ?};
      {? _wyn1=0
      || _wyn:=0
      ?}
   ?};
   _loop:=(_mode=0 | _mode=1 & _wyn=1) & B_POCONN.next()
!};

B_PORT.cntx_pop();
B_PREL.cntx_pop();
B_CONN.cntx_pop();
B_POCONN.cntx_pop();

{? 0 || exec('log','#b_proute',_b_proc,_poconn_count,_wyn) ?};

_wyn


\route_create4bpoconn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Tworzenie tras portów wyjściowych dla połączenia _d.
::       Konteksty:
::       - dodawanie portów dynamicznych - ręcznie;
::       - dodawanie portów dynamicznych - automatycznie dla warunków bram;
::       - dodawanie warunku na bramie;
::       - aktualizacja automatycznych warunków na bramie;
::       - usuwanie połączenia.
::       Generalnie powiązania portów są weryfikowane istnieniem tras pomiędzy portem źródłowym a docelowym.
::       POMYSŁ DO REALIZACJI: w celu przyspieszenia modelowania można przenieść wyznaczanie tras i tym samym
::       weryfikację powiązań portów do funkcji weryfikacji i akceptacji procesu.
::   WE: _a - -1-tryb sprawdzenia ciągłości trasy dla elementu już odwiedzanego z tego elementu do elementu docelowego
::             0-tryb sprawdzenia ciągłości trasy,
::             1-tryb zapisu trasy
::       _b - B_PROC.ref() - proces
::       _c - B_CONN.ref() - pełączenie elementów dla którego tworzone są trasy portów wyjściowych
::       _d - B_POCONN.ref() - połączenie portów
::       _e - B_PREL.ref() - element źródłowy
::       _f - B_PREL.ref() - element docelowy
::       _g - B_PREL.ref() - element aktualnie przetwarzany
::       _h - elementy odwiedzone '$B_PREL.ref()$B_PREL.ref()...'
::       _i - połączenie _c jest na ścieżce [0/1]
::   WY: 0-brak trasy dla połączenia _d lub niepowodzenie B_PROUTE.add(), 1-jest trasa dla połączenia _d
::----------------------------------------------------------------------------------------------------------------------
       _mode:=_a;
     _b_proc:=_b;
     _b_conn:=_c;
   _b_poconn:=_d;
       _from:=_e;
         _to:=_f;
    _current:={? var_pres('_g')=type_of(null()) || _g || _from ?};
    _visited:={? var_pres('_h')=type_of('')     || _h || '' ?};
_bconnOnPath:={? var_pres('_i')=type_of(0)      || _i || 0 ?};
   _visited0:={? var_pres('_j')=type_of(obj_new('obj')) || _j || _obj0:=obj_new('val'); _obj0.val:=''; _obj0 ?};
   _visited1:={? var_pres('_k')=type_of(obj_new('obj')) || _k || _obj1:=obj_new('val'); _obj1.val:=''; _obj1 ?};
        _log:={? var_pres('_l')=type_of(obj_new('obj')) || _l || obj_new('on','out','tab','cur_tab','rnr','route') ?};

_wyn:=0;

_first_run:=_<7;

{? _first_run
||
   _log.on:=0;
   {? _log.on
   ||
      _log.tab:=2;
      _log.cur_tab:=0;
      _log.out:=fopen('b_poconn_'+form(#_b_conn,-8,,'99')+'.xml','Uw');
      _log.on:=_log.out>0;
      {? _log.on
      ||
         _log.route:='r';
         fwrite(_log.out,
            exec('FindAndGet','#table',B_POCONN,_b_poconn,,"
               '<B_POCONN name=\"'
               +'Powiązanie: '+B_POCONN.FROM().NAME+' -> '+B_POCONN.TO().NAME
               +' (źródło: '+B_POCONN.PREL_SRC().SYMBOL
               +' , cel: '+B_POCONN.PREL_DST().SYMBOL+')'
               +'\">'
            ",'Nie znaleziono połączenia portów'))
      ?}
   ?}
?};

{? _visited*($_current)
:: Aktualny element był już odwiedzany
|| _wyn:=
      {? _mode<>-1
::    Sprawdzenie czy istnieje ścieżka od elemntu już odwiedzanego do elementu końcowego
::    Jeśli istnieje należy tworzyć trasę portu wyjściowego
      ||
         {? _visited1.val*($_current)
         || 1
         |? _visited0.val*($_current)
         || 0
         |? exec('route_create4bpoconn','#b_proute',-1,_b_proc,_b_conn,_b_poconn,_current,_to
               ,,,_bconnOnPath,,,_log)
         || _visited1.val+=$_current;
            1
         || _visited0.val+=$_current;
            0
         ?}
::    Ścieżka nie prowadzi do elementu końcowego, więc trasa nie będzie tworzona
      || 0
      ?}
||
   {? _log.on
   ||
      _log.rnr:=0
   ?};
   B_PROUTE.cntx_psh();
   B_PROUTE.prefix();
   B_CONN.cntx_psh();
   B_CONN.index('ORDER');
   B_CONN.prefix(_b_proc,_current);
:: Iteracaja po połączeniach z bieżącego elementu
   _loop:=B_CONN.first();
   {!
   |? _loop
   |!
      {? _log.on
      ||
         _log.rnr+=1;
         _log.route+='.'+form(_log.rnr,-3,,'99');
         fwrite(_log.out,(' '*_log.cur_tab)+'<B_PREL name="'
            +{? B_CONN.TO().SYMBOL='' || B_PREL.B_ELE().SYMBOL || B_PREL.SYMBOL ?}+'">');
         _log.cur_tab+=_log.tab
      ?};
      _wyn1:=0;
      {? _bconnOnPath=0 || _bconnOnPath:=_b_conn=B_CONN.ref() ?};
      {? _visited1.val*($B_CONN.TO)
::    jest ścieżka z B_CONN.TO do elementu docelowego
      || _wyn1:=1
      |? _visited0.val*($B_CONN.TO)
::    brak ścieżki z B_CONN.TO do elementu docelowego
      || _wyn1:=0
      |? B_CONN.TO=_to
::    Trasa prowadzi do elementu docelowego
      || {? _bconnOnPath & _wyn=0 || _wyn:=_bconnOnPath ?};
         {? _from<>_to
::       Analiza pętli do elementu docelowego
         || _wyn1:=exec('route_create4bpoconn','#b_proute',_mode,_b_proc,_b_conn,_b_poconn,B_CONN.TO,B_CONN.TO
               ,,,,_visited0,_visited1,_log)
::       Pętla ma zapisaną ścieżkę również na ostatnim połączeniu aby przekazywać parametry wkółko
         || _wyn1:=1
         ?}
::    Badamy dalej czy trasa prowadzi do elementu docelowego
      || _wyn1:=exec('route_create4bpoconn','#b_proute',_mode,_b_proc,_b_conn,_b_poconn,_from,_to
            ,B_CONN.TO,_visited+$_current,_bconnOnPath,_visited0,_visited1,_log)
      ?};
      {? _log.on
      ||
         _log.cur_tab-=_log.tab;
         fwrite(_log.out,(' '*_log.cur_tab)+'</B_PREL>')
      ?};
      {? _wyn1=1
::    Znaleziono ścieżkę do elementu końcowego, więc tworzymy trasę portu wyjściowego
::    dla elementów poprzedzających bieżący
      || _wyn:=1
      ?};
      {? _wyn1=1 & _mode<>-1
::    Zapis trasy
      ||
         {? _log.on
         ||
            fwrite(_log.out,(' '*_log.cur_tab)+'<ROUTE nr="'+form(_log.route,,,'99')+'">'
               +{? B_CONN.TO().SYMBOL='' || B_PREL.B_ELE().SYMBOL || B_PREL.SYMBOL ?}+'</ROUTE>')
         ?};
         {? _visited1.val*($B_CONN.TO)=0 || _visited1.val+=$B_CONN.TO  ?};
         {? _mode=1
         ||
            B_PROUTE.blank();
            B_PROUTE.index('UNIK');
            B_PROUTE.prefix(B_CONN.B_PROC,B_CONN.ref(),_b_poconn);
            {? ~B_PROUTE.first()
            ||
               B_PROUTE.B_PROC:=B_CONN.B_PROC;
               B_PROUTE.B_CONN:=B_CONN.ref();
               B_PROUTE.B_POCONN:=_b_poconn;
               _wyn:=B_PROUTE.add()
            ?}
         ?}
      ?};
      {? _log.on
      ||
         _log.route-=4
      ?};
      _loop:=(_mode<>-1 | _wyn<>1) & B_CONN.next()
   !};
   B_CONN.cntx_pop();
   B_PROUTE.cntx_pop()
?};

{? _first_run
||
   {? _log.on
   ||
      fwrite(_log.out,'</B_POCONN>');
      fclose(_log.out);
      ferase('b_poconn_'+form(#_b_poconn,-8,,'99')+'.log')
   ?}
?};

_wyn


\route_delete4bproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Kasowanie tras portów wyjściowych dla procesu _a
::   WE: _a - B_PROC.ref()
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;

B_PROUTE.cntx_psh();
B_PROUTE.index('B_PROC');
B_PROUTE.prefix(_b_proc);
_loop:=B_PROUTE.first();
{!
|? _loop
|!
   _loop:=B_PROUTE.del()
!};
B_PROUTE.cntx_pop()


\route_delete4bpoconn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Kasowanie tras portów wyjściowych dla połączenia _a
::   WE: _a - B_POCONN.ref()
::----------------------------------------------------------------------------------------------------------------------
_b_poconn:=_a;

B_PROUTE.cntx_psh();
B_PROUTE.index('B_POCONN');
B_PROUTE.prefix(_b_poconn);
_loop:=B_PROUTE.first();
{!
|? _loop
|!
   _loop:=B_PROUTE.del()
!};
B_PROUTE.cntx_pop()


\route_delete4bconn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Kasowanie przerwanych tras portów wyjściowych
::   WE: _a - B_CONN.ref()
::   WY: B_POCONNy dla których usunięto część trasy
::----------------------------------------------------------------------------------------------------------------------
_wyn:='';

_b_conn:=_a;

B_PROUTE.cntx_psh();
B_PROUTE.index('B_CONN');
B_PROUTE.prefix(_b_conn);
_loop:=B_PROUTE.first();
{!
|? _loop
|!
   {? _wyn*($B_PROUTE.B_POCONN)=0 || _wyn+=$B_PROUTE.B_POCONN ?};
   _loop:=B_PROUTE.next()
!};
B_PROUTE.cntx_pop();

_b_poconns:=_wyn;
{!
|? +_b_poconns
|! _b_poconn:=exec('FindAndGet','#table',B_POCONN,16+_b_poconns,,,null());
   _b_poconns:=16-_b_poconns;
   exec('route_delete4bpoconn','#b_proute',_b_poconn)
!};

_wyn


\route_refresh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Odtworzenie usuniętych tras dla _a lub usunięcie połączeń portów jeśli trasy już nie istnieją
::   WE: _a - lista B_POCONN.ref
::       _b - INTEGER - czy dodawac komunikaty do KOMMa o nieprawidlowosciach: [0] - nie
::                                                                              1  - tak
::----------------------------------------------------------------------------------------------------------------------
_b_poconns:=_a;
_komm:=_b;

_can_continue:=1;

{!
|? +_b_poconns & _can_continue
|! _b_poconn:=exec('FindAndGet','#table',B_POCONN,16+_b_poconns,,,null());
   _b_poconns:=16-_b_poconns;
   B_PREL.cntx_psh();
   B_POCONN.cntx_psh();
   B_POCONN.prefix();
   {? B_POCONN.seek(_b_poconn)
   || {? B_POCONN.PREL_SRC<>B_POCONN.B_CONN().FROM
::    Analiza połączeń pośrednich portów
      || _wyn:=exec('route_create4bpoconn','#b_proute'
            ,1,B_POCONN.B_PROC,B_POCONN.B_CONN,B_POCONN.ref(),B_POCONN.PREL_SRC,B_POCONN.PREL_DST);
         {? _wyn=0
::       Brak trasy dla połączenia pośredniego więc je usuwamy
         || B_CHOICE.cntx_psh();
            B_CHOICE.index('PREL_SRC');
            B_CHOICE.prefix(B_POCONN.PREL_SRC);
            {? B_CHOICE.first()
            || {!
::             Iteracja po warunkach odwołujących się do źródła połączenia pośredniego
               |? {? B_CHOICE.B_PREL=B_POCONN.PREL_DST
::                Usunięcie warunku na bramie wraz z połączeniem pośrednim jeśli cel tego połączenia jest bramą
                  || _can_continue:=exec('delete','#b_choice',B_CHOICE.ref());
                     B_CHOICE.first() & _can_continue>0
                  || B_CHOICE.next()
                  ?}
               !}
            ?};
            B_CHOICE.cntx_pop();

            {?  B_POCONN.seek(_b_poconn)
::          Usuwamy powiązanie pośrednie jeśli nie dotyczy bramy
            ||
               _b_proc:=B_POCONN.B_PROC;
               _to:=B_POCONN.TO;
               _prel_dst:=B_POCONN.PREL_DST;
               _nam_from:=B_POCONN.FROM().NAME;
               _nam_to:=B_POCONN.TO().NAME;
               _sym_src:=B_POCONN.PREL_SRC().SYMBOL;
               _sym_dst:=B_POCONN.PREL_DST().SYMBOL;
               _can_continue:=exec('delete','#b_poconn',B_POCONN.ref());
               B_POCONN.cntx_psh();
               B_POCONN.index('TO');
               B_POCONN.prefix(_to,_b_proc,_prel_dst);
::             pominięcie koumnikatu o usunię powiązania argumentów jeśli istnieje inne powiązanie
::             dotyczy przypadku usnięcia strzałki i ponownego dodania przed zapisem procesu
               _msg_on:=~B_POCONN.first();
               B_POCONN.cntx_pop();
               {? _komm>0 & _msg_on
               || {? _can_continue
                  || _msg:='Automatycznie usunięto nieprawidłowe powiązanie argumentów: \'';
                     _msg+=' \''+_nam_from+' -> '+_nam_to+'\'';
                     _msg+=' (źródło: '+_sym_src;
                     _msg+=' , cel: '+_sym_dst+').';
                     KOMM.add(_msg,'xwin16.png:7',,1)
                  || _msg:='Nie udało się automatycznie usunąć nieprawidłowego powiązania argumentów: \'';
                     _msg+=' \''+_nam_from+' -> '+_nam_to+'\'';
                     _msg+=' (źródło: '+_sym_src;
                     _msg+=' , cel: '+_sym_dst+').';
                     KOMM.add(_msg,'xwin16.png:14',,1)
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};
   B_POCONN.cntx_pop();
   B_PREL.cntx_pop()
!}


\route_prelPorts2gate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Tworzy trasy portów wyjściowych elementu _a.PREL_SRC do bramy _a.B_PREL
::   WE: _a - exec('buffer','#b_choice')
::   WY: 0/1 - status powodzenia tworzenia tras
::----------------------------------------------------------------------------------------------------------------------
_buf_b_choice:=_a;
_b_conn:=_b;

:: 0-tryb sprawdzenia ciągłości trasy, 1-tryb zapisu trasy
_mode:=1;
:: Bramka
_b_prel:=_buf_b_choice.B_PREL;
:: Proces
_b_proc:=exec('FindAndGet','#table',B_PREL,$_b_prel,,"B_PREL.B_PROC",null());
:: Połączenie do bramy dla którego tworzone są trasy
_b_conn:=_b_conn;
:: Element źródłowy (czynność)
_prel_src:=_buf_b_choice.PREL_SRC;
:: Element docelowy (bramka)
_prel_dst:=_b_prel;
:: Element ogólny elementu procesu, z którego tworzone są trasy
_b_ele:=exec('FindAndGet','#table',B_PREL,$_prel_src,,"B_PREL.B_ELE",null());
:: Bufor połączeń portów (B_POCONN)
_buf_b_poconn:=exec('buffer','#b_poconn');

_continue:=1;

B_PORT.cntx_psh();
B_PORT.index('UNIK');
{! _ii:=1..2
|!
   {? _ii=1
:: statyczne porty wyjściowe
   || B_PORT.prefix(_b_ele,null(),null(),exec('kind_out','#b_port'))
:: dynamiczne porty wyjściowe
   || B_PORT.prefix(null(),_prel_src,null(),exec('kind_out','#b_port'))
   ?};
   _loop:=B_PORT.first();
   {!
   |? _loop
:: Iteracja po portach wyjściowych elementu źródłowego
   |!
      _port_src:=B_PORT.ref();
::    Ustalenie portu docelowego dla portu źródłowego
      _port_dst:=exec('portdst4portsrc','#b_poconn',_b_proc,_prel_src,_port_src,_prel_dst);
      {? _port_dst=null()
      ||
::       Dodanie portu wejściowego odpowiadającego portowi wyjściowemu
         _port_dst:=exec('add_port2prel','#b_port',_port_src,_prel_dst);
         {? _port_dst=null()
::       Nie powiodło się dodanie portu wejściowego
         || _continue:=0
::       Dodanie powiązań portów i utworzenie tras
         ||
::          Dodanie połączenia portu wyjściowego elementu źródlowego z elementem docelowym
            _buf_b_poconn.blank(1);
            _buf_b_poconn.B_PROC:=_b_proc;
            _buf_b_poconn.B_CONN:=_b_conn;
            _buf_b_poconn.FROM:=_port_src;
            _buf_b_poconn.TO:=_port_dst;
            _buf_b_poconn.PREL_SRC:=_prel_src;
            _buf_b_poconn.PREL_DST:=_prel_dst;
            _b_poconn:=exec('add','#b_poconn',_buf_b_poconn);
::          Usunięcie tras dla połączenia
            exec('route_delete4bpoconn','#b_proute',_b_poconn);
::          Utworzenie tras portów wyjściowych elementu źródłowego do bramy
            _continue:=exec('route_create4bpoconn','#b_proute',_mode,_b_proc,_b_conn,_b_poconn,_prel_src,_prel_dst);
            {? _continue=0
            || exec('delete','#b_poconn',_b_poconn)
            ?}
         ?}
      ?};
      _loop:=_continue & B_PORT.next()
   !}
!};
B_PORT.cntx_pop();

_continue


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: !!!NIEWYKORZYSTYWANA!!! - Funkcja techniczna do wyświetlenia tras portów wyjściowych
::   WE: _a - B_PROC.SYMBOL
::----------------------------------------------------------------------------------------------------------------------

_Tab:=sql('
   select
      B_PROC.SYMBOL PROC,
      B_PROUTE.B_POCONN TRASA,
      B_PROUTE.B_CONN CONN,
      SRC.SYMBOL SRC,
      DES.SYMBOL DES,
      PSRC.SYMBOL PSRC,
      PDES.SYMBOL PDES,
      POSRC.SYMBOL POSRC,
      PODES.SYMBOL PODES
   from
      B_PROUTE
      join B_PROC using(B_PROUTE.B_PROC,B_PROC.REFERENCE)
      join B_CONN using(B_PROUTE.B_CONN,B_CONN.REFERENCE)
      join B_POCONN using(B_PROUTE.B_POCONN,B_POCONN.REFERENCE)

      join B_PREL as SRC using(B_POCONN.PREL_SRC,SRC.REFERENCE)
      join B_PREL as DES using(B_POCONN.PREL_DST,DES.REFERENCE)

      join B_PREL as PSRC using(B_CONN.FROM,PSRC.REFERENCE)
      join B_PREL as PDES using(B_CONN.TO,PDES.REFERENCE)

      join B_PORT as POSRC using(B_POCONN.FROM,POSRC.REFERENCE)
      left join B_PORT as PODES using(B_POCONN.TO,PODES.REFERENCE)
   where
      B_PROC.SYMBOL=\':_a\'
   order by
      1,2,3,4
   ',_a);
_wer:=_Tab.mk_sel();
_Tab.win_fld(_wer,,'PROC',,,15,,,'Proces'@);
_Tab.win_fld(_wer,,'TRASA',,,15,,,'Trasa'@);
_Tab.win_fld(_wer,,'CONN',,,15,,,'Połączenie'@);
_Tab.win_fld(_wer,,'SRC',,,15,,,'Z'@);
_Tab.win_fld(_wer,,'DES',,,15,,,'Do'@);
_Tab.win_fld(_wer,,'PSRC',,,15,,,'Pośredni z'@);
_Tab.win_fld(_wer,,'PDES',,,15,,,'Pośredni do'@);

_Tab.win_sel(_wer);
_Tab.select()


\log
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [19.02]
:: OPIS: log
::   WE: _a - PROC.ref();
::       _b - ilość przeanalizowanych B_POCONN
::       _c - wynik ciągłości tras portów wyjściowych
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_proc:=_a;
_poconn_count:=_b;
_result:=1;

_out:=fopen('b_proute.xml','Uw');
{? _out>0
||
   fwrite(_out,'<B_PROUTE>');
   fwrite(_out,'<B_POCONN-RESULT>'+$_result+'</B_POCONN-RESULT>');
   fwrite(_out,'<B_POCONN-COUNT>'+$_poconn_count+'</B_POCONN-COUNT>');
   B_PROUTE.cntx_psh();
   B_PROUTE.index('UNIK');
   B_PROUTE.prefix(_proc);
   _loop:=B_PROUTE.first();
   fwrite(_out,'<B_PROUTE-SIZE>'+$B_PROUTE.size()+'</B_PROUTE-SIZE>');
   fwrite(_out,'<B_CONN-B_POCONN>');
   {!
   |? _loop
   |!
      fwrite(_out,$B_PROUTE.B_CONN+$B_PROUTE.B_POCONN);
      _loop:=B_PROUTE.next()
   !};
   fwrite(_out,'</B_CONN-B_POCONN>');
   B_PROUTE.cntx_pop();
   fwrite(_out,'</B_PROUTE>');
   fclose(_out)
?}

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:09 1e2d74bf37dca14308eb34cc0344f036ec67ad3aa84bc2cb120ae332c93133999069897b06d9d398380112c8790d10ba9f62d6b23542428cce3dc933abad14304c46096492ffe988f0a045753c2ff2dd42f3759060ea06fb4c4f6d6fcebe370e590562d489022a30c6fd838f6f8d6ded74b7e9ad751b145a6fd72cc3ff28e818
