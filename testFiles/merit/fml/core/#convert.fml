:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: #convert.fml [17.00]
:: Utworzony: 18.12.2014
:: Autor: AK
::======================================================================================================================
:: Zawartość: Uniwersalne formuły do konwersji różnych typów danych
::======================================================================================================================


\str2val
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zamienia ciąg znaków na wartość będącą efektem wykonania formuły reprezentowanej przez ciąg znaków
::   WE: _a - ciag znakow
::       _b - menadżer procesów
::   WY: wartosc
::  OLD: \str2val/util.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')<>type_of(0) || _b:=0 ?};

{? _b || return(($_a)()) ?};

_str:=0;
_fml:=_a;

{? 1+_fml='\'' & _fml+1='\''
|| _fml:=1-_fml-1;
   _str:=1
?};

{? ~_str
|| ($_fml)()

|? _fml*'\''
|| _tmp:='';
   {!
   |? +_fml
   |! _char:=1+_fml;
      _fml:=1-_fml;
      _tmp+=_char;
      {? _char='\\' & (+_fml=0 | 1+_fml<>'\'')
      || _tmp+='\\'
      ?}
   !};
   ($('\''+_tmp+'\''))()

|| ($('\''+gsub(_fml,'\\','\\\\')+'\''))()
?}


\str2date
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2010]
:: OPIS: zamienia napis na date, format dziesiecioznakowy np. 2009.04.06, 2009-04-06, 12.04.2012
::   WE: _a - string w formacie 'yyyy*MM*dd' - gdzie * to dowolny znak lub
::            string w formacie 'dd*MM*yyyy' - gdzie * to dowolny znak
::       UWAGA. podanie innego formatu np. 8 znakowego zwróci datę zerową
::       _b -0 lub 1 - jezeli dzien jest wiekszy niz liczba dni w miesiacu to czy obcinac do maks. l. dni w msc.
::            (domyslnie 1)
::   WY: typ data w przypadku niepowodzenia date(0,0,0)
::  OLD: \zwr_date/podstawy.fml
::  OLD: \str2date/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('') || return(#0) ?};

_cut:={? var_pres('_b')<>type_of(0)  || 1 || {? _b<>0 & _b<>1 || 1 || _b ?} ?};
_wyn:=date(0,0,0);
{? +_a<>10 || return(_wyn) ?};
_nn:=_a;
_ch:=%(5+_nn+1);
_typ:={? _ch<48 | _ch>57 || 'XXXX.XX.XX' || exec('getFormDig','#string',_a) ?};
{? _typ='XXXX.XX.XX'
|| _rr:=#(4+_nn); _nn:=5-_nn;  _mm:=#(2+_nn); _nn:=3-_nn;  _dd:=#(2+_nn)
|? _typ='XX.XX.XXXX'
|| _dd:=#(2+_nn); _nn:=3-_nn;  _mm:=#(2+_nn); _nn:=3-_nn;  _rr:=#(4+_nn)
|| return(_wyn)
?};

{?  _rr>0 & _mm<=12
||  {? _dd<=date(_rr,_mm,0)~3
    || _wyn:=date(_rr,_mm,_dd)
    || _wyn:=date(_rr,_mm,0);
       {? ~_cut
       || _poza:=_dd-_wyn~3;
          _wyn:=_wyn+_poza
       ?}
    ?}
?};
_wyn


\val2fml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS & TMR [17.00]
:: OPIS: Konwertuje wartość na formułę.
::   WE: _a - wartość
::       _b - typ
::       [_c] - akronim tabeli (tylko dla typu złączeniowego)
::   WY: treść formuły
::----------------------------------------------------------------------------------------------------------------------
_type:={? var_pres('_b')=-1 || return('') || _b ?};

{? _type=20
|| form(_a,,2,'9.')

|? _type=type_of(0)
|| form(_a,,0,'9.')

|? _type=type_of('')
|| _a:=gsub(_a,'\\','\\\\');
   '\''+gsub(_a,'\'','\\\'')+'\''

|? _type=type_of("")
|| _a:=_a+'';
   _a:=gsub(_a,'\\','\\\\');
   '\"'+gsub(_a,'\'','\\\'')+'\"'

|? _type=type_of(date())
|| 'date('+$(_a~1)+','+$(_a~2)+','+$(_a~3)+')'

|? _type=type_of(time())
|| 'time('+$(_a~1)+','+$(_a~2)+','+$(_a~3)+')'

|? _type=type_of(null())
|| {? _a=null()
   || 'null'
   || _tab:=_c;
      _uidref:=exec('FindAndGet','#table',_tab,$_a,,"uidref()",'');
      {? type_of(_uidref)=type_of('') & _uidref<>'' & do_state()<>2
      || '{| '+_tab+' |! cntx_psh; use(ref_name(\''+_uidref+'\')); clear; _vv:={? seek(\''+_uidref+'\')'
         +' || ref || ~~ ?}; cntx_pop; _vv |}'
      || '~~'
      ?}
   ?}

:: BLOB - specjalna obsługa tylko dla wartości przechowywanych w tabeli BI_PORT
|? _type=33
|| {? _a=null()
   || 'null'
   || _uidref:=exec('FindAndGet','#table',BI_BLOB,$_a,,"uidref()",'');
      {? type_of(_uidref)=type_of('') & _uidref<>'' & do_state()<>2
      || '{| BI_BLOB |! cntx_psh; use(ref_name(\''+_uidref+'\')); clear; _vv:={? seek(\''+_uidref+'\')'
         +' || ref || ~~ ?}; cntx_pop; _vv |}'
      || '~~'
      ?}
   ?}

:: MEMO - specjalna obsługa tylko dla wartości przechowywanych w tabeli BI_PORT
|? _type=36
|| 'BI_PORT.memo_txt(,1,\'SYS_MEMO\')'

|? _type=type_of(~~)
|| '~~'
|| ''
?}


\val2display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Konwertuje dowolną wartość na postać 'czytelną'
::   WE: _a - wartość
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
_type:=var_pres('_a');
{? _type=type_of('')
|| gsub(_a,'\n',' ')
|? _type=type_of(0) | _type=type_of(date()) | _type=type_of(null())
|| $_a
|? _type=type_of(time())
|| form(_a,,3)
|? _type=type_of("")
|| _a+''
|? _type=type_of(~~)
|| ''
|| ''
?}


\val2display1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Konwertuje dowolną wartość na postać 'czytelną' a reference jeszcze bardziej 'czytelną'
::   WE: _a - wartość
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
{? type_of(_a)=type_of(null())
|| exec('record','#to_string',_a)
|| exec('val2display','#convert',_a)
?}


\to_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca (za)wartość parametru dowolnego typu przekonwertowana do STRING'a
::   WE: ANY     _a - coś, co chcemy rozpisać do STRING'a
::       STRING [_b]- separator, domyślnie ', '
::       STRING [_c]- lewy nawias, domyślnie '{'
::       STRING [_d]- prawy nawias, domyślnie '}'
::       STRING [_e]- rekurencyjnie?
::       STRING [_f]- z nazwami pol?
::       STRING [_g]- data i czas bez nawiasów
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \to_string/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_simple:=0;
{? var_pres('_a')>100 || _arr:=_a || _simple:=1; _arr:=obj_new(1); _arr[1]:=_a ?};
_txt:='';
_sep:={? var_pres('_b')=2 || _b || ', ' ?};
_lbra:={? var_pres('_c')=2 || _c || '{' ?};
_rbra:={? var_pres('_d')=2 || _d || '}' ?};
_reqr:={? var_pres('_e')=2 || _e || ''  ?};
_nams:={? var_pres('_f')=2 || _f || ''  ?};
_nobr:={? var_pres('_g')=1 || _g || 0  ?};
_bbra:='';
:: sprawdzam czy wymagane nazwy
::{? _nams<>'' || _nams:=(!_a) ?};
:: sprawdzam czy tablica czy tabela
{? type_of(_arr)=type_of(SYSLOG)
||
   _bbra:={? _arr.name()<>'' & _arr.ref()<>null() || '#'+$_arr.ref()+'#' || '' ?};
   {! _ff:=1.._arr.fld_num()
   |! _type:=var_pres(_arr.fld_acr(_ff),_arr,'diff_blob');
      _txt+={? _type=20 || form(_arr[_ff],,,'9.')
            |? _type=21 || '['+form(_arr[_ff])+']'
            |? _type=22 || form(_arr[_ff],,,'99')
            |? _type=24 || '<HEAD>'
            |? _type=25 || '<MEMO>'
            |? _type=26 || {? _arr[_ff]<>null() || $_arr[_ff] || 'null()' ?}
            |? _type=27 || ''''+_arr[_ff]+''''
::            |? _type=28 || '?'
            |? _type=29 || '['+form(_arr[_ff],,3)+']'
            |? _type=30 || 'R'+$_arr[_ff]
            |? _type=32 || form(_arr[_ff],,,'99')
            |? _type=33 || '<BLOBRAW>'
            |? _type=36 || '<SYS_MEMO>'
            |? _type=37 || '<BLOBIMAGE>'
                        || '<'+$_type+'>'
            ?}+_sep
   !}
||
   _arr_type:=type_of(_arr);
   {! _pp:=1..obj_len(_arr)
   |! _type:=var_pres('['+form(_pp,,,'99')+']',_arr);
      _txt+={? _nams=''
            || ''
            || {? obj_ntab(_arr)
               || obj_ntab_names(_arr)[_pp]+': '
               || !(_arr[_pp])+'['+$_pp+']: '
               ?}
            ?}
           +{? _type=0        || '~~'
            |? _type=1        || form(_arr[_pp],,,'9.')
            |? _type=2        || ''''+form(_arr[_pp])+''''
            |? _type=3        || '"'+form(_arr[_pp])+'"'
            |? _type=4        || {? ~_nobr || '['+form(_arr[_pp])+']' || form(_arr[_pp],,2) ?}
            |? _type=5        || {? ~_nobr || '['+form(_arr[_pp],,3)+']' || form(_arr[_pp],,3) ?}
            |? _type=7        || {? _arr[_pp]<>null() || $_arr[_pp] || 'null()' ?}
            |? _type<0        || '###'
::            |? _type=133      || '<meth>'
            |? _type=_arr_type
             & _arr[_pp]=_arr || '&'
            |? _reqr<>''      || '<'+$_type+'>={'+exec('to_string','#convert',_arr[_pp],_sep,_lbra,_rbra,_reqr,_nams)+'}'
                              || '<'+$_type+'>'
            ?}+_sep
   !}
?};
{? +_bbra>0 || _bbra+=_sep ?};
{? _simple || _bbra+(_txt-(+_sep)) || _bbra+_lbra+(_txt-(+_sep))+_rbra ?}


\str2obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zmienia ciąg znaków na tablicę
::   WE: _a - STRING
::   WY: obj_new() / ~~
::----------------------------------------------------------------------------------------------------------------------
_size:=+_a;
_result:=~~;
{? _size>0
|| _result:=obj_new(_size);
   {! _it:=1.._size
   |! _result[_it]:=(_it+_a)+1
   !}
?};
_result


\MaskInt2RefSql
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.30]
:: OPIS: zwraca ref sql na postawie maski i ref-u(integer)
::   WE: _a - maska tabeli
::       _b - ref w postaci integer
::   WY: ref SQL
:: UWAGA. nie kontrolujemy poprawnosci masek
::  OLD: \narefsql/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
form(_a)+(-(('00000000'+BB.hex(_b))+8))


\sys2sys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.00]
:: OPIS: Konwertuje liczbę między systemami numerycznymi
::   WE: _a - prezentacja liczby
::       _b - system liczby _a (2..34)
::       _c - system liczby wynikowej (2..34)
::   WY: Zapis liczby wynikowej
::----------------------------------------------------------------------------------------------------------------------
{? _b<2 | _b>34 | _c<2 | _c>34
|| FUN.emsg('Nieprawidłowy system liczby.'@)
?};
_liczba:=exec('sys2ten','#convert',_a,_b);
exec('ten2sys','#convert',_liczba,_c)


\ten2sys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.00]
:: OPIS: Konwertuje liczbę między systemem dziesietnym a wskazanym
::   WE:  _a  - liczba w systemie dziesietnym
::        _b  - system liczbowy wynikowy (2..34)
::       [_c] - maksymalna liczba znaków w wyniku
::   WY: Zapis liczby wynikowej
::----------------------------------------------------------------------------------------------------------------------
_baza:='0123456789ABCDEFGHIJKLMNOPRSTUWXYZ';
{? _b>+_baza
|| FUN.emsg('Za duża baza liczby (max 34)'@);
   return(0)
?};
_wynik:='';
{? var_pres('_c')<=0 || _c:=6 ?};
{! _i:=_c//-1..1
|! _max:=pow(_b,_i);
   {? _a>=_max
   || _l:=int(_a/_max);
      _wynik+=((_l+1)+_baza)+1;
      _a:=_a-_l*_max
   ?}
!};
_wynik+=((_a+1)+_baza)+1;
_wynik


\sys2ten
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.00]
:: OPIS: Konwertuje liczbę między systemem wskazanym a dziesiętnym
::   WE:  _a  - liczba w podanym systemie (napis)
::        _b  - system liczby _a (2..34)
::   WY: liczba w systemie dziesiętnym
::----------------------------------------------------------------------------------------------------------------------
_baza:='0123456789ABCDEFGHIJKLMNOPRSTUWXYZ';
{? _b>+_baza
|| FUN.emsg('Za duża baza liczby (max 34)'@);
   return(0)
?};
_liczba:=0;
{! _i:=+_a//-1..1
|! _zn:=1+(_a+_i);
   _max:=pow(_b,_i-1);
   _poz:=(_baza*_zn)-1;
   _liczba+=_poz*_max
!};
_liczba


\str2time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Tworzy godzinę ze stringa
::   WE: _a  [STRING]   - string w formacie 'hh*mm' lub 'hh*mm*ss' - gdzie * to znak separatora
::      [_b] [STRING]   - znak separatora (domyślnie ':')
::      [_c] [ANY]      - wartość zwracana w przypadku gdy nie jesteśmy w stanie poprawnie
::                        zamienić przekazanego napisu na czas [domyślnie time(0,0,0)]
::   WY: czas - w przypadku niepowodzenia time(0,0,0)
::  OLD: \str2time/plan_kal.fml
::  OLD: \zwr_czas/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
_res:={? _>2 || _c || time(0,0,0) ?};
_str:={? var_pres('_a')=type_of('') || _a || return(_res) ?};
_sep:={? var_pres('_b')=type_of('') || _b || ':'          ?};

{? _>2
|| {! _ii:=1..+_str
   |! _ch:=(_ii+_str)+1;
      {? _ch<>_sep & (_ch<'0' | _ch>'9')
      || return(_res)
      ?}
   !}
?};

_godz:=_min:=_sek:=0;

_split:=spli_str(_str,_sep);
{? obj_len(_split)>=1
|| _godz:=#_split[1]
?};
{? obj_len(_split)>=2
|| _min:=#_split[2]
?};
{? obj_len(_split)>=3
|| _sek:=#_split[3]
?};

{? _godz>=0
|| {? _min>=0 & _min<60
   || {? _sek>=0 & _sek<60
      || _res:=time(_godz,_min,_sek)
   || _res:=time(_godz,_min,0)
      ?}
   || _res:=time(_godz,0,0)
   ?}
?};
_res


\parseTime
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [18.42]
:: OPIS: Tworzy wartość typu odstęp czasowy na podstawie napisu
::   WE: _a [STRING] - napis w formacie 'hh*mm' lub 'hh*mm*ss', gdzie * to znak separatora
::       _b [STRING] - (opcjonalny) znak separatora (domyślnie ':')
::   WY: odstęp czasowy lub wartość typu pustego w przypadku gdy napis jest niepoprawny
::UWAGA: str2time nie nadaje się do zastosowań, w których istotna jest kontrola poprawności argumentu _a
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('')
|| return()
?};

_str:=form(_a);
_sep:={? var_pres('_b')=type_of('') & _b<>'' || _b || ':' ?};

{! _ii:=1..+_str
|! _ch:=(_ii+_str)+1;
   {? _ch<>_sep & (_ch<'0' | _ch>'9')
   || return()
   ?}
!};

_str:=spli_str(_str,_sep);
_len:=obj_len(_str);
{? _len<2 | _len>3 | +_str[1]<1 | +_str[2]<>2 | (_len=3 & +_str[3]<>2)
|| return()
?};

_th:=#_str[1];
{? (_tm:=#_str[2])>=60 | (_ts:={? _len=3 || #_str[3] ?})>=60
|| return()
?};

time(_th,_tm,_ts)


\time2float
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Konwertuje czas podany w parametrze _a na liczbe godzin od 00:00.
::       Jezeli operacja sie nie powiedzie, np. parametr nie jest czasem, to wraca wartosc -1
::   WE: _a - konwertowany czas
::   WY: po konwersji
::  OLD: \time2float/printf.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=-1;
{? var_pres('_a')>0
|| {? type_of(_a)=5
   || _result:=_a~1 + (_a~2)/60 + (_a~3)/3600
   ?}
?};
_result


\float2time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Konwertuje czas technologiczny podany w parametrze na format czasowy czyli 000:00:00
::   WE: _a - REAL - liczba godzin
::   WY: TIME
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_value_real:=_a;
_result:=time(0,0,0);
{? _value_real>0 & _value_real<=32767
|| _sek:=(_value_real*3600)$0;
   _tm_sek:=_sek*exec('second','#tm_stamp');
   _result:=exec('tm_stamp2longtime','#tm_stamp',_tm_sek)
?};
_result


\time2min
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: zmienia czas na minuty
::   WE: _a - TIME - odstęp czasowy
::  OLD: \time2min/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_czas:=_a;
*_czas


\min2time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: zamienia minuty na czas
::   WE: _a - REAL - liczba minut
::  OLD: \min2time/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_min:=_a;
*_min


\str2real
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MZ [2008]
:: OPIS: zamienia STRING na REAL
::   WE: _a - STRING do zamiany
::       [_b] - separator tysięcy - domyślnie spacja
::  OLD: \str2real/portal.fml
::----------------------------------------------------------------------------------------------------------------------
_separator:={? var_pres('_b')=type_of('') || _b || ' ' ?};
_a:=gsub(_a,_separator,'');
_a:=gsub(_a,',','.');
#_a


\num_to_roman
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [17.00]
:: OPIS: Konwertuje liczbę na zapis rzymski (zwraca string)
::   WE: _a - liczba (integer)
::   WY: liczba w zapisie rzymskim
::  OLD: \num_to_roman/#string.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0 | type_of(_a)<>type_of(0) | _a<1 || return('') ?};
_rnum:='';
{! |?
   {? _a>=1000 || _rnum+='M';  _a-=1000
   |? _a>=900  || _rnum+='CM'; _a-=900
   |? _a>=500  || _rnum+='D';  _a-=500
   |? _a>=400  || _rnum+='CD'; _a-=400
   |? _a>=100  || _rnum+='C';  _a-=100
   |? _a>=90   || _rnum+='XC'; _a-=90
   |? _a>=50   || _rnum+='L';  _a-=50
   |? _a>=40   || _rnum+='XL'; _a-=40
   |? _a>=10   || _rnum+='X';  _a-=10
   |? _a>=9    || _rnum+='IX'; _a-=9
   |? _a>=5    || _rnum+='V';  _a-=5
   |? _a>=4    || _rnum+='IV'; _a-=4
   || _rnum+='I'; _a-=1
   ?};
   _a>0
!};
_rnum


\roman_to_num
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [17.00]
:: OPIS: Konwertuje liczbę w zapisie rzymskim (string) na liczbę (integer)
::   WE: _a - string z liczbą w zapisie rzymskim np. 'XIX'
::   WY: liczba (integer)
::  OLD: \roman_to_num/#string.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0 | type_of(_a)<>type_of('') | _a='' || return(0) ?};
_return:=0;
_rval:="{? -_a='i' || 1
        |? -_a='v' || 5
        |? -_a='x' || 10
        |? -_a='l' || 50
        |? -_a='c' || 100
        |? -_a='d' || 500
        |? -_a='m' || 1000
        || 0
        ?}";
_max:=+_a;
_tab:=obj_new(_max);
{! _i:=1.._max |!
   _tab[_i]:=exec('mid','#string',_a,_i,1)
!};
{! _i:=1.._max |!
   {? _i=_max | _rval(_tab[_i])>=_rval(_tab[_i+1])
   || _return+=_rval(_tab[_i])
   || _return-=_rval(_tab[_i])
   ?}
!};
_return


\str2date8
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PJ] [17.28]
:: OPIS: Zamienia napis na date, format 8-znakowy (same cyfry np. '20170522')
::   WE: _a - string w formacie 'yyyyMMdd'
::   WY: typ data, w przypadku niepowodzenia date(0,0,0)
::----------------------------------------------------------------------------------------------------------------------
_wy:=date(0,0,0);
{? _>0 & type_of(_a)=type_of('') & _a<>'' & +_a=8
|| _a:=form(_a);
   _year:=#(4+(_a));
   _month:=#(exec('mid','#string',_a,5,2));
   _day:=#(exec('mid','#string',_a,7,2));
   {? _year>1900 & _year<2100 & _month>0 & _month<=12 & _day>0 & _day<=31
   || no_msg(1);
      on_error(3);
      _data:=date(_year,_month,_day);
      {? in_error() || _wy:=date(0,0,0) || _wy:=_data ?};
      on_error(0);
      no_msg(0)
   ?}
?};
_wy


\time2str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [18.42]
:: OPIS: Zamienia czas na napis z podziałem dni, godzin, minut i sekund
::   WE: _a - wartość time
::   WY: napis DD dni, HH godz., MM min., SS sek. (w aktualnym języku interfejsu)
::----------------------------------------------------------------------------------------------------------------------
_res:='';
{? var_pres('_a')=type_of(time()) & _a<>time(0,0,0)
|| _dd:=(_a~1)%24;
   _hh:=(_a~1)%*24;
   _mm:=_a~2;
   _ss:=_a~3;
   _res:={? _dd>0 || form(_dd,,0,'99')+{? _dd=1 || ' '+'dzień'@+',' || ' '+'dni'@+',' ?} || '' ?}
        +{? _hh>0 || form(_hh,,0,'99')+' '+'godz.'@+',' || '' ?}
        +{? _mm>0 || form(_mm,,0,'99')+' '+'min.'@+',' || '' ?}
        +{? _ss>0 || form(_ss,,0,'99')+' '+'sek.'@+',' || '' ?};
   _res:=_res-1
?};
_res


\color_conv
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [17.00]
:: OPIS: Zwraca kolor w formacje RR:GG:BB
::   WE: _a - kolor w formacie hex
::  OLD: \color_conv/#pulpit.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0 || return('') ?};
_h2i:="
   _res:=0; _m:=1;
   {! _i:=1..+_a
   |! _x:=-(_a-(_i-1)+1);
      {? _x='0' || ~~
      |? _v:=#_x || _res+=_v*_m
      |? 'a'<=_x & _x<='f' || _res+=(%_x-87)*_m
      || return('')
      ?};
      _m:=_m*16
   !};
   form(_res,-3)
";
_h2i(2+_a)+':'+_h2i(_a-2+2)+':'+_h2i(_a+2)


\idtime2iso8601
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [20.14]
:: OPIS: Zamienia idtime na napis odpowiadający ISO8601 ('2017-05-10T11:03:31')
::   WE: _a [STRING] - wartość IDTIME
::   WY:     STRING  - napis określający czas wg standardu ISO8601
::----------------------------------------------------------------------------------------------------------------------
_idtime:={? var_pres('_a')=type_of('') & (+_a=31) || _a || return('') ?};
gsub(gsub(19+_idtime,'/','-'),' ','T')


\date2iso8601
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [20.14]
:: OPIS: Zamienia datę na napis odpowiadający ISO8601 ('2017-05-10T11:03:31')
::   WE: _a [DATE] - data
::       _b [TIME] - czas
::   WY:   STRING  - napis określający czas wg standardu ISO8601
::----------------------------------------------------------------------------------------------------------------------
_result:='null';
_data:={? var_pres('_a')=type_of(date) || _a || #0 ?};
_czas:={? var_pres('_b')=type_of(time) || _b || time(0,0,0) ?};
{? _data<>#0
|| _result:='%1T%2'[gsub($_data,'/','-'),_czas$3]
?};
_result


\iso_datetime_parse
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [21.37]
:: OPIS: Parsuje napis na obiekt zgodny z wynikiem funkcji iso_datetime_parse, z możliwością dodatkowego uwzględnienia
::       strefy czasowej w jakiej znajduje się Polska
::   WE: _a  [STRING] - napis określający czas wg standardu ISO8601
::      [_b] [NUMBER] - czy uwzględniać timezoneOffset jeżeli napis jest w UTC (na razie tylko dla Polski)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
 _s_time:={? var_pres('_a')=type_of('') || _a || '' ?};
_withTZO:={? var_pres('_b')=type_of(0)  || _b || 0  ?};

_dt:=iso_datetime_parse(_s_time);
{? _withTZO & _dt.tz='Z'
|| _ts:=exec('create','#tm_stamp',_dt.date,_dt.time);
   {? _ts>0
   || _offsetMin:=exec('timezoneOffset','#datetime',_dt.date,_dt.time,'m');
      _ts-=_offsetMin*exec('minute','#tm_stamp');
      _dt.date:=exec('tm_stamp2date','#tm_stamp',_ts);
      _dt.time:=exec('tm_stamp2time','#tm_stamp',_ts)
   ?}
?};
_dt


\ulamek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Formuła zwraca słowną reprezentacje ułamka zwykłego.
::   WE: _a [NUMBER] - Licznik [1;999].
::       _b [NUMBER] - Mianownik [1;999].
::   WY: Słowna reprezentacja ułamka zwykłego lub ''.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) & int(_a)=_a & 0<_a & _a<1000
|| _licznik:=_a
|| return('')
?};
{? var_pres('_b')=type_of(0) & int(_b)=_b & 0<_b & _b<1000
|| _mianownik:=_b
|| return('')
?};

{? _licznik<10
|| _lstr:=spli_str('jedna|dwie|trzy|cztery|pięć|sześć|siedem|osiem|dziewięć','|')[_licznik]
|| _lstr:=STR.słownie(_licznik)
?};

_suf:=
   {? _licznik=1
   || "'a'"
   |? 1<_licznik & _licznik<5
   || "{? _a=2 || 'ie' || 'e' ?}"
   || "{? _a=2 || 'ich' |? _a=3 || 'ch' || 'ych' ?}"
   ?};

_mpom:=_mianownik;
_ms:=_mpom%100;
_mpom:=_mianownik-100*_ms;
_md:=_mpom%10;
_mj:=_mpom-10*_md;

_mstr:='';
{? _ms>0
:: Setki.
|| {? _md=0 & _mj=0
   || _mstr+=' '+
         {? _ms=2 || 'dwu'
         |? _ms=3 || 'trzech'
         |? _ms=4 || 'czterech'
         |? _ms>4 || STR.słownie(_ms)
         || ''
         ?}+
         'setn'+_suf(0)
   || _mstr+=' '+STR.słownie(_ms*100)
   ?}
?};
{? _md=1
:: Nastki.
|| _mstr+=' '+
      spli_str(
         'dziesiąt|jedenast|dwunast|trzynast|czternast|piętnast|szesnast|siedemnast|osiemnast|dziewiętnast','|'
      )[_mj+1]+_suf(0);
   _mj:=0
|? _md>1
:: Dziesiątki.
|| _mstr+=' '+
      spli_str(
         'dwudziest|trzydziest|czterdziest|pięćdziesiąt|sześćdziesiąt|siedemdziesiąt|osiemdziesiąt|dziewięćdziesiąt','|'
      )[_md-1]+_suf(0)
?};
{? _mj>0
:: Jedności.
|| _mstr+=' '+spli_str('pierwsz|drug|trzeci|czwart|piąt|szóst|siódm|ósm|dziewiąt','|')[_mj]+_suf(_mj)
?};

'%1 %2' [_lstr,|_mstr]


\msc_nazwa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [21.14]
:: OPIS: Funkcja zwraca napis będący nazwą miesiąca kalendarzowego
::   WE: _a  [INTEGER] - numer miesiąca
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_msc:={? var_pres('_a')=type_of(0) || _a || return(_result) ?};

_result:={? _msc=1  || 'Styczeń'
         |? _msc=2  || 'Luty'
         |? _msc=3  || 'Marzec'
         |? _msc=4  || 'Kwiecień'
         |? _msc=5  || 'Maj'
         |? _msc=6  || 'Czerwiec'
         |? _msc=7  || 'Lipiec'
         |? _msc=8  || 'Sierpień'
         |? _msc=9  || 'Wrzesień'
         |? _msc=10 || 'Październik'
         |? _msc=11 || 'Listopad'
         |? _msc=12 || 'Grudzień'
         || ''
         ?};
_result


\B2xB
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [21.14]
:: OPIS: Formuła dynamicznie konwertuje liczbę bajtów do najbardziej czytelnej postaci, zwracając odpowiadającą im
::       liczbę kilo- / mega- / giga- / tera- bajtów.
::   WE:  _a  [NUMBER] - Rozmiar jednostki informacji (w bajtach).
::       [_b] [NUMBER] - Sposób konwersji (patrz: https://pl.wikipedia.org/wiki/Jednostka_informacji):
::                        0 - przedrostki dwójkowe [domyślnie].
::                        1 - przedrostki dziesiętne.
::   WY: Tablica elementów nazwanych:
::          r [NUMBER] - rozmiar;
::          p [STRING] - przedrostek.
::----------------------------------------------------------------------------------------------------------------------
_size_in:=_a;
_tryb:={? var_pres('_b')=type_of(0) & (_a=0 | _a=1) || _a || 0 ?};

_dzielnik:={? _tryb || 1000 || 1024 ?};
_ret:=obj_new('r','p');
_ret.r:=_size_in;
_ret.p:='';

_jedn:=spli_str('kMGT');

{! _lp:=1 .. obj_len(_jedn)
|? {? _ret.r>_dzielnik
   || _ret.r/=_dzielnik;
      _ret.p:=_jedn[_lp];
      1
   ?}
!};

_ret


\x509_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [21.37]
:: OPIS: Zwraca wartość z pola użytkownika certyfikatu
::   WE: _a - napis z opisem uzytkownika
::       _b - poszukiwane pole
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_uri:=_a;
_fnd:=_b;
_lista:=spli_str(_uri,',');
{! _ii:=1..obj_len(_lista)
|! _el:=spli_str(_lista[_ii],'=');
   {? obj_len(_el)=2 & _el[1]=_fnd
   || return(_el[2])
   ?};
   &_el
!};
''

:Sign Version 2.0 jowisz:1048 2023/06/23 14:13:35 cd14a26df93bd479beae97388405faa63e8b38cb7cfc7324c97e072bace81055c74ea587ba94ea64cfe762f4923ba28b00d724d8d12982398a9445ca36d4578571d7398ae5450a74d9b521ee6eac317ae6c54a13a713fe46f3cf5c06dc28b55d68d694da558e005f4fab116457a3da32365010e265ded6d775da048f128c1018
