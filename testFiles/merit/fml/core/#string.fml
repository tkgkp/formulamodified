:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: #string.fml [17.00]
:: Utworzony: 17.12.2014
:: Autor: AK
::======================================================================================================================
:: Zawartosc: Uniwersalne operacje na łańcuchach (stringach)
::======================================================================================================================


\podziel_calosc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [2010]
:: OPIS: Dzieli podany string
::   WE:  _a  - string do analizy
::       [_b] - czy sprawdzać i podwajać znak ['] (T/N)
::   WY: zmieniony string
::  OLD: \podziel_calosc/skid.fml
::----------------------------------------------------------------------------------------------------------------------
{? _>=2  || {? type_of(_b)<>2 || _b:='N' ?} || _b:='N' ?};
_wyn:=_a;
{? +_a>121
||
   VAR_DEL.delete('__wyk');
   {!
   |? _wyn:=exec('podziel_string','#string',_wyn);__wyk=1
   !};
   VAR_DEL.delete('__wyk')
?};
{? _b='T'
||
   {? _wyn*''''>0
   || _wyn:=gsub(_wyn,'\'','\'\'')
   ?}
?};
_wyn


\podziel_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [2010]
:: OPIS: Dzieli podany string, jeżeli dłuzszy niż 121 znaków szuka spacji i dzieli po ostatniej znalezionej spacji,
::       gdy nie ma spacji dzieli ciag co 120 znaków
::   WE: string do analizy
::   WY: zmieniony string
::  OLD: \podziel_string/skid.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:='';
_str:=_a;
__wyk:=0;
{!
|?
   {? _str*'\n'>0 | +_str>121
   ||
      {? (_str*'\n')>0
      || _bstr:=(_str*'\n')+_str
      || _bstr:=_str;
         _str:=''
      ?};
      {? +_bstr>121
      ||
         _spacja:=0;{! _i:=120 //-1.. 0 |? _spacja:=_i;(1+(_i-_bstr))*' '=0 !};
         {? _spacja=0
         || _bstr:=(120+_bstr)+'\n'+((120)-_bstr)
         || _bstr:=((_spacja)+_bstr)+'\n'+((_spacja+1)-_bstr)
         ?};
         __wyk:=1
      ?};
      _wyn+=_bstr;
      _str:=(_str*'\n')-_str
   ?};
   _str*'\n'>0 | +_str>121
!};
_wyn+=_str;
_wyn


\chn_real
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Formuła zmieniająca przecinek na kropkę w napisie. Sprawdza czy napis zawiera poprawnie zapisaną liczbę różną
::       od 0
::   WE: _a - napis z przecinkiem
::       _b - 1 wynik ma być liczbą, 0 wynik ma być napisem
::  OLD: \chn_real/util.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=_a;
{? _przec:=_a*','
|| _a:=((_przec-1)+_a)+'.'+(_przec-_a)
?};
{? _b || _ret:=#_a || _ret:=_a ?};
_ret


\form
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Formatuje do LEWEJ i zwraca podany tekst (kolejne linie=kolejne parametry)
::   WE: STRING _a - 'LR' formatować do lewej, do prawej w przeciwnym wypadku do środka.
::       STRING _[2]... kolejne linijki tekstu
::   WY: sformatowany tekst
::  OLD: \form/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_lrc:={? _>0 & type_of(_a)=2
      || _a:=-_a;
         {? 'lr'*_a || _a || 'c'?}
      || 'c'
      ?};
_result:='';
_max:=0;
{! __:=2.._ |! {? type_of(_[__])=2 & _max<+_[__] || _max:=+_[__] ?} !};

{? _max>0
|| _fix:=' '*_max;
   {! __:=2.._
   |! {? type_of(_[__])=2
      || _result+={? _lrc='l' || _max+(_[__]+_fix)
                  |? _lrc='r' || (_fix+_[__])+_max
                              || _[__]
                  ?}+'\n'
      ?}
   !};
   _result:=_result-1
?};
_result


\valid_acronim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy podany ciąg znaków może być użyty jako akronim, np. elementu tablicy nazwanej
::   WE: _a - STRING
::       [_b] - maksymalna długość ciągu znaków domyślnie 31
::----------------------------------------------------------------------------------------------------------------------
_acr:=_a;
_max:={? var_pres('_b')=type_of(0) & _b>0 || _b || 31 ?};

_result:=1;

:: za długi akronim
{? +_acr>_max || return(0) ?};

:: Kolejne znaki
{! _it:=1..+_acr
|!
   _znak:=1+((_it-1)-_acr);

   {? _it=1
   ||
::    tylko literki
      {? %_znak<65 | %_znak>90 || return(0) ?}
   ||
::    literki, cyferki, podkreślenie
      {? %_znak<48 | %_znak>57 & %_znak<65 | %_znak>90 & %_znak<95 | %_znak>95 || return(0) ?}
   ?}
!};

_result


\wz_acronim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wzorzec na akronim
::----------------------------------------------------------------------------------------------------------------------
'Uu!'


\valid_acronim_desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Treść komunikatu o dozwolonej budowie akronimu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'Akronim musi rozpoczynać się od wielkiej litery.\n'
'Akronim może zawierać wielkie litery, cyfry i znaki podkreślenia.\n'
'Akronim nie może być dłuższy niż 31 znaków.'@


\mid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Formula wycina tekst ze stringu
::   WE: _a = tekst, _b - pozycja startowa, _ ile znakow
::   WY: wyciety tekst
::  OLD: \mid/skid_sap.fml
::----------------------------------------------------------------------------------------------------------------------
_temp:=(_b-1)-_a;
_c+_temp


\rb_nosp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [8.40]
:: OPIS: Usuwa spacje z napisu
::   WE: _a: Napis, z ktorego usuwamy spacje
::  OLD: \rb_nosp/skid_ror.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a<>'' || {! |? _a*' '>0 |! _pos:=_a*' '; _a:=((_pos-1)+_a)+(_pos-_a) !} ?}; _a


\chkForm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: tno [2006]
:: OPIS: funkcja sprawdza, czy podany parametrem tekst jest zgodny z zadanym drugim parametrem formatem.
::       W razie potrzeby wyswietlany jest komunikat o bledzie.
::
::       chkForm (string, format[, warning])
::
::       zapis formatu: %c - cyfra: '0' .. '9',
::                      %z - litera: 'a' .. 'z' oraz 'A' .. 'Z',
::                      %l - mala litera: 'a' .. 'z',
::                      %L - duza litera: 'A' .. 'Z',
::                      %% - znak '%',
::                      pozostale znaki odpowiadaja sobie.
::
::            Przykladowy format kodu pocztowego: '%c%c-%c%c%c',
::                        format rejestracji samochodowej: '%L%L%L%c%c%c%c'
::   WE: _a - string:STRING (sprawdzany tekst),
::       _b - format:STRING (format tekstu),
::       _c - warning:NUMBER (czy ma byc wyswietlana informacja o bledzie [1], czy nie [0]).
::
::   WY: typu NUMBER: 1 - tekst zgodny z formatem, 0 - tekst nie zgodny z formatem
::  OLD: \chkForm/format.fml
::----------------------------------------------------------------------------------------------------------------------
:: przepisanie formatu
_d:=_b;

:: czy zgodnosc
_e:=1;
:: licznik petli
_f:=1;

{!
|? _e & _d<>''
|!
  {? (_g:=1 + _d)='%'
  || _d:=1 - _d;
     {? (_g:=1 + _d) = 'c' || _e:=exec('isDigit', '#string', 1 + ((_f - 1) - _a))
     |? _g='z'             || _e:=exec('isLetter', '#string', 1 + ((_f - 1) - _a))
     |? _g='l'             || _e:=exec('isLetter', '#string', 1 + ((_f - 1) - _a), 1)
     |? _g='L'             || _e:=exec('isLetter', '#string', 1 + ((_f - 1) - _a), 2)
     |? _g='%'             || _e:=((1 + ((_f - 1) - _a)) = '%')
     || _e:=((1 + ((_f - 1) - _a)) = _g)
     ?}
  ||
     _e:=((1 + ((_f - 1) - _a)) = _g)
  ?};
  _d:=1 - _d;
  _f+=1
!};
{? ~_e & _>2 & _c=1
||
   _f:='';
   _d:=_b;
   {!
   |? _d <> ''
   |!
      {? (_g:=1 + _d)='%'
      ||
         _d:=1 - _d;
         {? (_g:=1 + _d)='c' || _f+='0'
         |? _g='z'             || _f+='z'
         |? _g='l'             || _f+='a'
         |? _g='L'             || _f+='A'
         |? _g='%'             || _f+='%'
         ||
            _f+=_g
         ?}
     ||
       _f+=_g
     ?};
     _d:=1 - _d
   !};
   FUN.info('Nieprawidłowy format.\n\nPrawidłowy format: %1.'@[ _f])
?};
_e


\isDigit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: tno [2006]
:: OPIS: funkcja sprawdza, czy podany parametrem znak jest cyfra
::       isDigit (char)
::   WE: _a - char:STRING (1 znak) (znak do sprawdzenia).
::   WY: typu NUMBER: 1 - znak jest cyfra, 0 - znak nie jest cyfrą.
::  OLD: \isDigit/format.fml
::----------------------------------------------------------------------------------------------------------------------

_a >= '0' & _a <= '9'


\isLetter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: tno [2006]
:: OPIS: funkcja sprawdza, czy podany parametrem znak jest litera takiego typu, jaki zostal zadany drugim parametrem
::       isLetter (char[, type])
::   WE: _a - char:STRING (1 znak) (znak do sprawdzenia),
::       _b - type:NUMBER (typ sprawdzania: 0 - dowolna litera, 1 - mala litera, 2 - duza litera)
::   WY: typu NUMBER: 1 - znak jest litera danego typu, 0 - znak nie jest litera danego typu.
::  OLD: \isLetter/format.fml
::----------------------------------------------------------------------------------------------------------------------

{? _ > 1
|| {? _b = 0 || _a >= 'A' & _a <= 'ż'
   |? _b = 1 || _a >= 'a' & _a <= 'ż'
   |? _b = 2 || _a >= 'A' & _a <= 'Ż'
   ||
      0
   ?}
||
   _a >= 'A' & _a <= 'ż'
?}


\revert
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Odwraca kolejność liter w podanym tekście
::   WE: STRING: _a
::   WY: STRING
::  OLD: \revert_string/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_src:=_a; _dst:=''; _len:=+_a; {! _cc:=1.._len |! _dst+=_src+1; _src:=_src-1 !}; _dst


\niptostr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK [17.00]
:: OPIS: Usuwa z ciagu znakow znaki '-'
::   WE: STRING: _a
::   WY: STRING
::  OLD: \niptostr/skid_kh.fml
::       \formnip/skid_ror.fml
::----------------------------------------------------------------------------------------------------------------------
_nap:=_a;
_dl:=+_nap;
_wyn:='';
_i:=0;
{!
|? _i<_dl
|! _i+=1;
   _zn:=(1+_nap);
   _nap:=(1-_nap);
   {? _zn<>'-' || _wyn+=_zn ?}
!};
_wyn


\strtosql
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [2006]
:: OPIS: modyfikuje format zapisu stringu gdy występuje \
::   WE: _a - string do zmiany
::  OLD: \strtosql/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------

_str:=_a;_wyn:='';
{? type_of(_a)=2 & _str*'\\'
|| {!
   |?
      _poz:=_str*'\\';
      _wyn+=_poz+_str+'\\';
      _str:=_poz-_str;
      _str*'\\'
   !};
   _wyn+=_str
|| _wyn:=_str
?};
_wyn


\wz_cyfry
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [2010]
:: OPIS: wzorzec na cyfry
::  OLD: \wz_cyfry/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
'9!'


\htm2win
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MZ [2008]
:: OPIS: Znaki html zamienia na znaki windy
::   WE: _a - txt to konwersji
::  OLD: \htm2win/skid
::----------------------------------------------------------------------------------------------------------------------
txt:='';
txt:=gsub(_a,'&amp;','&');
txt:=gsub(txt,'&quot;','"');
txt:=gsub(txt,'&#039;','//');
txt:=gsub(txt,'&lt;','<');
gsub(txt,'&gt;','>')


\count_substr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2011]
:: OPIS: zliczanie ilosci wystapienia danego podciagu w ciagu
::   WE: _a - string, _b - substring
::   WY: string wynikowy
::  OLD: \count_substr/lib_prod.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<2 || return(0) ?};
{? (+_a)<1 | (+_b)<1 || return(0) ?};
_string:=_a;
_cnt:=0;
_bdsl:=(+_b)-1;
{! |?
   _fnd:=_string*_b;
   {? _fnd>0
   ||
      _cnt+=1;
      _string:=(_fnd+_bdsl)-_string;
      1
   ||
      0
   ?}
!};
_cnt


\dotnotnum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2011]
:: OPIS: sprawdzenie czy w ciągu w dowolnym miejscu bezpośrednio po kropce występuje inny znak niż cyfra
::   WE: _a - string
::   WY: 1 - tak, 0 - nie
::  OLD: \dotnotnum/lib_prod.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<1 || return(0) ?};
{? (+_a)<1 || return(0) ?};
_string:=_a;
{! |?
   _fnd:=_string*'.';
   {? _fnd>0
   ||
      _string:=_fnd-_string;
      {? +_string>1
      ||
         {? ('0123456789'*(1+_string))=0
         ||
            return(1)
         ?}
      ?}
   ?}
!};
0


\repl_substr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2011]
:: OPIS: zamienia wszystkie wystapienia podciagu w ciagu na inny podciag
::   WE: _a - string, _b - substring zrodlowy, _c - substring docelowy
::   WY: string wynikowy
::  OLD: \repl_substr/lib_prod.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<3 || return(0) ?};
{? (+_a)<1 | (+_b)<1 || return(0) ?};
_string:=_a;
_cnt:='';
_bdsl:=(+_b)-1;
{! |?
   _fnd:=_string*_b;
   {? _fnd>0
   ||
      _cnt+=((_fnd-1)+_string)+_c;
      _string:=(_fnd+_bdsl)-_string;
      1
   ||
      _cnt+=_string;
      0
   ?}
!};
_cnt


\lines
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Dzieli podany tekst na linie. Zwraca tabelkę tymczasową zawierającą kolejne linie podzielonego tekstu.
::       Tekst jest dzielony wg spacji. Funkcja minimalizuje ilość podziałów wyrazów - jeśli wyraz jest
::       krótszy niż limit to nigdy nie zostanie urwany w połowie, tylko elegancko dodany w nowej linii
::   WE: _a - STRING - tekst który podzielić
::       _b - INTEGER - limit znaków w jednej linii - max 255
::       [_c] - STRING - zawartość pierwszej linii tekstu - dla wywołań rekurencyjnych
::   WY: tab_tmp() - tabelka tymczasowa zawierająca kolejne linie tekstu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_text:=_a;
_limit:=_b;

{? _limit>255
|| _limit:=255
?};

_line:='';
{? var_pres('_c')=type_of('')
|| _line:=_c;
   _line:=_limit+_line
?};

_lines:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'LP','INTEGER','Liczba porządkowa',
   'LINE','STRING[255]','Linia tekstu',
   'LEN','INTEGER','Długość wyrazu w linii'
);

{? +_text>_limit
||

:: Przekazana nazwa parametru jest dłuższa niż się zmieści w oknie więc tnę tą nazwę i dodaję
:: etykiety do okna żeby wyświetlić cały napis
   _split:=spli_str(_text,' ');
   _split_size:=obj_len(_split);
   {? _split_size>2
   ||
      _it:=1;
      {!
      |?
         _word:=_split[_it];
         _word_size:=+_word;
         {? _word_size>_limit
         ||
::          Jeśli słowo przekracza rozmiar limitu i będzie cięte tak czy siak
::          to je tnę bez spacji
            {? var_pres('_rec_tab')>100
            || obj_del(_rec_tab)
            ?};
::          !!! REKURENCJA !!!
            _rec_tab:=exec('lines','#string',_word,_limit,_line);

            _rec_size:=_rec_tab.size();
            {? _rec_tab.first()
            || _rec_it:=1;
               {!
               |?
                  {? _rec_size=_rec_it
                  ||
::                   Ostatniej linii z wywołania rekurencyjnego nie dodaję od razu,
::                   tylko dopisuję jako początek nowej linii która może być kontynuowana
::                   po to by zachować ciągłość tekstu
                     _line:=_rec_tab.LINE
                  ||
::                   Dodaje linie z wywołania rekurencyjnego
                     _lines.blank();
                     _lines.LINE:=form(_rec_tab.LINE);
                     _lines.LEN:=_rec_tab.LEN;
                     _lines.LP:=_lines.size();
                     _lines.add()
                  ?};
                  _rec_it+=1;
                  _rec_tab.next()
               !}
            ?};
::          Przetworzyłem to słowo już więc je czyszczę, żeby nie dodawać ponownie
            _word:=''
         ?};

::       Sprawdzam czy to co mam do tej pory plus następny wyraz
::       przekroczy dopuszczalny rozmiar linii
         _next:='';
         _next_size:=0;
         {? _it+1<=_split_size
         || _next:=_split[_it+1];
            _next_size:=+_next
         ?};

         {? +(_line+_word+' '+_next)>_limit
         ||
::          Następny wyraz spowoduje przekroczenie limitu więc dodaję wiersz do wyniku
::          i zeruję linię
            {? _line<>''
            || {? _word<>''
               || _line+=_word+' '
               ?};
::             Jeśli następny wyraz będzie i tak dzielony to nie dodaję nowej linii
::             tylko tworzę jej zaczątek
               {? _next_size>_limit
               || _line+=' '
               ||
                  _lines.blank();
                  _lines.LINE:=form(_line);
                  _lines.LEN:=+_line;
                  _lines.LP:=_lines.size();
                  _lines.add();
                  _line:=''
               ?}
            || _line+=_word+' '
            ?}
         ||
::          Mogę dodać następny wyraz do bieżącej linii
            _line+=_word+' '
         ?};
         _it+=1;
         _it<=_split_size
      !};
      {? _line<>''
      || _lines.blank();
         _lines.LINE:=form(_line);
         _lines.LEN:=+_line;
         _lines.LP:=_lines.size();
         _lines.add()
      ?}
   ||
::    Słowo bez spacji - tnę je po prostu na równe kawałki i dodaję do wyniku
      _text_size:=+_text;
      _text_left:=_text_size;

      _cut_pos:=0;
      _left_line:=_limit-(+_line);

      _line+=_left_line+_text;
      _text_left-=_left_line;
      _cut_pos:=_left_line;

      _lines.blank();
      _lines.LINE:=form(_line);
      _lines.LEN:=+_line;
      _lines.LP:=_lines.size();
      _lines.add();

      {!
      |? _line:=_limit+(_cut_pos-_text);

         _lines.blank();
         _lines.LINE:=form(_line);
         _lines.LEN:=+_line;
         _lines.LP:=_lines.size();
         _lines.add();

         _cut_pos+=_limit;
         _text_left-=_limit;
         _text_left>0
      !}
   ?}
||
:: Tekst jest mniejszy niż limit więc dodaję go jako jedną linię
   _lines.blank();
   _lines.LINE:=form(_text);
   _lines.LEN:=+_text;
   _lines.LP:=_lines.size();
   _lines.add()
?};
_lines


\filename
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [11.22]
:: OPIS: Formula wycina z podanej sciezki nazwe pliku
::   WE: _a = sciezka
::   WY: nazwa pliku
::  OLD: \filename/skid_sap.fml
::----------------------------------------------------------------------------------------------------------------------
_i:=+_a;
_next:=1;
{! |?
    _znak:=exec('mid','#string',_a,_i,1);
    {? _znak='/' | _znak='\\'
    || _next:=0;
       _a:=_i-_a
    ?};
    _i-=1;
    _i>=1 & _next
!};
_a


\text2print
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Funkcja usuwa z tekstu końce linii tabulacje i wielokrotne spacje.
::   WE: _a - Tekst do przetworzenia.
::   WY: Tekst przetworzony.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _przed:=form(_a) || return('') ?};

_patt:=obj_new(3);
_patt[1]:='\t';
_patt[2]:='\r';
_patt[3]:='\n';

_przed:=gsub(_przed,_patt,' ');
{!
|? _po:=gsub(_przed,'  ',' ');
   _po<>_przed
|! _przed:=_po
!};

_po


\memo2print
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Zwraca zawartość pola notatnikowego. Z tekstu usuwane są końce linii, tabulacje i wielokrotne spacje.
::   WE: _a - Alias do tabeli.
::       _b - Akronim pola notatnikowego (opcjonalnie).
::       _c - Wskazanie na rekord (opcjonalnie).
::  OLD: \memo/util.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(SYSLOG) || return('') ?};

_a.cntx_psh();
_a.prefix();

{? var_pres('_c')=type_of(null()) & _c
|| _a.seek(_c)
?};

_text:={? var_pres('_b')=type_of('') & _b<>'' || _a.memo_txt(,1,_b) || _a.memo_txt(,1) ?};
_text:=exec('text2print','#string',_text);

_a.cntx_pop();

_text


\fileext
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [12.30]
:: OPIS: Formula wycina z podanej sciezki rozszerzenie pliku
::   WE: _a = sciezka
::   WY: rozszerzenie pliku
::  OLD: \fileext/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
_i:=+_a;
_next:=1;
{! |?
    _znak:=exec('mid','#string',_a,_i,1);
    {? _znak='.'
    || _next:=0;
       _a:=_i-_a
    ?};
    _i-=1;
    _i>=1 & _next
!};
_a


\pwd_encode
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zakodowuje przekazane hasło za pomocą podanego klucza
::   WE: _a - STRING - hasło do zakodowania
::       _b - STRING - klucz do kodowania (UWAGA!!! - minimum 24 znaki!!!)
::   WY: STRING - zakodowane hasło
::  OLD: \pwd_encode/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_pwd:=_a;
_key:=_b;

_result:='';
_can_continue:=1;

{? +_key<24
|| FUN.emsg('Klucz szyfrujący powinien mieć co najmniej 24 znaki'@);
   _can_continue:=0
?};
::_pwd:=exec('pwd_characters','#string',_pwd,'encode');

{? _can_continue>0 & _pwd<>''
|| _lib:=lib_load_srv_jar('pwdcodec.jar');
   {? _lib>0
   || _decl_encrypt:=lib_decl(_lib,,'String','encrypt','String', 'String');
      {? _decl_encrypt>0
      || _result:=lib_call(_decl_encrypt,_pwd,_key)
      || _result:='%1 Nie udała się deklaracja metody: %2 '@['!!!BŁĄD_PWD_ENCODE:','encrypt']
      ?};
      lib_free(_lib)
   || _result:='%1 Nie udało się załadować biblioteki pwdcodec.jar na serwerze'@['!!!BŁĄD_PWD_ENCODE:']
   ?}
?};
_result


\pwd_decode
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [23.25]
:: OPIS: Odkodowuje przekazane hasło za pomocą podanego klucza
::   WE: _a - STRING - zakodowane hasło
::       _b - STRING - klucz do kodowania (UWAGA!!! - minimum 24 znaki!!!)
::   WY: STRING - odkodowane hasło
::  OLD: \pwd_decode/libfml.fml
::  OLD: \pwd_decode/skid_jar.fml
:: ~OST: INTMPDIR
::----------------------------------------------------------------------------------------------------------------------
_pwd:=_a;
_key:=_b;

_result:='';
_can_continue:=1;

{? +_key<24
|| FUN.emsg('Klucz szyfrujący powinien mieć co najmniej 24 znaki'@);
   _can_continue:=0
?};

{? _can_continue>0 & _pwd<>''
|| _lib:=lib_load_srv_jar('pwdcodec.jar');
   {? _lib>0
   || _decl_decrypt:=lib_decl(_lib,,'String','decrypt','String', 'String');
      {? _decl_decrypt>0
      || _result:=lib_call(_decl_decrypt,_pwd,_key)
      || _result:='%1 Nie udała się deklaracja metody: %2 '@['!!!BŁĄD_PWD_DECODE:','decrypt']
      ?};
      lib_free(_lib)
   || _result:='%1 Nie udało się załadować biblioteki pwdcodec.jar na serwerze'@['!!!BŁĄD_PWD_ENCODE:']
   ?}
?};
_result


\pwd_characters
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Zamienia niedozwolone znaki dla funkcji encode,decode
::   WE: _a - STRING - ciąg znaków w którym zamieniać
::       _b - STRING - tryb działania: encode,decode
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_str:=_a;
_mode:=_b;
{? _mode='encode'
|| {? _str*'>'>0
   || _str:=gsub(_str,'>','__l_e_s_s__')
   ?};
   {? _str*' '>0
   || _str:=gsub(_str,' ','__s_p_a_c_e__')
   ?};
   {? _str*'"'>0
   || _str:=gsub(_str,'"','__q_u_o_t_a__')
   ?};
   {? _str*'\''>0
   || _str:=gsub(_str,'\'','__a_p_o_s_t_r_o_p_h_e__')
   ?};
   {? _str*'\t'>0
   || _str:=gsub(_str,'\t','__t_a_b__')
   ?};
   {? _str*'\n'>0
   || _str:=gsub(_str,'\n','__e_n_t_e_r__')
   ?};
   ~~
|? _mode='decode'
|| {? _str*'__l_e_s_s__'>0
   || _str:=gsub(_str,'__l_e_s_s__','>')
   ?};
   {? _str*'__s_p_a_c_e__'>0
   || _str:=gsub(_str,'__s_p_a_c_e__',' ')
   ?};
   {? _str*'__q_u_o_t_a__'>0
   || _str:=gsub(_str,'__q_u_o_t_a__','"')
   ?};
   {? _str*'__a_p_o_s_t_r_o_p_h_e__'>0
   || _str:=gsub(_str,'__a_p_o_s_t_r_o_p_h_e__','\'')
   ?};
   {? _str*'__t_a_b__'>0
   || _str:=gsub(_str,'__t_a_b__','\t')
   ?};
   {? _str*'__e_n_t_e_r__'>0
   || _str:=gsub(_str,'__e_n_t_e_r__','\n')
   ?};
   ~~
?};
_str


\str_to_pth
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [2011]
:: OPIS: usuniecie znakow niedozwolonych w pth
::   WE: _a - symbol do zmiany
::   WY: zmieniony string
::  OLD: \str_to_pth/faktury.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=_a;
_wyn:=gsub(_wyn, '>', '');
_wyn:=gsub(_wyn, '<', '');
_wyn:=gsub(_wyn, '%', '');
_wyn:=gsub(_wyn, '$', '');
_wyn:=gsub(_wyn, '\\', '');
_wyn:=gsub(_wyn, '/', '');
_wyn:=gsub(_wyn, '*', '');
_wyn:=gsub(_wyn, '?', '');
_wyn:=gsub(_wyn, ':', '');
_wyn:=gsub(_wyn, '|', '');
_wyn:=gsub(_wyn, '(', '');
_wyn:=gsub(_wyn, ')', '');
_wyn:=gsub(_wyn, '[', '');
_wyn:=gsub(_wyn, ']', '');
_wyn:=gsub(_wyn, '{', '');
_wyn:=gsub(_wyn, '}', '');
_wyn


\instring
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Sprawdzenie, czy znaki z ciągu _b wystepują w ciągu _a
::   WE: _a - znaki dopuszczalne
::       _b - znaki badane
::   WY: 1 / 0
::  OLD: \instring/lib_prod.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{! _i:=1..+_b
|! _comp:=(_i+_b)+1;
   _res:=_a*_comp;
   {? _res=0 || return(0) ?}
!};
_res


\allActions
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Zwraca ciąg liter z wszystkimi kodami ASCII (bez polskich znaków) w formacie akcji dla okienka
::   WE: [_a] - znaki do usunięcia
::       [_b] - 1-tylko dla niepustej dziedziny 0-domyślnie dla obu
::   WY: ciąg liter w formacie akcji dla okienka
::----------------------------------------------------------------------------------------------------------------------
_del:={? var_pres('_a')=type_of('') || _a || '' ?};
_prf:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_len:=+_del;

_res:='';
{! _i:=65..90 |! _res+=(%_i)+(%(_i+32)) !};
_i:=1;
{! |? _i<=_len
|! _ch:=1+((_i-1)-_del);
   _res:=gsub(_res,_ch,'');
   _i+=1
!};

{? ~_prf || _res:=_res+':'+_res ?};
_res


\ascii_to_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Dekoduje zakodowany ciag znakow podanych jako parametr _a na stringa
::   WE: _a - zakodowany ciag znakow np '128;212;1;23'
::   WY: STRING - wynikowy napis
::  OLD: \asciiToString/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_split:=spli_str(_a,';');

{! _it:=1..obj_len(_split)
|! _word:=_split[_it];
   _ascii:=#_word;
   _letter:=%_ascii;
   _result+=_letter
!};
_result


\string_to_ascii
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Dekoduje ciag znakow podanych jako parametr _a na ciag kodow ASCII separowanych znakiem ';'
::   WE: _a - ciag znakow do zakodowania
::   WY: STRING - zakodowany ciag znakow np '128;212;1;23'
::  OLD: \stringToAscii/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? _>0
|| _length:=+_a;
   {! _current:=1.._length
   |! _result+=$(%(_current+_a+1))+';'
   !}
?};
_result


\string_to_unicode
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Dekoduje ciag znakow podanych jako parametr _a na ciag kodow ASCII separowanych znakiem ';'
::   WE: _a - ciag znakow do zakodowania
::   WY: STRING - zakodowany ciag znakow np '128;212;1;23'
::  OLD: \stringToAscii/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? _>0
|| _length:=+_a;
   {! _current:=1.._length
   |! _result+=$(^(_current+_a+1))+';'
   !}
?};
_result


\wz_constant
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wzorzec na stałą część redagowanego pola
::   WE: _a - STRING - stała cześć pola
::----------------------------------------------------------------------------------------------------------------------
_in:=_a;
_len:=+_in;
_out:='';
{! _it:=1.._len
|! _out+='\\'+(1+((_it-1)-_in))
!};
_out


\delspace
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.30]
:: OPIS: usuwa spacje z wartosci znakowej
::   WE: _a - string
::       [_b] - 0-z lewej i prawej (domyslnie) 1-tylko z lewej 2-tylko z prawej
::   WY: napis z usunietymi spacjami
::  OLD: \delspace/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
{? _>=2 || {? type_of(_b)<>1 || _b:=0 ?} || _b:=0 ?};

_space:=' ';

{? type_of(_a)<>2
|| _wyn:=_a
|| {? ~_b  || _wyn:=form(_a)
   |? _b=1 || _wyn:=|_a
   |? _b=2
   || _wyn:=_a;
      _len:=+_a;
      {!
      |? {? (_wyn+1)=_space
         || _wyn:=_wyn-1;
            _len-=1;
            _len>0
         || 0
         ?}
      !}
   || _wyn:=_a
   ?}
?};
_wyn


\uplowstr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.10]
:: OPIS: sprawdzenie czy podany ciag znakowy zawiera tylko male lub tylko duze litery
::   WE: _a - ciag znakowy
::       _b - 0-czy male litery 1-czy duze litery
::   WY: 1-jest dobrze 0-niestety
::  OLD: \uplowstr/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:={? _b || _a=(~-_a) || _a=(-~_a) ?};
_wyn


\get_str_size
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca liczbę Bajtów zajmowanych przez tekst (w formacie UTF-8)
::   WE: STRING _a - tekst
::   WY: liczba B
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::  OLD: \get_str_size/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_str:=_a;
_fname:=form(SYSLOG.tm_stamp(),,,'99')+'.tmp';
_file:=fopen(_fname,'Uw',1);
_size:=0;
{? _file>0
||
   fwrite(_file,_str);
   fclose(_file);
   _file:=fopen(_fname,'br',1);
   {? _file>0
   || _size:=fgetsize(_file)-2;
      fclose(_file)
   ?};
   ferase(_fname,1);
   ~~
|| _size:=-1
?};
_size


\get_string_byte_size
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Oblicza rozmiaru tekstu w bajtach w reprezentacji w MacroBASE.
::       Nie korzysta z fizycznych plików, całe obliczenie jest wykonywane na plikach w pamięci.
::   WE: STRING _a - tekst
::   WY: liczba B
::----------------------------------------------------------------------------------------------------------------------
_str:=_a;
_chunk_size:=524172%5;
_file:=fopen(null,'w!',,, 1);
{? ~_file.is_open() || return(-1) ?};

{! |?
  _chunk:=_chunk_size+_str;
  _file.fwrite(iconv('exmazovia').to(_chunk));
  _str:=_chunk_size-_str;
  _str<>''
!};

_size:=_file.copy('b').fgetsize();

return(_size)


\getMetaVar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.28]
:: OPIS: Zwraca wartość z pola typu SYS_MEMO
::       wg schematu <TYTUŁ:WARTOŚĆ> lub wg schematu trzech określonych różnych meta znaków
::       Jeżeli dana wartość nie zostanie znaleziona to zwróci pusty znak lub błąd wywołania
::   WE: _a - akronim tabeli
::       _b - pole typu SYS_MEMO
::       _c - odpowiednik TYTUŁU
::       [_d] - ref rekordu lub domyślnie dany
::       [_e] - zestaw meta znaków trójka trzech różnych znaków, domyślnie '<:>'
::   WY: wartość lub ''
::----------------------------------------------------------------------------------------------------------------------
_res:='';

_title:={? var_pres('_c')=type_of('') || _c || '' ?};
_opis:='';
_ref:={? var_pres('_d')=type_of(null()) & _d<>null || _d || ($(_a+'.ref()'))() ?};
_err:=0;

{? var_pres('_e')=type_of('') & (+_e)=3
|| _be:=1+_e;
   _ae:=_e+1;
   _sp:=1+(1-_e);
   _err:=_be=_ae | _be=_sp | _ae=_sp
|| _be:='<';
   _ae:='>';
   _sp:=':'
?};

{? ~_err
||
:: pobranie wartości
   {| ($_a)()
   |! cntx_psh();
      _msk:=ref_name(_ref);
      {? _msk<>''
      || use(_msk);
         prefix();
         {? seek(_ref) || _opis:=memo_txt(0,1,_b) ?}
      ?};
      cntx_pop()
   |};
:: poszukiwanie wartości
   {? _opis<>'' & _title<>''
   || _ok:=1;
      {!
      |? _tyt:='';
         _war:='';
         _wsk:=_opis*_be;
         {? _wsk
         || _opis:=_wsk-_opis;
            _wsk:=_opis*_sp;
            {? _wsk
            || _tyt:=form((_wsk-1)+_opis);
               _opis:=_wsk-_opis;
               _wsk:=_opis*_ae;
               {? _wsk
               || _war:=form((_wsk-1)+_opis);
                  _opis:=_wsk-_opis
               ?}
            ?}
         || _ok:=0
         ?};
         {? _tyt=_title & _war<>''
         || _res:=_war
         ?};
         _ok & _res='' & +_opis
      !}
   ?}
?};
_res


\getFormDig
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.28]
:: OPIS: Zwraca format zapisu cyfr z kropkami
::       Każda wartość inna niż cyfra zapisywana jest jako '.', każda cyfra to 'X'
::   WE: _a - napis do analizy
::   WY: np. 'XX.XX.XXXX' lub ''
::----------------------------------------------------------------------------------------------------------------------
_str:={? var_pres('_a')=type_of('') || _a || '' ?};
_res:='';
{? +_str
|| {!
   |? _ch:=1+_str; _str:=1-_str;
      _res+={? exec('isDigit','#string',_ch) || 'X' || '.' ?};
      +_str
   !}
?};
_res


\random
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwraca losowy string
::   WE: _a - INTEGER - długość wygenerowanego stringu
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_len:=_a;

_result:='';

{! _it:=1.._len
|! _ascii:=65+(rand()*56)$0;
   _result+=%_ascii
!};
_result


\podziel_string_x
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Dzieli podany string, jezeli dluzszy niz X znakow szuka spacji i dzieli po ostatniej znalezionej spacji,
::       gdy nie ma spacji dzieli ciag co X-1 znakow
::   WE: _a - string do analizy
::       _b - Liczba znaków po przekroczeniu której będzie dzielony tekst
::   WY: zmieniony string
::----------------------------------------------------------------------------------------------------------------------
_wyn:='';
_str:=_a;
_lz:=floor(_b);
_lz_1:=_lz-1;
__wyk:=0;
{!
|?
   {? _str*'\n'>0 | +_str>_lz
   ||
      {? (_str*'\n')>0
      || _bstr:=(_str*'\n')+_str
      || _bstr:=_str;
         _str:=''
      ?};
      {? +_bstr>_lz
      ||
         _spacja:=0;{! _i:=_lz_1 //-1.. 0 |? _spacja:=_i;(1+(_i-_bstr))*' '=0 !};
         {? _spacja=0
         || _bstr:=(_lz_1+_bstr)+'- '+'\n'+((_lz_1)-_bstr)
         || _bstr:=((_spacja)+_bstr)+'\n'+((_spacja+1)-_bstr)
         ?};
         __wyk:=1
      ?};
      _wyn+=_bstr;
      _str:=(_str*'\n')-_str
   ?};
   _str*'\n'>0 | +_str>_lz
!};
_wyn+=_str;
_wyn


\strcut
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [20.42]
:: OPIS: Skraca podany ciąg znaków do zadanej długości. Jeśli była konieczność skrócenia i parametr pozwala
::       dodaje trzy kropki "…" na końcu.
::   WE: _a [STRING]  - pacjent (podany ciąg znaków)
::       _b [INTEGER] - maksymalna długość jaką może osiągnąć wynikowy ciąg znaków
::      [_c][INTEGER] - 0/1, czy dodawać trzykropek na końcu jeśli była konieczność skracania. Domyślnie 0.
::   WY: _ret [STRING] - skrócony ciąg znaków
::----------------------------------------------------------------------------------------------------------------------
_ret:={? var_pres('_a')=type_of('') || _a || '' ?};
_dl:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_tkr:={? var_pres('_c')=type_of(0) || _c || 0 ?};

{? +_ret>_dl
|| {? _tkr || _dl-=1 ?};
   _ret:=_dl+_ret;
   {? _tkr || _ret+='…' ?}
?};

_ret


\str2num
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MW [21.37]
:: OPIS: Zamiana napisu na liczbę, z obcięciem końcowych zanków napisu
::   WE: napis
::   WY: liczba
::----------------------------------------------------------------------------------------------------------------------
_num:=0;
_txt:=_a;
{!
|? _num:=#_txt;
   _txt:=_txt-1;
   +_txt>0 & _num=0
!};
_num


\valid_rule_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [21.37]
:: OPIS: Formuła sprawdza, czy przekazany ciąg jest prawidłową nazwą procedury do wykonania.
::       Zgodnie z dokumentacją:
::          Nazwa procedury może być dowolnym ciągiem znaków składających się z liter, cyfr i znaku podkreślenia,
::          który nie rozpoczyna się od cyfry. Nazwa nie może mieć więcej niż 31 znaków (zadeklarowane dłuższe nazwy
::          są obcinane do tej właśnie liczby).
::   WE: _a [STRING] - Badana nazwa.
::   WY: Napis pusty, jeżeli nazwa jest poprawna, lub przyczyna niepoprawności.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & +_a
|| _name:=_a
|| return('Nieprawidłowy parametr wywołania.')
?};

{! _lp:=1 .. +_name
|! _znak:=1+((_lp-1)-_name);
   {? ~(_znak='_' | exec('isLetter','#string',_znak) | (_lp>1 & exec('isDigit','#string',_znak)))
   || return('"%1" nie jest prawidłową nazwą procedury (%2:%3).' [_name,$_lp,_znak])
   ?}
!};
{? +_name>31
|| 'Nazwa procedura ma więcej niż 31 znaków.'
|| ''
?}


\isAlphaNum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [23.25]
:: OPIS: funkcja sprawdza, czy podany parametrem znak jest cyfra lub dużą literą
::   WE: _a - char:STRING (1 znak) (znak do sprawdzenia).
::   WY: typu NUMBER: 1 - jest, 0 - nie jest.
::----------------------------------------------------------------------------------------------------------------------
_res:=exec('isDigit','#string',_a) | exec('isLetter','#string',_a,2);
_res


\is_uidref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Spawdza czy przekazany STRING jest prawdziwym uidrefem
::   WE: _a - STRING - string co do którego mamy podejrzenie że jest uidrefem
::   WY: 0 - nie jest
::       1 - jest
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_uidref:=_a;
_result:=0;

{? type_of(_uidref)=type_of('')
|| _tab:=ref_tab(_uidref);
   {? var_pres('_tab')>100
   || _result:=1
   ?}
?};
_result


\next_letter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [RR.xx]
:: OPIS: Zwraca kolejną literę względem tej przekazanej
::   WE:  _a  - STRING - litera
::       [_b] - INTEGER - [1]/-1 - kierunek zmiany wartości: dodawanie,odejmowanie
::   WY: STRING - następna litera lub '' jeżeli nie udało się ustalić
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_letter:=_a;
_dir:=1;
{? var_pres('_b')=type_of(0)
|| _dir:=_b
?};

_result:='';

{? (_letter>='A' & _letter<='Z') | (_letter>='a' & _letter<='z')
|| _num:=%_letter;
   {? _dir>0
   || _num+=1
   |? _dir<0
   || _num-=1
   ?};
   _result_candidate:=%_num;

   {? (_result_candidate>='A' & _result_candidate<='Z') | (_result_candidate>='a' & _result_candidate<='z')
   || _result:=_result_candidate
   ?}
?};
_result

:Sign Version 2.0 jowisz:1045 2023/07/27 11:26:01 114f2e5e7fe194742dfe9912b8e334df3c0e40b43cdcad2d3ccf80cb7d14f91d751936f996f3c41fae434daaa703db9e50f9c344784b6a87646d714a3f7d338a1a6ba905ce09b879de996084a82f26d8d3e6f4a2d12f54d443c0d05363c9751ae14ca30fdb47e0d47592964a80d25e50c8655b13494eea7d106bab91d9b918fa
