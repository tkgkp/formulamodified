:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: #datetime.fml [17.00]
:: Utworzony: 17.12.2014
:: Autor: AK
::======================================================================================================================
:: Zawartość: Uniwersalne operacje na dacie czasie
::======================================================================================================================


\NumberOfWeek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: liczy tydzien w miesiacu na podstawie daty
::   WE: _a - data
::       [_b] - sposób obliczenia tygodnia w roku:
::            0-pierwszy tydzień od początku roku niezależnie od jego długości
::            1-pierwszy tydzień - pierszy pełny tydzień od poniedziałku do niedzieli w roku
::            2-(domyślnie)tydzień zawierający pierwszy czwartek roku jest pierwszym tygodniem roku i otrzymuje numer 1.
::              System jest zgodny z metodologią określoną w normie ISO 8601,
::              nazywany europejskim systemem numerowania tygodni.
::   WY: nr tygodnia dla zadanej daty
::  OLD: \nr_tyg/wysylki.fml
::       \week_num/kalend.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')<>type_of(1) || _b:=2 ?};
_wyn:=0;
{? _a<>date(0,0,0)
|| _pocz:=date(_a~1,1,1);
   _last:=date(_a~1,12,0);
   _nday:=(_pocz~4);
   _lday:=(_last~4);
   _add:=~_b | (_b=2 & _nday<=4);

   {? _b=2 & _nday>4 & _a<=(_pocz+7-_nday)
   || _wyn:=exec('NumberOfWeek','#datetime',_pocz-1,2)
   |? _b=2 & _nday<4 & _a<=(_pocz+7-_nday)
   || _wyn:=1
   |? _b=2 & _nday>4 & _lday>4 & _a>=(_last-_lday+1)
   || _wyn:=52
   |? _b=2 & _lday<4 & _a>=(_last-_lday+1)
   || _wyn:=1
   || _wyn:=((_a-(_pocz-(_nday)+1))%7)+{? _add || 1 || 0 ?}
   ?}
?};
_wyn


\CompareDateTime
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.30]
:: OPIS: porownuje dwa zestawy par daty i czasu
::   WE: _a - data 1
::       _b - czas 1
::       _c - data 2
::       _d - czas 2
::   WY: 0-rowne 1-pierwszy wiekszy 2-drugi wiekszy
::  OLD: \compdttm/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
{? _a>_c | (_a=_c & _b>_d) || _wyn:=1
|? _c>_a | (_a=_c & _d>_b) || _wyn:=2
?};
_wyn


\zwr_okr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2010]
:: OPIS: zwraca okres wg podanej daty i parametru
::   WE: _a - data
::       _b - 1-rok,2-miesiac,3-dzien,4-polrocze,5-kwartal,6-tydzien,7-cały rok
::     lub
::       _a - R-rok, P-półrocze, K-kwartał, M-miesiąc, D-dziń
::       _b - data
::   WY: liczba informujaca ... ktory to ;) lub 0-jeśli błędne parametry
::  OLD: \zwr_okr/podstawy.fml
::       \FZL.OKR_NR
::----------------------------------------------------------------------------------------------------------------------
_opc:=0;
_res:=0;
{? var_pres('_a')=type_of(date) & var_pres('_b')=type_of(0)
|| _data:=_a;
   _opc:=_b
|? var_pres('_a')=type_of('') & var_pres('_b')=type_of(date)
|| _data:=_b;
   _opc:={? _a='P' || 4
         |? _a='K' || 5
         |? _a='M' || 2
         |? _a='R' || 7
:: [rr] coś tu nie gra dla umów i złoszeń
::         |? _a='D' || 3
         || 2
         ?}
?};
{? _opc
|| _res:={? _opc<4 || _data~_opc
         |? _opc=4 || 1+((_data~2)>6)
         |? _opc=5 || (2+(_data~2))%3
         |? _opc=6 || _d0:=date(_data~1,1,1); _db:=_data; ((_db-_d0)+_d0~4+(7-_db~4))%7
         |? _opc=7 || 1
         || 0
         ?}
?};
_res


\timezoneOffset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja zwraca przesunięcie strefy czasowej w Polsce względem UTC dla przekazanej daty i godziny
::   WE: _a - data
::       _b - godzina
::       [_c] - 'h' - godziny (domyślnie), 'm' - minuty, 's' - sekundy
::   WY: przesunięcie czasowe w wybranych jednostkach czasu lub 0 jeżeli funkcja się nie powiedzie
::  OLD: \timezoneOffset/kalend.fml
::----------------------------------------------------------------------------------------------------------------------
_jedn:={? var_pres('_c')<>type_of('') || 'h' || _c ?};
_off:=0;
{? var_pres('_a')=type_of(date()) & var_pres('_b')=type_of(time())
|| _lastDM:=date(_a~1,3,0);
   _lastDO:=date(_a~1,10,0);
   _lastSM:={? _lastDM~4<>7 || date(_a~1,3,0)-_lastDM~4 || _lastDM ?};
   _lastSO:={? _lastDO~4<>7 || date(_a~1,10,0)-_lastDO~4 || _lastDO ?};
   _DST_s:=#(_lastSM$0+time(2,0,0)$0);
   _DST_e:=#(_lastSO$0+time(2,0,0)$0);
   _dt:=#(_a$0+_b$0);
   {? _dt>=_DST_s & _dt<_DST_e
   || _off:=-2
   || _off:=-1
   ?};
   {? _jedn='m'
   || _off:=_off*60
   |? _jedn='s'
   || _off:=_off*60*60
   ?}
?};
_off


\timeDiff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja wyliczająca różnicę w czasie
::   WE: _a - data początkowa
::       _b - godzina początkowa
::       _c - data końcowa
::       _d - godzina końcowa
::       [_e] - czy uwzględniać timezoneOffset (1/0) [domyślnie: 0-nie]
::       [_f] - zwraca samo przesunięcie timezoneOffset pomiędzy początkiem i końcem
::             (parametr _e nie ma wtedy znaczenia)
::   WY: różnica czasu pomiędzy podanymi datami i godzinami typu time(0,0,0)
::  OLD: \timeDiff/kalend.fml
::----------------------------------------------------------------------------------------------------------------------
_data_p:={? var_pres('_a')=type_of(date()) || _a || return(0) ?};
_godz_p:={? var_pres('_b')=type_of(time()) || _b || return(0) ?};
_data_k:={? var_pres('_c')=type_of(date()) || _c || return(0) ?};
_godz_k:={? var_pres('_d')=type_of(time()) || _d || return(0) ?};
_withTZO:={? var_pres('_e')=type_of(0)      || _e || _e:=0 ?};
_onlyTZO:={? var_pres('_f')=type_of(0)      || _f || _f:=0 ?};

{? _onlyTZO
|| _diff:=exec('timezoneOffset','#datetime',_data_k,_godz_k,'m')-exec('timezoneOffset','#datetime',_data_p,_godz_p,'m')
|| _diff:=(_data_k-_data_p); _diff*=24; _diff:=time(_godz_k~1+_diff,_godz_k~2,_godz_k~3)-_godz_p;
   _diff:=*_diff;
   {? _withTZO
   || _diff+=
         exec('timezoneOffset','#datetime',_data_k,_godz_k,'m')-
         exec('timezoneOffset','#datetime',_data_p,_godz_p,'m')
   ?}
?};
*_diff


\max_rok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.28]
:: OPIS: Zwraca maksymalną wartośc jaką może przyjąć parametr rok dla funkcji date()
::       - rok dla daty jest oparty na short int (max 32767)
::       - rok bardzo często jest wykorzystywany w maskach tabel, zakłada się więc, że będzie 4-o cyfrowy (max 9999)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
9999


\kwartal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KO [12.30]
:: OPIS: Ustalenie kwartału na podstawie numeru miesiąca
::   WE: _a - numer miesiąca
::  OLD: \ust_kwartal/szk_prac.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(0) | _a<1 | _a>12
|| return(0)
?};

{? _a<=3  || 1
|? _a<=6  || 2
|? _a<=9  || 3
|? _a<=12 || 4
?}


\date_in_interval
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Sprawdza, czy data _a mieści się w przedziale od _b do _c,
::       z tym, że date(0,0,0) oznaczają brak ograniczenia
::   WE: _a [DATE] - sprawdzana data
::       _b [DATE] - początek przedziału
::       _c [DATE] - koniec przedziału
::   WY: 0 - data nie miści się w przedziale / 1 - data mieści się w przedziale
::----------------------------------------------------------------------------------------------------------------------
_date:=_a;
_od:=_b;
_do:={? _c=date(0,0,0) || date(exec('max_rok','#datetime'),12,31) || _c ?};

_result:=(_date>=_od) & (_date<=_do);

_result


\time_multi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [21.37]
:: OPIS: Mnoży podaną wartość typu TIME
::   WE: _a [TIME] - wartość do pomnożenia
::       _b [INTEGER] - mnożnik
::   WY: _ret [TIME] - podana wartość pomnożona przez mnożnik
::----------------------------------------------------------------------------------------------------------------------
_ret:=time(0,0,0);
{! .._b
|! _ret+=_a
!};

_ret

:Sign Version 2.0 jowisz:1045 2021/09/17 15:17:04 a387fccb35544b8d0285dc87d5836c3c705a92368e4d314bb1ffc840ff15230aca84cc60ad4f82ba983f5df5db477ca48261aa0eb6981493a9076b57bb0de0c3cd6ccbb1af37f1912e1714ea00a7a6064913db61e7df2189d36b7cfcede85d3e6bcf9a0d470e1b9ceb7af172d4e05ba949519fba267a8df22ec2c0616508f92f
