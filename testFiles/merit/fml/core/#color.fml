:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: #Color.fml [17.00]
:: Utworzony: 17.12.2014
:: Autor: AK
::======================================================================================================================
:: Zawartość: Uniwersalne formuły do obsługi kolorów
::======================================================================================================================


\kolor_rand
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca losowy kolor w formacie '128:128:128'
::   WY: String koloru
::  OLD: \kolor_rand/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:='';
{? var_pres('__RGB')<0
|| __RGB:=obj_new('R','G','B');
   __RGB.R:=0;
   __RGB.G:=0;
   __RGB.B:=0
?};

__RGB.R:=_r:=((255*rand())#0+__RGB.R) %* 255;
__RGB.G:=_g:=((255*rand())#0+__RGB.G) %* 255;
__RGB.B:=_b:=((255*rand())#0+__RGB.B) %* 255;
_wyn:=$_r+':'+$_g+':'+$_b;
_wyn


\hex2dec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [17.00]
:: OPIS: Konwersja koloru w notacji 'hex' (kolor HTML) na natację 'dec' (kolor MacroBASE)
::   WE: _a kolor 'hex'
::   WY: kolor 'dec'
::----------------------------------------------------------------------------------------------------------------------
_dl:=+_a;
{? _dl<6 || return('') ?};
_kol:=obj_new(_dl);
{! _aa:=1.._dl |!
   _text:=(_aa+_a)+1;
   {? _text='A' | _text='a'
   ||
      _text:='10'
   |? _text='B' | _text='b'
   ||
      _text:='11'
   |? _text='C' | _text='c'
   ||
      _text:='12'
   |? _text='D' | _text='d'
   ||
      _text:='13'
   |? _text='E' | _text='e'
   ||
      _text:='14'
   |? _text='F' | _text='f'
   ||
      _text:='15'
   ?};
   _kol[_aa]:=_text
!};
_r:=$(16*#_kol[1]+#_kol[2]);
_g:=$(16*#_kol[3]+#_kol[4]);
_b:=$(16*#_kol[5]+#_kol[6]);
_color:=_r+':'+_g+':'+_b


\dec2hex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Konwersja koloru w notacji 'dec' (kolor MacroBASE) na notację 'hex' (kolor HTML)
::   WE: _a - STRING - kolor '128:128:128'
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_in:=_a;

_result:='#';
_split:=spli_str(_in,':');
_len:=obj_len(_split);
{? _len>0
|| {! _it:=1.._len
   |! _num:=#_split[_it];
      _result+=('0'+BIT.hex(_num))+2
   !}
?};
_result


\rgb2hsl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.42]
:: OPIS: Formuła konwertuje kolor podany poprzez parametry RGB na HSL.
::   WE: _a [NUMBER] - (R) Składowa czerwona -  wartość z przedzału: [0;255].
::       _b [NUMBER] - (G) Składowa zielona - wartość z przedzału: [0;255].
::       _c [NUMBER] - (B) Składowa niebieska - wartość z przedzału: [0;255].
::   WY: Tablica z elementami nazwanymi lub ~~ przy błędnym wywołaniu.
::       Struktura tablicy:
::          h [NUMBER] - Barwa - wartość z przedziału: [0;360].
::          s [NUMBER] - Nasycenie - wartość z przedziału: [0;100].
::          l [NUMBER] - Jasność - wartość z przedziału: [0;100].
::----------------------------------------------------------------------------------------------------------------------
_in:=obj_new('r','g','b');
_ok:=1;
{! _lp:=1 .. 3
|? _ok
|! {? var_pres('_[%1]' [$_lp])=type_of(0) & _[_lp]=int(_[_lp]) & _[_lp]>=0 & _[_lp]<=255
   || _in[_lp]:=_[_lp]/255
   || _ok:=0
   ?}
!};
{? ~_ok
|| return()
?};

_minRGB:=1;
_maxRGB:=0;
{! _lp:=1 .. 3
|! {? _in[_lp]<_minRGB
   || _minRGB:=_in[_lp]
   ?};
   {? _maxRGB<_in[_lp]
   || _maxRGB:=_in[_lp]
   ?}
!};
_delta:=_maxRGB-_minRGB;

_ret:=obj_new('h','s','l');
_ret.h:=_ret.s:=0;
_ret.l:=100*(_minRGB+_maxRGB)/2;

{? _delta>0
|| _ret.s:=100*_delta/{? _ret.l<50 || _minRGB+_maxRGB || 2-_minRGB-_maxRGB ?};
   _sr:=(((_maxRGB-_in.r)/6)+(_delta/2))/_delta;
   _sg:=(((_maxRGB-_in.g)/6)+(_delta/2))/_delta;
   _sb:=(((_maxRGB-_in.b)/6)+(_delta/2))/_delta;
   _ret.h:=
      {? _in.r=_maxRGB
      || _sb-_sg
      |? _in.g=_maxRGB
      || 1/3+_sr-_sb
      || 2/3+_sg-_sr
      ?};
   {? _ret.h<0
   || _ret.h+=1
   |? _ret.h>1
   || _ret.h_=1
   ?};
   _ret.h*=360
?};

_ret


\rgb2hsv
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.42]
:: OPIS: Formuła konwertuje kolor podany poprzez parametry RGB na HSV.
::   WE: _a [NUMBER] - (R) Składowa czerwona -  wartość z przedzału: [0;255].
::       _b [NUMBER] - (G) Składowa zielona - wartość z przedzału: [0;255].
::       _c [NUMBER] - (B) Składowa niebieska - wartość z przedzału: [0;255].
::   WY: Tablica z elementami nazwanymi lub ~~ przy błędnym wywołaniu.
::       Struktura tablicy:
::          h [NUMBER] - Barwa - wartość z przedziału: [0;360].
::          s [NUMBER] - Nasycenie - wartość z przedziału: [0;100].
::          v [NUMBER] - Moc światła - wartość z przedziału: [0;100].
::----------------------------------------------------------------------------------------------------------------------
_in:=obj_new('r','g','b');
_ok:=1;
{! _lp:=1 .. 3
|? _ok
|! {? var_pres('_[%1]' [$_lp])=type_of(0) & _[_lp]=int(_[_lp]) & _[_lp]>=0 & _[_lp]<=255
   || _in[_lp]:=_[_lp]/255
   || _ok:=0
   ?}
!};
{? ~_ok
|| return()
?};

_minRGB:=1;
_maxRGB:=0;
{! _lp:=1 .. 3
|! {? _in[_lp]<_minRGB
   || _minRGB:=_in[_lp]
   ?};
   {? _maxRGB<_in[_lp]
   || _maxRGB:=_in[_lp]
   ?}
!};
_delta:=_maxRGB-_minRGB;

_ret:=obj_new('h','s','v');
_ret.h:=_ret.s:=0;
_ret.v:=100*_maxRGB;

{? _delta>0
|| _ret.s:=100*_delta/_maxRGB;

   {? _in.r=_maxRGB
   || _ret.h:=(_in.g-_in.b)/_delta
   |? _in.g=_maxRGB
   || _ret.h:=2+(_in.b-_in.r)/_delta
   || _ret.h:=4+(_in.r-_in.g)/_delta
   ?};
   _ret.h*=60;
   {? _ret.h<0
   || _ret.h+=360
   ?}
?};

_ret


\hsl2rgb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.42]
:: OPIS: Formuła konwertuje kolor podany poprzez parametry HSV na RGB.
::   WE: _a [NUMBER] - Barwa - wartość z przedziału: [0;360].
::       _b [NUMBER] - Nasycenie - wartość z przedziału: [0;100].
::       _c [NUMBER] - Jasność - wartość z przedziału: [0;100].
::   WY: Tablica z elementami nazwanymi lub ~~ przy błędnym wywołaniu.
::       Struktura tablicy:
::          r [NUMBER] - Składowa czerwona -  wartość z przedzału: [0;255].
::          g [NUMBER] - Składowa zielona - wartość z przedzału: [0;255].
::          b [NUMBER] - Składowa niebieska - wartość z przedzału: [0;255].
::----------------------------------------------------------------------------------------------------------------------
_in:=obj_new('h','s','l');
{? var_pres('_a')=type_of(0) & _a>=0 & _a<=360
|| _in.h:=_a/360
|| return()
?};
_ok:=1;
{! _lp:=2 .. 3
|? _ok
|! {? var_pres('_[%1]' [$_lp])=type_of(0) & _[_lp]>=0 & _[_lp]<=100
   || _in[_lp]:=_[_lp]/100
   || _ok:=0
   ?}
!};
{? ~_ok
|| return()
?};

_ret:=obj_new('r','g','b');
_ret.r:=_ret.g:=_ret.b:=0;
{? _in.s=0
|| _ret.r:=_ret.g:=_ret.b:=_in.l*255$0
|| _v2:={? _in.l<0.5 || _in.l*(1+_in.s) || _in.l+_in.s-_in.s*_in.l ?};
   _v1:=2*_in.l-_v2;

   _h2rgb:=
      "  _v1:=_a;
         _v2:=_b;
         _vh:=_c;
         {? _vh<0
         || _vh+=1
         |? _vh>1
         || _vh-=1
         ?};
         {? 6*_vh<1
         || _v1+(_v2-_v1)*6*_vh
         |? 2*_vh<1
         || _v2
         |? 3*_vh<2
         || _v1+(_v2-_v1)*(2/3-_vh)*6
         || _v1
         ?}
      ";

   _ret.r:=(255*_h2rgb(_v1,_v2,_in.h+1/3))$0;
   _ret.g:=(255*_h2rgb(_v1,_v2,_in.h))$0;
   _ret.b:=(255*_h2rgb(_v1,_v2,_in.h-1/3))$0
?};

_ret


\hsv2rgb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.42]
:: OPIS: Formuła konwertuje kolor podany poprzez parametry HSV na RGB.
::   WE: _a [NUMBER] - Barwa - wartość z przedziału: [0;360].
::       _b [NUMBER] - Nasycenie - wartość z przedziału: [0;100].
::       _c [NUMBER] - Moc światła - wartość z przedziału: [0;100].
::   WY: Tablica z elementami nazwanymi lub ~~ przy błędnym wywołaniu.
::       Struktura tablicy:
::          r [NUMBER] - Składowa czerwona -  wartość z przedzału: [0;255].
::          g [NUMBER] - Składowa zielona - wartość z przedzału: [0;255].
::          b [NUMBER] - Składowa niebieska - wartość z przedzału: [0;255].
::----------------------------------------------------------------------------------------------------------------------
_in:=obj_new('h','s','v');
{? var_pres('_a')=type_of(0) & _a>=0 & _a<=360
|| _in.h:=_a/360
|| return()
?};
_ok:=1;
{! _lp:=2 .. 3
|? _ok
|! {? var_pres('_[%1]' [$_lp])=type_of(0) & _[_lp]>=0 & _[_lp]<=100
   || _in[_lp]:=_[_lp]/100
   || _ok:=0
   ?}
!};
{? ~_ok
|| return()
?};

_ret:=obj_new('r','g','b');
_ret.r:=_ret.g:=_ret.b:=0;
{? _in.s=0
|| _ret.r:=_ret.g:=_ret.b:=_in.v*255$0
|| _vh:=_in.h*6;
   {? _vh=6
   || _vh:=0
   ?};
   _vi:=floor(_vh);
   _v1:=_in.v*(1-_in.s);
   _v2:=_in.v*(1-_in.s*(_vh-_vi));
   _v3:=_in.v*(1-_in.s*(1-(_vh-_vi)));
   {? _vi=0
   || _ret.r:=_in.v;
      _ret.g:=_v3;
      _ret.b:=_v1
   |? _vi=1
   || _ret.r:=_v2;
      _ret.g:=_in.v;
      _ret.b:=_v1
   |? _vi=2
   || _ret.r:=_v1;
      _ret.g:=_in.v;
      _ret.b:=_v3
   |? _vi=3
   || _ret.r:=_v1;
      _ret.g:=_v2;
      _ret.b:=_in.v
   |? _vi=4
   || _ret.r:=_v3;
      _ret.g:=_v1;
      _ret.b:=_in.v
   || _ret.r:=_in.v;
      _ret.g:=_v1;
      _ret.b:=_v2
   ?};
   {! _lp:=1 .. 3
   |! _ret[_lp]:=_ret[_lp]*255$0
   !}
?};

_ret


\decl_color
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK [8.40]
:: OPIS: Deklaracja klasy COLOR
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('COLOR',@.CLASS)<0
|| obj_decl('COLOR',
:kolory
      obj_fld('f','0:0:0'),
::      obj_fld('b','255:172:89'),
      obj_fld('b',''),
      obj_fld('tf',''),
      obj_fld('tb',''),
:zalogowany uzytkownik
      obj_fld('user',''),
      obj_fld('klib',''),
:w tych polach przechowywane sa formuly ktora po wykonaniu zwracaja identyfikator koloru
:w okienku wertowania na rekord przed
      obj_fld('formula1',''),
:na wyswietl dla pola
      obj_fld('formula2',''),
:identyfikator dla okienek tymczasowych
      obj_fld('id_tmp','TAB_TYMCZ#01#01'),
      obj_fld('id_tmp2','TAB_TYMCZ#01#02'),
:identyfikator dla pol nieredagowalnych
      obj_fld('id_nrd','FLD_NRD#01#01'),
:identyfikator dla pol wyszarzonych
      obj_fld('id_nv','FLD_NV#01#01'),
:akronim okienka redakcyjnego tabeli UST_SYS
      obj_fld('oksys',''),
      obj_fld('ustwer',''),
      obj_fld('ustslo',''),
:ostatni prefiks identyfikatora - jak sie zmieni od nowa znajdywana jest formula
:w okienku wertowania na rekord przed
      obj_fld('prefiks1',''),
:na wyswietl dla pola
      obj_fld('prefiks2',''),
:kolory standardowe - czcionki i tla
      obj_fld('fonstand','0:0:0'),
      obj_fld('bcgstand','255:172:89'),
:ustawia kolor standardowy - _a - nowy kolor czcionki, _b - _tla
      obj_meth('setstkol',".fonstand:=_a; .bcgstand:=_b;~~"),
:ustawianie kolorow
      obj_meth('d_fon',".f"),
      obj_meth('d_bcg',".b"),
:LP przy dodawaniu rekordow do KOLTMP
      obj_fld('lp',0),
      obj_fld('lp_usr',''),
:zmienna, czy po dodawaniu miejsc wykorzystanie dopinac do nich schematy
      obj_fld('czy_ust',0),
:tabela tymczasowa - trzyma ustawienia kolorow - dla biezacego systemu i uzytkownika
:inicjowanie na starcie
:WE: _a - domyslny schemat kolorow
      obj_meth('ini_tmp1',"
         UST_MWYK.index('ID'); UST_MWYK.prefix();
         UST_S.index('US_NAZ'); UST_S.prefix();
         UST_KOL.index('UST_KOL2'); UST_KOL.prefix(UST_MWYK.ref(),.user,);
         .add_tmp(UST_KOL.first(),_a)
      "),
:dodawanie rekordow do tabeli KOLTMP
:WE: _a - 1/0 -  jest/nie jest ustawiony kolor, _b - kolor domyslny
      obj_meth('add_tmp',"_zwrot:=0;
                       KOLTMP.index('INDEX1');
                       {? ~KOLTMP.find_key(UST_MWYK.ID,UST_MWYK.ID)
                       || {? .lp_usr='' | .lp_usr<>.user
                          || KOLTMP.cntx_psh();
                             KOLTMP.index('INDEX3');
                             KOLTMP.prefix(.user,);
                             .lp:={? KOLTMP.last() || KOLTMP.LP || 0 ?};
                             KOLTMP.cntx_pop();
                             .lp_usr:=.user
                          ?};
                          .lp+=1;
                          KOLTMP.blank();
                          KOLTMP.USER:=.user;
                          KOLTMP.LP:=.lp; KOLTMP.AKT:=_a;
                          KOLTMP.ID:=UST_MWYK.ID;
                          KOLTMP.FORMULA:=UST_MWYK.FORMULA;
                          KOLTMP.OPIS:=translate(UST_MWYK.OPIS);
                          {? _a
                          || KOLTMP.FONT_KOL:=UST_KOL.UST_S().FONT_KOL;
                             KOLTMP.BCG_KOL:=UST_S.BCG_KOL;
                             KOLTMP.SCHEMAT:=UST_S.NAZWA
                          ?};
                          KOLTMP.SCH_DOM:=_b; _zwrot:=KOLTMP.add(1)
                       ?};
                       _zwrot
                       "),
:modyfikacje tabeli KOLTMP - przy zmianie parametrow koloru
:WE - _a - nazwa schematu kolorow
      obj_meth('akttmp',"KOLTMP.cntx_psh(); KOLTMP.index('INDEX2'); KOLTMP.prefix(.user,_a,_a);
                       {? KOLTMP.first()
                       || {! |?
                             KOLTMP.FONT_KOL:=UST_S.FONT_KOL;
                             KOLTMP.BCG_KOL:=UST_S.BCG_KOL; KOLTMP.put();
                             KOLTMP.next()
                          !}
                       ?};
                       KOLTMP.cntx_pop();
                       ~~
                       "),
::    Edycja koloru za pomocą systemowej kontrolki
::    WE:   [_a] - STRING - startowy kolor w edytorze w formacie '255:255:255'
::    WY:   STRING kolor wybrany przez użytkownika, lub '' jeżeli użytkownik zrezygnował
      obj_meth('edit',"

         _init:='';
         {? var_pres('_a')=type_of('')
         || _init:=_a
         ?};

         _result:='';
         {? exec('runtime_r10','#system')
         || _col:=dlg_color(_init)
         ||
            {? type_of(.klib)=type_of('')
            || _dll:=lib_load('mbutil.dll',1);
               {? _dll<>0
               || .klib:=lib_decl(_dll,,'char *','GetColor','char *')
               ?}
            ?};
            _col:=lib_call(.klib,_init)
         ?};
         {? type_of(_col)=type_of('') & _col<>''
         || _result:=_col
         ?};
         _result
      "),

::    Zmiana koloru
::    WE:   _a - INTEGER - tryb wyboru: 1 - kolor czcionki, 2 - kolor tła
::          _b - STRING - istniejący kolor w formacie '255:255:255'
      obj_meth('zmien_k',"
         {? _a<>1
         || _ok:=FUN.choice('Kolor tła'@,,'Wybierz'@,'Bez tła'@);
            {? _ok=1
            || _q:=.edit(_b);
               _ok:=_q<>''
            || _q:=''
            ?}
         || _q:=.edit(_b);
            _ok:=_q<>''
         ?};
         {? _ok
         || {? _a=1
            || .tf:=_q; UST_S.FONT_KOL:=.tf
            || .tb:=_q; UST_S.BCG_KOL:=.tb
            ?};
            UST_S.put();
            .akttmp(UST_S.NAZWA);
            .prefiks1:=.prefiks2:=''
         ?};~~
      ",type_of(1),type_of('')),
      obj_meth('__init',"
         _a.tf:=_a.f;
         _a.tb:=_a.b;
         _a.user:=app_info('app_user');
         ~~
      "),
      obj_meth('__done',"lib_free(.klib)"),
:zmiana usera
      obj_virt('zmien_user',"
         .user:=_a;
         ~~
      "),
:stworzenie okienka tymczasowego dla schematow kolorow
      obj_virt('sch_okn',"
         {? .ustwer=''
         || {! _i:=1..2
            |! _wer:=UST_S.mk_sel('Schematy kolorów'@,'P',,'ust_s_wer'+$_i,,,,,'U');
               UST_S.win_fld(_wer,,'NAZWA',,,,,,,,'Nazwa schematu kolorów'@);
               UST_S.win_fld(_wer,,'FONT_KOL',,,,,1,,,'Kolor czcionki schematu'@);
               UST_S.win_fld(_wer,,'BCG_KOL',,,,,1,,,'Kolor tła schematu'@);
               {? _i=2
               || UST_S.win_act(_wer,0,'Formuła','Wybierz'@@,,'Dołączanie schematu koloru.'@,\"sel_exit()\",,1,,,,'W');
                  UST_S.win_btn(_wer,'text=%1,btn_label_align=center,panel=right,align=begin'['Wybierz'@],'menu:W',,,,,,'noempty')
               ?};
               UST_S.win_act(_wer,0,'Dołącz',,,'Dołączanie schematu koloru.'@,,,_i=1);
               UST_S.win_act(_wer,0,'Popraw',,,'Poprawienie schematu koloru.'@,\"Color.ed_kol(2)\",\"Color.akt_mwyk(); 1\",);
               _fml:=\"Color.zmien_k(2,UST_S.BCG_KOL)\";
               UST_S.win_act(_wer,0,'Formuła','Zmień kolor &tła'@@,,'Ustawianie koloru tła.'@,,_fml,,,,,'T');
               UST_S.win_btn(_wer,'text=%1,btn_label_align=center,panel=right,align=begin'['Zmień kolor &tła'@],'menu:T');
               _fml:=\"Color.zmien_k(1,UST_S.FONT_KOL)\";
               UST_S.win_act(_wer,0,'Formuła','Zmień kolor &czcionki'@@,,'Ustawianie koloru czcionki.'@,,_fml,,,,,'C');
               UST_S.win_btn(_wer,'text=%1,btn_label_align=center,panel=right,align=begin'['Zmień kolor &czcionki'@],'menu:C');
               UST_S.win_act(_wer,0,'Usuń',,,'Usunięcie schematu koloru.'@,\"Color.ed_kol(1)\");
               UST_S.win_act(_wer,0,'Rekord',,,,,\"Color.rek_po()\");
               UST_S.win_act(_wer,1,'Dołącz',,,'Dołączanie schematu koloru.'@,,,1);
               UST_S.win_act(_wer,1,'Rekord',,,,,\"Color.rek_po()\");
               UST_S.win_act(_wer,,'Kolejność');
               {? _i=1
               || .ustwer:=_wer;
                  UST_S.win_sel(_wer)
               || .ustslo:=_wer
               ?}
            !}
         ?};
         ~~
      "),
:rekord po dla schematow kolorow - czy jest poprawna nazwa
      obj_virt('rek_po',"{? 1+UST_S.NAZWA='~'
                        || FUN.info('Nazwy kolorów zaczynające sie od znaku ''~''\nsą zastrzeżone.'@); 0
                        || _zwrot:=1; _user:=UST_S.USER; _nazwa:=UST_S.NAZWA;
                           {? -menu_txt='popraw' || _ref:=UST_S.ref() ?};
                           UST_S.cntx_psh();
                           UST_S.index('US_NAZ'); UST_S.prefix(_user,_user,_nazwa,_nazwa);
                           {? UST_S.first() & {? -menu_txt='popraw' || UST_S.ref()<>_ref || 1 ?}
                           || FUN.info('Istnieje już schemat o podanej nazwie.'@); _zwrot:=0
                           ?};
                           UST_S.cntx_pop(); _zwrot
                        ?}"),
:przed usuwaniem i poprawianiem schematow kolorow
:WE: _a=1 - usuwanie, 2-poprawianie
      obj_virt('ed_kol',"{? 1+UST_S.NAZWA='~'
                        || {? _a=1
                           || FUN.info('Kolor systemowy.\nUsuwanie zabronione.'@)
                           || FUN.info('Kolor systemowy.\nPoprawianie nazwy schematu zabronione.'@)
                           ?};
                           0
                        |? UST_S.count>0
                        || {? _a=1
                           ||  FUN.info('Kolor wykorzystywany.\nUsuwanie zabronione.'@)
                           ||  FUN.info('Kolor wykorzystywany.\nPoprawianie nazwy schematu zabronione.'@)
                           ?};0
                        || 1
                        ?}"),
:schematy kolorow - wyswietlenie okienka
      obj_virt('sch_kol',".akt_sch(); UST_S.index('US_NAZ');  UST_S.prefix(.user,.user); .sch_okn(); UST_S.select(,,,'W:W');~~"),
:aktualizacja tabeli tymczasowej - przy wejsciu do schematow kolorow
      obj_virt('akt_sch',"UST_S.index('US_NAZ');  UST_S.prefix(.user,.user);
                         {? UST_S.first() || {! |? .akttmp(UST_S.NAZWA); UST_S.next() !} ?};
                         .prefiks1:=.prefiks2:='';
                         ~~
                        "),
:przyporzadkowania schematow kolorow do zdarzen
      obj_virt('sch_wyk',"
         .akt_mwyk();
         KOLTMP.index('INDEX3');
         .ed_mwyk();
         {? var_pres('TTKOL')<=0
         || TTKOL:=tab_tmp(3,
               'LP','INTEGER','Lp.',
               'OPIS','STRING[90]','Opis',
               'REF','INTEGER',
            );
            KOLTMP.cntx_psh();
            KOLTMP.index('INDEX3');
            KOLTMP.prefix(.user,);
            {? KOLTMP.first()
            || {!
               |? TTKOL.LP:=KOLTMP.LP;
                  TTKOL.OPIS:=translate(KOLTMP.OPIS);
                  TTKOL.REF:=#KOLTMP.ref();
                  TTKOL.add();
                  KOLTMP.next()
               !}
            ?};
            KOLTMP.cntx_pop();
            _o:=TTKOL.mk_sel('Miejsca wykorzystania'@,'P',,'koltmp_wer1',,,,,'U');
            TTKOL.win_fld(_o,,'LP',,,4,,1,'Liczba porządkowa'@);
            TTKOL.win_fld(_o,,'OPIS',,,90,,1,'Opis'@,,'Opis miejsca wykorzystania'@);
            TTKOL.win_fld(_o,SKID,'KOLOR','NAZWA','US_NAZ',15,,,'Schemat kolorów'@,,'Schemat kolorów miejsca wykorzystania'@);
            TTKOL.win_act(_o,0,'Rekord',,,,\"KOLTMP.prefix();KOLTMP.seek(TTKOL.REF,); Color.dspkolor(); 0\",\"Color.src_mwyk(); Color.pop_mwyk()\");
            .akcjemw(_o,TTKOL);
            TTKOL.win_act(_o,,'Kolejność');
            TTKOL.win_sel(_o)
         ?};
         TTKOL.select();
         ~~
      "),
:aktualizacja tabeli tymczasowej
      obj_virt('akt_mwyk',"
         KOLTMP.cntx_psh();
         UST_S.cntx_psh();
         UST_MWYK.cntx_psh();
         UST_KOL.index('UST_KOL2'); UST_KOL.prefix();
         UST_MWYK.index('ID'); UST_MWYK.prefix();
         _kolor:=SKID.KOLOR;
         {? UST_MWYK.first()
         || {!
            |? {? UST_KOL.find_key(UST_MWYK.ref(),.user,.user)
               || SKID.KOLOR:=UST_KOL.UST_S;
                  UST_KOL.UST_S();
                  KOLTMP.index('INDEX1'); KOLTMP.prefix(.user,);
                  {? KOLTMP.find_key(UST_MWYK.ID,UST_MWYK.ID) || .pop_mwyk() ?}
               ?};
               UST_MWYK.next()
            !}
         ?};
         SKID.KOLOR:=_kolor;
         .prefiks1:=.prefiks2:='';
         UST_MWYK.cntx_pop();
         UST_S.cntx_pop();
         KOLTMP.cntx_pop();
         ~~
      "),
:przyporzadkowanie schematu kolorow do zdarzenia
      obj_virt('pop_mwyk',"
         _user:={? _ || _a || .user ?};
         UST_MWYK.cntx_psh();
         UST_KOL.cntx_psh(); UST_KOL.index('UST_KOL2');
         UST_MWYK.index('ID'); UST_MWYK.prefix(KOLTMP.ID,KOLTMP.ID);
         no_msg(1);
         {? UST_MWYK.first()
         || UST_KOL.prefix(UST_MWYK.ref(),_user,_user);
            {? UST_KOL.first() || UST_KOL.del() ?}
         ?};
         no_msg(0);
         UST_MWYK.cntx_pop();
         .form_put(UST_MWYK.ID,UST_MWYK.FORMULA,UST_MWYK.OPIS); .tput(0);
         {? SKID.KOLOR
         || SKID.KOLOR();
            UST_KOL.UST_S:=UST_S.ref();
            UST_KOL.UST_MWYK:=UST_MWYK.ref();
            UST_KOL.add(1);
            .tput(1)
         || .tput(2)
         ?};
         .prefiks1:=.prefiks2:='';
         UST_KOL.cntx_pop();
         KOLTMP.index('INDEX3');
         ~~
      "),
:modyfikacje tabeli KOLTMP
      obj_meth('tput',"{? _a=0
                    || KOLTMP.AKT:=0
                    |? _a=1
                    || KOLTMP.FONT_KOL:=UST_KOL.UST_S().FONT_KOL;
                       KOLTMP.BCG_KOL:=UST_S.BCG_KOL;
                       KOLTMP.SCHEMAT:=UST_S.NAZWA;
                       KOLTMP.AKT:=1
                    |? _a=2
                    || KOLTMP.FONT_KOL:=KOLTMP.BCG_KOL:=KOLTMP.SCHEMAT:=''; KOLTMP.AKT:=0
                    ?};
                    KOLTMP.put();~~"),
:wyswietlenie zawartosci pola SKID.KOLOR
      obj_virt('dspkolor',"UST_S.cntx_psh(); UST_S.index('US_NAZ'); UST_S.prefix(.user,.user);
                         SKID.KOLOR:={? UST_S.find_key(KOLTMP.SCHEMAT,KOLTMP.SCHEMAT)
                                     || UST_S.ref
                                     || null
                                     ?};
                         UST_S.cntx_pop();~~
                        "),
:na spacje w tabeli KOLTMP
      obj_virt('dspmwyk',"KOLTMP.win_edit(.oksys); ZMIENNE.TEXT:=translate(KOLTMP.OPIS); KOLTMP.display()"),
:Popraw na tabeli KOLTMP
      obj_virt('popsys',"
         UST_MWYK.cntx_psh();
         UST_MWYK.index('ID');
         UST_MWYK.prefix(KOLTMP.ID);
         {? UST_MWYK.first()
         || UST_MWYK.win_edit('RED');
            {? UST_MWYK.edit(\"chk_rec('OPIS')\")
            || UST_MWYK.put();
               .form_put(UST_MWYK.ID,UST_MWYK.FORMULA,UST_MWYK.OPIS)
            ?}
         ?};
         UST_MWYK.cntx_pop()
      "),
:Poprawiane rekordu w tabeli KOLTMP - dla zmienionej formuly WE: _a - ID, _b - nowa formula, _c - opis
      obj_virt('form_put',"KOLTMP.cntx_psh(); KOLTMP.index('INDEX1');
                         {? KOLTMP.find_key(_a,_a)
                         || KOLTMP.FORMULA:=_b; KOLTMP.OPIS:=translate(_c); KOLTMP.put()
                         ?};
                         KOLTMP.cntx_pop()
                        "),
:ustawienie formuly do sprawdzania  rekordow
:_a - prefiks ID
      obj_virt('znal_for',"KOLTMP.index('INDEX1'); KOLTMP.prefix(.user,_a);
                         _zwrot:='';
                         {? KOLTMP.first()
                         || {! |?
                               {? |KOLTMP.FORMULA<>''
                               || _zwrot:=|KOLTMP.FORMULA
                               ?};
                               _zwrot='' & KOLTMP.next()
                            !}
                         ?};
                         KOLTMP.prefix(.user,);_zwrot
                        "),
:rekord przed ustawienie koloru w zaleznosci od wyniku formuly - _a - prefiks ID
:jesli sie zmieni szuka od nowa formuly do kolorowania rekordow w okienku wertowania
      obj_virt('rekprzed',"params_set(params_get()); .srchfor1(_a)"),
:wyswietl dla pola - ustawienie koloru w zaleznosci od wyniku formuly - _a - prefiks ID
:jesli sie zmieni szuka od nowa formuly do kolorowania pola
      obj_virt('flddisp',"params_set(params_get()); .srchfor2(_a)"),
:wykorzystywane do szukania formuly w akcji na rekord przed
      obj_virt('srchfor1',"params_set(params_get());
                           _zwrot:='';
                           {? _a<>.prefiks1
                           || .prefiks1:=_a; .formula1:=.znal_for(.prefiks1)
                           ?};
                           {? .formula1<>''
                           || _wyk_for:=($('params_set(params_get()); '+.formula1))();
                              {? type_of(_wyk_for)=2 & _wyk_for<>''
                              || _zwrot:=.fnd_kol(_wyk_for)
                              ?}
                           || _zwrot:=''
                           ?}; _zwrot
                           "),
:wykorzystywane do szukania formuly w akcji na wyswietl dla pola
      obj_virt('srchfor2',"params_set(params_get());
                           _zwrot:='';
                           {? _a<>.prefiks2
                           || .prefiks2:=_a; .formula2:=.znal_for(.prefiks2)
                           ?};
                           {? .formula2<>''
                           || _wyk_for:=($('params_set(params_get()); '+.formula2))();
                              {? type_of(_wyk_for)=2 & _wyk_for<>''
                              || _zwrot:=.fnd_kol(_wyk_for)
                              ?}
                           || _zwrot:=''
                           ?}; _zwrot
                           "),
:szukanie koloru w tabeli tymczasowej
:_a - identyfikator
      obj_virt('fnd_kol',"KOLTMP.index('INDEX1'); KOLTMP.prefix(.user,_a,_a);
                          _zwrot:={? KOLTMP.first() & KOLTMP.AKT
                                  || KOLTMP.FONT_KOL+','+KOLTMP.BCG_KOL
                                  || ''
                                  ?};
                          KOLTMP.prefix(.user,);
                          _zwrot
                         "),
:dodaje rekord do tabel UST_SYS i UST_MWYK (jesli istnieje juz rekord w tabeli
:UST_MWYK o tym ID to tylko dodaje do UST_SYS)
:WE: _a - identyfikator, _b - formula, _c - opis, _d-schemat kolorow
      obj_virt('add',"
         {? type_of(_b)<>2 || _b:='' ?};
         {? type_of(_c)<>2 || _c:='' ?};
         {? var_pres('_d')<=0 || _d:='' ?};
         UST_MWYK.index('ID'); UST_MWYK.prefix();
         _new:={? ~UST_MWYK.find_key(_a,_a) || .a_mwyk(_a,_b,_c); 1
               |? UST_MWYK.FORMULA<>_b | UST_MWYK.OPIS<>_c || .p_mwyk(_a,_b,_c); 0
               ?};
         UST_KOL.cntx_psh();
         UST_KOL.index('UST_KOL2');
         UST_KOL.prefix(UST_MWYK.ref(),.user,);
         .czy_ust:=~UST_KOL.first();
         UST_KOL.cntx_pop();
         {? .ini_tmp1(_d)
         || {? _new
            || .ust_sch(_d,1);
               {? |_d<>'' || .new_mwyk(_d) ?}
            |? .czy_ust
            || .ust_sch(_d,1)
            ?}
         ?};
         return(.)
      "),
:ustawia schemat kolorow
:_a - nazwa schematu systemowego (z '~' na poczatku) - lub pusty string - schemat standardowy
:_b=0 - ustawia puste przyporzadkowanie jesli _a=''
      obj_virt('ust_sch',"UST_S.index('US_NAZ'); UST_S.prefix(.user,.user); _search:=0;
                    {? |_a<>''
                    || _search:=UST_S.find_key(_a); SKID.KOLOR:=UST_S.ref()
                    |? |_a='' & _b=1
                    || _search:=UST_S.find_key('~Standardowy'); SKID.KOLOR:=UST_S.ref()
                    |? |_a='' & _b=0
                    || _search:=1; SKID.KOLOR:=null
                    ?};
                    {? _search || .pop_mwyk() ?}
                   "),
:dla nowego miejsca wykorzystania ustawia kolor dla wszystkich uzytkownikow
      obj_virt('new_mwyk',"TAB_US:=tab_tmp(1,'USER','STRING[10]','');
                     _ind:=TAB_US.ndx_tmp('',1,'USER',,0,'USER',,0); TAB_US.index(_ind);
                     UST_S.cntx_psh(); UST_S.prefix();
                     {? UST_S.first()
                     || {! |?
                           {? UST_S.USER<>.user & ~TAB_US.find_key(UST_S.USER,UST_S.USER) || TAB_US.USER:=UST_S.USER; TAB_US.add() ?};
                           UST_S.next()
                        !}
                     ?};
                     UST_S.cntx_pop();
                     {? TAB_US.first()
                     || UST_S.index('US_NAZ');
                        {! |?
                           UST_S.prefix(TAB_US.USER,TAB_US.USER,_a);
                           {? UST_S.first() || SKID.KOLOR:=UST_S.ref(); .pop_mwyk(TAB_US.USER) ?};
                           TAB_US.next()
                        !}
                     ?};
                     VAR_DEL.delete('TAB_US')
                    "),
:dodaje rekord do UST_MWYK
:WE: _a - identyfikator, _b - formula, _c - opis
      obj_virt('a_mwyk',"UST_MWYK.ID:=_a; UST_MWYK.FORMULA:=_b;
                   UST_MWYK.OPIS:=_c; UST_MWYK.add(1)"),
      obj_virt('p_mwyk',"UST_MWYK.ID:=_a; UST_MWYK.FORMULA:=_b;
                   UST_MWYK.OPIS:=_c; UST_MWYK.put()"),
:ustawia kolor standardowe
      obj_meth('set_sys',"
         UST_S.cntx_psh();
         UST_S.index('US_NAZ');
         UST_S.prefix(.user,.user);
         {? ~UST_S.find_key(_a,_a) || .ust_s_add(.user,_a,_b,_c) ?};
         UST_S.cntx_pop();
      ~~"),


      obj_meth('add_std',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Metoda dodaje standardowe kolory.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  UST_S.index('US_NAZ');
      UST_S.prefix(.user,.user);
:: liczba schematow systemowych
      _size:=0;
:: formula sprawdzajaca i ewentualnie dodajaca schemat
      _ust_s:=\"
         {? ~UST_S.find_key(_b,_b)
         || _a.ust_s_add(_a.user,_b,_c,_d)
         ?}
      \";
::
:: _size+=1; _ust_s(.,'~<nazwa_schem>' ,'kolor_tlo__','kolor_front');
::
      _size+=1; _ust_s(.,'~Krytyczny',    '188:26:34',  '');
      _size+=1; _ust_s(.,'~Nieprawidłowy','153:147:0', '');
      _size+=1; _ust_s(.,'~Ostrzeżenie',  '0:69:173',  '');
      _size+=1; _ust_s(.,'~Standardowy',  '64:143:61',  '');
      _size+=1; _ust_s(.,'~Wyróżnienie 1','79:0:178',   '');
      _size+=1; _ust_s(.,'~Wyróżnienie 2','0:116:173',  '');
      _size+=1; _ust_s(.,'~Wyróżnienie 3','171:0:27',  '');
      _size+=1; _ust_s(.,'~Wyszarzenie',  '131:143:160','');
      {? UST_S.size()=_size
      || UST_KOL.index('UST_KOL1');
         UST_KOL.prefix(.user);
         .czy_ust:=~UST_KOL.first()
      ?};
      ~~
   "),
:dodaje rekord do UST_S
:WE: _a - uzytkownik, _b - nazwa, _c - kolor tla, _d - kolor fontu
      obj_virt('ust_s_add',"UST_S.USER:=_a; UST_S.NAZWA:=_b;
                      UST_S.FONT_KOL:=_c; UST_S.BCG_KOL:=_d;
                      UST_S.add(1);~~"),
:szuka miejsca wykorzystania (UST_MWYK i UST_SYS) dla KOLTMP i systemu
      obj_virt('src_mwyk',"
         UST_MWYK.index('ID');
         UST_MWYK.prefix();
         UST_MWYK.find_key(KOLTMP.ID,KOLTMP.ID)
      "),
:przywraca domyslne ustawienia schematow kolorow do miejsc wykorzystania
      obj_virt('dom_ust',"{? _ | FUN.ask('Przywrócić domyślne przyporządkowania\n'
                           'schematów kolorów do wszystkich miejsc wykorzystywania?'@)
                    || _ref:=KOLTMP.ref();
                       {? KOLTMP.first()
                       || {! |?
                            Color.src_mwyk(); Color.ust_sch(KOLTMP.SCH_DOM,1);
                            KOLTMP.next()
                          !}
                       ?};
                       KOLTMP.seek(_ref)
                    ?}"),
:dodaje okienka wertowania i edycyjne tabeli UST_SYS
      obj_virt('sel_mwyk',"
         {? KOLTMP.win_sel('?')=''
         || _wer:=KOLTMP.mk_sel('Miejsca wykorzystania'@,'P',,'koltmp_wer',,,,,'U');
            KOLTMP.win_fld(_wer,,'LP',,,4,,1,,,'Liczba porządkowa'@);
            KOLTMP.win_fld(_wer,,'OPIS',,,90,,1,'Opis'@,,'Opis miejsca wykorzystania'@);
            KOLTMP.win_fld(_wer,SKID,'KOLOR','NAZWA','US_NAZ',15,,,'Schemat kolorów'@,,'Schemat kolorów miejsca wykorzystania'@);
            .akcjemw(_wer);
            KOLTMP.win_act(_wer,,'Kolejność');
            KOLTMP.win_sel(_wer)
         ?}
      "),
      obj_virt('akcjemw',"
         _fml:=\"
            UST_S.cntx_psh();
            UST_S.index('US_NAZ');
            UST_S.prefix(Color.user,Color.user);
            Color.sch_okn();
            UST_S.win_sel(Color.ustslo);
            {? UST_S.select()
            || SKID.KOLOR:=UST_S.ref();
               Color.src_mwyk();
               Color.pop_mwyk()
            ?};
            UST_S.actions(UST_S.win_sel('?'),,'D');
            UST_S.cntx_pop()
         \";
         {? sec_superuser()
         || _b.win_act(_a,0,'Formuła','Popraw'@@,,'Edycja opisu i formuły'@,\"Color.popsys(); 0\",,,,,,'P')
         ?};
         _b.win_act(_a,0,'Formuła','Zmień s&chemat'@@,,'Przypisanie schematu kolorów'@,_fml,,1,,,,'Z');
         _b.win_btn(_a,'text=%1,btn_label_align=center,panel=right,align=begin'['Zmień s&chemat'@],'menu:Z');
         _b.win_act(_a,0,'Formuła','Wydruk'@@,,'Drukowanie ustawień'@,\"
                g_tt_e:=obj_new(KOLTMP.fld_num());
                g_tt_w:=obj_new(KOLTMP.fld_num());
                g_tt_p:=obj_new(KOLTMP.fld_num());
                {! _i:=1..KOLTMP.fld_num() |! 0; g_tt_w[_i]:=1; g_tt_e[_i]:=g_tt_p[_i]:=0 !};
                g_tt_e[2]:=g_tt_e[7]:=1; g_tt_w[2]:=70; g_tt_w[7]:=40;
                PAR_WYDR.TTMPAKR:='KOLTMP';
                PAR_WYDR.TITLE:='MIEJSCA WYKORZYSTANIA SCHEMATÓW KOLORÓW'@;
                exec('rep_exec','#b_report',,'wsp_tt',,,,,,,,'W');
                VAR_DEL.delete('g_tt_w','g_tt_e','g_tt_p');
                0
             \",,,,,,'W',,'icon=print');
         _fml:=\"Color.dom_ust(); 0\";
         _b.win_act(_a,0,'Formuła','Przywróć &domyślne'@@,,'Przywracanie domyślnych ustawień'@,_fml,,,,,,'D');
         _b.win_btn(_a,'text=%1,btn_label_align=center,panel=bottom,align=begin'['Przywróć &domyślne'@],'menu:D');
         _b.win_act(_a,0,'Formuła','K&opiuj ustawienia'@@,,'Kopiowanie ustawień od innego użytkownika'@,\"exec('kop_ust','#color',''); 0\");
         _b.win_act(_a,0,'Wyświetl',,,,\"Color.dspmwyk(); 0\");
         {? sec_superuser()
         || _b.win_act(_a,0,'Szukaj')
         ?};
         ~~
      "),
      obj_virt('ed_mwyk',"
         {? .oksys=''
         || _edit:=KOLTMP.mk_edit('Miejsca wykorzystania'@,,'koltmp_red');
            KOLTMP.win_efld(_edit,,'LP');
            KOLTMP.win_efld(_edit,,'ID');
            KOLTMP.win_efld(_edit,ZMIENNE,'TEXT');
            KOLTMP.win_efld(_edit,,'FORMULA');
            KOLTMP.win_edit(_edit);
            .oksys:=_edit
         ?}
      "),
      obj_meth('chng_kol',"
::----------------------------------------------------------------------------------------------------------------------
::   UTW: BZ [2009]
::  OPIS: Metoda zamienia postac koloru '255:255:255' na postac '#FFFFFF'
::    WE: _a - kolor w postaci '255:255:255'
::    WY: kolor w postaci '#FFFFFF'
::----------------------------------------------------------------------------------------------------------------------
         _wy:='#';
         STR.split(_a,':');
         {! ..3
         |! _hex:=BB.hex(#(STR.get_word()));
            {? +_hex=1 || _wy+='0'+_hex || _wy+=_hex ?}
         !};
         _wy
      ",type_of('')),

   )
?}


\kop_ust
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK [8.40]
:: OPIS: Kopiowanie ustawien od innego uzytkownika
::----------------------------------------------------------------------------------------------------------------------
KOL_USER:=tab_tmp(1,'USER','STRING[18]','Użytkownik'@);
_wer:=KOL_USER.mk_sel('Użytkownicy'@,,,'kol_user_wer');
KOL_USER.win_fld(_wer,,'USER');
KOL_USER.win_act(_wer,0,'Formuła','Wybierz'@@,,,"sel_exit(); 0",,1,,,,'W');
KOL_USER.win_sel(_wer);
UST_KOL.index('UST_KOL1'); UST_KOL.prefix();
_user:='';
{? UST_KOL.first()
|| {! |?
      _nuser:=UST_KOL.UST_S().USER;
      {? _nuser<>_user & _nuser<>Color.user
      || _user:=_nuser;
         KOL_USER.USER:=_user;
         KOL_USER.add()
      ?};
      UST_KOL.next()
   !}
?};
{? KOL_USER.first()
|| {? FUN.ask('Skopiować przyporządkowania schematów kolorów'
              '\ndo wszystkich miejsc wykorzystywania od innego użytkownika?'@)
   || {? KOL_USER.select()
      || _ref:=KOLTMP.ref();
         UST_KOL.index('UST_KOL2'); UST_KOL.prefix();
         {? KOLTMP.first()
         || {!
            |? _sch:=0;
               {? Color.src_mwyk() & UST_KOL.find_key(UST_MWYK.ref,KOL_USER.USER,KOL_USER.USER)
               || _sch:=UST_KOL.UST_S<>null;
                  {? UST_KOL.UST_S<>null
                  || UST_KOL.UST_S();
                     _kolor:=UST_S.NAZWA; _font:=UST_S.FONT_KOL; _bcg:=UST_S.BCG_KOL;
                     UST_S.cntx_psh(); UST_S.index('US_NAZ'); UST_S.prefix(Color.user,Color.user,_kolor,_kolor);
                     {? ~UST_S.first()
                     || UST_S.USER:=Color.user; UST_S.NAZWA:=_kolor;
                        UST_S.FONT_KOL:=_font; UST_S.BCG_KOL:=_bcg; UST_S.add()
                     || UST_S.FONT_KOL:=_font; UST_S.BCG_KOL:=_bcg; UST_S.put()
                     ?};
                     UST_S.cntx_pop()
                  ?};
                  KOLTMP.SCHEMAT:=UST_S.NAZWA; KOLTMP.BCG_KOL:=UST_S.BCG_KOL;
                  KOLTMP.FONT_KOL:=UST_S.FONT_KOL
               ?};
               _naz_sch:={? _sch<>0 || UST_S.NAZWA || '' ?};
               KOLTMP.AKT:=_sch; KOLTMP.put(); Color.ust_sch(_naz_sch,0);
               KOLTMP.next()
            !}
         ?};
         KOLTMP.seek(_ref)
      ?}
   ?}
|| FUN.info('Nie ma zdefiniowanych ustawień\ndla innych użytkowników.'@)
?};
obj_del(KOL_USER); UST_KOL.ndx_drop();
1


\use_color
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK [8.40]
:: OPIS: Wyswietlenie pola SKID.KOLOR
::----------------------------------------------------------------------------------------------------------------------
UST_S.FONT_KOL+','+UST_S.BCG_KOL


\set_font
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK  [8.40]
:: OPIS: Ustawienie koloru fontu
::----------------------------------------------------------------------------------------------------------------------
Color.d_fon()


\set_background
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK  [8.40]
:: OPIS: Ustawienie koloru tla
::----------------------------------------------------------------------------------------------------------------------
Color.d_bcg()


\decl_legend
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.00]
:: OPIS: Deklaracja obiektu LEGEND
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('LEGEND',@.CLASS)<0
|| obj_decl('LEGEND',
      obj_fld('user',''),
      obj_meth('__init',"_a.user:=app_info('app_user');~~"),
      obj_meth('zmien_user',"
         .user:=_a;
         ~~
      "),
      obj_meth('add',"
         KOLIKO.blank();
         {? var_pres('_d')=type_of('')
         || KOLIKO.FILE:=_d
         || KOLIKO.FILE:='xwin16.png'
         ?};
         {? var_pres('_b')=type_of(1)
         || KOLIKO.ICON:=_b
         |? var_pres('_b')=type_of('')
         || KOLIKO.NAZWA:=_b;
            KOLIKO.FILE:='*.ttf'
         ?};
         KOLIKO.USER:=.user;
         KOLIKO.ID:=_a;
         KOLIKO.OPIS:=_c;
         KOLIKO.add()
      ")
   );
   ~~
?}


\complementaryColors
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: zwraca kolor wg kolejnych dopełnień
::   WE: _a - numer koloru
::       [_b] - 1-bez drugiego wyrażenia 0(domyślnie)-z drugim
::----------------------------------------------------------------------------------------------------------------------
_dod:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_wsp:=199;

_dopel:=~(_a%*2);
_linit:={? _dopel || _a-1 || _a ?};
_ninit:=_linit%*6;
_ilwsp:=_linit%6;
_wyn:='';
{? _dopel
|| _color:=(_ilwsp*_wsp)%*256;
   {! _i..3
   |! _wyn+={? ((2*_i)-1)=_ninit
            || form(_color,,0,'99')
            || '255'
            ?}+':'
   !}
|| _color:=(_ilwsp*_wsp)%*256;
   {! _i..3
   |! _wyn+={? ((2*_i)-1)=_ninit
            || form(255-_color,,0,'99')
            || '0'
            ?}+':'
   !}
?};
_wyn:=(_wyn-1);
_wyn:=_wyn+{? ~_dod || ','+_wyn || '' ?};
_wyn


\contrast
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca kolor który jest kontrastowy do koloru podanego w parametrze
::   WE:  _a - STRING - kolor w formacie '255:255:255'
::       [_b] - INTEGER - tryb określania kontrastowego koloru
::                         1 - prosty wg średniej z kolorow RGB
::                         [2] - wg jasnosci obliczonej wg jakiegos standardu
::                         3 - max kontrast
::   WY: STRING - kolor kontrastowy w formacie '255:255:255'
::  OLD: \color_contrast/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_kolor:=_a;

_mode:=2;
{? var_pres('_b')=type_of(0)
|| _mode:=_b
?};

_result:='';

_black:='0:0:0';
_white:='255:255:255';

_split:=spli_str(_kolor,':');

_col_r:=#_split[1];
_col_g:=#_split[2];
_col_b:=#_split[3];

{? _mode=1
||
:: Obliczam srednidnia z RBG
   _srednia:=(_col_r+_col_g+_col_b)/3;
   {? _srednia<80
   ||
::    80 jest dobrane organoleptycznie - z reguły działa, ale zdarzają sie kolory dla których
::    jednak nie zadziala
      _result:=_white
   || _result:=_black
   ?}
|? _mode=2
||
:: Obliczam jasność wg jakiegoś standardu o którym czytałem w necie
   _brightness:=((_col_r*299)+(_col_g*587)+(_col_b*114))/100;
   {? _brightness<85
   || _result:=_white
   || _result:=_black
   ?}
|? _mode=3
||
:: Dla każdego składnika określam kontrastowa wartość
   _con_r:={? _col_r<128
           || 255
           || 0
           ?};
   _con_g:={? _col_g<128
           || 255
           || 0
           ?};
   _con_b:={? _col_b<128
           || 255
           || 0
           ?};
   _result:=$_con_r+':'+$_con_g+':'+$_con_b
?};
_result


\findfnv
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MM  [2006]
:: OPIS: Szuka w tabeli KOLTMP rekordu dla pól wyszarzonych
::  OLD: \findfnv/skid_kol.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('Color')>0 || Color.fnd_kol(Color.id_nv) || '' ?}


\findtmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK  [8.40]
:: OPIS: Szuka w tabeli KOLTMP rekordu dla tabel tymczasowych
::  OLD: \findtmp/skid_kol.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('Color')>0 || Color.fnd_kol(Color.id_tmp) || '' ?}


\findtmp2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MM  [8.70]
:: OPIS: Szuka w tabeli KOLTMP rekordu dla tabel tymczasowych (drugi kolor)
::  OLD: \findtmp2/skid_kol.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('Color')>0 || Color.fnd_kol(Color.id_tmp2) || '' ?}


\valid_rgb_dec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.14]
:: OPIS: Formuła sprawdza, czy podany parametr jest poprawnym napisem zawierającym kolor w formacie R:G:B.
::       Napis pusty NIE jest traktowany jako prawidłowy.
::   WE:  _a  [STRING] - Napis w formacie R:G:B (np. 255:255:255).
::       [_b] [NUMBER] - Tryb wsadowy (bez komunikatów).
::   WY: Wynik weryfikacji: 0/1, a w trybie wsadowym: '' lub przyczyna niepowodzenia,
::----------------------------------------------------------------------------------------------------------------------
_batch:=var_pres('_b')=type_of(0) & _b;
{? var_pres('_a')<>type_of('')
:: Typ (błąd techniczny).
|| _msg:='Nieprawidłowy typ parametru "%1".'@ ['KOLOR'];
   {? _batch
   || return(_msg)
   || FUN.emsg(_msg);
      return(0)
   ?}
?};

_fret:={? _batch || "_a" || "FUN.info(_a); 0" ?};
{? +_a<5
:: Długość (0:0:0 - 255:255:255).
|| return(_fret('Napis jest zbyt krótki.'@))
|? +_a>11
|| return(_fret('Napis jest zbyt długi.'@))

|? _kolor:=spli_str(_a,':');
   obj_len(_kolor)<>3
:: Budowa 1.
|| return(_fret('Nieprawidłowa budowa napisu.'@))

|? _err:='';
   {! _lp:=1 .. 3
   |? _err=''
   |! _val:=#_kolor[_lp];
      {? _val=0 & _kolor[_lp]<>'0'
      || _err:='Nieprawidłowa budowa składowej koloru %1 [%2].'@ [$_lp,_kolor[_lp]]
      |? _val<0 | _val>255
      || _err:='Nieprawidłowa wartość składowej koloru %1 [%2].'@ [$_lp,_kolor[_lp]]
      ?}
   !};
   _err<>''
|| return(_fret(_err))
?};

{? _batch
|| ''
|| 1
?}

:Sign Version 2.0 jowisz:1045 2023/10/20 15:22:55 299a778dbbab096bd0a8fab7b69a1a54109ec3ac343efb58661e0a2cf82e8ef5f2c9f2cea78fb49c3887239af278534d02be0e3852ed67689bebfe0c7dc26a45b6fe30b8413b703d0be2fa971550525ad742dbb94c365c9cb6578578e190b104dc9a571cac43166872645bbea8f23bccc6acb7da20baf7db8f000c7051133b2c
