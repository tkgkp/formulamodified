:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: #tree.fml [17.00]
:: Utworzony: 17.12.2014
:: Autor: AK
::======================================================================================================================
:: Zawartość: Uniwersalne formuły do obsługi drzewa
::======================================================================================================================


\del_tree_branch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Odcina elementy zależne od podanego węzła
::   WE:  _a  [TABLE]   - tabela
::        _b  [STRING]  - akronim pola TREE_REF
::       [_c] [STRING]  - akronim indeksu, w którym pierwsze pole jest _b, [ tworzony własny indeks tymczasowy ]
::        _d  [INTEGER] - wskazanie na rodzica
::       [_e] [RULE]    - formuła kasująca (tabela jest reprezentowana jako .tab [".tab.del()"]
::   WY: 1-ok / -<nr_bledu> - jezeli cos nie tak, to po numerze bledu mozna dojsc do przyczyny
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \del_tree_branch/libfml.fml
::----------------------------------------------------------------------------------------------------------------------
_tree:=obj_new('tab','del_tree');
_tree.tab:=_a;
_fld:=_b;
_ndx:={? var_pres('_c')=2 || _c || '' ?};
_parent:=_d;
_del_rule:={? var_pres('_e')=3 || _e || ".tab.del()" ?};

_tree.del_tree:=$("
                   .tab.cntx_psh();
                   .tab.prefix(_a);
                   _result:={? .tab.first()
                            ||
                               {!
                               |?
                                  .del_tree(#.tab.ref()) & ("+_del_rule+")
                               !};
                               .tab.first()=0
                            || 1
                            ?};
                   .tab.cntx_pop();
                   _result
                  "
                 );

_tree.tab.cntx_psh();
_ndx_drop:=0;
{? _ndx='' || _ndx_drop:=1; _ndx:=_tree.tab.ndx_tmp(,,_fld,,) ?};
_tree.tab.index(_ndx);
_result:=_tree.del_tree(_parent);
_tree.tab.cntx_pop();
{? _ndx_drop || _tree.tab.ndx_drop(_ndx) ?};
_result


\zwrw_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10] na podstawie MM [2006]
:: OPIS: Zwija i rozwija całe drzewko
::       Zakłada się że jest ustawiony indeks z pierwszym polem wskazanym w _b
::   WE: _a - akronim tabeli lub TABELA!
::       _b - akronim pola, w ktorym trzymany jest ref tabeli
::       _c - akronim okienka ze strukturą hierarchiczną (opcja)
::       _d, _e, _f.... wartości pól poprzedzających pole TREE_REF (opcja) - typu STRING
::  OLD: \zwrw_all/skid_usp.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:={? _>0
      || {? type_of(_a)=2               || ($(''+_a))()
         |? type_of(_a)=type_of(SYSLOG) || _a
                                        || return(~~)
         ?}
      || return(~~)
      ?};

_parent:={?_>1 & type_of(_b)=2 || _b || return(~~) ?};
   _win:={?_>2 & type_of(_c)=2 || _c || ''         ?};

_fpos:=3;
_size:=_-_fpos; {? _size<=0 || _size:=0 ?};

_arr:=~~;
_prefix:='';

{? _size>0
|| _arr:=obj_new(_size);
   {! _aa:=1.._size
   |! _arr[_aa]:=_[_aa+_fpos];
      {? type_of(_arr[_aa])=3
      || _prefix+='_arr['+form(_aa,,,'99')+'](),'
      || _prefix+='_arr['+form(_aa,,,'99')+'],'
      ?}
   !};
   _prefix+='null()';
   ~~
?};

_FmlX:=$("
          _tab:=_a;
          _win:=_b;
          _arr:=_c;

          _cr_ref:=_tab.ref();
          _zw:={? _tab."+_parent+"<>null() || 1 || _tab.tr_state()=1 ?};

          _tab.cntx_psh();
          {? ~_zw
          || _tab.prefix("+_prefix+");
             {? _tab.first()
             || {!
                |? _zw:=_tab.tr_state()=1;
                   _zw=null() & _tab.next()
                !}
             ?};
             _tab.seek(_cr_ref)
          ?};
          {? _tab."+_parent+"<>null()
          || {!
             |?
                {? _tab.seek(_tab."+_parent+",_tab.name())
                || _tab."+_parent+"<>null()
                || 0
                ?}
             !}
          ?};
          _cr_refp:=_tab.ref();
          _tab.cntx_pop();
          {? _tab.seek(_cr_refp)
          || {? _win<>''
             || _tab.tr_set(~_zw,_win)
             || _tab.tr_set(~_zw)
             ?}
          ?};
          _tab.seek(_cr_refp)
       ");
_FmlX(_tab,_win,_arr)


\default_expanded
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła na "rozwinięta" - domyślnie wszystkie węzły rozwinięte
::----------------------------------------------------------------------------------------------------------------------
{? _a=-1 || 1 || _a ?}


\default_collapsed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła na "rozwinięta" - domyślnie wszystkie węzły zwinięte
::----------------------------------------------------------------------------------------------------------------------
{? _a=-1 || 0 || _a ?}


\tree_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MZ [2011]
:: OPIS: rekurencyjne usuwanie pozycji w drzewku
::   WE: _a - identyfikator tabeli
::       _b - poziom do usuniecia = TREE_REF
::  OLD: \tree_del/podstawy.fml
::----------------------------------------------------------------------------------------------------------------------
_a.cntx_psh();
_a.prefix(_b);
{? _a.first()
|| {!
   |? exec('tree_del','#tree',_a,_a.ref());
      _a.del()
   !}
?};
_a.cntx_pop()


\zwin_rozwin
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Zwijanie / rozwijanie drzewa. Funkcja dedykowana obsłudze akcji w menu okna wertowania.
::       Jeżeli jest choć jedna zwinięta gałąź - rozwija wszystkie. Jeżeli wszystkie są rozwinięte - zwija.
::       Działanie funkcji nie jest prawidłowe, gdy drzewo zostało ograniczone metodą tr_root().
::       Niestety na dzień dzisiejszy nie ma odpowiednich narzędzi (funkcji, metod), które pozwoliłyby oprogramować
::       taką sytuację.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=cur_tab(1,1);
_ws:=cur_win(1,1);

:: Szukam akronimu pola typu TREE_REF. Z jednej strony jest to forma kontroli wywołania, z drugiej akronim może być
:: potrzebny jeżeli okaże się, że zwijamy drzewo.
_tree_acr:='';
{! _lp:=1 .. _TAB.fld_num()
|? _tree_acr=''
|! _acr:=_TAB.fld_acr(_lp);
   {? var_pres(_acr,_TAB)=32
   || _tree_acr:=_acr
   ?}
!};
{? _tree_acr=''
|| FUN.error('W schemacie tabeli nie znaleziono pola typu %1.'@['TREE_REF']);
   return()
?};

:: Buduję formułę prefiksującą (z uwzględnieniem aktualnego prefiksu), która będzie potrzebna przy sprawdzaniu, czy
:: bieżący element posiada elementy podrzędne.
_cp:=_TAB.cur_prfx();
{? _cp=''
|| _prfx:="_a.prefix(#_a.ref())"
|| _prfx:=$('_a.prefix('+_cp+{? _cp+1=',' || '' || ',' ?}+'#_a.ref())')
?};

_ref:=_TAB.ref();
_state:=_TAB.first();
{!
|? _TAB.cntx_psh();
   _prfx(_TAB);
   _child:=_TAB.first();
   _TAB.cntx_pop();
   {? _child
::    Interesują nas stany tylko gałęzi (a nie liści).
   || _state:=_TAB.tr_state()
   ?};
   _TAB.next() & _state
!};
_TAB.first();
_TAB.tr_set(~_state,_ws);
_TAB.seek(_ref);
{? _state
:: Jeżeli drzewo było rozwinięte (a więc zwijaliśmy), to stańmy na najwyższym poziomie bieżącego elementu.
|| {!
   |? _up:=($('_a.'+_tree_acr))(_TAB)
   |! _TAB.seek(_up,)
   !}
?};
~~


\tree_root
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Zwraca korzeń dla danej gałęzi/liścia drzewa
::   WE: _a - TAB.ref()
::   WY: TAB.ref()
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_tab:=ref_tab(_ref);

_result:=null();

:: Szukam akronimu pola typu TREE_REF.
_tree_acr:='';
{! _lp:=1 .. _tab.fld_num()
|? _tree_acr=''
|! _acr:=_tab.fld_acr(_lp);
   {? var_pres(_acr,_tab)=32
   || _tree_acr:=_acr
   ?}
!};
{? _tree_acr=''
|| FUN.error('W schemacie tabeli nie znaleziono pola typu %1.'@['TREE_REF']);
   return()
?};

_tab.cntx_psh();
_tab.prefix();
{? _tab.seek(_ref)
||
   _parent:=($('_a.'+_tree_acr))(_tab);
   {? _parent & _tab.seek(_parent)
   || {? ($('_a.'+_tree_acr))(_tab)=0
      || _result:=_tab.ref()
      || _result:=exec('tree_root','#tree',_tab.ref())
      ?}
   || _result:=_ref
   ?}
?};
_tab.cntx_pop();

_result


\bind_node
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [22.26]
:: OPIS: Przepina elementy drzewa do wskazanego
::   WE: [_a] [RULE] - treść formuły odpowiedzialnej za ustalenie zapisu nadrzędnego
::       [_b] [_TABLE] - alias tabeli, domyślnie aktualnie przeglądana w bieżącym okienku (również w grupie okien)
::       [_c] [STRING] - akronim pola wskazującego zapis nadrzędny, jeśli pominięty, to przyjęty zostanie akronim tabeli
::   WY: 0/1/any - porażka/sukces/wartość zwrócona przez formułę _a
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_fml:={? var_pres('_a')=type_of("") || _a || "0" ?};
_TAB:={? var_pres('_b')=type_of(SYSLOG) || _b || cur_tab(1,1) ?};
_col:={? var_pres('_c')=type_of('') & _c<>'' || _c || 2-!_TAB ?};
_mod:=$('%1.%2:=_a; %1.put()'[!_TAB,_col]);

:: ustal nadrzędny
_ref:=_fml(_TAB,_col);

:: oczekiwane wskazanie lub numer wiersza tabeli,
:: dla której wykonujemy operację przepięcia zapisów
{? type_of(_ref)=type_of(null)
|| {? _ref<>null & ref_tab(_ref)<>_TAB
   || return(0)
   ?};
   _ref:=#_ref
|? type_of(_ref)<>type_of(0)
|| return(_ref)
?};

_SEL:=_TAB.sel_aget();
_TAB.sel_adel();
{? ~_SEL.first()
:: wykanaj dla bieżącego
|| _SEL.REF:=#_TAB.ref();
   _SEL.add()
?};

_ret:=1;
_nms:=no_msg(1);
:: własna transakcja
_mdo:=(do_state()=0);
{? _mdo<>0
|| do()
?};

errno();
_loop:=_SEL.first();
{!
|? _loop & _ret
|! _ret:=(_TAB.seek(_SEL.REF,,1) & _mod(_ref)<>0);
   _loop:=_SEL.next()
!};

:: epilog
no_msg(_nms);
{? _mdo<>0
|| {? _ret=0
::    anuluj
   || undo()
   ?};
   end()
?};

_ret


\bind_node_error
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [22.26]
:: OPIS: Wyświetla komunikat o niepowodzeniu reorganizacji struktury hierarchicznej.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? do_state()<>0
|| return()
?};
FUN.emsg(
   {? errno()=377
   || 'Wykryto próbę naruszenia struktury hierarchicznej.\n'
      'Reorganizacja zapisów została anulowana.'@
   || 'Reorganizacja zapisów nie powiodła się.'@
   ?}
);
~~

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:10 ce1de416cd220aef2a7b881bb372bacd237ade1f5c721a0f60bb0248b76d723cf3ffa9a7317e01db9b9b96068dbdf5ae22f48183a29aa047f05eb38ad10032bbb512a0ee05a8455ef06c76db6dd68e4b8323473370e6255f6be46b4a455187b9c91024b29f68a82a1acef7baacbca27048f2c07e8ab005329aa8e96a74e9d4d8
