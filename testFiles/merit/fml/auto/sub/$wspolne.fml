:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: $wspolne.fml
:: Utworzony: 01.06.2020
:: Autor: ARTSLO
:: Systemy:
::======================================================================================================================
:: Zawartość: formuły z dziedziny ZWS współdzielone przez powiązane obszary robocze
::======================================================================================================================
\bf_imp_xls
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [19.22]
:: OPIS: bufor na ustawienia importu
::----------------------------------------------------------------------------------------------------------------------
return(tab_tmp(1,
'PROCESY','STRING[4]','Czy importować procesy?',
'NADPISUJ','STRING[1]','Czy nadpisywać?',
'DIR','STRING[100]','Ściezka do katalogu z plikami do importu'))


\bf_xls_kom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [19.22]
:: OPIS: bufor na komunikaty po imporcie z plików xlsx
::----------------------------------------------------------------------------------------------------------------------
return(tab_tmp( 2
,'MESSAGE'   ,'STRING[255]'   ,'Komunikat'
,'FILE'      ,'STRING[255]','Nazwa pliku'
,'SHEET'     ,'STRING[255]','Zakładka'
,'ROW'       ,'STRING[10]'    ,'Wiersz'))


\bf_proc_xls
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: bufor na ustawienia importu
::----------------------------------------------------------------------------------------------------------------------
return(tab_tmp(1,
'SCRIPT','STRING[255]','scieżka do polozenia scryptu pythona',
'DIR','STRING[255]','sciezka do katalogu na pliki posrednie',
'DIR2','STRING[255]','Ściezka do katalogu z danymi wzorcowymi'))


\import_kom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [20.42]
:: OPIS: Formuła pomocnicza aby zebrać komunikaty powstałe po imporcie. Lekko zmodyfikowania kopia funkcji
::       \select_hist/#excel_imex.fml
::       komunikaty zostają wyexportowane do pliku $import_kom.csv lub zwrócone w postaci json
::   WE: [_a] - obj_new - środowisko imex - wynik działania exec('env','#excel_imex')
::       [_b] - czy pokazać wszystkie komunikaty 0 - nie (tylko bieżący wiersz, domyślnie), 1 - tak
::       _c [STRING] - 'json'/'plik_roboczy' - określa sposób zwrócenia komunikatów z importu
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
{? var_pres('_a')>100
|| _env:=_a
|| _env:=params_get().env_xls
?};
{? var_pres('_b')=type_of(0)
|| _wszystko:=_b
|| _wszystko:=0
?};
{? var_pres('_c')=type_of('') & (_c='json' | _c='plik_roboczy')
|| _opcja_zwrotu:=_c
|| FUN.error('Błędy parametr _c - sposób wyboru zwrócenia komunikatów'@);
   return()
?};

_ndx:=_env.NDX_HIST2;
_tab_head:=_env.TAB_HEAD;
_win:='';
{? _env.TRANSACTIONS>0
|| _tab_hist:=exec('tab_hist','#excel_imex',_env,0,0);
   _tab_hist_src:=_env.TAB_HIST;
   _tab_hist_src.cntx_psh();
   _tab_hist_src.index(_env.NDX_HIST3);
   {? _wszystko
   || _tab_hist_src.prefix()
   || _tab_hist_src.prefix(_tab_head.FILE)
   ?};
   exec('tab2tab','#table',_tab_hist_src,_tab_hist,1,0);
   _tab_hist_src.cntx_pop();
   _ndx:=_tab_hist.ndx_tmp(,,'EXPORTED',,,'ID',,,'LP',,);
   _win:=exec('win_hist','#excel_imex',_env,_tab_hist)
|| _tab_hist:=_env.TAB_HIST;
   _win:=exec('win_hist','#excel_imex',_env,_tab_hist);
   ~~
?};

_tab_head.cntx_psh();
_tab_hist.cntx_psh();
_tab_hist.index(_ndx);
{? _wszystko
|| _tab_hist.prefix('T')
|| _tab_hist.prefix('T',_tab_head.ID,)
?};
:: zabezpieczenie przed enterami w csv
_loop:=_tab_hist.first();
{!
|? _loop
|! _tab_hist.memo_set(gsub(_tab_hist.memo_txt(0,1,'MESSAGE'),'\n'),'MESSAGE');
   _tab_hist.memo_put(,'MESSAGE');
   _loop:=_tab_hist.next()
!};
:: koniec zabezpieczenia
_tab_hist.first();
_tab_hist.win_sel(_win);
::_tab_hist.select();
{? _opcja_zwrotu='json'
|| _obiekt_json:=_tab_hist.json_records(,'MESSAGE',,'FILE',,'SHEET',,'ROW',)
|| _tab_hist.export('$import_kom.csv',,,'UTF-8',,
      'MESSAGE',,1,,
      'FILE',,2,,
      'SHEET',,3,,
      'ROW',,4,);
      _obiekt_json:=~~
?};
_tab_hist.cntx_pop();
_tab_head.cntx_pop();
_obiekt_json


\clean_xls_kom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [20.14]
:: OPIS: Formuła czyszcząca listę komunikatów z zapisów uznanych jako 'do ignorowania'
::   WE: [_a] - wskazanie na  obiekt bufor'a na komunikaty po imporcie z plików xlsx
::   WY: obiekt z wyfiltrowaną listą komunikatów
::----------------------------------------------------------------------------------------------------------------------
_ignore_list:='Brak wartości w kolumnie \'Data obowiązywania\'.|'+
              'Brak wartości w kolumnie \'Koszty uzyskania przychodu - podstawowe\'.|'+
              'Brak wartości w kolumnie \'Minimalny wiek\'.|'+
              'Brak wartości w kolumnie \'Najniższa emerytura\'.|'+
              'Brak wartości w kolumnie \'Przychód zwolniony od podatku\'.|'+
              'Brak wartości w kolumnie \'Urlop wypoczynkowy\'.|'+
              'Brak wartości w kolumnie \'Wypadkowe (ubezpieczenia społeczne)\'.|'+
              'Brak wartości w kolumnie \'Emerytalne (ubezpieczenia społeczne)\'.|'+
              'Nie udała się zmiana logowania Active Directory dla użytkownika: ankieta|'+
              'Nie udała się zmiana logowania Active Directory dla użytkownika: odbc|'+
              'Nie udała się zmiana logowania Active Directory dla użytkownika: odbcweb|'+
              'Nie udała się zmiana logowania Active Directory dla użytkownika: service|'+
              'Zaimportowano:|'+
              'Zmodyfikowano hasło|'+
              'Zabronione modyfikowanie hasła i znacznika ""użytkownik specjalny"" dla użytkownika: admin|'+
              'Zmieniono dane logowania Active Directory użytkownika';
_tab_ign:=spli_str(_ignore_list,'|');
_clean:="_return:=0;
         {! _i:=1..obj_len(_a)
         |! {? _b*_a[_i] || _return:=1 ?}
         !};
         _return";

{? _a.first()
|| {!
   |? {? _clean(_tab_ign,_a.MESSAGE)
      || _a.del()
      || _a.next()
      ?}
   !}
?};
_a


\prepare_proc_files
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Funkcja przygotowuje pośrednie pliki z listą plików oraz zawartością zakładki procesy z pliku procesy.xlsx
::       danych wzorcowych i przenosi je do katalogu aplikacji
::   WE: _a - położenie skryptu pythona na końcówce aplikacji
::       _b - ścieżka gdzie mają powstać pliki pośrednie
::       _c - ścieżka do danych wzorcowych
:: ~OST: INFCOPY,INFERASE,INFEXISTS,INSYSTEM
::----------------------------------------------------------------------------------------------------------------------
_a:={? var_pres('_a')>0 & type_of(_a)=type_of('') || _a || '' ?};
{? _a<>''
|| system('@python '+_a+' '+_c+' '+_b);
   _f1:=fexists('@'+_b+'files.csv',0);
   _f2:=fexists('@'+_b+'procesy.csv',0);
   {? _f1 & _f2
   || fcopy('@'+_b+'files.csv',pth_dir('files.csv')+'/files.csv',,,1);
      fcopy('@'+_b+'procesy.csv',pth_dir('procesy.csv')+'/procesy.csv',,,1)
   ?};
   {? fexists('files.csv',1) & fexists('procesy.csv',1)
   || ferase('@'+_b+'files.csv',0);
      ferase('@'+_b+'procesy.csv',0);
      1
   || 0
   ?}
|| 0
?}


\analyze_proc_files
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Funkcja analizuje przygotowane wcześniej pliki pośrednie dotyczące danych wzorcowych procesów. Sprawdzane są:
::       istnienie wielu wersji tego samego procesu (w plikach i w .xlsx), obecność plik<->.xlsx,
::       obecność .svg<->.graphml
::   WE:
::   WY: tabela zawierająca wykryte nieprawidłowości
::----------------------------------------------------------------------------------------------------------------------
:: Tabela wynikowa
_wyn:=tab_tmp(1,'NAZWA','STRING[255]','Nazwa',
                'KOD','STRING[255]','Kod procesu',
                'FTXN','STRING[1]','Jest plik ale nie ma w xlsx',
                'NFXT','STRING[1]','Nie ma w pliku a jest w xlsx',
                'MOF','STRING[1]','Wiele wersji procesu w plikach',
                'MOX','STRING[1]','Wiele wersji procesu w xlsx',
                'STGN','STRING[1]','Jest svg nie ma graphml',
                'SNGT','STRING[1]','Jest graphml nie ma svg');

:: Wczytujemy listę plików danych wzorcowych
_tab:=tab_tmp(1,'NAME','STRING[255]','Nazwa');
_tab.import('files.csv',0,1,';','UTF-8',,'NAME',,1,);

_proc:=tab_tmp(1,'NAZWA','STRING[255]','Nazwa',
                 'SVG','STRING[1]','svg?',
                 'GRAPHML','STRING[1]','Graphml?',
                 'KOD','STRING[255]','Kod procesu');
_ndx:=_proc.ndx_tmp(,1,'NAZWA',,,'NAZWA',,);
_ndx_sg:=_proc.ndx_tmp(,1,'SVG',,,'GRAPHML',,);
_proc.index(_ndx);
:: Odsiewamy tylko pliki .svg i .graphl i dopisujemy do tabeli pośredniej
_loop:=_tab.first();
{!
|? _loop
|! _s:=0;
   _g:=0;
   _name:='';
   {? _tab.NAME+4='.svg'
   || _s:=1;
      _name:=_tab.NAME-4
   |? _tab.NAME+8='.graphml'
   || _g:=1;
      _name:=_tab.NAME-8
   ?};
   {? (_s | _g) & _proc.find_key(_name,_name)
   || {? _s
      || _proc.SVG:='T'
      |? _g
      || _proc.GRAPHML:='T'
      ?};
      _proc.put()
   |? (_s | _g)
   || _proc.NAZWA:=_name;
      _k:=_tab.NAME*'-';
      _proc.KOD:=gsub((_k-1)+_tab.NAME,' ','');
      {? _s
      || _proc.SVG:='T'
      |? _g
      || _proc.GRAPHML:='T'
      ?};
      _proc.add()
   ?};
   _loop:=_tab.next()
!};

:: z tabeli pośredniej zczytujemy do tabeli wynikowej procesy które mają plik svg ale nie mają pliku graphml
_proc.index(_ndx_sg);
_proc.prefix('T','N');
_lopp:=_proc.first();
{!
|? _loop
|! _wyn.NAZWA:=_proc.NAZWA;
   _wyn.KOD:=gsub(((_proc.NAZWA*'-')-1)+_proc.NAZWA,' ','');
   {! _n:=3.._wyn.fld_num |! _wyn[_n]:={? _wyn.fld_acr(_n)<>'STGN' || 'N' || 'T' ?} !};
   _wyn.add();
   _loop:=_proc.next()
!};

:: z tabeli pośredniej zczytujemy do tabeli wynikowej procesy które mają plik graphml ale nie mają wpliku svg
_proc.prefix('N','T');
_lopp:=_proc.first();
{!
|? _loop
|! _wyn.NAZWA:=_proc.NAZWA;
   _wyn.KOD:=gsub(((_proc.NAZWA*'-')-1)+_proc.NAZWA,' ','');
   {! _n:=3.._wyn.fld_num |! _wyn[_n]:={? _wyn.fld_acr(_n)<>'SNGT' || 'N' || 'T' ?} !};
   _wyn.add();
   _loop:=_proc.next()
!};

:: zbieramy informacje z tabeli pośredniej o procesach które mają wiecej niż jedną wersję i wpisujemy do tabeli wynikowej
_fdupl:=sql('select KOD from :_a where :_a.VL>1',sql('select KOD, sum(1) as VL from :_a group by KOD', _proc));

_loop:=_fdupl.first();
{!
|? _loop
|! _wyn.NAZWA:='';
   _wyn.KOD:=_fdupl.KOD;
   {! _n:=3.._wyn.fld_num |! _wyn[_n]:={? _wyn.fld_acr(_n)<>'MOF' || 'N' || 'T' ?} !};
   _wyn.add();
   _loop:=_fdupl.next()
!};


_xls_pos:=tab_tmp(1,'NAZWA','STRING[255]','Nazwa');
_xls_pos.import('procesy.csv',0,1,';','UTF-8',,'NAZWA',,1,);
_xls:=tab_tmp(1,'NAZWA','STRING[255]','Nazwa',
                'KOD','STRING[255]','Kod procesu');

_loop:=_xls_pos.first();
{!
|? _loop
|! _xls.NAZWA:=_xls_pos.NAZWA;
   _xls.KOD:=gsub(((_xls_pos.NAZWA*'-')-1)+_xls_pos.NAZWA,' ','');
   _xls.add();
   _loop:=_xls_pos.next()
!};

_xndx:=_xls.ndx_tmp(,1,'NAZWA',,,'NAZWA',,);

:: sprawdzamy czy wszystkie procesy z plików znajdują się w xlsx
_xls.index(_xndx);
_proc.index(_ndx);
_loop:=_proc.first();
{!
|? _loop
|! {? _xls.find_key(_proc.NAZWA+'.graphml',_proc.NAZWA+'.graphml')
   || 'ok'
   || _wyn.NAZWA:=_proc.NAZWA;
      _wyn.KOD:=gsub(((_proc.NAZWA*'-')-1)+_proc.NAZWA,' ','');
      {! _n:=3.._wyn.fld_num |! _wyn[_n]:={? _wyn.fld_acr(_n)<>'FTXN' || 'N' || 'T' ?} !};
      _wyn.add()
   ?};
   _loop:=_proc.next()
!};

:: sprawdzamy czy wszystkie procesy z xlsx są też w plikach
_xls.index(_xndx);
_proc.index(_ndx);
_loop:=_xls.first();
{!
|? _loop
|! {? _proc.find_key(_xls.NAZWA-8,_xls.NAZWA-8)
   || 'ok'
   || _wyn.NAZWA:=_xls.NAZWA;
      _wyn.KOD:=gsub(((_xls.NAZWA*'-')-1)+_xls.NAZWA,' ','');
      {! _n:=3.._wyn.fld_num |! _wyn[_n]:={? _wyn.fld_acr(_n)<>'NFXT' || 'N' || 'T' ?} !};
      _wyn.add()
   ?};
   _loop:=_xls.next()
!};

:: sprawdzamy czy jest wiele wersji tego samego procesu w pliku xlsx
_xdupl:=sql('select KOD from :_a where :_a.VL>1',sql('select KOD, sum(1) as VL from :_a group by KOD', _xls));
_loop:=_xdupl.first();
{!
|? _loop
|! _wyn.NAZWA:='';
   _wyn.KOD:=_xdupl.KOD;
   {! _n:=3.._wyn.fld_num |! _wyn[_n]:={? _wyn.fld_acr(_n)<>'MOX' || 'N' || 'T' ?} !};
   _wyn.add();
   _loop:=_xdupl.next()
!};

_wyn


\proc_files_list
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [23.25]
:: OPIS: Funckja zwraca tabelkę z symbolami procesów wsytepujących w plikach użytych danych wzorcowych do importu
::   WE:
::   WY: tabela tymczasowa z symbolami procesów
::----------------------------------------------------------------------------------------------------------------------
:: Wczytujemy listę plików danych wzorcowych
_tab:=tab_tmp(1,'NAME','STRING[255]','Nazwa');
_tab2:=tab_tmp(1,'NAME','STRING[255]','Nazwa');
{? fexists('files.csv',1)
|| _tab.import('files.csv',0,1,';','UTF-8',,'NAME',,1,);
   _loop:=_tab.first();
   {!
   |? _loop
   |! {? _tab.NAME*'.graphml'
      || _tab2.NAME:=((_tab.NAME*' ')-1)+_tab.NAME;
         _tab2.add()
      ?};
      _loop:=_tab.next()
   !}
?};
_tab2

:Sign Version 2.0 jowisz:1048 2023/06/23 14:12:17 73ce0c487965fc81f3ec209f254c9da289c2df7d4f62c55050c1717161a688f3bc7b208c3bbb3a11e02aec02870393180ffe35b9e3bc867e551519b37c2dec6a3852d470c95a3320dec7ab9b176adfb66ae3d378943dbace616a4383b6bea39104d9d6ac1b152da15e51b4a417c10f3dde3ae277f82af152e7cd4700b35ebd3a
